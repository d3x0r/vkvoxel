#ifdef _MSC_VER
// because snprintf IS secure; and _snprintf doesn't help.
#  define _CRT_SECURE_NO_WARNINGS
#endif
#ifndef HAVE_SSL
#  define NO_SSL 1
#endif
#ifndef HAVE_ZLIB
#  define __NO_WEBSOCK_COMPRESSION__
#endif
#define SACK_AMALGAMATE
#define NO_OPEN_MACRO
//#define __NO_MMAP__
#define __STATIC__
#define __NO_OPTIONS__
#define __NO_ODBC__
#define NO_FILEOP_ALIAS
#define SACK_BAG_EXPORTS
//#define __STATIC_GLOBALS__
//#define TYPELIB_SOURCE
//#define __NO_INTERFACE_SUPPORT__
#define NEED_SHLAPI
#define NEED_SHLOBJ
#define JSON_PARSER_MAIN_SOURCE
#define FORCE_COLOR_MACROS
#define WINFILE_COMMON_SOURCE
#include <stdio.h>
#include <stdarg.h>
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#if _XOPEN_SOURCE < 500
#  undef _XOPEN_SOURCE
#  define _XOPEN_SOURCE 500
#endif
#  ifndef _GNU_SOURCE
#    define _GNU_SOURCE
#  endif
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#if _POSIX_C_SOURCE < 200112L
#  ifdef _POSIX_C_SOURCE
#    undef _POSIX_C_SOURCE
#  endif
#  define _POSIX_C_SOURCE 200112L
#endif
#include <stdlib.h>
#include <stddef.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#ifndef _WIN32
#  ifndef __LINUX__
#    define __LINUX__
#  endif
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
#  ifndef NOMINMAX
                  // Macros min(a,b) and max(a,b)
#    define NOMINMAX
#  endif
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
#  if _MSC_VER > 1500
#    define fileno _fileno
#    define stricmp _stricmp
#    define strdup _strdup
#  endif
#  ifdef WANT_MMSYSTEM
#    include <mmsystem.h>
#  endif
#  if USE_NATIVE_TIME_GET_TIME
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#    ifdef __cplusplus
extern "C"
#    endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  endif
#  ifdef WIN32
#    if defined( NEED_SHLAPI )
#      include <shlwapi.h>
#      include <shellapi.h>
#    endif
#    ifdef NEED_V4W
#      include <vfw.h>
#    endif
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ "(" STRSYM(__LINE__) ") Would DebugBreak here..." ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      if defined( __EMSCRIPTEN__ ) || defined( __ARM__ )
#        define DebugBreak()
#      else
#        define DebugBreak()  __asm__("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#include <errno.h>
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#ifndef SACK_PRIMITIVE_TYPES_INCLUDED
#define SACK_PRIMITIVE_TYPES_INCLUDED
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  ifdef __cplusplus
#    define DeclareThreadLocal static thread_local
#    define DeclareThreadVar  thread_local
#  else
#    define DeclareThreadLocal static __declspec(thread)
#    define DeclareThreadVar __declspec(thread)
#  endif
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) || defined( __MAC__ ) )
#    define HAS_TLS 1
#    ifdef __cplusplus
#      define DeclareThreadLocal static thread_local
#      define DeclareThreadVar thread_local
#    else
#    define DeclareThreadLocal static __thread
#    define DeclareThreadVar __thread
#  endif
#else
// if no HAS_TLS
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    define MD5_SOURCE
#    define SHA2_SOURCE
#    define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#      define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#      define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
	individual library module once upon a time.           */
#      define JSOX_PARSER_SOURCE
#      define HTML5_WEBSOCKET_SOURCE
#      define SACK_WEBSOCKET_CLIENT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SERVICE_SOURCE
#    ifndef __NO_SQL__
#      ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#        define SQLGETOPTION_SOURCE
#      endif
#    endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define PSI_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#    ifndef IMAGE_LIBRARY_SOURCE
#      define IMAGE_LIBRARY_SOURCE
#    endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#    define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#    ifndef RENDER_LIBRARY_SOURCE
#      define RENDER_LIBRARY_SOURCE
#    endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#if !defined( _WIN32 ) && !defined( __MAC__ )
#  include <sys/syscall.h>
#elif defined( __MAC__ )
#endif
#ifndef MY_TYPES_INCLUDED
#  define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#  include <limits.h>
 // typelib requires this
#  ifdef _MSC_VER
#    ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#      include <intrin.h>
#    endif
#  endif
 // typelib requires this
#  include <string.h>
#  if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#    include <dlfcn.h>
#  endif
#  if defined( _MSC_VER )
#    define EMPTY_STRUCT struct { char nothing[]; }
#  endif
#  if defined( __WATCOMC__ )
#     define EMPTY_STRUCT char
#  endif
#  ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#    define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#  else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#    define TEXT_NAMESPACE_END
#  endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#  define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#  define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#  define CPROC
#if !defined( _WIN32 )
#  define PUBLIC_METHOD
#  define REFERENCE_METHOD extern
#else
#  define PUBLIC_METHOD __declspec(dllexport)
#  define REFERENCE_METHOD __declspec(dllimport)
#endif
#  ifdef SACK_BAG_EXPORTS
#    ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#      define EXPORT_METHOD [DllImport(LibName)] public
#    else
#      ifdef __cplusplus_cli
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
#          define EXPORT_METHOD __declspec(dllexport)
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#      else
#        if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#          define EXPORT_METHOD
#          define IMPORT_METHOD extern
#        else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#          define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#          define IMPORT_METHOD __declspec(dllimport)
#        endif
#        define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#        define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#      endif
#    endif
#  else
#  if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#    if defined( __LINUX__ ) || defined( __STATIC__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#      define LITERAL_LIB_EXPORT_METHOD
#      define LITERAL_LIB_IMPORT_METHOD extern
#    else
#      define EXPORT_METHOD __declspec(dllexport)
#      define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#    endif
#  endif
#endif
#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#include <emscripten/emscripten.h>
// Emscripten exports just need to be not optimized out.
#  undef  EXPORT_METHOD
#  define EXPORT_METHOD                EMSCRIPTEN_KEEPALIVE
#  undef  LITERAL_LIB_EXPORT_METHOD
#  define LITERAL_LIB_EXPORT_METHOD    EMSCRIPTEN_KEEPALIVE
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
#ifdef __cplusplus
namespace sack {
#endif
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( "Library Enter" );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( "Library Enter" );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) #n
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) n
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) "(" TEXT(STRSYM(__LINE__))" : ")
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , __FILE__, __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     __FILE__, __LINE__
//#define FILELINE_LEADSRC     __FILE__, __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_NULL        , NULL, 0
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT "%s(%" _32f "): "
#define FILELINE_FILELINEFMT_MIN "%s(%" _32f ")"
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = __FILE__; uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#  define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#  define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_NULL */
#  define DBG_NULL
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#  define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#  define DBG_VARSRC
#else
// used to specify whether debug information is being passed - can be referenced in compiled code
#  define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#  define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#  define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#  define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#  define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
	  in _DEBUG mode, pass FILELINE_NULL */
#  define DBG_NULL        FILELINE_NULL
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#  define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#  define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#  define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#  define DBG_VARSRC      FILELINE_VARSRC
#endif
/* cannot declare _0 since that overloads the
   vector library definition for origin (0,0,0,0,...) */
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists
 *  (it does, but it's in vectlib, and is an origin vector)
*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of int32_t (LONG)
 */
typedef int  SBIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get
// padded as normal; this is appended to a strcture
// and is ued on GCC comiplers for __attribute__((packed))
#ifndef PACKED
#  define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are past end or beginning of string for instance */
#define RUNE_AFTER_END     0x8000000
#define RUNE_BEFORE_START  0x8000001
/* Used to handle returned values that are invalid utf8 encodings. */
#define BADUTF8            0xFFFD
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
#ifdef __cplusplus
 //SACK_NAMESPACE_END // namespace sack {
}
#endif
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#ifndef __STDC_FORMAT_MACROS
#  define __STDC_FORMAT_MACROS
#endif
#include <inttypes.h>
#endif
/*
   Top level namespace.  SACK Is the System Abstraction Componnet Kit.
   With a little work subsets of this namesapce can be used.  Typrically
   this is built as just one large c/c++ shared library.
*/
#ifdef __cplusplus
namespace sack {
#endif
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   "u"
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   "x"
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   "X"
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   "d"
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   "u"
/* 8 bit hex output printf format sppecifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   "x"
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   "X"
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   "d"
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   PRIu32
#  define _32fx    PRIx32
#  define _32fX    PRIX32
#  define _32fs    PRId32
#  define _64f    PRIu64
#  define _64fx   PRIx64
#  define _64fX   PRIX64
#  define _64fs   PRId64
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   "u"
#  define _32fx   "x"
#  define _32fX   "X"
#  define _32fs   "d"
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#  define _cstring_f "s"
#  define _string_f "s"
#  define _ustring_f "S"
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu64
#      define _size_fx    PRIx64
#      define _size_fX    PRIX64
#      define _size_fs    PRId64
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f     PRIu32
#      define _size_fx    PRIx32
#      define _size_fX    PRIX32
#      define _size_fs    PRId32
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    "zu"
#      define _size_fx   "zx"
#      define _size_fX   "zX"
#      define _size_fs   "zd"
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs  PRIuPTR
#    define _PTRSZVALfx  PRIxPTR
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf "p"
#define _PTRSZVALf "p"
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    "llu"
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   "llx"
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   "llX"
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   "lld"
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 )
#  define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#  define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#  ifdef __MAC__
     DeclareThreadLocal uint64_t tmpThreadid;
#    define GetMyThreadID()  ((pthread_threadid_np(NULL, &tmpThreadid)),tmpThreadid)
#  else
#    ifndef GETPID_RETURNS_PPID
#      define GETPID_RETURNS_PPID
#    endif
#    ifdef GETPID_RETURNS_PPID
#      ifdef __ANDROID__
#        define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#      else
#        if defined( __EMSCRIPTEN__ )
#          define GetMyThreadID()  ( (uint64_t)(pthread_self()) )
#        else
#          define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(syscall(SYS_gettid)) ) )
#        endif
#      endif
#    else
#      define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#    endif
#  endif
#  define _GetMyThreadID GetMyThreadID
#endif
//---------------------- Declare Link; 'single and a half'ly-linked lists -----------------------
// Thse macros are for linking and unlininking things in a linked list.
// The list is basically a singly-linked list, but also references the pointer that
// is pointing at the current node.  This simplifies insert/remove operations, because
// the specific list that the node is in, is not required.
// List heads will always be updated correctly.
//
// A few 'tricks' are available, such as
//     0) These are deemed dangerous; and uncomprehendable by anyone but the maintainer.
//        use at your own time and expense required to explain WHY these work.
//     1) when declaring a root node, include another node before it, and it's
//        simple to make this a circularly linked list.
//     2) defining DeclareLink at the start of the strcture, the 'me' pointer
//        also happens to be 'prior', so you can step through the list in both
//        directions.
//
//
//
// struct my_node {
//    DeclareLink( struct my_node );
//    // ...
// };
//
// that declares
//      struct my_node *next;  // the next node in list.
//      struct my_node **me;   // address of the pointer pointing to 'me';
//
//
//  struct my_node *root; // a root of a list of my_node.  It should be initialized to NULL.
//
//  struct my_node *newNode = (struct my_node*)malloc( sizeof( *newNode ) );
//     // does not require next or me to be initiialized.
//  LinkThing( root, newNode );
//     // now newNode is in the list.
//
//  to remove from a list
//
//  struct my_node *someNode; // this should be a pointer to some valid node.
//  UnlinkThing( someNode );
//     The new node is now not in the list.
//
//  To move one node from one list to another
//
//   struct my_node *rootAvail;  // available nodes
//   struct my_node *rootUsed;   // nodes in use
//
//   struct my_node *someNode; // some node in a list
//   someNode = rootAvail; // get first available.
//   if( !someNode ) ; // create a new one or abort
//   RelinkThing( rootUsed, someNode );
//      'someNode' is removed from its existing list, and added to the 'rootUsed' list.
//
// For Declaring the link structure members for lists
#define DeclareLink( type )  type *next; type **me
/* Link a new node into the list.
   Example
   struct mynode
   {
       DeclareLink( struct mynode );
   } *node;
	struct mynode *list;
   // node allocation not shown.
	LinkThing( list_root, node );
*/
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. LinkThing() inserts the new
 node as the new head of the list.
 this has to scan the list to find the end, so it is a O(n) operation.
 All other linked list operations are O(1)
 */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
// inserts 'node' after Thing
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
// similar to LinkThingAfter but puts the new 'thing'
// before the 'node' specified.
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
// move a list from one list to another.
// unlinks node from where it was, inserts at the head of another.
// this can also be use to reproiritize within the same list.
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink
 safe iterator macro that tests if node is valid, which returns
 the next item in the list, else returns NULL
 */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//----------- FLAG SETS (single bit fields) -----------------
/* the default type to use for flag sets - flag sets are arrays of bits
 which can be set/read with/as integer values an index.
 All of the fields in a maskset are the same width */
#define FLAGSETTYPE uintmax_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) )),1)
// clear a single flag index
#define RESETFLAG(v,n) ( ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) ),0)
// test if a flags is set
//  result is 0 or not; the value returned is the bit shifted within the word, and not always '1'
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
// return value is undefined... and is a whole bunch of flags from some offset...
// if you want ot toggle and flag and test the result, use TESTGOGGLEFLAG() instead.
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= (FLAGSETTYPE)1 << ( (n) & FLAGROUND((v)[0]) ))
// Toggle a bit, return the state of the bit after toggling.
#define TESTTOGGLEFLAG(v,n)  ( TOGGLEFLAG(v,n), TESTFLAG(v,n) )
//----------- MASK SETS -----------------
//  MASK Sets are arrays of bit-fields of some bit-width (5, 3, ... )
//  they are set/returned as integer values.
//  They are stored-in/accessed via a uint8_t which gives byte-offset calculations.
// they return their value as uintmax_t from the offset memory address directly;
//   Some platforms(Arm) may SIGBUS because of wide offset accesses spanning word boundaries.
//   This issue may be fixed by rounding, grabbing the word aligned values and shifting manually
// Declarataion/Instantiation of a mask set is done with MASKSET macro below
// 32 bits max for range on mask
#define MASK_MAX_LENGTH (sizeof(MASKSET_READTYPE)*CHAR_BIT)
/* gives a 32 bit mask possible from flagset..
 - updated; return max int possible; but only the low N bits will be set
 - mask sets are meant for small values, but could be used for like 21 bit fields. (another form of unicode encoding I suppose)
 */
#define MASKSET_READTYPE uintmax_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( ((MASKSET_READTYPE)-1) >> ((sizeof(MASKSET_READTYPE) * CHAR_BIT)-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length)) & (sizeof(MASKSET_READTYPE) - 1) ) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&(sizeof(MASKSET_READTYPE) - 1)) )
/* declare a mask set.
 MASKSET( maskVariableName
        , 32 //number of items
		  , 5 // number of bits per field
		  );
   declares
	uint8_t maskVariableName[ (32*5 +(CHAR_BIT-1))/CHAR_BIT ];  //data array used for storage.
   const int askVariableName_mask_size = 5;  // used aautomatically by macros
*/
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r
#define MASKSET_(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]
/* set a field index to a value
    SETMASK( askVariableName, 3, 13 );  // set set member 3 to the value '13'
 */
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
#define SETMASK_(v,v2,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v2##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v2##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v2##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v2##_mask_size,val) )
/* get the value of a field
     GETMASK( maskVariableName, 3 );   // returns '13' given the SETMASK() example code.
 */
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&(sizeof(MASKSET_READTYPE) - 1)))
#define GETMASK_(v,v2,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v2##_mask_size))/MASKTYPEBITS((v)[0])))[0]         & MASK_MASK(n,v2##_mask_size) )	                                                                           >> (((n)*(v2##_mask_size))&(sizeof(MASKSET_READTYPE) - 1)))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
/* LIST is a slab array of pointers, each pointer may be
	assigned to point to any user data.
	Remarks
	When the list is filled to the capacity of Cnt elements, the
	list is reallocated to be larger.
	Cannot add NULL pointer to list, empty elements in the list
	are represented with NULL, and may be filled by any non-NULL
	value.                                                       */
	_LINKLIST_NAMESPACE
	/* <combine sack::containers::list::LinkBlock>
		\ \                                         */
	typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST;
typedef struct LinkBlock volatile* volatile PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock volatile * volatile PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size. No locking is provided.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
	Remarks
	This is a stack 'by reference'. When extended, the stack will
	occupy different memory, care must be taken to not duplicate
	pointers to this stack.                                       */
	typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
		If top == 0, the stack is empty, until a pointer is added and
		top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
							thread safety.                                            */
							//volatile uint32_t     Lock;
							/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK;
typedef struct LinkStack volatile* volatile PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
						 all messages, unless they are network)
																										  */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK;
typedef struct DataListStack volatile* volatile PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
		queue. If Top==Bottom, then the queue is empty, until a
		pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
		the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
		thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE;
typedef struct LinkQueue volatile* volatile PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
		queue is empty, until an entry is added at Top, and Top
		increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
		returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
		elements added to it than it has count, it will be expanded,
		and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
		is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE;
typedef struct DataQueue volatile* volatile PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
#ifdef __cplusplus
 //SACK_NAMESPACE_END // namespace sack {
}
#endif
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
#  define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
#  ifdef __cplusplus
	namespace sack {
   /* Containers is a bunch of common types like lists, queues,
      stacks.                                                   */
	   namespace containers {
#  endif
#  ifdef __cplusplus
/* virtual file system using file system IO instead of memory mapped IO */
namespace list {
#  endif
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE        MakeListEx   ( PLIST *pList DBG_PASS );
/* Destroy a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  void TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
#define GetLinkCount(l) GetLinksUsed(&(l))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinksUsed( PLIST *pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class iList
{
public:
	volatile PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX index) { return GetLink( &list, index ); }
} *piList;
#  endif
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((i)=0),((v)=(t)(uintptr_t)NULL),(l))                                                        for( ; ((i) < ((l)->Cnt))?                                         (((v)=(t)(uintptr_t)((l)->pNode[i])),1):(((v)=(t)(uintptr_t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
 //		namespace list;
	}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
/* A type of dynamic array that contains the data of the elements and not just pointers like PLIST. Has no locks builtin. */
namespace data_list {
#endif
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \    ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((i)=0),((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ;	                                               (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  void TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
 //		namespace link_stack {
		}
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE   MakeDataStackEx( PDATASTACK *pds, size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE   MakeDataStackLimitedEx( PDATASTACK *pds, size_t size, INDEX count DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC PDATASTACK TYPELIB_CALLTYPE CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC void TYPELIB_CALLTYPE PushDataEx( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  void TYPELIB_CALLTYPE   MakeLinkQueueEx( PLINKQUEUE *into DBG_PASS );
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC void TYPELIB_CALLTYPE PrequeLinkEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE   MakeDataQueueEx( PDATAQUEUE *into, INDEX size DBG_PASS );
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC void TYPELIB_CALLTYPE MakeLargeDataQueueEx( PDATAQUEUE *pdq, INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC void TYPELIB_CALLTYPE PrequeDataEx( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/* returns how many entries are in the queue. */
TYPELIB_PROC  INDEX   TYPELIB_CALLTYPE      GetDataQueueLength( PDATAQUEUE pdq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
#define PeekDataQueue( q, type, result ) PeekDataQueueEx( q, type, result, 0 )
/*
 * gets the address a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  Index from 0 to N indexes from first ( to be dequeued )
 * to last item in queue.
 */
TYPELIB_PROC POINTER TYPELIB_CALLTYPE  PeekDataInQueueEx    ( PDATAQUEUE *pplq, INDEX idx );
/*
 * Results with the first item in the queue, else NULL.
 */
TYPELIB_PROC POINTER TYPELIB_CALLTYPE  PeekDataInQueue    ( PDATAQUEUE *pplq );
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
/* This is a rough emulation of SYSv IPC Message Queue objects.
*/
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
}
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
// declare a type that is a set; this type isn't used internally, but is used for
// some utility macros, and to get the size of memory to allocate a set block.
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
// declare a set type that contains class elements; this type isn't used internally, but is used for
// some utility macros, and to get the size of memory to allocate a set block.
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \    Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
    // this is the size of the bit pool before the pointer pool
	uint32_t nBias;
 // the bit pool starts here (booleanUsed) after a number of
	uint32_t bUsed[1];
	                   // bits begins the aligned pointer pool.
} GENERICSET, *PGENERICSET;
/* \    Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \    Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \    Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \    Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \    Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \    Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, (POINTER)member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \    Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
/*
 StoreSetIntoEx() - stores a set into a packed linear array passed in.
 to get the size to create the array, can use CountUsedInSet()...
 doing it this way is less calls then a for-each-set-member self-copy.
    */
TYPELIB_PROC  void * TYPELIB_CALLTYPE  StoreSetIntoEx( GENERICSET *pSet, void*unit, int unitsize, int max );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
// this THis defines/initializes the data part of a PTEXT/TEXT structure.
// used with DECLTEXTSZTYPE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1  ,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
#  include <strings.h>
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#  define stricmp strcasecmp
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \    See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \    See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \    See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( double value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a piece of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \    See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \    <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.
     allows +/- leadin ([-*]|[+*])*
     supports 0x### (hex), 0b#### (binary), 0o#### (octal), 0### (octal)
	 decimal 1-9[0-9]*
	 buggy implementation supports +/- inline continue number and are either ignored(+)
	 or changes the overall sign of the number(-).  A Decimal definatly ends the number.
	 And octal/binary digits aren't checked for range, so 8/9 will over-flow in octal,
	 and 2-9 overflow to upper bits in octal...
	    0b901090 // would be like   0b 10100110    0b1001 +  010 + 1001<<3 + 0
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Converts a text to the longest precision signed integer
   value.  Does the work of IntCreateFromText.
   IntCreateFromTextRef updates the pointer passed by reference so
   the pointer ends at the first character after the returned number.
   */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromTextRef( CTEXTSTR *p_ );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \    Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \     Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space " \t"
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC char * TYPELIB_CALLTYPE WcharConvert_v2 ( const wchar_t *wch, size_t len, size_t *outlen DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \    Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history; negative indexes are recalled commands.
	int nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
/* Parses a string that contains a comma separated list of
   strings into an array of strings. Has no quoting support, and
   simply parses on any comma in a string.
   Parameters
   \ \
                                                                 */
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
/* Parses a string with numbers separated by commas into an
   array of ints.                                           */
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
/* Binary tree object; supports custom sort routines
*/
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \    Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \    Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \    See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 101 = no longer matching; result with last 100 match.
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
//
// Basically scans left and right from 100 match to find best match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \    <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   int total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	}
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
}
 // namespace sack
}
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
#ifdef __cplusplus
namespace sack {
#endif
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
#ifdef __cplusplus
 //SACK_NAMESPACE_END // namespace sack {
}
#endif
// this should become common to all libraries and programs...
//#include <construct.h> // pronounced 'kahn-struct'
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END } }
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//  returns the millisecond of the day (since UNIX Epoch) * 256 ( << 8 )
// the lowest 8 bits are the timezone / 15.
// The effect of the low [7/]8 bits being the time zone is that within the same millisecond
// UTC +0 sorts first, followed by +1, +2, ... etc until -14, -13, -12,... -1
// the low [7/]8 bits are the signed timezone
// (timezone could have been either be hr*60 + min (ISO TZ format)
// or in minutes (hr*60+mn) this would only take 7 bits
// one would think 8 bit shifts would be slightly more efficient than 7 bits.
// and sign extension for 8 bits already exists.
// - REVISION - timezone with hr*100 does not divide by 15 cleanly.
//     The timezone is ( hour*60 + min ) / 15 which is a range from -56 to 48
//     minimal representation is 7 bits (0 - 127 or -64 - 63)
//     still keeping 8 bits for shifting, so the effective range is only -56 to 48 of -128 to 127
// struct time_of_day {
//    uint64_t epoch_milliseconds : 56;
//    int64_t timezone : 8; divided by 15... hours * 60 / 15
// }
// returns the nanosecond of the day (since UNIX Epoch) and timezone/15
SYSLOG_PROC  int64_t SYSLOG_API GetTimeOfDay( uint64_t* tick, int8_t* ptz );
// binary little endian order; somewhat
typedef struct sack_expanded_time_tag
{
	uint16_t ms;
	uint8_t sc,mn,hr,dy,mo;
	uint16_t yr;
	int8_t zhr, zmn;
} SACK_TIME;
typedef struct sack_expanded_time_tag *PSACK_TIME;
// convert a integer time value to an expanded structure.
SYSLOG_PROC void     SYSLOG_API ConvertTickToTime( int64_t, PSACK_TIME st );
// convert a expanded time structure to a integer value.
SYSLOG_PROC int64_t SYSLOG_API ConvertTimeToTick( PSACK_TIME st );
// returns timezone as hours*100 + minutes.
// result is often negated?
SYSLOG_PROC  int SYSLOG_API GetTimeZone(void);
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
//SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
//SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  BinaryToString( PVARTEXT pvt, const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLogEx(buf,...) SystemLogFL(buf,##__VA_ARGS__)
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#define SystemLog(buf)    SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLogFL(s FILELINE_SRC )
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLogFL( s FILELINE_SRC )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
#ifdef __cplusplus
 //LOGGING_NAMESPACE_END
} }
using namespace sack::logging;
#endif
#endif
// these macros test the the range of integer and unsigned
// such that an unsigned > integer range is true if it is more than an maxint
// and signed integer < 0 is less than any unsigned value.
// the macro prefix SUS  or USS is the comparison type
// Signed-UnSigned and UnSigned-Signed  depending on the
// operand order.
// the arguments passed are variable a and b and the respective types of those
// if( SUS_GT( 324, int, 545, unsigned int ) ) {
//    is >
// }
/* Compare two numbers a>b, the first being signed and the second
   being unsigned. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
/* Compare two numbers a>b, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
/* Compare two numbers, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
/* Compare two numbers, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
/* Compare two numbers a>=b, the first being signed and the second
   being unsigned. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
/* Compare two numbers a>=b, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
/* Compare two numbers a<=b, the first being signed and the second
   being unsigned. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
/* Compare two numbers a<=b, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.
   at is the type of a and bt is the type of b
*/
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#if 0
// simplified meanings of the macros
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
/* Compare two numbers, the first being unsigned and the second
   being signed. Compares only within overlapping ranges else
   \returns condition of non-overlap.                           */
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
#ifdef __cplusplus
namespace sack {
  /*
    System interface namespace has Tasks, Environment, and dynamic library loading.
  */
	namespace system {
#endif
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
#define LPP_OPTION_ELEVATE              64
// use ctrl-break instead of ctrl-c for break (see also LPP_OPTION_USE_SIGNAL)
#define LPP_OPTION_USE_CONTROL_BREAK   128
// specify CREATE_NO_WINDOW in create process
#define LPP_OPTION_NO_WINDOW           256
// use process signal to kill process instead of ctrl-c or ctrl-break
#define LPP_OPTION_USE_SIGNAL          512
// This might be a useful windows option in some cases
#define LPP_OPTION_DETACH             1024
// this is a Linux option - uses forkpty() instead of just fork() to
// start a process - meant for interactive processes.
#define LPP_OPTION_INTERACTIVE        2048
struct environmentValue {
	char* field;
	char* value;
};
/**
 start process end monitoring based on a process ID
 */
SYSTEM_PROC( PTASK_INFO, MonitorTaskEx )( int pid, int flags, TaskEnd EndNotice, uintptr_t psv DBG_PASS );
#define MonitorTask(pid,flags,end,psv) MonitorTaskEx( pid, flags, end, psv DBG_SRC )
/**
 Launch a process...
 provides hoooks for task output, task end notification, flags control spawning behavior...
 */
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgram_v2 )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskOutput OutputHandler2
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                               , PLIST envStrings
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
enum terminate_program_flags {
	TERMINATE_PROGRAM_CHAIN = 1,
	TERMINATE_PROGRAM_CHILDMOST = 2,
};
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
// additional flags from the enum terminate_program_flags may be used.
//   _CHAIN = terminate the whole chain, starting from child-most task.
//   _CHILDMOST = terminate the youngest child in the chain.
SYSTEM_PROC( uintptr_t, TerminateProgramEx )( PTASK_INFO task, int options );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// this approximates the install path, as the parent of a program in /bin/ so GetProgramPath()/..; otherwise is TARGET_INSTALL_PREFIX
SYSTEM_PROC( CTEXTSTR, GetInstallPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
// send data to child process.  buffer is an array of bytes of length buflen
SYSTEM_PROC( size_t, task_send )( PTASK_INFO task, const uint8_t*buffer, size_t buflen );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  DefineRegistryMethod("SACK",_OnLibraryLoad,"system/library","load_event",name "_LoadEvent",void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR const *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
/*
   Check if task spawning is allowed...
*/
SYSTEM_PROC( LOGICAL, sack_system_allow_spawn )( void );
/*
   Disallow task spawning.
*/
SYSTEM_PROC( void, sack_system_disallow_spawn )( void );
#ifdef __ANDROID__
// sets the path the program using this is at
SYSTEM_PROC(void, SACKSystemSetProgramPath)( CTEXTSTR path );
// sets the name of the program using this library
SYSTEM_PROC(void, SACKSystemSetProgramName)( CTEXTSTR name );
// sets the current working path of the system using this library(getcwd doesn't work?)
SYSTEM_PROC(void, SACKSystemSetWorkingPath)( CTEXTSTR name );
// Set the path of this library.
SYSTEM_PROC(void, SACKSystemSetLibraryPath)( CTEXTSTR name );
#endif
/*
* Creates a process-identified exit event which can be signaled to terminate the process.
*/
SYSTEM_PROC( void, EnableExitEvent )( void );
/*
  Add callback which is called when the exit event is executed.
  The callback can return non-zero to prevent the task from exiting; but the event is no
  longer valid, and cannot be triggered again.
*/
SYSTEM_PROC( void, AddKillSignalCallback )( int( *cb )( uintptr_t ), uintptr_t );
/*
  Remove a callback which was added to event callback list.
*/
SYSTEM_PROC( void, RemoveKillSignalCallback )( int( *cb )( uintptr_t ), uintptr_t );
#if _WIN32
/*
  moves the window of the task; if there is a main window for the task within the timeout perioud.
  callback is called when the window is moved; this allows a background thread to wait
  until the task has created its window.
*/
SYSTEM_PROC( void, MoveTaskWindow )( PTASK_INFO task, int timeout, int left, int top, int width, int height, void cb( uintptr_t, LOGICAL ), uintptr_t psv );
/*
  sets styles for window (class and window style attributes)
  runs a thread which is able to wait for the task's window to be created.  callback is called when completed.
  If no callback is supplied, there is no notification of success or failure.
  `int` status passed to the callback is a combination of statuses for window(1), windowEx(2), and class(4) styles
  and is 7 if all styles are set successfully.
  -1 can be passed as a style value to prevent updates to that style type.
*/
SYSTEM_PROC( void, StyleTaskWindow )( PTASK_INFO task, int timeout, int windowStyle, int windowExStyle, int classStyle, void cb( uintptr_t, int ), uintptr_t psv );
/*
  Moves the window of the specified task to the specified display device; using a lookup to get the display size.
  -1 is an invalid display.
  0 is the default display
  1+ is the first display and subsequent displays - one of which may be the default
*/
SYSTEM_PROC( void, MoveTaskWindowToDisplay )( PTASK_INFO task, int timeout, int display, void cb( uintptr_t, LOGICAL ), uintptr_t psv );
/*
  Moves the window of the specified task to the specified monitor; using a lookup to get the display size.
  0 and less is an invalid display.
  1+ is the first monitor and subsequent monitors
*/
SYSTEM_PROC( void, MoveTaskWindowToMonitor )( PTASK_INFO task, int timeout, int display, void cb( uintptr_t, LOGICAL ), uintptr_t psv );
/*
  Refresh internal window handle for task; uses internal handle as cached value for performance.
*/
SYSTEM_PROC( HWND, RefreshTaskWindow )( PTASK_INFO task );
/*
  Returns a character string with the window title in it.  If the window is not found for
  the task the string is "No Window".
  The caller is responsible for releasing the string buffer;
*/
SYSTEM_PROC( char*, GetWindowTitle )( PTASK_INFO task );
struct process_tree_pair {
    int process_id;
    INDEX parent_id;
    INDEX child_id;
    INDEX next_id;
};
/*
  returns a datalist of process_tree_pair members;
    parent_id is an index into the datalist...
    current = GetDataItem( &pdlResult, 0)
    while( current->child_id >= 0 ) {
      current = GetDataItem( &pdlResult,current->child_id );
    }
    // although that doesn't account for peers - and assumes a linear
    // child list.
    struct depth_node {
      struct process_tree_pair *pair;
      int level;
    }
    PDATASTACK stack = CreateDataStack( sizeof( struct depth_node ));
    struct depth_node node;
    struct depth_node deepest_node;
    deepest_node.level = -1;
    node.pair = GetDataItem( &pdlResult, 0);
    node.level = 0;
    PushData( &node );
    while( current = PopData( &stack ) ) {
      if( current->child_id >= 0 ){
        node.pair = GetDataItem( &pdlResult, current->child_id );
        node.level = current.level+1;
        if( node.level > deepest_node.level ) {
          deepest_node = node;
        }
        PushData( &node );
      }
      if( current->next_id >= 0 ){
        node.pair = GetDataItem( &pdlResult, current->next_id );
        node.level = current.level;
        PushData( &node );
      }
    }
*/
SYSTEM_PROC( PDATALIST, GetProcessTree )( PTASK_INFO task );
#endif
#ifdef __LINUX__
/*
  Processes launched with LPP_OPTION_INTERACTIVE have a PTY handle.
  This retrieves that handle so things like setting terminal size can
  be done.
*/
SYSTEM_PROC( int, GetTaskPTY )( PTASK_INFO task );
#endif
#ifdef __cplusplus
 // SACK_SYSTEM_NAMESPACE_END
} }
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
/* Compatibility declaration for MinGW (use MinGW64 to build now
   please?)                                                      */
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
/* Compatibility declaration for MinGW (use MinGW64 to build now
   please?)                                                      */
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
/* Memory interface. see <link memory>, */
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#if defined( __MAC__ )
#  define strdup(s) StrDup(s)
#  define strdup_free(s) Release(s)
#else
#  define strdup_free(s) free(s)
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
#define _TIMER_NAMESPACE_END }
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define _TIMER_NAMESPACE_END
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
#ifdef __cplusplus
namespace sack {
/*
   timer, timing, threading, and criticalsection.
*/
namespace timers {
# endif
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
	// these are not included without a special compile flag
	// only required by low level deveopers who may be against
   // undefined behavior.
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
}
 // namespace sack
}
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate / New - get new memory
   Release / Deallocate - allow others to use this memory
   Hold - keep the memory; requires an additional Release.
   Reallocate - given an existing block, allocate a new block, and copy the minimum of what's already in the block, and the new block size.  It is possible this is the same address, which is just extended into a free block.
   OpenSpace - Low level system memory; requested by filename and region name and provides sharing;  NULL, NULL is just new memory.
   GetHeapMemStats - Run diagnostics on the heap blocks.
   SetAllocateLogging - enable allocate/deallocate loggging for debugging; returns the previous logging state.
   SetAllocateDebug -  disables additional runtime checks compiled in for debug builds/
   SetManualAllocateCheck - GetHeapMemStats is run every Allocate/Deallocate in debug mode; this disables that behavior, and expects the libary's user to check as required.
   SetCriticalLogging - Enable/disable critical section logging; does of course influence timing when enabled.
   SetMinAllocate - defines a minimum size that will be tracked internally; if every block is at least 100 bytes (for example), there is less chance at fragmentation when allocating 32-96 byte blocks.
   SetHeapUnit - How much to expand the heap when more space is required.   Very large allocations will end up with their own memory mapped; but the sum of all small allocations will fill up a block of memory, and this controls the expansion rate.
   AlignOfMemBlock - Get the alignment of a memory block; allows reallocate
                                                */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( "Picture Memory", "Picture.mem", 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, size_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, size_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, size_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, size_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,(uintptr_t)(sizeof(type)*(count))))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (POINTER)(p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx((POINTER)p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS );
#define SetAllocateLogging(tf) SetAllocateLoggingEx( tf DBG_SRC )
MEM_PROC  int MEM_API  ClearAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS );
#define ClearAllocateLogging(tf) ClearAllocateLoggingEx( tf DBG_SRC )
MEM_PROC  int MEM_API  ResetAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS );
#define ResetAllocateLogging(tf) ResetAllocateLoggingEx( tf DBG_SRC )
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( volatile uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( volatile uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* Compares two strings, one utf8 and one utf16, case insensitively.
	Parameters
	s1 :  string to compare
	s2 :  string to compare
	Returns
	0 if equal.
	1 if (s1 \>s2)
	\-1 if (s1 \< s2)
	if s1 is NULL and s2 is not NULL, return is -1.
	if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API StrCaseCmp_u8u16( const char* s1, const wchar_t* s2 );
/* Compares two strings, one utf8 and one utf16, case insensitively.
	Parameters
	s1 :  string to compare
	s2 :  string to compare
	maxlen : maximum characters to compare
	Returns
	0 if equal.
	1 if (s1 \>s2)
	\-1 if (s1 \< s2)
	if s1 is NULL and s2 is not NULL, return is -1.
	if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API StrCaseCmpEx_u8u16( const char* s1, const wchar_t* s2, size_t maxLen );
/* Compares two strings, both utf16, case insensitively.
	Parameters
	s1 :  string to compare
	s2 :  string to compare
	Returns
	0 if equal.
	1 if (s1 \>s2)
	\-1 if (s1 \< s2)
	if s1 is NULL and s2 is not NULL, return is -1.
	if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmpW( const wchar_t* s1, const wchar_t* s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* \Returns the count of bytes in a string, which includes the \u0000 at the end.
	Parameters
	s :  string to measure (with wide characters)
	Returns
	length of string.                             */
MEM_PROC  size_t MEM_API  StrBytesW( wchar_t const* s );
/* \Returns the count of bytes in a string, if converted to utf8.
	Parameters
	s : wide string to measure (with wide characters)
	Returns
	length of string.                             */
MEM_PROC  size_t MEM_API  StrBytesWu8( wchar_t const* s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTRUNE c );
/* Finds the last instance of a character in a string.
	Parameters
	s1 :  String to search in
	c :   character to find
	Returns
	NULL if character is not in the string.
	a pointer to the last character in s1 that matches c. */
MEM_PROC  const wchar_t* MEM_API  StrRChrW( const wchar_t* s1, TEXTRUNE c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
MEM_PROC  wchar_t* MEM_API  StrRChrW( wchar_t* s1, TEXTRUNE c );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( "look in this string", "in" );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( "look in this string" );
   TEXTCHAR *found = StrStr( writable_string, "in" );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
}
 // namespace sack
}
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifdef __LINUX__
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
#define _TIMER_NAMESPACE_END }
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define _TIMER_NAMESPACE_END
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ )
#  if defined( __ANDROID__ ) || defined( EMSCRIPTEN ) || defined( __MAC__ )
// android > 21 can use pthread_mutex_timedop
#    define USE_PIPE_SEMS
#  else
//   Default behavior is to use pthread_mutex_timedlock for wakeable sleeps.
// no semtimedop; no semctl, etc
//#    include <sys/sem.h>
//originally used semctl; but that consumes system resources that are not
//cleaned up when the process exits.
#endif
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
#ifdef __cplusplus
namespace timers {
#endif
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/*
  OnThreadCreate allows registering a procedure to run
  when a thread is created.  (Or an existing thread becomes
  tracked within this library, via MakeThread() ).
  It is called once per thread, for each thread created
  after registering the callback.
*/
TIMER_PROC( void, OnThreadCreate )( void ( *v )( void ) );
/*
  OnThreadExit allows registering a procedure to run
  when a thread exits.
  It is called once per thread, for each thread that exits
  after registering the callback.
*/
TIMER_PROC( void, OnThreadExit )( void ( *v )( void ) );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
	application; native windows criticalsections allocate an
   external object; this should be called typically.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#  define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#  define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#  if DBG_AVAILABLE
#    define EnterCriticalSecEx(pcs, a, b) EnterCriticalSection( pcs )
#    define LeaveCriticalSecEx(pcs, a, b) LeaveCriticalSection( pcs )
#    define InitializeCriticalSecEx(pcs, a, b) InitializeCriticalSection( pcs )
#  else
#    define EnterCriticalSecEx(pcs) EnterCriticalSection( pcs )
#    define LeaveCriticalSecEx(pcs) LeaveCriticalSection( pcs )
#    define InitializeCriticalSecEx(pcs) InitializeCriticalSection( pcs )
#  endif
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _WIN32
#  ifdef CONSOLE_SHELL
 // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#    define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#    define EndSaneWinMain() } }
#  else
#    define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#    define EndSaneWinMain() } }
#  endif
#else
#  if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#    define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#    define EndSaneWinMain()
#  else
#    define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#    define EndSaneWinMain() } }
#  endif
#endif
/**
 * https://stackoverflow.com/questions/3585583/convert-unix-linux-time-to-windows-filetime
 * number of seconds from 1 Jan. 1601 00:00 to 1 Jan 1970 00:00 UTC
 * subtract from FILETIME to get timespec
 * add to timespec to get FILETIME ticks.
 * * 1000000000
 */
#define EPOCH_DIFF 11644473600ULL
#define EPOCH_DIFF_MS 11644473600000ULL
#define EPOCH_DIFF_NS 11644473600000000000ULL
#ifdef WIN32
DeclareThreadLocal FILETIME ft;
// we want this as fast as possible, so inline always.
#define timeGetTime64ns( ) ( GetSystemTimeAsFileTime( &ft ),((uint64_t*)&ft)[0]*100-EPOCH_DIFF_NS )
#define timeGetTime64( ) ( GetSystemTimeAsFileTime( &ft ),((uint64_t*)&ft)[0]/10000-EPOCH_DIFF_MS )
#define timeGetTime() (uint32_t)(timeGetTime64())
#else
DeclareThreadLocal struct timespec global_static_time_ts;
#define timeGetTime64ns( ) ( clock_gettime(CLOCK_REALTIME, &global_static_time_ts), (uint64_t)global_static_time_ts.tv_sec*(uint64_t)1000000000 + (uint64_t)global_static_time_ts.tv_nsec )
#define timeGetTime64( ) ( clock_gettime(CLOCK_REALTIME, &global_static_time_ts), (uint64_t)global_static_time_ts.tv_sec*(uint64_t)1000 + (uint64_t)global_static_time_ts.tv_nsec/1000000 )
#define timeGetTime() (uint32_t)(timeGetTime64())
#endif
#define tickToTimeSpec(ts,tick) (((ts).tv_sec = (tick) / 1000ULL),((ts).tv_nsec=((tick)%1000ULL)*1000000ULL))
#define tickToFileTime(ft,tick) ((((ft).highPart).tv_sec = ((tick*10000)+EPOCH_DIFF_MS)>>32 ),(((ft).lowPart)=((tick*10000)+EPOCH_DIFF_MS) & 0XFFFFFFFF ))
#define tickNsToTimeSpec(ts,tick) (((ts).tv_sec = (tick) / 1000000000ULL),((ts).tv_nsec=(tick)%1000000000ULL))
#define tickNsToFileTime(ft,tick) ((((ft).highPart).tv_sec = ((tick)+EPOCH_DIFF_NS)>>32 ),(((ft).lowPart)=((tick)+EPOCH_DIFF_NS) & 0XFFFFFFFF ))
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define snprintf _snprintf
#    define vsnprintf _vsnprintf
#    if defined( _UNICODE )
#      define tnprintf _snwprintf
#      define vtnprintf _vsnwprintf
#    else
#      define tnprintf _snprintf
#      define vtnprintf _vsnprintf
#    endif
#    define snwprintf _snwprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
#if 0
#ifdef __cplusplus
namespace sack {
   namespace logging {
#endif
      INDEX real_lprintf( char const* f,... ) { va_list va; int n; va_start(va,f); n = vprintf(f ,va); puts(""); return n; }
      INDEX null_lprintf( char const* f,... ) { return 0; }
      RealLogFunction _xlprintf(uint32_t level DBG_PASS) { return real_lprintf; };
      void SystemLog( char const* f ) { puts( f ); puts( "ZZZZ\n" ); }
#ifdef __cplusplus
   }
}
#endif
#endif
/*
 *  Crafted by James Buckeyne
 *
 *	(c) Freedom Collective 2000-2006++
 *
 *	code to drive standard containers, lists, stacks, queues
 *	auto expanding, auto tracking, threadsafe containers...
 *
 *  standardized to never use int.
 *
 * see also - include/typelib.h
 *
 */
 // offsetof
 // Sleep
/* Deadstart interface. Deadstart is like bootstrap, and handles
   code that runs before main(). See <link deadstart>            */
#ifndef DEADSTART_DEFINED
#define DEADSTART_DEFINED
#ifdef WIN32
//#include <stdhdrs.h>
#endif
 // leach, assuming this will be compiled with this part at least.
#define pastejunk_(a,b) a##b
#define pastejunk(a,b) pastejunk_(a,b)
#ifdef __cplusplus
#  define USE_SACK_DEADSTART_NAMESPACE using namespace sack::app::deadstart;
#  define SACK_DEADSTART_NAMESPACE  SACK_NAMESPACE namespace app { namespace deadstart {
#  define SACK_DEADSTART_NAMESPACE_END  } } SACK_NAMESPACE_END
namespace sack{
	namespace app{
/* Application namespace. */
/* These are compiler-platform abstractions to provide a method
   of initialization that allows for creation of threads, and
   transparent (easy to use) method of scheduling routines for
   initialization.
   Example
   This schedules a routine to run at startup. Fill in the
   routine with the code you want, and it will run at
   DEFAULT_PRELOAD_PRIORITY which is the number 69.
   <code lang="c++">
   PRELOAD( MyCustomInit )
   {
       // do something here (do anything here,
       // without limitations that are imposed by DllMain/LibMain.
   }
   </code>
   If you wanted a routine which was guaranteed to run before
   MyCustomInit you might use PRIORITY_PRELOAD whcih allows you
   to specify a priority.
   <code lang="c++">
   PRIORITY_PRELOAD( MyOtherInit, DEFAULT_PRELOAD_PRIORITY-10 )
   {
      // this will run before other things.
   }
   </code>
   Priorities are listed in deadstart.h and exit_priorities.h. The
   priorities are treated backwards, so low number startup
   priorities go first, and higher number shutdown priorities go
   first.
   Remarks
   In some compilers and compile modes this is also fairly easy
   to do. A lot of compilers do not offer priority, and are
   impossible to maintain an order in. Some compilers only
   provide startup priority for C++ mode. This system works as
   \long as there is a way to run a single function at some
   point before main() and after C runtime initializes.
   In Windows, you might think you have this ability with
   DllMain, but there are severe limitations that you would have
   to get around; primary is the inability to create a thread,
   well, you can create it, but it will remain suspended until
   you leave DllMains and all DllMains finish. There is also no
   way to consistantly provide initialization order, like memory
   needs to be initialized before anything else.
                                                                   */
		namespace deadstart {
		}
	}
 //SACK_NAMESPACE_END
}
#else
#define USE_SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE_END
#endif
#ifdef TYPELIB_SOURCE
#define DEADSTART_SOURCE
#endif
#ifdef __cplusplus
namespace sack{
	namespace app{
		namespace deadstart {
//SACK_DEADSTART_NAMESPACE
#endif
/* A macro to specify the call type of schedule routines. This
   can be changed in most projects without affect, it comes into
   play if plugins built by different compilers are used,
   __cdecl is most standard.                                     */
#define DEADSTART_CALLTYPE CPROC
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define DEADSTART_PROC extern
#  elif defined( _TYPELIBRARY_SOURCE )
#    define DEADSTART_PROC EXPORT_METHOD
#  else
/* A definition for how to declare these functions. if the
   source itself is comipling these are _export, otherwise
   external things linking here are _import.               */
#    define DEADSTART_PROC IMPORT_METHOD
#  endif
     // 28 (thread ID for critical sections used to allocate memory)
#define TIMER_MODULE_PRELOAD_PRIORITY  (CONFIG_SCRIPT_PRELOAD_PRIORITY-3)
     // 30 specify where to load external resources from... like the option database
#define VIRTUAL_FILESYSTEM_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
   /* this is just a global space initializer (shared, named
      region, allows static link plugins to share information)
      Allocates its shared memory global region, so if this library
      is built statically and referenced in multiple plugins
      ConfigScript can share the same symbol tables. This also
		provides sharing between C++ and C.                           */
         // 31
#define CONFIG_SCRIPT_PRELOAD_PRIORITY    (SQL_PRELOAD_PRIORITY-3)
			// this is just a global space initializer (shared, named region, allows static link plugins to share information)
         // 34
#define SQL_PRELOAD_PRIORITY    (SYSLOG_PRELOAD_PRIORITY-1)
/* Level at which logging is initialized. Nothing under this
   should be doing logging, if it does, the behavior is not as
   well defined.                                               */
#define SYSLOG_PRELOAD_PRIORITY 35
   // global_init_preload_priority-1 is used by sharemem.. memory needs init before it can register itself
#define GLOBAL_INIT_PRELOAD_PRIORITY 37
 // OS A[bstraction] L[ayer] O[n] T[op] - system lib
#define OSALOT_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
/* Level which names initializes. Names is the process
   registration code. It has a common shared global registered.
   <link sack::app::registry, procreg; aka names.c>             */
#define NAMESPACE_PRELOAD_PRIORITY 39
/* image_preload MUST be after Namespce preload (anything that
   uses RegisterAndCreateGlobal) should init this before vidlib
   (which needs image?)                                         */
#define IMAGE_PRELOAD_PRIORITY  45
/* Level at which the video render library performs its
   initialization; RegisterClass() level code.          */
#define VIDLIB_PRELOAD_PRIORITY 46
/* Initialization level where PSI registers its builtin
   controls.                                            */
#define PSI_PRELOAD_PRIORITY    47
// need to open the queues and threads before the service server can begin...
#define MESSAGE_CLIENT_PRELOAD_PRIORITY 65
/* Level which message core service initializes. During startup
   message services can register themselves also; but not before
   this priority level.                                          */
#define MESSAGE_SERVICE_PRELOAD_PRIORITY 66
/* Routines are scheduled at this priority when the PRELOAD
   function is used.                                        */
#define DEFAULT_PRELOAD_PRIORITY (DEADSTART_PRELOAD_PRIORITY-1)
/* Not sure where this is referenced, this the core routine
   itself is scheduled with this symbol to the compiler if
   appropriate.                                             */
#define DEADSTART_PRELOAD_PRIORITY 70
#define PRIORITY_UNLOAD(proc,priority) PRIORITY_ATEXIT( proc##_unload, priority )
/* Used by PRELOAD and PRIORITY_PRELOAD macros to register a
   startup routine at a specific priority. Lower number
   priorities are scheduled to run before higher number
   priorities*backwards from ATEXIT priorities*. Using this
   scheduling mechanisms, routines which create threads under
   windows are guaranteed to run before main, and are guaranteed
   able to create threads. (They are outside of the loader lock)
   Parameters
   function :  pointer to a function to call at startup.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityStartupProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* Used by ATEXIT and PRIORITY_ATEXIT macros to register a
   shutdown routine at a specific priority. Higher number
   priorities are scheduled to run before lower number
   priorities. *backwards from PRELOAD priorities* This
   registers functions which are run while the program exits if
   it is at all able to run when exiting. calling exit() or
   BAG_Exit() will invoke these.
   Parameters
   function :  pointer to a function to call at shutdown.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityShutdownProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* This routine is used internally when LoadFunction is called.
   After MarkDeadstartComplete is called, any call to a
   RegisterPriorityStartupProc will call the startup routine
   immediately instead of waiting. This function disables the
   auto-running of this function, and instead enques the startup
   to the list of startups. When completed, at some later point,
   call ResumeDeadstart() to dispatched all scheduled routines,
   and release the suspend; however, if initial deastart was not
   dispatched, then ResumeDeadstart does not do the invoke, it
   only releases the suspend.                                    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  SuspendDeadstart ( void );
/* Resumes a suspended deadstart. If root deadstart is
   completed, then ResumeDeadstart will call InvokeDeadstarts
   after resuming deadstart.                                  */
DEADSTART_PROC  void DEADSTART_CALLTYPE  ResumeDeadstart ( void );
/* Not usually used by user code, but this invokes all the
   routines which have been scheduled to run for startup. If
   your compiler doesn't have a method of handling deadstart
   code, this can be manually called. It can also be called if
   you loaded a library yourself without using the LoadFunction
   interface, to invoke startups scheduled in the loaded
   library.                                                     */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeDeadstart (void);
/* This just calls the list of shutdown procedures. This should
   not be used usually from user code, since internally this is
   handled by catching atexit() or with a static destructor.    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeExits (void);
/* This is typically called after the first InvokeDeadstarts
   completes. The code that runs this is usually a routine just
   before main(). So once code in main begins to run, all prior
   initialization has been performed.                           */
DEADSTART_PROC  void DEADSTART_CALLTYPE  MarkRootDeadstartComplete ( void );
/* \returns whether InvokeDeadstarts has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartStarted ( void );
/* \returns whether MarkRootDeadstartComplete has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartComplete ( void );
/*
   Setup flags to ignore control C Events on windows.  use 1 << (ControlType) or'd together to set ignore.
   Use 0 to clear ignore.
*/
DEADSTART_PROC void DEADSTART_CALLTYPE IgnoreBreakHandler( int ignore );
#if defined( __LINUX__ )
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef DOC_O_MAT
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef __cplusplus
/* Defines some code to run at program inialization time. Allows
   specification of a priority. Lower priorities run first. (default
   is 69).
   Example
   <code>
   PRIORITY_PRELOAD( MyOtherInit, 153 )
   {
      // run some code probably after most all other initializtion is done.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                         */
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);	 namespace { static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityStartupProc( name,TOSTR(name),priority,(void*)this DBG_SRC);	  }	  } pastejunk(do_schedule_,name);   }	  static void name(void)
/* This is used once in deadstart_prog.c which is used to invoke
   startups when the program finishes loading.                   */
#define MAGIC_PRIORITY_PRELOAD(name,priority) static void CPROC name(void);	 namespace { static class pastejunk(schedule_,name) {	     public:pastejunk(schedule_,name)() {	  name();	    }	  } pastejunk(do_schedul_,name);   }	  static void name(void)
/*
  Internal macro used to trigger InvokeExits() which runs scheduled exits.
                                                                     */
#define ATEXIT_INVOKE_INTERNAL(name) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(~schedule_,name)() {			    name();	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* Defines some code to run at program shutdown time. Allows
   specification of a priority. Higher priorities are run first.
   Example
   <code>
   PRIORITY_ATEXIT( MyOtherShutdown, 153 )
   {
      // run some code probably before most library code dissolves.
      // last to load, first to unload.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                 */
	/*name(); / * call on destructor of static object.*/
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static class pastejunk(shutdown_,name) {	   public:pastejunk(shutdown_,name)() {       RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	   }	  } do_shutdown_##name;	     void name(void)
/* This is the most basic way to define some code to run
   initialization before main.
   Example
   <code lang="c++">
   PRELOAD( MyInitCode )
   {
      // some code here
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>      */
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
/* Basic way to register a routine to run when the program exits
   gracefully.
   Example
   \    <code>
   ATEXIT( MyExitRoutine )
   {
       // this will be run sometime during program shutdown
   }
   </code>                                                       */
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
/* This is the core atexit. It dispatches all other exit
   routines. This is defined for internal use only...    */
#define ROOT_ATEXIT(name) ATEXIT_INVOKE_INTERNAL(name)
//------------------------------------------------------------------------------------
// Win32 Watcom
//------------------------------------------------------------------------------------
#elif defined( __WATCOMC__ )
#pragma off (check_stack)
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_pad;
typedef void(*__type_rtn ) ( void );
#ifdef __cplusplus
#pragma pack(1)
#else
#pragma pack(1)
#endif
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // - priority (0-highest 255-lowest)
	 __type_rtp  priority;
#define RUNTIME_PRIORITY_FILTER(x)  (((x)>255)?255:(x))
      // - routine
    __type_rtn  rtn;
};
#pragma pack()
/* end code taken from openwatcom/bld/watcom/h/rtinit.h */
//------------------------------------------------------------------------------------
// watcom
//------------------------------------------------------------------------------------
//void RegisterStartupProc( void (*proc)(void) );
#define PRIORITY_PRELOAD(name,priority) static void pastejunk(schedule_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_ctor_label)={0,(DEADSTART_PRELOAD_PRIORITY-1),pastejunk(schedule_,name)};	 static void pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),RUNTIME_PRIORITY_FILTER(priority),&pastejunk(name,_ctor_label) DBG_SRC );	}	                                       void name(void)
#define ATEXIT_PRIORITY(name,priority) static void pastejunk(schedule_exit_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_dtor_label)={0,69,pastejunk(schedule_exit_,name)};	 static void pastejunk(schedule_exit_,name)(void) {	                                              RegisterPriorityShutdownProc( name,TOSTR(name),RUNTIME_PRIORITY_FILTER(priority),&name##_dtor_label DBG_SRC );	}	                                       void name(void)
// syslog runs preload at priority 65
// message service runs preload priority 66
// deadstart itself tries to run at priority 70 (after all others have registered)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
// this is a special case macro used in client.c
// perhaps all PRIORITY_ATEXIT routines should use this
// this enables cleaning up things that require threads to be
// active under windows... (message disconnect)
// however this routine is only triggered in windows by calling
// BAG_Exit(nn) which is aliased to replace exit(n) automatically
#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY( name,priority)
/*
static void name(void); static void name##_x_(void);	static struct rt_init __based(__segname("YI")) name##_dtor_label={0,priority,name##_x_};	 static void name##_x_(void) { char myname[256];myname[0]=*(CTEXTSTR)&name##_dtor_label;GetModuleFileName(NULL,myname,sizeof(myname));name(); }	 static void name(void)
  */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
// if priority_atexit is used with priority 0 - the proc is scheduled into
// atexit, and exit() is then invoked.
//#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY(name,priority )
//------------------------------------------------------------------------------------
// Linux
//------------------------------------------------------------------------------------
#elif defined( __GNUC__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short   __type_rtp_priority;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp       rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp       scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp_priority  priority;
#define RT_LIST_INIT_PADDING
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	 CTEXTSTR file;
#endif
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#if defined( __GNUC__ ) && defined( __64__)
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
#endif
} __attribute__((packed));
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  if defined( __GNUC__ ) && defined( __64__)
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label), {0,0}
#  else
#    define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#  endif
#else
#  define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#endif
#define RTINIT_STATIC static
#define ATEXIT_PRIORITY PRIORITY_ATEXIT
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#ifdef __MAC__
#  define DEADSTART_SECTION "TEXT,deadstart_list"
#else
#  define DEADSTART_SECTION "deadstart_list"
#endif
#ifdef __MANUAL_PRELOAD__
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)		__attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 =	 {0,0,pr RT_LIST_INIT_PADDING, __LINE__, name PASS_FILENAME	, TOSTR(name) JUNKINIT(name)} ;	 void name(void);	 void pastejunk(registerStartup,name)(void) __attribute__((constructor));	 void pastejunk(registerStartup,name)(void) {	 RegisterPriorityStartupProc(name,TOSTR(name),pr,NULL DBG_SRC); }	 void name(void)
#else
#if defined( _WIN32 ) || defined( __GNUC__ )
#  define HIDDEN_VISIBILITY
#else
#  define HIDDEN_VISIBILITY  __attribute__((visibility("hidden")))
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	         RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)	         __attribute__((section(DEADSTART_SECTION))) __attribute__((used))	  ={0,0,pr RT_LIST_INIT_PADDING	                                   ,__LINE__,name	                                                 PASS_FILENAME	                                                 ,TOSTR(name)	                                                   JUNKINIT(name)};	                                               static void name(void) __attribute__((used));	 void name(void)
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void name(void);           static void pastejunk(atexit,name)(void) __attribute__((constructor));   void pastejunk(atexit,name)(void)                                        {	                                                                        RegisterPriorityShutdownProc(name,TOSTR(name),priority,NULL DBG_SRC); }                                                                        void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT( name,ATEXIT_PRIORITY_DEFAULT )
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// CYGWIN (-mno-cygwin)
//------------------------------------------------------------------------------------
#elif defined( __CYGWIN__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_rtp_priority;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#ifdef __cplusplus
	//rt_init( int _rtn_type ) { rt_init::rtn_type = _rtn_type; }
	/*rt_init( int _priority, CTEXTSTR name, __type_rtn rtn, CTEXTSTR _file, int _line )
	{
		rtn_type = 0;
		scheduled = 0;
		priority = priority;
		file = _file;
		line = _line;
      routine = rtn;
		}
      */
#endif
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp_priority  priority;
#define RT_LIST_INIT_PADDING
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
	 CTEXTSTR file;
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( __GNUC__ ) && defined( __64__ )
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#ifdef __cplusplus
#define RTINIT_STATIC
#else
#define RTINIT_STATIC static
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define ATEXIT_PRIORITY(name,priority) static void name(void); static void atexit##name(void) __attribute__((constructor));	  void atexit_failed##name(void(*f)(void),int i,CTEXTSTR s1,CTEXTSTR s2,int n) { lprintf( "Failed to load atexit_priority registerar from core program." );} void atexit##name(void)                                                  {	                                                                        static char myname[256];HMODULE mod;if(myname[0])return;myname[0]='a';GetModuleFileName( NULL, myname, sizeof( myname ) );	mod=LoadLibrary(myname);if(mod){   typedef void (*x)(void);void(*rsp)( x,const CTEXTSTR,int,const CTEXTSTR,int);	 if((rsp=((void(*)(void(*)(void),const CTEXTSTR,int,const CTEXTSTR,int))(GetProcAddress( mod, "RegisterPriorityShutdownProc")))))	 {rsp( name,TOSTR(name),priority DBG_SRC);}	 else atexit_failed##name(name,priority,TOSTR(name) DBG_SRC);	        }     FreeLibrary( mod);	 }             void name( void)
#ifdef _DEBUG
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct pastejunk(rt_init name,_ctor_label)	   __attribute__((section("deadstart_list")))	 ={0,0,pr RT_LIST_INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 static void name(void)
#define ATEXIT(name)      ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_DEFAULT)
#define PRIORITY_ATEXIT ATEXIT_PRIORITY
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// WIN32 MSVC
//------------------------------------------------------------------------------------
#elif defined( _MSC_VER ) && defined( _WIN32 )
//#define PRELOAD(name) __declspec(allocate(".CRT$XCAA")) void CPROC name(void)
//#pragma section(".CRT$XCA",long,read)
//#pragma section(".CRT$XCZ",long,read)
// put init in both C startup and C++ startup list...
// looks like only one or the other is invoked, not both?
/////// also the variables to be put into these segments
#if defined( __cplusplus_cli )
#define LOG_ERROR(n) System::Console::WriteLine( gcnew System::String(n) + gcnew System::String( myname) ) )
#else
#define LOG_ERROR(n) SystemLog( n )
// since we get linked first, then the runtime is added, we have to link against the last indicator of section,
// so we get put between start to end.
#define _STARTSEG_ ".CRT$XIM"
#define _STARTSEG2_ ".CRT$XCY"
#define _ENDSEG_ ".CRT$XTM"
//#pragma data_seg(".CRT$XIA")
#pragma data_seg(".CRT$XIM")
#pragma section(".CRT$XIM",long,read)
#pragma data_seg(".CRT$XCY")
#pragma section(".CRT$XCY",long,read)
//#pragma data_seg(".CRT$XIZ")
//#pragma data_seg(".CRT$YCZ")
#pragma data_seg(".CRT$XTM")
#pragma section(".CRT$XTM",long,read)
#pragma data_seg()
	                                       /*static __declspec(allocate(_STARTSEG_)) void (CPROC*pointer_##name)(void) = pastejunk(schedule_,name);*/
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static int CPROC pastejunk(schedule_,name)(void);	   __declspec(allocate(_STARTSEG_)) int (CPROC*pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)))(void) = pastejunk(schedule_,name);	 int CPROC pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)) DBG_SRC );	return 0;	 }	 static void CPROC name(void)
#define ROOT_ATEXIT(name) static void name(void);	 __declspec(allocate(_ENDSEG_)) static void (*f##name)(void)=name;    static void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
typedef void(*atexit_priority_proc)(void (*)(void),int,CTEXTSTR DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static int schedule_atexit_##name(void);	   __declspec(allocate(_STARTSEG_)) void (CPROC*pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)))(void) = (void(CPROC*)(void))schedule_atexit_##name;	 static int schedule_atexit_##name(void) {	                 RegisterPriorityShutdownProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)) DBG_SRC );	return 0;	 }	                                       static void CPROC name(void)
#define ATEXIT_PRIORITY(name,priority) PRIORITY_ATEXIT(name,priority)
#endif
#ifdef __cplusplus_cli
#define InvokeDeadstart() do {	                                              TEXTCHAR myname[256];HMODULE mod;	 mod=LoadLibrary("sack_bag.dll");if(mod){           void(*rsp)(void);	 if((rsp=((void(*)(void))(GetProcAddress( mod, "RunDeadstart"))))){rsp();}else{lprintf( "Hey failed to get proc %d", GetLastError() );}	FreeLibrary( mod); }} while(0)
#else
#endif
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//extern uint32_t deadstart_complete;
//#define DEADSTART_LINK uint32_t *deadstart_link_couple = &deadstart_complete; // make sure we reference this symbol
//#pragma data_seg(".CRT$XCAA")
//extern void __cdecl __security_init_cookie(void);
//static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
//#pragma data_seg()
//------------------------------------------------------------------------------------
// UNDEFINED
//------------------------------------------------------------------------------------
#else
#error "there's nothing I can do to wrap PRELOAD() or ATEXIT()!"
/* This is the most basic way to define some startup code that
   runs at some point before the program starts. This code is
   declared as static, so the same preload initialization name
   can be used in multiple files.
   <link sack::app::deadstart, See Also.>                      */
#define PRELOAD(name)
#endif
/* Defines ATEXIT priorities so the library can tear itself down
   gracefully.                                                   */
// the higher the number the earlier it is run
#define ATEXIT_PRIORITY_SHAREMEM  1
#define ATEXIT_PRIORITY_THREAD_SEMS ATEXIT_PRIORITY_SYSLOG-1
#define ATEXIT_PRIORITY_SYSLOG    35
#define ATEXIT_PRIORITY_MSGCLIENT 85
#define ATEXIT_PRIORITY_DEFAULT   90
#define ATEXIT_PRIORITY_TIMERS   (ATEXIT_PRIORITY_DEFAULT+1)
// this is the first exit to be run.
// under linux it is __attribute__((destructor))
// under all it is registered during preload as atexit()
// only the runexits in deadstart should use ROOT_ATEXIT
#ifdef __WATCOMC__
#define ATEXIT_PRIORITY_ROOT 255
#else
#define ATEXIT_PRIORITY_ROOT 101
#endif
#ifdef __cplusplus
 //SACK_DEADSTART_NAMESPACE_END
} } }
#endif
USE_SACK_DEADSTART_NAMESPACE
#endif
/*
 * Create: James Buckeyne
 *
 * Purpose: Provide a general structure to register names of
 *   routines and data structures which may be consulted
 *   for runtime linking.  Aliases and other features make this
 *   a useful library for tracking interface registration...
 *
 *  The namespace may be enumerated.
 */
#ifndef PROCEDURE_REGISTRY_LIBRARY_DEFINED
#define PROCEDURE_REGISTRY_LIBRARY_DEFINED
#ifdef PROCREG_SOURCE
#define PROCREG_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PROCREG_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#ifdef __cplusplus_cli
//using namespace System;
#endif
#   define _INTERFACE_NAMESPACE namespace Interface {
#   define _INTERFACE_NAMESPACE_END }
#define PROCREG_NAMESPACE namespace sack { namespace app { namespace registry {
#define _PROCREG_NAMESPACE namespace registry {
#define _APP_NAMESPACE namespace app {
#define PROCREG_NAMESPACE_END }}}
//extern "C"  {
#else
#   define _INTERFACE_NAMESPACE
#   define _INTERFACE_NAMESPACE_END
#define _PROCREG_NAMESPACE
#define _APP_NAMESPACE
#define PROCREG_NAMESPACE
#define PROCREG_NAMESPACE_END
#endif
#ifdef __cplusplus
namespace sack {
#endif
/* Deadstart is support which differs per compiler, but allows
   applications access a C++ feature - static classes with
   constructors that initialize at loadtime, but, have the
   feature that you can create threads. Deadstart code is run
   after the DLL load lock under windows that prevents creation
   of threads; however, deadstart is run before main. Deadstart
   routines can have a priority. Certain features require others
   to be present always. This allows explicit control of
   priority unlink using classes with static constructors, which
   requires ordering of objects to provide linking order. Also
   provides a similar registration mechanism for atexit, but
   extending with priority. Deadstop registrations are done
   sometime during normal C atexit() handling, but may be
   triggered first by calling BAG_Exit.
   Registry offers support to register functions, and data under
   a hierarchy of names. Names are kept in a string cache, which
   applications can take benefit of. Strings will exist only a
   single time. This table could be saved, and a look-aside
   table for language translation purposes. Registry is the
   support that the latest PSI relies on for registering event
   callbacks for controls. The registry was always used, but,
   the access to it was encapsulated by DoRegisterControl
   registering the appropriate methods.                          */
	_APP_NAMESPACE
   /* Contains methods dealing with registering routines and values
      in memory. Provisions are available to save the configuration
      state, but the best that can be offered here would be a
      translation tool for text strings. The namespace is savable,
      but most of the content of the registration space are short
      term pointers. Namespace containing registry namespace.
      old notes - very discongruant probably should delete them.
      Process name registry
      it's a tree of names.
      there are paths, and entries
      paths are represented as class_name
      PCLASSROOT is also a suitable class name
      PCLASSROOT is defined as a valid CTEXTSTR.
      there is (apparently) a name that is not valid as a path name
      that is TREE
      guess.
      POINTER in these two are equal to (void(*)(void)) but -
      that's rarely the most useful thing... so
      name class is a tree of keys... /\<...\>
      psi/control/## might contain procs Init Destroy Move
      RegAlias( "psi/control/3", "psi/control/button"
      ); psi/control/button and psi/control/3 might reference the
      same routines
      psi/frame Init Destroy Move memlib Alloc Free
      network/tcp
      I guess name class trees are somewhat shallow at the moment
      not going beyond 1-3 layers
      names may eventually be registered and reference out of body
      services, even out of box...
      the values passed as returntype and parms/args need not be
      real genuine types, but do need to be consistant between the
      registrant and the requestor... this provides for full name
      dressing, return type and paramter type may both cause
      overridden functions to occur...                              */
_PROCREG_NAMESPACE
#ifndef REGISTRY_STRUCTURE_DEFINED
	// make these a CTEXTSTR to be compatible with name_class...
#ifdef __cplusplus
	// because of name mangling and stronger type casting
	// it becomes difficult to pass a tree_def_tag * as a CTEXTSTR classname
	// as valid as this is.
	typedef struct tree_def_tag const * PCLASSROOT;
#else
	typedef CTEXTSTR PCLASSROOT;
#endif
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#else
	typedef struct tree_def_tag const * PCLASSROOT;
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#endif
/* CheckClassRoot reads for a path of names, but does not create
   it if it does not exist.                                      */
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR class_name );
/* \Returns a PCLASSROOT of a specified path. The path may be
   either a PCLASSROOT or a text string indicating the path. the
   Ex versions allow passing a base PCLASSROOT path and an
   additional subpath to get. GetClassRoot will always create
   the path if it did not exist before, and will always result
   with a root.
   Remarks
   a CTEXTSTR (plain text string, probably wide character if
   compiled unicode) and a PCLASSROOT are always
   interchangeable. Though you may need a forced type cast, I
   have defined both CTEXTSTR and PCLASSROOT function overloads
   for c++ compiled code, and C isn't so unkind about the
   conversion. I think problem might lie that CTEXTSTR has a
   const qualifier and PCLASSROOT doesn't (but should).
   Example
   <code lang="c++">
   PCLASSROOT root = GetClassRoot( "psi/resource" );
   // returns the root of all resource names.
   </code>
   <code>
   PCLASSROOT root2 = GetClassRootEx( "psi/resource", "buttons" );
   </code>                                                         */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class );
#ifdef __cplusplus
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class );
#endif
/* Fills a string with the path name to the specified node */
PROCREG_PROC( int, GetClassPath )( TEXTSTR out, size_t len, PCLASSROOT root );
/* Sets the interface configuration file to be used by the
	registry. This is the file that will be used to save the
	configuration of the interface, and will be loaded at startup.
	If this is not set, then the default interface configuration
	file will be used.
	Parameters
	filename :  The name of the file to use for the interface
	         configuration.  the file is duplicated, so the value
			 may be deallocated after this.
	Example
	<code lang="c++">
	char *filename = strdup( "my_interface.cfg" );
	SetInterfaceConfigFile( filename );
	free( filename );
	</code>                                                                 */
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename );
/* Sets the interface configuration file to be used by the
	registry. This is the file that will be used to save the
	configuration of the interface, and will be loaded at startup.
	If this is not set, then the default interface configuration
	file will be used.
	Parameters
	filename :  The name of the file to use for the interface
	         configuration.  The pointer passed is retained,
			 and is not duplicated.
	Example
	<code lang="c++">
	  SetStaticInterfaceConfigFile( "my_interface.cfg" );
	</code>                                                                 */
PROCREG_PROC( void, SetStaticInterfaceConfigFile )( CTEXTSTR filename );
/* Get[First/Next]RegisteredName( "classname", &amp;data );
   these operations are not threadsafe and multiple thread
   accesses will cause mis-stepping
   These functions as passed the address of a POINTER. this
   POINTER is for the use of the browse routines and should is
   meaningless to he calling application.
   Parameters
   root :       The root to search from
   classname :  A sub\-path from the root to search from
   data :       the address of a pointer that keeps track of
                information about the search. (opaque to user)
   Example
   Usage:
   <code lang="c++">
   CTEXTSTR result;
   POINTER data = NULL;
   for( result = GetFirstRegisteredName( "some/class/path", &amp;data );
        \result;
        \result = GetNextRegisteredName( &amp;data ) )
   {
        // result is a string name of the current node.
        // can use that name and GetRegistered____ (function/int/value)
        if( NameHasBranches( &amp;data ) ) // for consitancy in syntax
        {
            // consider recursing through tree, name becomes a valid classname for GetFirstRegisteredName()
        }
   }
   </code>                                                                                                  */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data );
#ifdef __cplusplus
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
	PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data );
#endif
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data );
/* Steps to the next registered name being browsed. Is passed
   only the pointer to data. See GetFirstRegisteredName for
   usage.
   See Also
   <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, sack::app::registry::GetFirstRegisteredNameEx Function> */
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data );
/* When using GetFirstRegisteredName and GetNextRegisteredName
   to browse through names, this function is able to get the
   current PCLASSROOT of the current node, usually you end up
   with just the content of that registered name.
   \result with the current node ( useful for pulling registered
   subvalues like description, or file and line )
                                                                 */
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data );
#ifdef __cplusplus
//PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, POINTER *data );
//PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( POINTER *data );
#endif
// while doing a scan for registered procedures, allow applications to check for branches
//PROCREG_PROC( int, NameHasBranches )( POINTER *data );
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data );
// while doing a scan for registered procedures, allow applications to ignore aliases...
PROCREG_PROC( int, NameIsAlias )( PCLASSROOT *data );
/*
 * RegisterProcedureExx(
 *
 */
 // root name or PCLASSROOT of base path
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
 // an additional path on root
													  , CTEXTSTR name_class
 // the name of the value entry saved in the tree
													  , CTEXTSTR public_name
 // the text return type of this function - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR returntype
 // name of the library this symbol is in - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR library
 // actual C function name in library - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR name
 // preferably the raw argument string of types and no variable references "([type][,type]...)"
													  , CTEXTSTR args
 // file and line of the calling application.  May be no parameter in release mode.
													  DBG_PASS
													  );
/*
 * RegisterProcedureEx( root       // root path
 *                    , name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedureEx(root,nc,n,rtype,proc,args)  RegisterProcedureExx( (root),(nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * RegisterProcedure( name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedure(nc,n,rtype,proc,args)  RegisterProcedureExx( NULL, (nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * Branches on the tree may be aliased together to form a single branch
 *
 */
				// RegisterClassAlias( "psi/control/button", "psi/control/3" );
				// then the same set of values can be referenced both ways with
				// really only a single modified value.
/* parameters to RegisterClassAliasEx are the original name, and the new alias name for the origianl branch*/
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias );
/* <combine sack::app::registry::RegisterClassAliasEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                              */
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR newalias );
// root, return, public, args, address
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR parms
																  );
#define ReadRegisteredProcedure( root,rt,a) ((rt(CPROC*)a)ReadRegisteredProcedureEx(root,#rt,#a))
/* Gets a function that has been registered. */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
#define GetRegisteredProcedureExx(root,nc,rt,n,a) ((rt (CPROC*)a)GetRegisteredProcedureExxx(root,nc,#rt,n,#a))
#define GetRegisteredProcedure2(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
#define GetRegisteredProcedureNonCPROC(nc,rtype,name,args) (rtype (*)args)GetRegisteredProcedureEx((nc),#rtype, name, #args )
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													, PCLASSROOT name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
													, PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
                                       , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#endif
//#define RegisterFunctionExx( r,nc,p,rt,proc,ar ) RegisterFunctionExx( r,nc,p,rt,proc,ar,TARGETNAME,NULL DBG_SRC )
//#define RegisterFunctionEx(r,nc,pn,rt,proc,args,lib,rn) RegisterFunctionExx(r,nc,pn,rt,proc,args,lib,rn DBG_SRC)
#define RegisterFunctionEx( root,proc,rt,pn,a) RegisterFunctionExx( root,NULL,pn,rt,(PROCEDURE)(proc),a,NULL,NULL DBG_SRC )
#define RegisterFunction( nc,proc,rt,pn,a) RegisterFunctionExx( (PCLASSROOT)NULL,nc,pn,rt,(PROCEDURE)(proc),a,TARGETNAME,NULL DBG_SRC )
#define SimpleRegisterMethod(r,proc,rt,name,args) RegisterFunctionExx(r,NULL,name,rt,(PROCEDURE)proc,args,NULL,NULL DBG_SRC )
#define GetRegisteredProcedure(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),#rtype, #name, #args )
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value );
/* \ \
   Parameters
   root :        Root class to start searching from
   name_class :  An additional sub\-path to get the name from
   name :        the name within the path specified
   bIntVal :     a true/false whether to get the string or
                 integer value from the specified node.
   Returns
   A pointer to a string if bIntVal is not set. (NULL if there
   was no string).
   Otherwise will be an int shorter than or equal to the size of
   a pointer, which should be cast to an int if bIntVal is set,
   and there is a value registered there. Probably 0 if no
   value, so registered 0 value and no value is
   indistinguisable.                                             */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
PROCREG_PROC( int, RegisterIntValueEx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
#endif
/* This is like GetRegisteredValue, but takes the address of the
   type to return into instead of having to cast the final
   \result.
   if bIntValue, result should be passed as an (&amp;int)        */
PROCREG_PROC( int, GetRegisteredStaticValue )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name
															, CTEXTSTR *result
															, int bIntVal );
#define GetRegisteredStaticIntValue(r,nc,name,result) GetRegisteredStaticValue(r,nc,name,(CTEXTSTR*)result,TRUE )
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name );
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name );
#endif
typedef void (CPROC*OpenCloseNotification)( POINTER, uintptr_t );
#define PUBLIC_DATA( public, struct, open, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataType( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)close ); }
#define PUBLIC_DATA_EX( public, struct, open, update, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataTypeEx( "system/data/structs"	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)update, (OpenCloseNotification)close ); }
#define GET_PUBLIC_DATA( public, type, instname )    (type*)CreateRegisteredDataType( "system/data/structs", public, instname )
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , OpenCloseNotification open
												 , OpenCloseNotification close );
/* Registers a structure as creatable in shared memory by name.
   So a single name of the structure can be used to retrieve a
   pointer to one created.
   Example
   \ \
   <code lang="c++">
   POINTER p = CreateRegisteredDataType( "My types", "my_registered_type", "my instance" );
   // p will result to a region of type 'my_registered_type' called 'my_instance'
   // if it did not exist, it will be created, otherwise the one existing is returned.
   </code>
   Parameters
   root :          optional root name (ex version uses this)
   classname :     path to the type
   name :          name of the type to create an instance of
   instancename :  a name for the instance created.                                         */
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename );
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
													, CTEXTSTR classname
													, CTEXTSTR name
													, uintptr_t size
													, OpenCloseNotification Open
													, OpenCloseNotification Close );
/* <combine sack::app::registry::CreateRegisteredDataType@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                */
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename );
/* Outputs through syslog a tree dump of all names registered. */
PROCREG_PROC( void, DumpRegisteredNames )( void );
/* Dumps through syslog all names registered from the specified
   root point. (instead of dumping the whole tree)              */
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root );
PROCREG_PROC( int, SaveTree )( void );
PROCREG_PROC( int, LoadTree )( void );
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
/* Releases an interface. When interfaces are registered, they
   register with a OnGetInterface and an OnDropInterface
   callback so that it may do additional work to cleanup from
   giving you a copy of the interface.
   Example
   <code lang="c++">
   POINTER p = GetInterface( "image" );
   DropInterface( p );
   </code>                                                     */
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_x );
PROCREG_PROC( POINTER, GetInterface_v4 )( CTEXTSTR pServiceName, LOGICAL ReadConfig, int quietFail DBG_PASS );
#define GetInterfaceV4( a, b )  GetInterface_v4( a, FALSE, b DBG_SRC )
/* \Returns the pointer to a registered interface. This is
   typically a structure that contains pointer to functions. Takes
   a text string to an interface. Interfaces are registered at a
   known location in the registry tree.                            */
PROCREG_PROC( POINTER, GetInterfaceDbg )( CTEXTSTR pServiceName DBG_PASS );
#define GetInterface(n) GetInterfaceDbg( n DBG_SRC )
#define GetRegisteredInterface(name) GetInterface(name)
PROCREG_PROC( LOGICAL, RegisterInterfaceEx )( CTEXTSTR name, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS );
//PROCREG_PROC( LOGICAL, RegisterInterface )(CTEXTSTR name, POINTER( CPROC*load )(void), void(CPROC*unload)(POINTER));
#define RegisterInterface(n,l,u) RegisterInterfaceEx( n,l,u DBG_SRC )
// unregister a function, should be smart and do full return type
// and parameters..... but for now this only references name, this indicates
// that this has not been properly(fully) extended, and should be layered
// in such a way as to allow this function work in it's minimal form.
PROCREG_PROC( int, ReleaseRegisteredFunctionEx )( PCLASSROOT root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													  );
#define ReleaseRegisteredFunction(nc,pn) ReleaseRegisteredFunctionEx(NULL,nc,pn)
/* This is a macro used to paste two symbols together. */
#define paste_(a,b) a##b
#define paste(a,b) paste_(a,b)
#define preproc_symbol(a)  a
#ifdef __cplusplus
#define EXTRA_PRELOAD_SYMBOL _
#else
#define EXTRA_PRELOAD_SYMBOL
#endif
#define DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line), SQL_PRELOAD_PRIORITY ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2_i(task,name,classtype,methodname,desc,returntype,argtypes,line)
/* Dekware uses this macro.
     passes preload priority override.
	 so it can register new internal commands before initial macros are run.
*/
#define DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(paste(Register,name),Method),preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line), priority ) {	  SimpleRegisterMethod( task "/" classtype, paste(name,line)	  , #returntype, methodname, #argtypes );    RegisterValue( task "/" classtype "/" methodname, "Description", desc ); }	                                                                          static returntype CPROC paste(name,line)
/* This macro indirection is to resolve inner macros like "" around text.  */
#define DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   DefineRegistryMethod2P_i(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)
/*
    This method is used by PSI/Intershell.
	no description
*/
#define DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(paste(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   DefineRegistryMethod_i(task,name,classtype,classbase,methodname,returntype,argtypes,line)
/*
#define _0_DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   static returntype _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes)	  _1__DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
// this macro is used for ___DefineRegistryMethodP. Because this is used with complex names
// an extra define wrapper of priority_preload must be used to fully resolve paramters.
/*
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIOR_PRELOAD( paste(paset(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL),line), priority ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase, paste(name,line)	  , #returntype, methodname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
*/
/* <combine sack::app::registry::SimpleRegisterMethod>
   General form to build a registered procedure. Used by simple
   macros to create PRELOAD'ed registered functions. This flavor
   requires the user to provide 'static' and a return type that
   matches the return type specified in the macro. This makes
   usage most C-like, and convenient to know what the return
   value of a function should be (if any).
   Parameters
   priority :    The preload priority to load at.
   task :        process level name registry. This would be
                 "Intershell" or "psi" or some other base prefix.
                 The prefix can contain a path longer than 1
                 level.
   name :        This is the function name to build. (Can be used
                 for link debugging sometimes)
   classtype :   class of the name being registered
   methodname :  name of the routine to register
   returntype :  the literal type of the return type of this
                 function (void, int, PStruct* )
   argtypes :    Argument signature of the routine in parenthesis
   line :        this is usually filled with __LINE__ so that the
                 same function name (name) will be different in
                 different files (even in the same file)
   Remarks
   This registers a routine at the specified preload priority.
   Registers under [task]/[classname]/methodname. The name of
   the registered routine from a C perspective is [name][line]. This
   function is not called directly, but will only be referenced
   from the registered name.
   Example
   See <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, GetFirstRegisteredNameEx> */
/*
#define _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _2___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   _1__DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes)	  _0_DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
*/
#define DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(paste(Register##name##Button,preproc_symbol(EXTRA_PRELOAD_SYMBOL)),line) ) {	  SimpleRegisterMethod( task "/" classtype "/" classbase "/" methodname, paste(name,line)	  , #returntype, subname, #argtypes ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes)	  DefineRegistrySubMethod_i(task,name,classtype,classbase,methodname,subname,returntype,argtypes,__LINE__)
/* attempts to use dynamic linking functions to resolve passed
   global name if that fails, then a type is registered for this
   global, and an instance created, so that that instance may be
   reloaded again, otherwise the data in the main application is
   used... actually we should deprecate the dynamic loading
   part, and just register the type.
   SimpleRegisterAndCreateGlobal Simply registers the type as a
   global variable type. Allows creation of the global space
   later.
   Parameters
   name :         name of the pointer to global type to create.<p />text
                  string to register this created global as.
   ppGlobal :     address of the pointer to global memory.
   global_size :  size of the global area to create
   Example
   <code lang="c++">
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   PRELOAD( Init )
   {
       SimpleRegisterAndCreateGlobal( global );
   }
   </code>                                                               */
PROCREG_PROC( void, RegisterAndCreateGlobal )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name );
/* <combine sack::app::registry::RegisterAndCreateGlobal@POINTER *@uintptr_t@CTEXTSTR>
   \ \                                                                                   */
#define SimpleRegisterAndCreateGlobal( name )	 RegisterAndCreateGlobal( (POINTER*)&name, sizeof( *name ), #name )
/* Init routine is called, otherwise a 0 filled space is
   returned. Init routine is passed the pointer to the global
   and the size of the global block the global data block is
   zero initialized.
   Parameters
   ppGlobal :     Address of the pointer to the global region
   global_size :  size of the global region to create
   name :         name of the global region to register (so
                  future users get back the same data area)
   Init :         function to call to initialize the region when
                  created. (doesn't have to be a global. Could be
                  used to implement types that have class
                  constructors \- or not, since there's only one
                  instance of a global \- this is more for
                  singletons).
   Example
   <code>
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   </code>
   <code lang="c++">
   void __cdecl InitRegion( POINTER region, uintptr_t region_size )
   {
       // do something to initialize 'region'
   }
   PRELOAD( InitGlobal )
   {
       SimpleRegisterAndCreateGlobalWithInit( global, InitRegion );
   }
   </code>                                                          */
PROCREG_PROC( void, RegisterAndCreateGlobalWithInit )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Init)(POINTER,uintptr_t) );
/* <combine sack::app::registry::RegisterAndCreateGlobalWithInit@POINTER *@uintptr_t@CTEXTSTR@void __cdecl*InitPOINTER\,uintptr_t>
   \ \                                                                                                                              */
#define SimpleRegisterAndCreateGlobalWithInit( name,init )	 RegisterAndCreateGlobalWithInit( (POINTER*)&name, sizeof( *name ), #name, init )
/* a tree dump will result with dictionary names that may translate automatically. */
/* This has been exported as a courtesy for StrDup.
 * this routine MAY result with a translated string.
 * this routine MAY result with the same pointer.
 * this routine MAY need to be improved if MANY more strdups are replaced
 * Add a binary tree search index when large.
 * Add a transaltion tree index at the same time.
 */
PROCREG_PROC( CTEXTSTR, SaveNameConcatN )( CTEXTSTR name1, ... );
// no space stripping, saves literal text (case insensitive indexing; '/' and '\' are the same)
PROCREG_PROC( CTEXTSTR, SaveText )( CTEXTSTR text );
// no space stripping, saves literal text (case sensitive indexing; '/' and '\' are the same)
PROCREG_PROC( CTEXTSTR, SaveTextCS )( CTEXTSTR text );
PROCREG_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::app::registry;
#endif
#endif
#define MY_OFFSETOF( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
#ifndef USE_CUSTOM_ALLOCER
#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
 // this has to be a compile option (option from cmake)
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#define USE_CUSTOM_ALLOCER 1
#else
#define USE_CUSTOM_ALLOCER 0
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace containers {
#endif
		//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace list {
#endif
			static struct list_local_data
			{
				volatile uint32_t lock;
			}
#ifdef __STATIC_GLOBALS__
	s_list_local;
#  define list_local  (s_list_local)
#  define list_local_lock (&s_list_local.lock)
#else
	 * _list_local, s_list_local;
#  define list_local  ((_list_local)?(*_list_local):(s_list_local))
#  define list_local_lock ((_list_local)?(&_list_local->lock):(&s_list_local.lock))
#endif
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
			PLIST  CreateListEx( DBG_VOIDPASS )
			{
				PLIST pl;
				INDEX size;
				pl = (PLIST)AllocateEx( (size = (INDEX)offsetof( LIST, pNode[0] )) DBG_RELAY );
				MemSet( (POINTER)pl, 0, size );
				return pl;
			}
			//--------------------------------------------------------------------------
			void  MakeListEx( PLIST *into DBG_PASS )
			{
				PLIST pl;
				INDEX size;
				(*into) = pl = (PLIST)AllocateEx( (size = (INDEX)offsetof( LIST, pNode[0] )) DBG_RELAY );
				MemSet( (POINTER)pl, 0, size );
			}
			//--------------------------------------------------------------------------
			void  DeleteListEx( PLIST* pList DBG_PASS )
			{
				PLIST ppList;
				while (LockedExchange( list_local_lock, 1 ))
					Relinquish();
				if (pList &&
					(ppList = (PLIST)LockedExchangePtrSzVal( (uintptr_t*)pList, 0 ))
					)
				{
					ReleaseEx( (POINTER)ppList DBG_RELAY );
				}
				list_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			static void ExpandListEx( PLIST* pList, INDEX amount DBG_PASS )
			{
 //-V595
				PLIST old_list = (*pList);
				PLIST pl;
				uintptr_t size;
				uintptr_t old_size;
				if (!pList)
					return;
				if (*pList)
				{
					old_size = ((uintptr_t) & ((*pList)->pNode[(*pList)->Cnt])) - ((uintptr_t)(*pList));
					size = ((uintptr_t) & ((*pList)->pNode[(*pList)->Cnt + amount])) - ((uintptr_t)(*pList));
					//old_size = offsetof( LIST, pNode[(*pList)->Cnt]));
					pl = (PLIST)AllocateEx( size DBG_RELAY );
				}
				else
				{
					old_size = 0;
					pl = (PLIST)AllocateEx( size = MY_OFFSETOF( pList, pNode[amount] ) DBG_RELAY );
					pl->Cnt = 0;
				}
				if (old_list)
				{
					// copy old list to new list
					MemCpy( (POINTER)pl, (POINTER)*pList, old_size );
					if (amount == 1)
						pl->pNode[pl->Cnt++] = NULL;
					else
					{
						// clear the new additions to the list
						MemSet( (POINTER)(pl->pNode + pl->Cnt), 0, size - old_size );
						pl->Cnt += amount;
					}
					// set the new list before releasing the old one.
					(*pList) = pl;
					// remove the old list...
					ReleaseEx( (POINTER)old_list DBG_RELAY );
				}
				else
				{
 // clear whole structure on creation...
					MemSet( (POINTER)pl, 0, size );
  // one more ( always a free )
					pl->Cnt = amount;
					// brand new list.
					*pList = pl;
				}
			}
			//--------------------------------------------------------------------------
			void AddLinkEx( PLIST* pList, POINTER p DBG_PASS )
			{
				INDEX i;
				if (!pList)
					return;
				if (!(*pList))
				{
				retry1:
					ExpandListEx( pList, 8 DBG_RELAY );
				}
				else
				{
					while (LockedExchange( list_local_lock, 1 ))
						Relinquish();
					// cannot trust that the list will exist all the time
					// we may start calling this function and have the
					// list re-allocated.
					if (!(*pList))
					{
						list_local_lock[0] = 0;
						return;
					}
				}
				for (i = 0; i < (*pList)->Cnt; i++)
				{
					if (!(*pList)->pNode[i])
					{
						(*pList)->pNode[i] = p;
						break;
					}
				}
				if (i == (*pList)->Cnt)
  // pList->Cnt changes - don't test in WHILE
					goto retry1;
				list_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			void  SetLinkEx( PLIST* pList, INDEX idx, POINTER p DBG_PASS )
			{
				INDEX sz;
				if (!pList)
					return;
				if (*pList)
				{
					while (LockedExchange( list_local_lock, 1 ))
						Relinquish();
					if (!(*pList))
					{
						list_local_lock[0] = 0;
						return;
					}
				}
				if (idx == INVALID_INDEX)
				{
					list_local_lock[0] = 0;
 // not set...
					return;
				}
				sz = 0;
				while (!(*pList) || (sz = (*pList)->Cnt) <= idx)
					ExpandListEx( pList, (idx - sz) + 1 DBG_RELAY );
				(*pList)->pNode[idx] = p;
				list_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			POINTER  GetLink( PLIST* pList, INDEX idx )
			{
				// must lock the list so that it's not expanded out from under us...
				POINTER p;
				if (!pList || !(*pList))
					return NULL;
				if (idx == INVALID_INDEX)
 // not set...
					return NULL;
				while (LockedExchange( list_local_lock, 1 ))
					Relinquish();
				if (!(*pList))
				{
					list_local_lock[0] = 0;
					return NULL;
				}
				if ((*pList)->Cnt <= idx)
				{
					list_local_lock[0] = 0;
					return NULL;
				}
				p = (*pList)->pNode[idx];
				list_local_lock[0] = 0;
				return p;
			}
			//--------------------------------------------------------------------------
			POINTER* GetLinkAddress( PLIST* pList, INDEX idx )
			{
				// must lock the list so that it's not expanded out from under us...
				POINTER* p;
				if (!pList || !(*pList))
					return NULL;
				if (idx == INVALID_INDEX)
 // not set...
					return NULL;
				if ((*pList)->Cnt <= idx)
				{
					return NULL;
				}
				p = (POINTER*)((*pList)->pNode + idx);
				return p;
			}
			//--------------------------------------------------------------------------
			uintptr_t  ForAllLinks( PLIST* pList, ForProc func, uintptr_t user )
			{
				INDEX i;
				uintptr_t result = 0;
				while (LockedExchange( list_local_lock, 1 ))
					Relinquish();
				if (pList && *pList)
				{
					for (i = 0; i < ((*pList)->Cnt); i++)
					{
						if ((*pList)->pNode[i])
						{
							result = func( user, i, (POINTER*)((*pList)->pNode + i) );
							if (result)
								break;
						}
					}
				}
				list_local_lock[0] = 0;
				return result;
			}
			//--------------------------------------------------------------------------
			INDEX GetLinkCount_( PLIST pList ) {
				INDEX i;
				POINTER p;
				INDEX count = 0;
				LIST_FORALL( pList, i, POINTER, p ) {
					count++;
				}
				return count;
			}
			//--------------------------------------------------------------------------
			INDEX GetLinksUsed( PLIST *pList ) {
				INDEX i;
				POINTER p;
				INDEX count = 0;
				LIST_FORALL( (*pList), i, POINTER, p ) {
					count++;
				}
				return count;
			}
			//--------------------------------------------------------------------------
			static uintptr_t CPROC IsLink( uintptr_t value, INDEX i, POINTER* link )
			{
				if (value == (uintptr_t)(*link))
 // 0 might be value so add one to make it non zero
					return i + 1;
				return 0;
			}
			//--------------------------------------------------------------------------
			INDEX  FindLink( PLIST* pList, POINTER value )
			{
				if (!pList || !(*pList))
					return INVALID_INDEX;
				return ForAllLinks( pList, IsLink, (uintptr_t)value ) - 1;
			}
			//--------------------------------------------------------------------------
			static uintptr_t CPROC KillLink( uintptr_t value, INDEX i, POINTER* link )
			{
				if (value == (uintptr_t)(*link))
				{
					(*link) = NULL;
 // stop searching
					return 1;
				}
				return 0;
			}
			LOGICAL  DeleteLink( PLIST* pList, CPOINTER value )
			{
				if (ForAllLinks( pList, KillLink, (uintptr_t)value ))
					return TRUE;
				return FALSE;
			}
			//--------------------------------------------------------------------------
			static uintptr_t CPROC RemoveItem( uintptr_t value, INDEX i, POINTER* link )
			{
				*link = NULL;
				return 0;
			}
			void EmptyList( PLIST* pList )
			{
				ForAllLinks( pList, RemoveItem, 0 );
			}
#ifdef __cplusplus
//		namespace list {
		};
		namespace data_list {
#endif
#if 0
// data list blocks were never auto-locked?
			static struct data_list_local_data
			{
				uint32_t lock;
			} s_data_list_local, * _data_list_local;
#ifdef __STATIC_GLOBALS__
#  define data_list_local  ((s_data_list_local))
#  define data_list_local_lock  ((&s_data_list_local.lock))
#else
#  define data_list_local  ((_data_list_local)?(*_data_list_local):(s_data_list_local))
#  define data_list_local_lock  ((_data_list_local)?(&_data_list_local->lock):(&s_data_list_local.lock))
#endif
#endif
			//--------------------------------------------------------------------------
			PDATALIST ExpandDataListEx( PDATALIST* ppdl, INDEX entries DBG_PASS )
			{
 //-V595
				PDATALIST pdl = (*ppdl);
				PDATALIST pNewList;
				if (!ppdl || !*ppdl)
 // can't expand - was not created (no data size)
					return NULL;
				if ((*ppdl))
					entries += (*ppdl)->Avail;
				pNewList = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ((*ppdl)->Size * entries) - 1 DBG_RELAY );
				MemCpy( (POINTER)pNewList->data, (POINTER)(*ppdl)->data, (*ppdl)->Avail * (*ppdl)->Size );
				pNewList->Cnt = (*ppdl)->Cnt;
				pNewList->Avail = entries;
				pNewList->Size = (*ppdl)->Size;
				// set the new list int he pointer
				*ppdl = pNewList;
				ReleaseEx( (POINTER)pdl DBG_RELAY );
				return pNewList;
			}
			//--------------------------------------------------------------------------
			PDATALIST  CreateDataListEx( uintptr_t nSize DBG_PASS )
			{
				PDATALIST pdl = (PDATALIST)AllocateEx( sizeof( DATALIST ) + (nSize * 8) - 1 DBG_RELAY );
				pdl->Cnt = 0;
				pdl->Avail = 8;
				pdl->Size = nSize;
				return pdl;
			}
			//--------------------------------------------------------------------------
			void  DeleteDataListEx( PDATALIST* ppdl DBG_PASS )
			{
				if (ppdl)
				{
					if (*ppdl)
					{
						ReleaseEx( (POINTER)*ppdl DBG_RELAY );
						*ppdl = NULL;
					}
				}
			}
			//--------------------------------------------------------------------------
			POINTER SetDataItemEx( PDATALIST* ppdl, INDEX idx, POINTER data DBG_PASS )
			{
				POINTER p = NULL;
				if (!ppdl || !(*ppdl) || idx > 0x1000000)
					return NULL;
				if (idx >= (*ppdl)->Avail)
				{
					ExpandDataListEx( ppdl, idx + 32 DBG_RELAY );
				}
				p = (POINTER)((*ppdl)->data + ((*ppdl)->Size * idx));
				MemCpy( p, data, (*ppdl)->Size );
				if (idx >= (*ppdl)->Cnt)
					(*ppdl)->Cnt = idx + 1;
				return p;
			}
			//--------------------------------------------------------------------------
			POINTER AddDataItemEx( PDATALIST* ppdl, POINTER data DBG_PASS )
			{
				if (ppdl && *ppdl)
					return SetDataItemEx( ppdl, (*ppdl)->Cnt + 1, data DBG_RELAY );
				if (ppdl)
					return SetDataItemEx( ppdl, 0, data DBG_RELAY );
				return NULL;
			}
			void EmptyDataList( PDATALIST* ppdl )
			{
				if (ppdl && (*ppdl))
					(*ppdl)->Cnt = 0;
			}
			//--------------------------------------------------------------------------
			void DeleteDataItem( PDATALIST* ppdl, INDEX idx )
			{
				if (ppdl && *ppdl)
				{
					if (idx < ((*ppdl)->Cnt - 1))
						MemCpy( (POINTER)((*ppdl)->data + ((*ppdl)->Size * idx))
							, (POINTER)((*ppdl)->data + ((*ppdl)->Size * (idx + 1)))
							, (*ppdl)->Size * ( (*ppdl)->Cnt - idx - 1 ) );
					(*ppdl)->Cnt--;
				}
			}
			//--------------------------------------------------------------------------
			POINTER GetDataItem( PDATALIST* ppdl, INDEX idx )
			{
				POINTER p = NULL;
				if (ppdl && *ppdl && (idx < (*ppdl)->Cnt))
					p = (POINTER)((*ppdl)->data + ((*ppdl)->Size * idx));
				return p;
			}
			//--------------------------------------------------------------------------
#ifdef __cplusplus
//		namespace data_list {
		};
		namespace link_stack {
#endif
			void		MakeLinkStackLimitedEx( PLINKSTACK *into, int max_entries  DBG_PASS )
			{
				PLINKSTACK pls;
				(*into) = pls = (PLINKSTACK)AllocateEx( sizeof( LINKSTACK ) DBG_RELAY );
				pls->Top = 0;
				pls->Cnt = 0;
				pls->Max = max_entries;
			}
			PLINKSTACK		CreateLinkStackLimitedEx( int max_entries  DBG_PASS )
			{
				PLINKSTACK pls;
				pls = (PLINKSTACK)AllocateEx( sizeof( LINKSTACK ) DBG_RELAY );
				pls->Top = 0;
				pls->Cnt = 0;
				pls->Max = max_entries;
				return pls;
			}
			//--------------------------------------------------------------------------
			void  MakeLinkStackEx( PLINKSTACK *into DBG_PASS )
			{
				MakeLinkStackLimitedEx( into, 0 DBG_RELAY );
			}
			//--------------------------------------------------------------------------
			PLINKSTACK  CreateLinkStackEx( DBG_VOIDPASS )
			{
				return CreateLinkStackLimitedEx( 0 DBG_RELAY );
			}
			//--------------------------------------------------------------------------
			void  DeleteLinkStackEx( PLINKSTACK* pls DBG_PASS )
			{
				if (pls && *pls)
				{
					ReleaseEx( (POINTER)*pls DBG_RELAY );
					*pls = 0;
				}
			}
			//--------------------------------------------------------------------------
			POINTER  PeekLinkEx( PLINKSTACK* pls, INDEX n )
			{
				// should lock - but it's fast enough?
				POINTER p = NULL;
				if (pls && *pls && ((*pls)->Top > n))
					p = (*pls)->pNode[(*pls)->Top - (n + 1)];
				return p;
			}
			//--------------------------------------------------------------------------
			POINTER  PeekLink( PLINKSTACK* pls )
			{
				return PeekLinkEx( pls, 0 );
			}
			//--------------------------------------------------------------------------
			POINTER  PopLink( PLINKSTACK* pls )
			{
				if (pls && *pls && (*pls)->Top)
					return (*pls)->pNode[--(*pls)->Top];
				return NULL;
			}
			//--------------------------------------------------------------------------
			static void ExpandStackEx( PLINKSTACK* stack, INDEX entries DBG_PASS )
			{
				PLINKSTACK pNewStack;
				if (*stack)
					entries += (*stack)->Cnt;
 //-V595
				pNewStack = (PLINKSTACK)AllocateEx( my_offsetof( stack, pNode[entries] ) DBG_RELAY );
				if (*stack)
				{
					PLINKSTACK pls = (*stack);
					MemCpy( (POINTER)pNewStack->pNode, (POINTER)(*stack)->pNode, (*stack)->Cnt * sizeof( POINTER ) );
					pNewStack->Top = (*stack)->Top;
					pNewStack->Max = (*stack)->Max;
					*stack = pNewStack;
					ReleaseEx( (POINTER)pls DBG_RELAY );
				}
				else
				{
					pNewStack->Top = 0;
					pNewStack->Max = 0;
					*stack = pNewStack;
				}
				pNewStack->Cnt = entries;
				//return pNewStack;
			}
			//--------------------------------------------------------------------------
			void  PushLinkEx( PLINKSTACK* pls, POINTER p DBG_PASS )
			{
				if (!pls)
					return;
				// should lock this thing :)
				if (!*pls ||
					(*pls)->Top == (*pls)->Cnt)
				{
					ExpandStackEx( pls, ((*pls) ? ((*pls)->Max) : 0) + 8 DBG_RELAY );
				}
				if ((*pls)->Max)
					if (((*pls)->Top) >= (*pls)->Max)
					{
						MemCpy( (POINTER)(*pls)->pNode, (POINTER)((*pls)->pNode + 1), (*pls)->Top - 1 );
						(*pls)->Top--;
					}
				(*pls)->pNode[(*pls)->Top] = p;
				(*pls)->Top++;
			}
#ifdef __cplusplus
//namespace link_stack
		}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
			POINTER  PopData( PDATASTACK* pds )
			{
				POINTER p = NULL;
				if ((pds) && (*pds) && (*pds)->Top)
				{
					(*pds)->Top--;
					p = (POINTER)((*pds)->data + ((*pds)->Size * ((*pds)->Top)));
				}
				return p;
			}
			//--------------------------------------------------------------------------
			static PDATASTACK ExpandDataStackEx( PDATASTACK* ppds, INDEX entries DBG_PASS )
			{
				PDATASTACK pNewStack;
				PDATASTACK pds = (*ppds);
				if (!pds)
					return NULL;
				entries += pds->Cnt;
				pNewStack = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ((*ppds)->Size * entries) - 1 DBG_RELAY );
				MemCpy( (POINTER)pNewStack->data, (POINTER)(*ppds)->data, (*ppds)->Cnt * (*ppds)->Size );
				pNewStack->Cnt = entries;
				pNewStack->Size = (*ppds)->Size;
				pNewStack->Top = (*ppds)->Top;
				(*ppds) = pNewStack;
				ReleaseEx( (POINTER)pds DBG_RELAY );
				return pNewStack;
			}
			//--------------------------------------------------------------------------
			void  PushDataEx( PDATASTACK* pds, POINTER pdata DBG_PASS )
			{
				if (pds && *pds)
				{
					if ((*pds)->Top == (*pds)->Cnt)
					{
						ExpandDataStackEx( pds, 1 DBG_RELAY );
					}
					if ((*pds)->Max)
						if (((*pds)->Top) >= (*pds)->Max)
						{
							MemCpy( (POINTER)(*pds)->data, (POINTER)((*pds)->data + (*pds)->Size), ((*pds)->Top - 1) * (*pds)->Size );
							(*pds)->Top--;
						}
					MemCpy( (POINTER)((*pds)->data + ((*pds)->Top * (*pds)->Size)), pdata, (*pds)->Size );
					(*pds)->Top++;
					return;
				}
			}
			//--------------------------------------------------------------------------
			POINTER  PeekDataEx( PDATASTACK* pds, INDEX nBack )
			{
				POINTER p = NULL;
				nBack++;
				if (!(*pds))
					return NULL;
				if (((int)((*pds)->Top) - (int)nBack) >= 0)
					p = (POINTER)((*pds)->data + ((*pds)->Size * ((*pds)->Top - nBack)));
				return p;
			}
			//--------------------------------------------------------------------------
			POINTER  PeekData( PDATASTACK* pds )
			{
				POINTER p = NULL;
				if (pds && *pds && (*pds)->Top)
					p = (POINTER)((*pds)->data + ((*pds)->Size * ((*pds)->Top - 1)));
				return p;
			}
			//--------------------------------------------------------------------------
			void  EmptyDataStack( PDATASTACK* pds )
			{
				if (pds && *pds)
					(*pds)->Top = 0;
			}
			//--------------------------------------------------------------------------
			PDATASTACK  CreateDataStackEx( size_t size DBG_PASS )
			{
				return CreateDataStackLimitedEx( size, 0 DBG_RELAY );
			}
			//--------------------------------------------------------------------------
			PDATASTACK  CreateDataStackLimitedEx( size_t size, INDEX max_items DBG_PASS )
			{
				PDATASTACK pds;
				pds = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + (10 * size) DBG_RELAY );
				pds->Cnt = 10;
				pds->Top = 0;
				pds->Size = size;
				pds->Max = max_items;
				return pds;
			}
			//--------------------------------------------------------------------------
			void DeleteDataStackEx( PDATASTACK* pds DBG_PASS )
			{
				ReleaseEx( (POINTER)(*pds) DBG_RELAY );
				*pds = NULL;
			}
#ifdef __cplusplus
//		namespace data_stack {
		}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace queue {
#endif
			static struct link_queue_local_data
			{
				volatile uint32_t lock;
				//#if !USE_CUSTOM_ALLOCER
				volatile PTHREAD thread;
				//#endif
			} s_link_queue_local
#if !defined( __STATIC_GLOBALS__ ) || defined( USE_CUSTOM_ALLOCER )
					, * _link_queue_local
#endif
				;
#if defined( __STATIC_GLOBALS__ ) && !defined( USE_CUSTOM_ALLOCER )
#  define link_queue_local  ((s_link_queue_local))
#  define link_queue_local_thread  ((s_link_queue_local.thread))
#  define link_queue_local_lock  ((&s_link_queue_local.lock))
#else
#  define link_queue_local  ((_link_queue_local)?(*_link_queue_local):(s_link_queue_local))
#  define link_queue_local_thread  ((_link_queue_local)?(*_link_queue_local).thread:(s_link_queue_local.thread))
#  define link_queue_local_lock  ((_link_queue_local)?(&_link_queue_local->lock):(&s_link_queue_local.lock))
#endif
			PLINKQUEUE CreateLinkQueueEx( DBG_VOIDPASS )
			{
				PLINKQUEUE plq = 0;
 //-V557
				plq = (PLINKQUEUE)AllocateEx( MY_OFFSETOF( &plq, pNode[8] ) DBG_RELAY );
#if USE_CUSTOM_ALLOCER
				plq->Lock = 0;
#endif
				plq->Top = 0;
				plq->Bottom = 0;
				plq->Cnt = 8;
				plq->pNode[0] = NULL;
 // shrug
				plq->pNode[1] = NULL;
				return plq;
			}
			//--------------------------------------------------------------------------
			void DeleteLinkQueueEx( PLINKQUEUE* pplq DBG_PASS )
			{
				if (!pplq)
					return;
#if USE_CUSTOM_ALLOCER
				retry_lock :
#endif
				while (LockedExchange( link_queue_local_lock, __LINE__ ))
				{
					Relinquish();
				}
#if USE_CUSTOM_ALLOCER
				if (_link_queue_local)
					_link_queue_local->thread = MakeThread();
				if (!(*pplq))
				{
					link_queue_local_lock[0] = 0;
					return;
				}
				if ((*pplq)->Lock)
				{
					link_queue_local_lock[0] = 0;
					Relinquish();
					goto retry_lock;
				}
				(*pplq)->Lock = 1;
#endif
				link_queue_local_lock[0] = 0;
				if (pplq)
				{
					if (*pplq)
						ReleaseEx( (POINTER)(*pplq) DBG_RELAY );
					*pplq = NULL;
				}
#if USE_CUSTOM_ALLOCER
				if (_link_queue_local)
					_link_queue_local->thread = NULL;
#endif
				//link_queue_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			static PLINKQUEUE ExpandLinkQueueEx( PLINKQUEUE* pplq, INDEX entries DBG_PASS )
			{
				PLINKQUEUE plqNew = NULL;
#if USE_CUSTOM_ALLOCER
				while (LockedExchange( link_queue_local_lock, __LINE__ ))
				{
					Relinquish();
				}
				if (_link_queue_local)
					_link_queue_local->thread = MakeThread();
#endif
				if (pplq)
				{
					PLINKQUEUE plq = *pplq;
					INDEX size;
					int prior_logging;
					size = MY_OFFSETOF( pplq, pNode[plq->Cnt + entries] );
					prior_logging = ClearAllocateLogging( FALSE );
					plqNew = (PLINKQUEUE)AllocateEx( size DBG_RELAY );
					plqNew->Cnt = plq->Cnt + entries;
					plqNew->Bottom = 0;
					if (plq->Bottom > plq->Top)
					{
						INDEX bottom_half;
						plqNew->Top = (bottom_half = plq->Cnt - plq->Bottom) + plq->Top;
						MemCpy( (POINTER)plqNew->pNode, (POINTER)(plq->pNode + plq->Bottom), sizeof( POINTER ) * bottom_half );
						MemCpy( (POINTER)(plqNew->pNode + bottom_half), (POINTER)plq->pNode, sizeof( POINTER ) * plq->Top );
					}
					else
					{
						plqNew->Top = plq->Top - plq->Bottom;
						MemCpy( (POINTER)plqNew->pNode, (POINTER)(plq->pNode + plq->Bottom), sizeof( POINTER ) * plqNew->Top );
					}
					//need to make sure plq is always valid; can be trying to get a lock
					(*pplq) = plqNew;
					Release( plq );
					ResetAllocateLogging( prior_logging );
				}
#if USE_CUSTOM_ALLOCER
				if (_link_queue_local)
					_link_queue_local->thread = NULL;
				link_queue_local_lock[0] = 0;
#endif
				return plqNew;
			}
			//--------------------------------------------------------------------------
			void  EnqueLinkEx( PLINKQUEUE* pplq, POINTER link DBG_PASS )
			{
				INDEX tmp;
				PLINKQUEUE plq;
#if USE_CUSTOM_ALLOCER
				int keep_lock = 0;
#endif
				if (!pplq)
					return;
				if (!(*pplq))
					*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
				retry_lock :
#endif
				while (LockedExchange( link_queue_local_lock, __LINE__ ))
				{
#if USE_CUSTOM_ALLOCER
					if (link_queue_local_thread == MakeThread())
					{
						keep_lock = 1;
						break;
					}
#endif
					Relinquish();
				}
#if USE_CUSTOM_ALLOCER
				if (_link_queue_local)
					_link_queue_local->thread = MakeThread();
				if (!(*pplq))
				{
					if (!keep_lock)
						link_queue_local_lock[0] = 0;
					return;
				}
				if ((*pplq)->Lock)
				{
					if (!keep_lock)
						link_queue_local_lock[0] = 0;
					Relinquish();
					goto retry_lock;
				}
				(*pplq)->Lock = 1;
				if (!keep_lock)
				{
					if (_link_queue_local)
						_link_queue_local->thread = NULL;
					link_queue_local_lock[0] = 0;
				}
#else
				if (!(*pplq))
				{
					//it could have been deallocated
					link_queue_local_lock[0] = 0;
					return;
				}
#endif
				plq = *pplq;
				//else
				//	s_link_queue_local.thread = MakeThread();
				if (link)
				{
					tmp = plq->Top + 1;
					if (tmp >= plq->Cnt)
						tmp -= plq->Cnt;
 // collided with self...
					if (tmp == plq->Bottom)
					{
						plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
						tmp = plq->Top + 1;
					}
					plq->pNode[plq->Top] = link;
					plq->Top = tmp;
				}
				*pplq = plq;
#if USE_CUSTOM_ALLOCER
				plq->Lock = 0;
#endif
				link_queue_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			void EnqueLinkNLEx( PLINKQUEUE* pplq, POINTER link DBG_PASS )
			{
				INDEX tmp, t, c;
				PLINKQUEUE plq;
				if (!pplq)
					return;
				if (!(*pplq))
					*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
				plq = *pplq;
				if (link)
				{
					tmp = (t = plq->Top) + 1;
					if (tmp >= (c = plq->Cnt))
						tmp -= c;
 // collided with self...
					if (tmp == (plq->Bottom))
					{
						plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
						tmp = (t = plq->Top) + 1;
					}
					plq->pNode[t] = link;
					plq->Top = tmp;
				}
				*pplq = plq;
			}
			//--------------------------------------------------------------------------
			void  PrequeLinkEx( PLINKQUEUE* pplq, POINTER link DBG_PASS )
			{
				INDEX tmp;
				PLINKQUEUE plq;
				if (!pplq)
					return;
				if (!(*pplq))
					*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
				retry_lock :
#endif
				while (LockedExchange( link_queue_local_lock, __LINE__ ))
					Relinquish();
#if USE_CUSTOM_ALLOCER
				if (!(*pplq))
				{
					link_queue_local_lock[0] = 0;
					return;
				}
				if ((*pplq)->Lock)
				{
					link_queue_local_lock[0] = 0;
					Relinquish();
					goto retry_lock;
				}
				(*pplq)->Lock = 1;
				link_queue_local_lock[0] = 0;
#else
				if (!(*pplq))
				{
					//it could have been deallocated
					link_queue_local_lock[0] = 0;
					return;
				}
#endif
				plq = *pplq;
				if (link)
				{
					tmp = plq->Bottom - 1;
					if (tmp & 0x80000000)
						tmp += plq->Cnt;
 // collided with self...
					if (tmp == plq->Top)
					{
						plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
						tmp = plq->Cnt - 1;
					}
					plq->pNode[tmp] = link;
					plq->Bottom = tmp;
				}
#if USE_CUSTOM_ALLOCER
				plq->Lock = 0;
#endif
				link_queue_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			LOGICAL  IsQueueEmpty( PLINKQUEUE* pplq )
			{
				if (!pplq || !(*pplq) ||
					(*pplq)->Bottom == (*pplq)->Top)
					return TRUE;
				return FALSE;
			}
			//--------------------------------------------------------------------------
			INDEX  GetQueueLength( PLINKQUEUE plq )
			{
				INDEX used = 0;
				if (plq)
				{
					used = plq->Top - plq->Bottom;
					if (plq->Top < plq->Bottom)
						used += plq->Cnt;
				}
				return used;
			}
			//--------------------------------------------------------------------------
			POINTER  PeekQueueEx( PLINKQUEUE plq, int idx )
			{
				size_t top;
				if (!plq)
					return NULL;
				if (idx < 0)
				{
					idx++;
					for (top = plq->Top ? (plq->Top - 1) : (plq->Cnt - 1)
						; idx && top != plq->Bottom
						; )
					{
						idx++;
						if (!top) top = plq->Cnt - 1;
						else top--;
					}
					if (idx == 0)
					{
						if (plq->Top == plq->Bottom)
							return NULL;
						return plq->pNode[top];
					}
				}
				else
				{
					for (top = plq->Bottom
						; idx != -1 && top != plq->Top
						; )
					{
						if (idx) {
							top++;
							if (top >= plq->Cnt)
								top -= plq->Cnt;
							idx--;
						}
						else { idx = -1; break; }
					}
					if (idx == -1)
						return plq->pNode[top];
				}
				return NULL;
			}
			POINTER  PeekQueue( PLINKQUEUE plq )
			{
				return PeekQueueEx( plq, 0 );
			}
			//--------------------------------------------------------------------------
			POINTER  DequeLink( PLINKQUEUE* pplq )
			{
				POINTER p;
				INDEX tmp;
				if (pplq && *pplq)
				{
#if USE_CUSTOM_ALLOCER
					int keep_lock = 0;
#endif
					uint32_t priorline;
#if USE_CUSTOM_ALLOCER
					retry_lock :
#endif
					while ((priorline = LockedExchange( link_queue_local_lock, __LINE__ )))
					{
#if USE_CUSTOM_ALLOCER
						if (link_queue_local_thread == MakeThread())
						{
							keep_lock = 1;
							break;
						}
#endif
						Relinquish();
					}
#if USE_CUSTOM_ALLOCER
					if (!pplq)
					{
						if (!keep_lock)
							link_queue_local_lock[0] = 0;
						return NULL;
					}
					if ((*pplq)->Lock)
					{
						if (!keep_lock)
							link_queue_local_lock[0] = 0;
						Relinquish();
						goto retry_lock;
					}
					(*pplq)->Lock = 1;
					if (!keep_lock)
						link_queue_local_lock[0] = 0;
#else
					if (!(*pplq))
					{
						//it could have been deallocated
						link_queue_local_lock[0] = 0;
						return NULL;
					}
#endif
				}
				else
					return NULL;
				p = NULL;
				if ((*pplq)->Bottom != (*pplq)->Top)
				{
					tmp = (*pplq)->Bottom + 1;
					if (tmp >= (*pplq)->Cnt)
						tmp -= (*pplq)->Cnt;
					p = (*pplq)->pNode[(*pplq)->Bottom];
					(*pplq)->Bottom = tmp;
				}
#if USE_CUSTOM_ALLOCER
				( *pplq )->Lock = 0;
#endif
				link_queue_local_lock[0] = 0;
				return p;
			}
			POINTER  DequeLinkNL( PLINKQUEUE* pplq )
			{
				INDEX b, t, c, tmp;
				POINTER p;
				if (!pplq || !*pplq)
					return NULL;
				p = NULL;
				if ((b = (*pplq)->Bottom) != (t = (*pplq)->Top))
				{
					tmp = b + 1;
					if (tmp >= (c = (*pplq)->Cnt))
						tmp -= c;
					p = (*pplq)->pNode[b];
					(*pplq)->Bottom = tmp;
				}
				return p;
			}
#ifdef __cplusplus
//		namespace queue {
		}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_queue {
#endif
			static struct data_queue_local_data
			{
				volatile uint32_t lock;
			}
			   s_data_queue_local
#ifndef __STATIC_GLOBALS__
				, * _data_queue_local
#endif
									;
#ifdef __STATIC_GLOBALS__
#  define data_queue_local  ((s_data_queue_local))
#  define data_queue_local_lock ((&s_data_queue_local.lock))
#else
#  define data_queue_local  ((_data_queue_local)?(*_data_queue_local):(s_data_queue_local))
#  define data_queue_local_lock ((_data_queue_local)?(&_data_queue_local->lock):(&s_data_queue_local.lock))
#endif
			PDATAQUEUE CreateDataQueueEx( INDEX size DBG_PASS )
			{
				PDATAQUEUE pdq;
				pdq = (PDATAQUEUE)AllocateEx( ((sizeof( DATAQUEUE ) + (2 * size)) - 1) DBG_RELAY );
				pdq->Top = 0;
				pdq->Bottom = 0;
				pdq->ExpandBy = 16;
				pdq->Size = size;
				pdq->Cnt = 2;
				return pdq;
			}
			//--------------------------------------------------------------------------
			void DeleteDataQueueEx( PDATAQUEUE* ppdq DBG_PASS )
			{
				if (ppdq)
				{
					if (*ppdq)
						ReleaseEx( (POINTER)*ppdq DBG_RELAY );
					*ppdq = NULL;
				}
			}
			//--------------------------------------------------------------------------
			static PDATAQUEUE ExpandDataQueueEx( PDATAQUEUE* ppdq, INDEX entries DBG_PASS )
			{
				PDATAQUEUE pdqNew = NULL;
				if (ppdq)
				{
					PDATAQUEUE pdq = *ppdq;
					//pdq->Cnt += entries;
					pdqNew = (PDATAQUEUE)AllocateEx( (uint32_t)offsetof( DATAQUEUE, data[0] ) + ((pdq->Cnt + entries) * pdq->Size) DBG_RELAY );
					pdqNew->Cnt = pdq->Cnt + entries;
					pdqNew->ExpandBy = pdq->ExpandBy;
					pdqNew->Bottom = 0;
					pdqNew->Size = pdq->Size;
					if (pdq->Bottom > pdq->Top)
					{
						INDEX bottom_half;
						/* if you see '- entries' in a diff... it was decided to not add it to the original queue above, instead */
						pdqNew->Top = (bottom_half = (pdq->Cnt) - pdq->Bottom) + pdq->Top;
						MemCpy( (POINTER)pdqNew->data
							, (POINTER)(pdq->data + (pdq->Bottom * pdq->Size))
							, pdq->Size * bottom_half );
						MemCpy( (POINTER)(pdqNew->data + (bottom_half * pdq->Size))
							, (POINTER)pdq->data
							, pdq->Size * pdq->Top );
					}
					else
					{
						pdqNew->Top = pdq->Top - pdq->Bottom;
						MemCpy( (POINTER)pdqNew->data
							, (POINTER)(pdq->data + (pdq->Bottom * pdq->Size))
							, pdq->Size * pdqNew->Top );
					}
					(*ppdq) = pdqNew;
					Release( pdq );
				}
				return pdqNew;
			}
			PDATAQUEUE  CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS )
			{
				PDATAQUEUE pdq = CreateDataQueueEx( size DBG_RELAY );
				pdq->ExpandBy = expand;
				ExpandDataQueueEx( &pdq, entries DBG_RELAY );
				return pdq;
			}
			//--------------------------------------------------------------------------
			void  EnqueDataEx( PDATAQUEUE* ppdq, POINTER link DBG_PASS )
			{
				INDEX tmp;
				PDATAQUEUE pdq;
				if (!ppdq)
					return;
				if (!(*ppdq))
 // cannot create this - no idea how big.
					return;
				while (LockedExchange( data_queue_local_lock, 1 ))
					Relinquish();
				pdq = *ppdq;
				if (link)
				{
					tmp = pdq->Top + 1;
					if (tmp >= pdq->Cnt)
						tmp -= pdq->Cnt;
 // collided with self...
					if (tmp == pdq->Bottom)
					{
						pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
						tmp = pdq->Top + 1;
					}
					MemCpy( (POINTER)(pdq->data + (pdq->Top * pdq->Size)), link, pdq->Size );
					pdq->Top = tmp;
				}
				data_queue_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			void PrequeDataEx( PDATAQUEUE* ppdq, POINTER link DBG_PASS )
			{
				INDEX tmp;
				PDATAQUEUE pdq;
				if (!ppdq)
					return;
				if (!(*ppdq))
 // cannot create this - no idea how big.
					return;
				while (LockedExchange( data_queue_local_lock, 1 ))
					Relinquish();
				pdq = *ppdq;
				if (link)
				{
					tmp = pdq->Bottom - 1;
					if (tmp > 0x80000000)
						tmp += pdq->Cnt;
 // collided with self...
					if (tmp == pdq->Top)
					{
						// expand re-aligns queue elements so bottom is 0 and top is N
						// so the bottom will always wrap when we try to add to the beginning...
						pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
						tmp = pdq->Cnt - 1;
					}
					MemCpy( (POINTER)(pdq->data + (tmp * pdq->Size)), link, pdq->Size );
					pdq->Bottom = tmp;
				}
				data_queue_local_lock[0] = 0;
			}
			//--------------------------------------------------------------------------
			LOGICAL  IsDataQueueEmpty( PDATAQUEUE* ppdq )
			{
				if (!ppdq || !(*ppdq) ||
					(*ppdq)->Bottom == (*ppdq)->Top)
					return TRUE;
				return FALSE;
			}
			//--------------------------------------------------------------------------
			LOGICAL  DequeData( PDATAQUEUE* ppdq, POINTER result )
			{
				LOGICAL p;
				INDEX tmp;
				if (ppdq && *ppdq)
					while (LockedExchange( data_queue_local_lock, 1 ))
						Relinquish();
				else
					return 0;
				p = 0;
				if ((*ppdq)->Bottom != (*ppdq)->Top)
				{
					tmp = (*ppdq)->Bottom + 1;
					if (tmp >= (*ppdq)->Cnt)
						tmp -= (*ppdq)->Cnt;
					if (result)
						MemCpy( result
							, (POINTER)((*ppdq)->data + (*ppdq)->Bottom * (*ppdq)->Size)
							, (*ppdq)->Size );
					p = 1;
					(*ppdq)->Bottom = tmp;
				}
				data_queue_local_lock[0] = 0;
				return p;
			}
			//--------------------------------------------------------------------------
			LOGICAL  UnqueData( PDATAQUEUE* ppdq, POINTER result )
			{
				LOGICAL p;
				INDEX tmp;
				if (ppdq && *ppdq)
					while (LockedExchange( data_queue_local_lock, 1 ))
						Relinquish();
				else
					return 0;
				p = 0;
				if ((*ppdq)->Bottom != (*ppdq)->Top)
				{
					tmp = (*ppdq)->Top;
					if (tmp)
						tmp--;
					else
						tmp = ((*ppdq)->Cnt) - 1;
					if (result)
						MemCpy( result
							, (POINTER)((*ppdq)->data + tmp * (*ppdq)->Size)
							, (*ppdq)->Size );
					p = 1;
					(*ppdq)->Top = tmp;
				}
				data_queue_local_lock[0] = 0;
				return p;
			}
			//--------------------------------------------------------------------------
			// zero is the first,
#undef PeekDataQueueEx
			LOGICAL  PeekDataQueueEx( PDATAQUEUE* ppdq, POINTER result, INDEX idx )
			{
				INDEX top;
				if (ppdq && *ppdq)
					while (LockedExchange( data_queue_local_lock, 1 ))
						Relinquish();
				else
					return 0;
				// cannot get invalid id.
				if (idx != INVALID_INDEX)
				{
					for (top = (*ppdq)->Bottom;
						idx != INVALID_INDEX && top != (*ppdq)->Top
						; )
					{
						idx--;
						if (idx != INVALID_INDEX)
						{
							top++;
							if ((top) >= (*ppdq)->Cnt)
								top = top - (*ppdq)->Cnt;
						}
					}
					if (idx == INVALID_INDEX)
					{
						MemCpy( result, (POINTER)((*ppdq)->data + top * (*ppdq)->Size), (*ppdq)->Size );
						data_queue_local_lock[0] = 0;
						return 1;
						//return (*ppdq)->pNode + top;
					}
				}
				data_queue_local_lock[0] = 0;
				return 0;
			}
#undef PeekDataQueue
			LOGICAL  PeekDataQueue( PDATAQUEUE* ppdq, POINTER result )
			{
				return PeekDataQueueEx( ppdq, result, 0 );
			}
			// zero is the first,
			POINTER  PeekDataInQueueEx( PDATAQUEUE* ppdq, INDEX idx )
			{
				INDEX top;
				if (ppdq && *ppdq)
					while (LockedExchange( data_queue_local_lock, 1 ))
						Relinquish();
				else
					return 0;
				// cannot get invalid id.
				if (idx != INVALID_INDEX)
				{
					for (top = (*ppdq)->Bottom;
						idx != INVALID_INDEX && top != (*ppdq)->Top
						; )
					{
						idx--;
						if (idx != INVALID_INDEX)
						{
							top++;
							if ((top) >= (*ppdq)->Cnt)
								top = top - (*ppdq)->Cnt;
						}
					}
					if (idx == INVALID_INDEX)
					{
						data_queue_local_lock[0] = 0;
						return (POINTER)((*ppdq)->data + top * (*ppdq)->Size);
					}
				}
				data_queue_local_lock[0] = 0;
				return NULL;
			}
			POINTER  PeekDataInQueue( PDATAQUEUE* ppdq )
			{
				return PeekDataInQueueEx( ppdq, 0 );
			}
			void  EmptyDataQueue( PDATAQUEUE* ppdq )
			{
				if (ppdq && *ppdq)
				{
					while (LockedExchange( data_queue_local_lock, 1 ))
						Relinquish();
					(*ppdq)->Bottom = (*ppdq)->Top = 0;
					data_queue_local_lock[0] = 0;
				}
			}
			//--------------------------------------------------------------------------
			INDEX  GetDataQueueLength( PDATAQUEUE pdq )
			{
				INDEX used = 0;
				if (pdq)
				{
					used = pdq->Top - pdq->Bottom;
					if (pdq->Top < pdq->Bottom)
						used += pdq->Cnt;
				}
				return used;
			}
#ifdef __cplusplus
//		namespace data_queue {
		};
#endif
#ifndef __STATIC_GLOBALS__
		PRIORITY_PRELOAD( InitLocals, NAMESPACE_PRELOAD_PRIORITY + 1 )
		{
#  ifdef __cplusplus
			RegisterAndCreateGlobal( (POINTER*)&list::_list_local, sizeof( *list::_list_local ), "_list_local" );
			//RegisterAndCreateGlobal( (POINTER*)&data_list::_data_list_local, sizeof( *data_list::_data_list_local ), "_data_list_local" );
			RegisterAndCreateGlobal( (POINTER*)&queue::_link_queue_local, sizeof( *queue::_link_queue_local ), "_link_queue_local" );
			RegisterAndCreateGlobal( (POINTER*)&data_queue::_data_queue_local, sizeof( *data_queue::_data_queue_local ), "_data_queue_local" );
#  else
			SimpleRegisterAndCreateGlobal( _list_local );
			//SimpleRegisterAndCreateGlobal( _data_list_local );
			SimpleRegisterAndCreateGlobal( _link_queue_local );
			SimpleRegisterAndCreateGlobal( _data_queue_local );
#  endif
		}
#endif
#ifdef __cplusplus
 //namespace sack {
	}
 //	namespace containers {
}
#endif
// restore this def in case of amalgamation
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
//--------------------------------------------------------------
// $Log: typecode.c,v $
// Revision 1.47  2005/05/25 16:50:30  d3x0r
// Synch with working repository.
//
// Revision 1.56  2005/05/20 23:15:13  jim
// Remove a noisy logging statement
//
// Revision 1.55  2005/05/16 23:18:22  jim
// Allocate the correct amount of space for the message queue - it's a MSGQUEUE not a DATAQUEUE.  Also implement DequeMessage() in such a way that the waited for message ID can change.
//
// Revision 1.54  2005/05/02 17:02:58  jim
// Moved the process-wait information to a seperate queue... does not work inline with normal messages...
//
// Revision 1.53  2005/04/20 23:38:20  jim
// Fixed leaving the critical section under a loop condition that resulted in error.
//
// Revision 1.52  2005/04/18 15:55:59  jim
// Much logging added to sack's implementation of SYSV msgq communications.
//
// Revision 1.51  2005/03/22 12:33:50  panther
// Restore disabled message queue logging
//
// Revision 1.50  2005/03/17 02:23:53  panther
// Checkpoint - working on message server abstraction interface... some of this seems to work quite well, some of this is still broken very badly...
//
// Revision 1.49  2005/03/14 16:04:03  panther
// If someone is waiting for any message, then they are definatly waiting for the currently enquing message.
//
// Revision 1.48  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.47  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.46  2004/10/25 10:40:00  d3x0r
// Linux compilation cleaning requirements...
//
// Revision 1.45  2004/10/02 19:49:57  d3x0r
// Fix logging... trying to track down multiple update display issues.... keys are queued, events are locally queued...
//
// Revision 1.44  2004/09/30 22:02:43  d3x0r
// checkpoing
//
// Revision 1.43  2004/09/30 09:42:52  d3x0r
// Fixed message queues for single app, all wraps, and nearly for two apps, but when removing logging, lost stability :(
//
// Revision 1.42  2004/09/30 01:14:48  d3x0r
// Cleaned up consistancy of PID and thread ID... extended message service a bit to supply event PID both ways.
//
// Revision 1.41  2004/09/29 16:43:03  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.40  2004/09/29 00:49:00  d3x0r
// Store waiting thread IDs IN the message queue... need to figure out how to shuffle these around.
//
// Revision 1.39  2004/09/24 08:09:49  d3x0r
// Test tial meeting the head...
//
// Revision 1.38  2004/09/23 11:07:33  d3x0r
// Minor adjustments...
//
// Revision 1.37  2004/09/23 00:36:55  d3x0r
// Fix result code when error no message and no wait... fix test for read messages and end of queue messages.
//
// Revision 1.36  2004/08/16 06:32:10  d3x0r
// Fix message queue routines... protect against no handle
//
// Revision 1.35  2004/07/13 04:17:49  d3x0r
// clean some warnings, and fix definiton of PRELOAD to be compiler friendly.
//
// Revision 1.34  2004/06/12 09:09:41  d3x0r
// ug - if queue is empty peek must be NULL...
//
// Revision 1.33  2004/05/24 16:40:29  d3x0r
// Add PeekQueue and GetQUeueLength
//
// Revision 1.32  2003/11/28 20:21:35  panther
// Add and fix EmptyList
//
// Revision 1.31  2003/10/31 02:24:53  panther
// Modified test to take variable msg count.
//
// Revision 1.30  2003/10/26 23:40:46  panther
// minor type fixes
//
// Revision 1.29  2003/10/26 23:32:17  panther
// Looks like most issues with simple message queuing are done.
//
// Revision 1.28  2003/10/22 10:45:40  panther
// Handle null lists in find
//
// Revision 1.27  2003/10/21 01:39:37  panther
// Fixed some issues with new perma-wait critical sections...
//
// Revision 1.26  2003/10/20 03:01:21  panther
// Fix getmythreadid - split depending if getpid returns ppid or pid.
// Fix memory allocator to init region correctly...
// fix initial status of found thred to reflect sleeping
// in /proc/#/status
//
// Revision 1.25  2003/10/20 00:04:21  panther
// Extend OpenSpace in SharedMem
// revise msgqueue operations to more resemble sysVipc msgq
//
// Revision 1.24  2003/10/18 23:41:04  panther
// Checkpoint... probably defuct
//
// Revision 1.23  2003/10/18 04:43:00  panther
// Quick patch...
//
// Revision 1.22  2003/10/17 00:56:05  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.21  2003/08/20 08:07:13  panther
// some fixes to blot scaled... fixed to makefiles test projects... fixes to export containters lib funcs
//
// Revision 1.20  2003/07/25 10:21:57  panther
// Fix callback for foralllinks
//
// Revision 1.19  2003/05/12 01:31:52  panther
// Fix return
//
// Revision 1.18  2003/05/02 01:11:26  panther
// Many minor fixes, tweaks....
//
// Revision 1.17  2003/04/21 11:46:52  panther
// Ug - forgot a commit somewhere... return pointer at set data item
//
// Revision 1.16  2003/04/20 08:14:07  panther
// *** empty log message ***
//
// Revision 1.15  2003/04/12 20:52:46  panther
// Added new type contrainer - data list.
//
// Revision 1.14  2003/03/31 01:11:28  panther
// Tweaks to work better under service application
//
// Revision 1.13  2003/03/30 21:15:57  panther
// Added EX functions to pass application source to DataStack allocations
//
// Revision 1.12  2003/03/30 00:14:36  panther
// fix pop stack data function
//
// Revision 1.11  2003/01/28 16:37:48  panther
// More logging extended logging
//
// Revision 1.10  2003/01/27 09:20:34  panther
// Error in passing debug argument to create queue
//
// Revision 1.9  2003/01/22 17:10:09  panther
// Added forwarding in EnqueLink To CreateQueue
//
// Revision 1.8  2002/11/06 09:49:17  panther
// Fixed data-queue allocation/copy.
//
// Revision 1.7  2002/11/04 09:29:50  panther
// Added container class - DATAQUEUE.
//
//
//  - Added DataQueue to compliment LinkQueue  (datastack/linkstack)
//  - Added EmptyDataStack method to quickly remove all items on stack.
// Revision 1.6  2002/07/15 08:28:56  panther
// Fixed some debug passing to allocate.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   code to provide a robust text class for C
 *   Parsing, text substitution, replacment, phrase splitting
 *   options for paired parsing of almost all pairable symbols
 *   used in common language.
 *
 *
 * see also - include/typelib.h
 *
 */
#define NO_UNICODE_C
#ifdef _MSC_VER
// derefecing NULL pointers; the function wouldn't be called with a NULL.
// and partial expressions in lower precision
// and NULL math because never NULL.
#  pragma warning( disable:6011 26451 28182)
//Warning C26451: Arithmetic overflow: Using operator '%operator%'
// on a %size1% byte value and then casting the result to a
// %size2% byte value. Cast the value to the wider type
// before calling operator '%operator%' to avoid overflow
#  pragma warning( disable:26451 )
#endif
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace text {
	using namespace sack::memory;
	using namespace sack::logging;
	using namespace sack::containers::queue;
#endif
typedef PTEXT (CPROC*GetTextOfProc)( uintptr_t, POINTER );
typedef struct text_exension_tag {
	uint32_t bits;
	GetTextOfProc TextOf;
	uintptr_t psvData;
}  TEXT_EXTENSION, *PTEXT_EXTENSION;
typedef struct vartext_tag {
	TEXTSTR collect_text;
	size_t collect_used;
	size_t collect_avail;
	size_t expand_by;
	PTEXT collect;
	PTEXT commit;
} VARTEXT;
//#ifdef __cplusplus
static PTEXT newline;
static PTEXT blank;
PRELOAD( AllocateDefaults )
{
	newline = (PTEXT)SegCreateFromText( "" );
	blank = (PTEXT)SegCreateFromText( " " );
}
//#define newline (*newline)
//#define blank	(*blank)
//#else
//__declspec( dllexport ) TEXT newline = { TF_STATIC, NULL, NULL, {1,1},{0,""}};
//__declspec( dllexport ) TEXT blank = { TF_STATIC, NULL, NULL, {1,1},{1," "}};
//#endif
static PLIST pTextExtensions;
//---------------------------------------------------------------------------
PTEXT SegCreateEx( size_t size DBG_PASS )
{
	PTEXT pTemp;
#if defined( _MSC_VER )
	//if( size > 0x8000 )
	//	_asm int 3;
#endif
	pTemp = (PTEXT)AllocateEx( sizeof(TEXT) + (size
#ifdef _MSC_VER
		+ 1
#endif
		)*sizeof(TEXTCHAR)
 // good thing [1] is already counted.
		DBG_RELAY );
	MemSet( pTemp, 0, sizeof(TEXT) + (size*sizeof(TEXTCHAR)) );
	pTemp->format.flags.prior_background = 1;
	pTemp->format.flags.prior_foreground = 1;
 // physical space IS one more....
	pTemp->data.size = size;
	return pTemp;
}
//---------------------------------------------------------------------------
PTEXT GetIndirect(PTEXT segment )
{
	if( !segment )
		return NULL;
	if( (segment->flags&TF_APPLICATION) )
	{
		INDEX idx;
		PTEXT_EXTENSION pte;
		LIST_FORALL( pTextExtensions, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->bits & segment->flags )
			{
				// size is used as a pointer...
				segment = pte->TextOf( pte->psvData, (POINTER)segment->data.size );
				break;
			}
		}
		if( !pte )
			return NULL;
		return segment;
	}
	// if it's not indirect... don't result..
	if( !(segment->flags&TF_INDIRECT) )
		return NULL;
	return (PTEXT)(segment->data.size);
}
//---------------------------------------------------------------------------
TEXTSTR GetText( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			return segment->data.data;
	}
	return NULL;
}
//---------------------------------------------------------------------------
size_t GetTextSize( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			if( !segment->data.size )
			{
				if( segment->flags & IS_DATA_FLAGS )
				{
					//lprintf( "Is Data falgs returns 2. %08x", segment->flags & IS_DATA_FLAGS );
 // is data even if is not acurate....
					return segment->data.size;
				}
				break;
			}
			else
				return segment->data.size;
	}
	return 0;
}
//---------------------------------------------------------------------------
uint32_t GetTextFlags( PTEXT segment )
{
	if( !segment )
		return 0;
	if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		return GetTextFlags( GetIndirect( segment ) );
	return segment->flags;
}
//---------------------------------------------------------------------------
void SegCopyFormat( PTEXT to_this, PTEXT copy_this )
{
	if( to_this && copy_this )
	{
		if( copy_this && !( copy_this->flags & TF_FORMATPOS ) )
		{
			to_this->format.position.offset.tabs = copy_this->format.position.offset.tabs;
			to_this->format.position.offset.spaces = copy_this->format.position.offset.spaces;
		}
		else
		{
			// copy absolute positioning...
		}
	}
}
//---------------------------------------------------------------------------
PTEXT SegDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT t;
	size_t n;
	if( pText )
	{
		if( pText->flags & TF_APPLICATION )
		{
			t = SegCreateIndirect( (PTEXT)pText->data.size );
			t->format = pText->format;
			t->flags = pText->flags;
		}
		else if( pText->flags & TF_INDIRECT )
		{
			t = SegCreateIndirectEx( SegDuplicateEx( GetIndirect( pText ) DBG_RELAY ) DBG_RELAY );
			t->format = pText->format;
			// some other mask needs to be here.. the getindirect
			// will have other flags...
			t->flags = pText->flags;
		}
		else
		{
			t = SegCreateEx( n = GetTextSize( pText ) DBG_RELAY );
			t->format = pText->format;
			MemCpy( GetText(t), GetText(pText), sizeof( TEXTCHAR ) * ( n + 1 ) );
			t->flags = pText->flags;
		}
		t->flags &= ~(TF_DEEP|TF_STATIC);
		return t;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT LineDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT pt;
	pt = pText;
	while( pt )
	{
		if( !(pt->flags&TF_STATIC) )
			HoldEx( (uint8_t*)pt DBG_RELAY  );
		if( (pt->flags & TF_INDIRECT ) || (pt->flags&TF_APPLICATION) )
			LineDuplicateEx( GetIndirect( pt ) DBG_RELAY );
		pt = NEXTLINE( pt );
	}
	return pText;
}
//---------------------------------------------------------------------------
PTEXT TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS )
{
	PTEXT pt;
	PTEXT pDup = NULL, pNew;
	pt = pText;
	while( pt )
	{
		if( (pt->flags & TF_INDIRECT ) && !(pt->flags&TF_APPLICATION) )
		{
			pNew = SegCreateIndirectEx(
			            TextDuplicateEx(
			                  GetIndirect( pt ), bSingle DBG_RELAY ) DBG_RELAY );
			pNew->format.position = pt->format.position;
			pNew->flags |= pt->flags&(IS_DATA_FLAGS);
			pNew->flags |= TF_DEEP;
		}
		else
			pNew = SegDuplicateEx( pt DBG_RELAY );
		pDup = SegAppend( pDup, pNew );
		if( bSingle )
			break;
		pt = NEXTLINE( pt );
	}
	return pDup;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromTextEx( CTEXTSTR text DBG_PASS )
{
	PTEXT pTemp;
	size_t nSize;
	if( text )
	{
		pTemp = SegCreateEx( nSize = StrLen( text ) DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
		pTemp = SegCreateEx( len DBG_RELAY );
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( len + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharEx( const char *text DBG_PASS )
{
	return SegCreateFromCharLenEx( text, strlen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideLenEx( const wchar_t *text, size_t nSize DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
		TEXTSTR text_string = WcharConvertLen( text, nSize );
		int outlen;
		for( outlen = 0; text_string[outlen]; outlen++ );
		pTemp = SegCreateEx( outlen DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( outlen + 1 ) );
		Deallocate( TEXTSTR, text_string );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideEx( const wchar_t *text DBG_PASS )
{
	return SegCreateFromWideLenEx( text, wcslen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromIntEx( int value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 12 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 12, "%d", value );
	pResult->data.data[11] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFrom_64Ex( int64_t value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 32, "%" _64f, value );
pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromFloatEx( double value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
 //-V512
	pResult->data.size = snprintf( pResult->data.data, 32, "%g", value );
	pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateIndirectEx( PTEXT pText DBG_PASS )
{
	PTEXT pSeg;
 // no data content for indirect...
	pSeg = SegCreateEx( -1 DBG_RELAY );
	pSeg->flags |= TF_INDIRECT;
	pSeg->data.size = (uintptr_t)pText;
	return pSeg;
}
//---------------------------------------------------------------------------
  // remove leading segments.
PTEXT SegBreak(PTEXT segment)
	 // return leading segments!  might be ORPHANED if not handled.
{
	PTEXT temp;
	if( !segment )
		return NULL;
	if((temp=PRIORLINE(segment)))
		SETNEXTLINE(temp,NULL);
	SETPRIORLINE(segment,NULL);
	return(temp);
}
INDEX  GetSegmentSpaceEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs)
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < nTabs && (INDEX)position > tabs[n]; n++ );
			if( n < nTabs )
				// now position is before the first tab... such that
				for( ; n < nTabs && n < segment->format.position.offset.tabs; n++ )
				{
					total += tabs[n]-position;
					position = tabs[n];
				}
			//lprintf( "Adding %d spaces", segment->format.position.offset.spaces );
			total += segment->format.position.offset.spaces;
		}
	}
	while( segment && (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize )
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < segment->format.position.offset.tabs; n++ )
			{
				if( !total )
					// I think this is wrong.  need to validate this equation.
					total += (position % nTabSize) + 1;
				else
					total += nTabSize;
			}
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLengthEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpaceEx( segment, position, nTabs, tabs ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLength ( PTEXT segment, size_t position, int nTabSize )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpace( segment, position, nTabSize ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
PTEXT SegAppend(PTEXT source,PTEXT other)
{
	PTEXT temp=source;
	if( temp )
	{
		if( other )
		{
			SetEnd(temp);
			SETNEXTLINE(temp,other);
			SETPRIORLINE(other,temp);
		}
	}
	else
	{
  // nothing was before...
		source=other;
	}
	return(source);
}
//---------------------------------------------------------------------------
void SegReleaseEx( PTEXT seg DBG_PASS)
{
	if( seg )
		ReleaseEx( seg DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegExpandEx(PTEXT source, INDEX nSize DBG_PASS)
{
	PTEXT temp;
	//Log1( "SegExpand...%d", nSize );
	temp = SegCreateEx( GetTextSize( source ) + nSize  DBG_RELAY );
	if( source )
	{
		MemCpy( temp->data.data, source->data.data, sizeof( TEXTCHAR)*(GetTextSize( source ) + 1) );
		temp->flags = source->flags;
		temp->format = source->format;
		SegSubst( temp, source );
		SegRelease( source );
	}
	return temp;
}
//---------------------------------------------------------------------------
void LineReleaseEx(PTEXT line DBG_PASS )
{
	PTEXT temp;
	if( !line )
		return;
	SetStart(line);
	while(line)
	{
		temp=NEXTLINE(line);
		if( !(line->flags&TF_STATIC) )
		{
			if( (( line->flags & (TF_INDIRECT|TF_DEEP) ) == (TF_INDIRECT|TF_DEEP) ) )
 // if indirect, don't want to release application content
				if( !(line->flags & TF_APPLICATION) )
					LineReleaseEx( GetIndirect( line ) DBG_RELAY );
			ReleaseEx( line DBG_RELAY );
		}
		line=temp;
	}
}
//---------------------------------------------------------------------------
PTEXT SegConcatEx(PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS )
{
	size_t idx=0;
	size_t len=0;
	PTEXT newseg;
	SegAppend( output, newseg = SegCreateEx( length DBG_RELAY ) );
	output = newseg;
	//output=SegExpandEx(output, length DBG_RELAY); /* add 1 for a null */
	GetText(output)[0]=0;
	while (input&&idx<length)
	{
		//#define min(a,b) (((a)<(b))?(a):(b))
		if( ( GetTextSize( input ) - offset ) < ( length-idx  ) )
			len = GetTextSize( input ) - offset;
		else
         len = length - idx;
		MemCpy( GetText(output) + idx,
				  GetText(input) + offset,
				  sizeof( TEXTCHAR ) * ( len + 1 ) );
		idx += len;
		offset = 0;
		input=NEXTLINE(input);
	}
	GetText(output)[idx]=0;
	return(output);
}
//---------------------------------------------------------------------------
PTEXT SegUnlink(PTEXT segment)
{
	PTEXT temp;
	if (segment)
	{
		if( ( temp = PRIORLINE(segment) ) )
			SETNEXTLINE(temp,NEXTLINE(segment));
		if( ( temp = NEXTLINE(segment) ) )
			SETPRIORLINE(temp,PRIORLINE(segment));
		SETPRIORLINE(segment, NULL);
		SETNEXTLINE(segment, NULL);
	}
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegGrab( PTEXT segment )
{
	SegUnlink( segment );
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegDelete( PTEXT segment )
{
	LineReleaseEx( SegGrab( segment ) DBG_SRC );
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegInsert( PTEXT what, PTEXT before )
{
	PTEXT that_start = what ,
			that_end= what;
	SetStart( that_start );
	SetEnd( that_end );
	if( before )
	{
		if( ( that_start->Prior = before->Prior) )
			that_start->Prior->Next = that_start;
		if( ( that_end->Next = before ) )
			that_end->Next->Prior = that_end;
	}
	return what;
}
//---------------------------------------------------------------------------
PTEXT SegSubst( PTEXT _this, PTEXT that )
{
	PTEXT that_start = that ,
			that_end= that;
	SetStart( that_start );
	SetEnd( that_end );
	if( ( that_end->Next = _this->Next ) )
		that_end->Next->Prior = that_end;
	if( ( that_start->Prior = _this->Prior) )
		that_start->Prior->Next = that_start;
	_this->Next = NULL;
	_this->Prior = NULL;
	return _this;
}
//---------------------------------------------------------------------------
PTEXT SegSplitEx( PTEXT *pLine, INDEX nPos  DBG_PASS)
{
	// there includes the character at nPos - so all calculations
	// on there are +1...
	PTEXT here, there;
	size_t nLen;
	nLen = GetTextSize( *pLine );
	if( nPos > nLen )
	{
		return NULL;
	}
	if( nPos == nLen )
		return *pLine;
	here = SegCreateEx( nPos DBG_RELAY );
 //-V595
	here->flags  = (*pLine)->flags;
	here->format = (*pLine)->format;
	there = SegCreateEx( (nLen - nPos) DBG_RELAY );
 //-V595
	there->flags  = (*pLine)->flags;
	there->format = (*pLine)->format;
 // was two characters presumably...
	there->format.position.offset.spaces = 0;
	there->format.position.offset.tabs = 0;
	MemCpy( GetText( here ), GetText( *pLine ), sizeof(TEXTCHAR)*nPos );
	GetText( here )[nPos] = 0;
	if( nLen - nPos )
	{
		MemCpy( GetText( there ), GetText( *pLine ) + nPos, sizeof(TEXTCHAR)*(nLen - nPos) );
		GetText( there )[nLen-nPos] = 0;
	}
	SETNEXTLINE( PRIORLINE( *pLine ), here );
	SETPRIORLINE( here, PRIORLINE( *pLine ) );
	SETNEXTLINE( here, there );
	SETPRIORLINE( there, here );
	SETNEXTLINE( there, NEXTLINE( *pLine ) );
	SETPRIORLINE( NEXTLINE( *pLine ), there );
	SETNEXTLINE( *pLine, NULL );
	SETPRIORLINE( *pLine, NULL );
	LineReleaseEx( *pLine DBG_RELAY );
	*pLine = here;
	return here;
}
//----------------------------------------------------------------------
TEXTRUNE NextCharEx( PTEXT input, size_t idx )
{
	if( ( ++idx ) >= input->data.size )
	{
		idx -= input->data.size;
		input = NEXTLINE( input );
	}
	if( input ) {
		return GetUtfCharIndexed( input->data.data, &idx, input->data.size );
		//return input->data.data[idx];
	}
	return 0;
}
#define NextChar() NextCharEx( input, tempText-tempText_ )
//----------------------------------------------------------------------
// In this final implementation - it was decided that for a general
// library, that expressions, escapes of expressions, apostrophes
// were of no consequence, and without expressions, there is no excess
// so this simply is text stream in, text stream out.
// these are just shortcuts - these bits of code were used repeatedly....
#define SET_SPACES() do {		word->format.position.offset.spaces = (uint16_t)spaces;		 word->format.position.offset.tabs = (uint16_t)tabs;		                             spaces = 0;		                                                         tabs = 0; } while(0)
//static CTEXTSTR normal_punctuation="\'\"\\({[<>]}):@%/,;!?=*&$^~#`";
//static CTEXTSTR not_punctuation;
PTEXT TextParse( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_space, int bTabs, int bSpaces  DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
	   burst into its block pieces.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
	      word;
	TEXTSTR tempText, tempText_;
	int has_minus = -1;
	int has_plus = -1;
	INDEX size;
	TEXTRUNE character;
	uint32_t elipses = FALSE,
	   spaces = 0, tabs = 0;
        // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, TextParse( GetIndirect( input ), punctuation, filter_space, bTabs, bSpaces DBG_RELAY ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText_ = tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( "Assuming %d spaces... ", spaces );
		for (;(character = GetUtfChar( (char const**)&tempText ) ),
 // while not at the
                   ((tempText-tempText_) <= (int)size); )
                                         // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( "VarTextGet Failed to result." );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				continue;
			}
		if( StrChr( filter_space, character ) )
		{
			goto is_a_space;
		}
		else if( StrChr( punctuation, character ) )
		{
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
				outdata = SegAppend( outdata, word );
				SET_SPACES();
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				outdata = SegAppend( outdata, word );
			}
			else
			{
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		else switch(character)
		{
		case '\n':
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
					SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
 // add a line-break packet
			outdata = SegAppend( outdata, SegCreate( 0 ) );
			break;
		case ' ':
// case '\xa0': // &nbsp;
		case 160 :
			if( bSpaces )
			{
			is_a_space:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			}
 //-V517
				if(0) {
		case '\t':
					if( bTabs )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							SET_SPACES();
							outdata = SegAppend( outdata, word );
						}
						if( spaces )
						{
						//lprintf( "Input stream has mangled spaces and tabs." );
 // assume that the tab takes care of appropriate spacing
							spaces = 0;
						}
						tabs++;
						break;
					}
 //-V517
				} else if(0) {
 // a space space character...
		case '\r':
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					break;
 //-V517
				} else if(0) {
 // handle multiple periods grouped (elipses)
		case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
						  ( c = NextChar() ) &&
						  ( c == '.' ) ) )
						{
							if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
							{
								outdata = SegAppend( outdata, word );
								SET_SPACES();
							}
							VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
							elipses = TRUE;
							break;
						}
						if( ( c = NextChar() ) &&
							( c >= '0' && c <= '9' ) )
						{
							// gather together as a floating point number...
							VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
							break;
						}
					}
				} else if(0) {
  // work seperations flaming-long-sword
				case '-':
					if( has_minus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_minus = 1;
						else
							has_minus = 0;
					}
					if( !has_minus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
				case '+':
				{
					int c;
					if( has_plus == -1 ) {
						if( !punctuation || StrChr( punctuation, '+' ) )
							has_plus = 1;
						else
							has_plus = 0;
					}
					if( !has_plus )
					{
						VarTextAddCharacterEx( &out, '+' DBG_OVERRIDE );
						break;
					}
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
							// gather together as a sign indication on a number.
						}
						VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
						break;
					}
				}
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
				}
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
PTEXT burstEx( PTEXT input DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
//#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
		burst into its block pieces.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
			word;
	TEXTSTR tempText, tempText_;
	size_t size;
	TEXTRUNE character;
	uint32_t elipses = FALSE,
		spaces = 0, tabs = 0;
		  // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, burst( GetIndirect( input ) ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText_ = tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( "Assuming %d spaces... ", spaces );
		for (;(character = GetUtfChar( (char const**)&tempText ) ),
 // while not at the
		             ((tempText-tempText_) <= (int)size); )
		                                      // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( "VarTextGet Failed to result." );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				continue;
			}
			switch(character)
			{
			case '\n':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
 // add a line-break packet
				outdata = SegAppend( outdata, SegCreate( 0 ) );
				break;
			case ' ':
// '\xa0': // nbsp
			case 160 :
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			case '\t':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				if( spaces )
				{
				//lprintf( "Input stream has mangled spaces and tabs." );
					spaces = 0;
				}
				tabs++;
				break;
 // a space space character...
			case '\r':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
 // handle multiple periods grouped (elipses)
			case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
							( c = NextChar() ) &&
							( c == '.' ) ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
						elipses = TRUE;
						break;
					}
					if( ( c = NextChar() ) &&
						 ( c >= '0' && c <= '9' ) )
					{
						// gather together as a floating point number...
						VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
						break;
					}
				}
  // work seperations flaming-long-sword
			case '-':
			case '+':
				{
					int c;
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						// gather together as a sign indication on a number.
						VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
						break;
					}
				}
 // single quote bound
			case '\'':
 // double quote bound
			case '\"':
 // escape next thingy... unusable in c processor
			case '\\':
 // expression bounders
			case '(':
			case '{':
			case '[':
			case '<':
 // expression closers
			case ')':
			case '}':
			case ']':
			case '>':
  // internet addresses
			case ':':
  // email addresses
			case '@':
			case '%':
			case '/':
			case ',':
			case ';':
			case '!':
			case '?':
			case '=':
			case '*':
			case '&':
			case '$':
			case '^':
			case '~':
			case '#':
			case '`':
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddRuneEx( &out, character, FALSE DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
//---------------------------------------------------------------------------
#undef LineLengthExx
size_t LineLengthExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL )
{
	return LineLengthExEx( pt, bSingle, 8, pEOL );
}
size_t LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL )
{
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	size_t length = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		if( !(pt->flags & ( IS_DATA_FLAGS | TF_INDIRECT)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
				length += pEOL->data.size;
			else
 // full binary \r\n insertion assumed
				length += 2;
		}
		else
		{
			if( skipspaces )
				skipspaces = FALSE;
			else
			{
				if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
 // not-including NULL.
					length += GetSegmentSpace( pt, length, nTabsize );
			}
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top seg.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
 // not-including NULL.
				length += GetTextSize( pt );
stack_resume:
			if( pt->flags&TF_TAG )
				length += 2;
			if( pt->flags&TF_PAREN )
				length += 2;
			if( pt->flags&TF_BRACE )
				length += 2;
			if( pt->flags&TF_BRACKET )
				length += 2;
			if( pt->flags&TF_QUOTE )
				length += 2;
			if( pt->flags&TF_SQUOTE )
				length += 2;
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
//	if( length > 60000 )
//		_asm int 3;
	return length;
}
#undef LineLengthEx
INDEX LineLengthEx( PTEXT pt, LOGICAL bSingle )
{
	return LineLengthExx( pt, bSingle, NULL );
}
//---------------------------------------------------------------------------
// attempts to build a solitary line segment from the text passed
// however, if there are color changes, or absolute position changes
// this cannot work... and it must provide multiple pieces...
#undef BuildLineExx
PTEXT BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS )
{
	return BuildLineExEx( pt, bSingle, 8, pEOL DBG_RELAY );
}
PTEXT BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS )
{
	TEXTSTR buf;
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack, firstadded;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	PTEXT pOut;
	uintptr_t ofs;
	{
		INDEX len;
		len = LineLengthExx( pt,bSingle,pEOL );
		if( !len )
			return NULL;
		pOut = SegCreateEx( len DBG_RELAY );
		firstadded = TRUE;
		buf = GetText( pOut );
	}
	ofs = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		// test color fields vs PRIOR_COLOR
		// if either the color IS the prior color - OR the value IS PRIOR_COLOR
		// then they can still be collapsed... DEFAULT_COLOR MAY be prior color
		// but there's no real telling... default is more like after a
		// attribute reset occurs...
		if( firstadded )
		{
			pOut->format.flags.foreground = pt->format.flags.foreground;
			pOut->format.flags.background = pt->format.flags.background;
			firstadded = FALSE;
		}
		else
		{
			if( ( !pt->format.flags.prior_foreground &&
				  !pt->format.flags.default_foreground &&
					pt->format.flags.foreground != pOut->format.flags.foreground ) ||
				 ( !pt->format.flags.prior_background &&
				  !pt->format.flags.default_background &&
					pt->format.flags.background != pOut->format.flags.background )
			  )
			{
				PTEXT pSplit;
				// ofs is the next valid character position....
				//Log( "Changing segment's color..." );
				if( ofs )
				{
					pSplit = SegSplitEx( &pOut, ofs DBG_RELAY );
					if( !pSplit )
					{
						lprintf( "Line was shorter than offset: %" _size_f " vs %" _PTRSZVALfs "", GetTextSize( pOut ), ofs );
					}
					pOut = NEXTLINE( pSplit );
					// new segments takes on the new attributes...
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
						//Log2( "Split at %d result %d", ofs, GetTextSize( pOut ) );
						buf = GetText( pOut );
					ofs = 0;
				}
				else
				{
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
				}
			}
		}
		if( !(pt->flags& (TF_INDIRECT|IS_DATA_FLAGS)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
			{
				MemCpy( buf + ofs, pEOL->data.data, sizeof( TEXTCHAR )*(pEOL->data.size + 1) );
				ofs += pEOL->data.size;
			}
			else
			{
				buf[ofs++] = '\r';
				buf[ofs++] = '\n';
			}
		}
		else
		{
			if( skipspaces )
			{
				skipspaces = FALSE;
			}
			else if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
			{
				size_t spaces = GetSegmentSpace( pt, ofs, nTabsize );
				// else we cannot collapse into single line (similar to colors.)
				while( spaces-- )
				{
					buf[ofs++] = ' ';
				}
			}
			// at this point spaces before tags, and after tags
			// which used to be expression level parsed are not
			// reconstructed correctly...
			if( pt->flags&TF_TAG )
				buf[ofs++] = '<';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = '(';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '{';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = '[';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
			{
				size_t len;
				MemCpy( buf+ofs, GetText( pt ), sizeof( TEXTCHAR) * (len = GetTextSize( pt ))+1 );
					ofs += len;
			}
stack_resume:
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = ']';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '}';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = ')';
			if( pt->flags&TF_TAG )
				buf[ofs++] = '>';
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
 // have to return length instead of new text seg...
	if( !pOut )
		return (PTEXT)ofs;
 // if formatting was inserted into the stream...
	SetStart( pOut );
	return pOut;
}
#undef BuildLineEx
PTEXT BuildLineEx( PTEXT pt, int bSingle DBG_PASS )
{
	return BuildLineExx( pt, bSingle, FALSE DBG_RELAY );
}
PTEXT FlattenLine( PTEXT pLine )
{
	 PTEXT pCur, p;
	 pCur = pLine;
	 // all indirected segments get promoted to
	 // the first level...
	 while( pCur )
	 {
		  if( pCur->flags & TF_STATIC )
		  {
			  p = SegDuplicate( pCur );
			  if( p )
			  {
				  SegSubst( pCur, p );
				  if( pCur == pLine )
					  pLine = p;
				  LineReleaseEx( pCur DBG_SRC );
				  pCur = p;
			  }
			  else
			  {
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
					continue;
			  }
		  }
		  if( pCur->flags & TF_INDIRECT )
		  {
				if( pCur->flags & TF_DEEP )
				{
					 p = FlattenLine( GetIndirect( pCur ) );
					 pCur->flags &= ~TF_DEEP;
				}
				else
				{
					 p = TextDuplicate( GetIndirect( pCur ), FALSE );
				}
				if( p )
				{
					SegSubst( pCur, p );
					if( pCur == pLine )
						pLine = p;
					p->flags |= pCur->flags & (~(TF_INDIRECT|TF_DEEP));
					LineReleaseEx( pCur DBG_SRC );
					pCur = p;
				}
				else
				{
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
				}
				continue;
		  }
		  pCur = NEXTLINE( pCur );
	 }
	 return pLine;
}
//----------------------------------------------------------------------------
POINTER GetApplicationPointer( PTEXT text )
{
	// okay indirects up to application data are okay.
	while( ( text->flags & TF_INDIRECT ) && !(text->flags & TF_APPLICATION) )
		return GetApplicationPointer( (PTEXT)text->data.size );
	if( text->flags & TF_APPLICATION )
		return (POINTER)text->data.size;
	return NULL;
}
//----------------------------------------------------------------------------
void SetApplicationPointer( PTEXT text, POINTER p)
{
	// sets only this segment.
	if( text )
	{
		text->flags |= TF_APPLICATION;
		text->data.size = (uintptr_t)p;
	}
}
//----------------------------------------------------------------------------
void RegisterTextExtension( uint32_t flags, PTEXT(CPROC*TextOf)(uintptr_t,POINTER), uintptr_t psvData)
{
	PTEXT_EXTENSION pte = (PTEXT_EXTENSION)Allocate( sizeof( TEXT_EXTENSION ) );
	pte->bits = flags;
	pte->TextOf = TextOf;
	pte->psvData = psvData;
	AddLink( &pTextExtensions, pte );
#if 0
	if( text && ( text->flags & TF_APPLICATION ) )
	{
		INDEX idx;
		PTEXT_EXENSTION pte;
		LIST_FORALL( pTextExtension, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->flags & text->flags )
			{
				text = pte->TextOf( text );
				break;
			}
		}
	}
#endif
	return;
}
//---------------------------------------------------------------------------
int TextIs( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextLike( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCaseCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextSimilar( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
	{
		size_t len1 = data ? StrLen( data ) : 0;
		size_t len2 = string ? StrLen( string ) : 0;
		return !StrCaseCmpEx( data, string, textmin( len1, len2 ) );
	}
	return 0;
}
//---------------------------------------------------------------------------
int SameText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	CTEXTSTR d2 = GetText( l2 );
	if( d1 && d2 )
		return StrCmp( d1, d2 );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int LikeText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	size_t len1 = d1 ? StrLen( d1 ) : 0;
	CTEXTSTR d2 = GetText( l2 );
	size_t len2 = d2 ? StrLen( d2 ) : 0;
	if( d1 && d2 )
		return StrCaseCmpEx( d1, d2, textmin( len1, len2 ) );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int CompareStrings( PTEXT pt1, int single1
                  , PTEXT pt2, int single2
                  , int bExact )
{
	while( pt1 && pt2 )
	{
		while( pt1 &&
				 pt1->flags && ( pt1->flags & TF_BINARY ) )
			pt1 = NEXTLINE( pt1 );
		while( pt2 &&
				 pt2->flags && ( pt2->flags & TF_BINARY ) )
			pt2 = NEXTLINE( pt2 );
		if( !pt1 && pt2 )
			return FALSE;
		if( pt1 && !pt2 )
			return FALSE;
		if( bExact )
		{
			if( SameText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		else
		{
			// Like returns string compare function literal...
			if( LikeText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		if( !single1 )
		{
			pt1 = NEXTLINE( pt1 );
			if( pt1 &&
				 !GetTextSize( pt1 ) && !(pt1->flags & IS_DATA_FLAGS))
				pt1 = NULL;
		}
		else
			pt1 = NULL;
		if( !single2 )
		{
			pt2 = NEXTLINE( pt2 );
			if( pt2 &&
				 !GetTextSize( pt2 ) &&
				 !(pt2->flags & IS_DATA_FLAGS))
				pt2 = NULL;
		}
		else
			pt2 = NULL;
	}
	if( !pt1 && !pt2 )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromTextRef( CTEXTSTR *p_ )
{
	CTEXTSTR p = p_[0];
	int s;
	int begin;
	int64_t num;
	LOGICAL altBase = FALSE;
	LOGICAL altBase2 = FALSE;
	int64_t base = 10;
	if( !p )
		return 0;
	//if( pText->flags & TF_INDIRECT )
	//   return IntCreateFromSeg( GetIndirect( pText ) );
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '.' )
			break;
		else if( *p == '+' )
		{
		}
		else if( *p == '-' && begin)
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( !altBase2 ) {
				if( *p == 'x' ) { altBase2 = TRUE; base = 16; }
				else if( *p == 'o' ) { altBase2 = TRUE; base = 8; }
				else if( *p == 'b' ) { altBase2 = TRUE; base = 2; }
				else break;
			} else {
				if( base > 10 ) {
					if( *p >= 'a' && *p <= 'f' ) {
						num *= base;
						num += *p - 'a' + 10;
					}
					else if( *p >= 'A' && *p <= 'F' ) {
						num *= base;
						num += *p - 'A' + 10;
					}
					else break;
				}
				else break;
			}
		}
		else
		{
			if( ( !altBase ) && (*p == '0') ) { altBase = TRUE; base = 10; }
			else { if( (*p - '0') >= base ) { break; } altBase = TRUE; }
			num *= base;
			num += *p - '0';
		}
		begin = FALSE;
		p++;
	}
	p_[0] = p;
	if( s & 1 )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromText( CTEXTSTR p )
{
	return IntCreateFromTextRef( &p );
}
//--------------------------------------------------------------------------
int64_t IntCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !pText || !p )
		return FALSE;
	if( pText->flags & TF_INDIRECT )
		return IntCreateFromSeg( GetIndirect( pText ) );
	return IntCreateFromText( p );
}
//--------------------------------------------------------------------------
double FloatCreateFromText( CTEXTSTR p, CTEXTSTR *vp )
{
	return strtod( p, (char **)vp );
	int s, begin, bDec = FALSE;
	double num;
	double base = 1;
	double temp;
	if( !p )
	{
		if( vp )
			(*vp) = p;
		return 0;
	}
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '-' && begin )
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( *p == '.' )
			{
				bDec = TRUE;
				base = 0.1;
			}
			else
				break;
		}
		else
		{
			if( bDec )
			{
				temp = *p - '0';
				num += base * temp;
				base /= 10;
			}
			else
			{
				num *= 10;
				num += *p - '0';
			}
		}
		begin = FALSE;
		p++;
	}
	if( vp )
		(*vp) = p;
	if( s )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
double FloatCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !p )
		return FALSE;
	return FloatCreateFromText( p, NULL );
}
//--------------------------------------------------------------------------
// if bUseAll - all segments must be part of the number
// otherwise, only as many segments as are needed for the number are used...
int IsSegAnyNumberEx( PTEXT *ppText, double *fNumber, int64_t *iNumber, int *bIntNumber, int bUseAll )
{
	CTEXTSTR pCurrentCharacter = NULL;
	PTEXT pBegin;
	PTEXT pText = *ppText;
	int decimal_count, begin = TRUE, digits;
	// int s;  // used to count negative signs... but this doesn't do a conversion so it's not needed.
	// remember where we started...
	// if the first segment is indirect, collect it and only it
	// as the number... making indirects within a number what then?
	if( pText->flags & TF_INDIRECT )
	{
		int status;
		PTEXT pTemp = GetIndirect( pText );
		if( pTemp
			&& (status = IsSegAnyNumberEx( &pTemp, fNumber, iNumber, bIntNumber, TRUE )) )
		{
			// step to next token - so we toss just this
			// one indirect statement.
			if( fNumber || iNumber )
			{
				// if resulting with a number, then step the text...
				(*ppText) = NEXTLINE( pText );
			}
			return status;
		}
		// not a number....
		return FALSE;
	}
	pBegin = pText;
	decimal_count = 0;
	//s = 0;
	digits = 0;
	while( pText )
	{
		// at this point... is this really valid?
		if( pText->flags & TF_INDIRECT )
		{
			lprintf( "Encountered indirect segment gathering number, stopping." );
			break;
		}
		if( !begin &&
			( pText->format.position.offset.spaces || pText->format.position.offset.tabs ) )
		{
			// had to continue with new segment, but it had spaces so stop now
			break;
		}
		pCurrentCharacter = GetText( pText );
		while( pCurrentCharacter && *pCurrentCharacter )
		{
			if( *pCurrentCharacter == '.' )
			{
				if( !decimal_count )
					decimal_count++;
				else
					break;
			}
			else if( ((*pCurrentCharacter) == '-') && begin)
			{
				//s++;
			}
			else if( ((*pCurrentCharacter) < '0') || ((*pCurrentCharacter) > '9') )
			{
				if( digits && ( pCurrentCharacter == GetText( pText ) ) )
				{
					pCurrentCharacter = GetText( PRIORLINE( pText ) );
					while( pCurrentCharacter[0] )
					{
						// if the number ended in a decimal, it can qualify as an integer
						if( pCurrentCharacter[0] == '.' && !pCurrentCharacter[1] )
							decimal_count--;
						pCurrentCharacter++;
					}
					pText = NULL;
				}
				break;
			}
			else
				digits++;
			begin = FALSE;
			pCurrentCharacter++;
		}
		// invalid character - stop, we're to abort.
		if( *pCurrentCharacter )
			break;
		pText = NEXTLINE( pText );
 //while( pText );
	}
	if( bUseAll && pText )
		// it's not a number, cause we didn't use all segments to get one
		return FALSE;
	if( *pCurrentCharacter || ( decimal_count > 1 ) || !digits )
	{
		// didn't collect enough meaningful info to be a number..
		// or information in this state is
		return FALSE;
	}
	// yeah it was a number, update the incoming pointer...
	if( fNumber || iNumber )
	{
		// if resulting with a number, then step the text...
		(*ppText) = pText;
	}
	if( decimal_count == 1 )
	{
		if( fNumber )
			(*fNumber) = FloatCreateFromSeg( pBegin );
		if( bIntNumber )
			(*bIntNumber) = 0;
 // return specifically it's a floating point number
		return 2;
	}
	if( iNumber )
		(*iNumber) = IntCreateFromSeg( pBegin );
	if( bIntNumber )
		(*bIntNumber) = 1;
 // return yes, and it's an int number
	return 1;
}
//---------------------------------------------------------------------------
//#define VERBOSE_DEBUG_VARTEXT
//---------------------------------------------------------------------------
#define COLLECT_LEN 4096
void VarTextInitEx( PVARTEXT pvt DBG_PASS )
{
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( COLLECT_LEN DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log( "Resetting collect_used (init)" );
#endif
	pvt->collect_used = 0;
	pvt->collect_avail = COLLECT_LEN;
	pvt->expand_by = 0;
}
 PVARTEXT  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( initial DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_used = 0;
	pvt->collect_avail = initial;
	pvt->expand_by = expand;
	return pvt;
}
//---------------------------------------------------------------------------
PVARTEXT VarTextCreateEx( DBG_VOIDPASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	VarTextInitEx( pvt DBG_RELAY );
	return pvt;
}
//---------------------------------------------------------------------------
void VarTextDestroyEx( PVARTEXT *ppvt DBG_PASS )
{
	if( ppvt && *ppvt )
	{
		VarTextEmptyEx( *ppvt DBG_RELAY );
		ReleaseEx( (*ppvt) DBG_RELAY );
		*ppvt = NULL;
	}
}
//---------------------------------------------------------------------------
void VarTextEmptyEx( PVARTEXT pvt DBG_PASS )
{
	if( pvt )
	{
		size_t expand = pvt->expand_by;
		LineReleaseEx( pvt->collect DBG_RELAY );
		LineReleaseEx( pvt->commit DBG_RELAY );
		MemSet( pvt, 0, sizeof( VARTEXT ) );
		pvt->expand_by = expand;
	}
}
//---------------------------------------------------------------------------
void VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( "Adding character %c", c );
#endif
	if( c == '\b' )
	{
		if( pvt->collect_used )
		{
			pvt->collect_used--;
			pvt->collect_text[pvt->collect_used] = 0;
		}
	}
	else
	{
		pvt->collect_text[pvt->collect_used++] = c;
		if( pvt->collect_used >= pvt->collect_avail )
		{
			//lprintf( "Expanding segment to make sure we have room to extend...(old %d)", pvt->collect->data.size );
			pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 DBG_RELAY );
			pvt->collect_avail = pvt->collect->data.size;
			pvt->collect_text = GetText( pvt->collect );
		}
	}
}
void VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS )
{
	int chars;
	int n;
	char output[6];
	chars = ConvertToUTF8Ex( output, c, overlong );
	for( n = 0; n < chars; n++ )
		VarTextAddCharacterEx( pvt, output[n] DBG_RELAY );
}
//---------------------------------------------------------------------------
void VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( "Adding character %c", c );
#endif
	{
		uint32_t n;
		for( n = 0; n < length; n++ )
		{
			if( !block[n] && ( length == VARTEXT_ADD_DATA_NULTERM ) )
				break;
			pvt->collect_text[pvt->collect_used++] = block[n];
			if( pvt->collect_used >= pvt->collect_avail )
			{
				//lprintf( "Expanding segment to make sure we have room to extend...(old %d)", pvt->collect->data.size );
				pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 + COLLECT_LEN DBG_RELAY );
				pvt->collect_avail = pvt->collect->data.size;
				pvt->collect_text = GetText( pvt->collect );
			}
		}
	}
}
//---------------------------------------------------------------------------
LOGICAL VarTextEndEx( PVARTEXT pvt DBG_PASS )
{
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		PTEXT segs= SegSplitEx( &pvt->collect, pvt->collect_used DBG_RELAY );
		//lprintf( "End collect at %d %d", pvt->collect_used, segs?segs->data.size:pvt->collect->data.size );
		if( !segs )
		{
			segs = pvt->collect;
		}
		//Log1( "Breaking collection adding... %s", GetText( segs ) );
		// so now the remaining buffer( if any )
		// is assigned to collect into.
		// This results in...
		pvt->collect = NEXTLINE( segs );
 // used all of the line...
		if( !pvt->collect )
		{
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( "Starting with new buffers " );
#endif
			VarTextInitEx( pvt DBG_RELAY );
		}
		else
		{
			 //Log1( "Remaining buffer is %d", GetTextSize( pvt->collect ) );
			SegBreak( pvt->collect );
			pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( "resetting collect_used after split" );
#endif
			pvt->collect_avail -= pvt->collect_used;
			pvt->collect_used = 0;
		}
		pvt->commit = SegAppend( pvt->commit, segs );
		return 1;
	}
	if( pvt && pvt->commit )
		return 1;
	return 0;
}
//---------------------------------------------------------------------------
PTEXT VarTextGetEx( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
	{
#ifdef VERBOSE_DEBUG_VARTEXT
		lprintf( DBG_FILELINEFMT "Get Text failed - no PVT." DBG_RELAY );
#endif
		return NULL;
	}
#ifdef VERBOSE_DEBUG_VARTEXT
	lprintf( DBG_FILELINEFMT "Grabbing the text from %p..." DBG_RELAY, pvt );
#endif
	if( VarTextEndEx( pvt DBG_RELAY ) )
	{
		PTEXT result = pvt->commit;
		pvt->commit = NULL;
		return result;
	}
	return NULL;
}
//---------------------------------------------------------------------------
 PTEXT  VarTextPeekEx ( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
		return NULL;
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		SetTextSize( pvt->collect, pvt->collect_used );
		//VarTextAddCharacterEx( pvt, 0 DBG_RELAY );
		return pvt->collect;
	}
	return NULL;
}
//---------------------------------------------------------------------------
void VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS)
{
	pvt->collect = SegExpandEx( pvt->collect, size DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_avail += size;
}
//---------------------------------------------------------------------------
INDEX VarTextLength( PVARTEXT pvt )
{
	//Log1( "Length is : %d", pvt->collect_used );
	if( pvt )
		return pvt->collect_used;
	return 0;
}
//---------------------------------------------------------------------------
INDEX vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args )
{
	INDEX len;
// this might be unicode...
#if ( defined( UNDER_CE ) || defined( _WIN32 ) ) && !defined( MINGW_SUX )
#  ifdef USE_UCRT
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
							, args
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
		va_end( tmp_args );
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#ifdef VERBOSE_DEBUG_VARTEXT
		Log3( "Print Length: %d into %d after %s", len, pvt->collect_used, pvt->collect_text );
#endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#  else
	int tries = 0;
	while( 1 )
	{
		size_t destlen;
		if( pvt->collect_text )
		{
			len = StringCbVPrintf ( pvt->collect_text + pvt->collect_used
									, ((destlen = pvt->collect_avail - pvt->collect_used) * sizeof( TEXTCHAR ))
									, format, args );
		}
		else
			len = STRSAFE_E_INSUFFICIENT_BUFFER;
		if( len == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			tries++;
			if( tries == 100 )
			{
				lprintf( "Single buffer expanded more then %d", tries * ( (pvt->expand_by)?pvt->expand_by:(16384+pvt->expand_by) ) );
 // didn't add any
				return 0;
			}
			VarTextExpand( pvt, (pvt->expand_by)?pvt->expand_by:(16384)  );
			continue;
		}
		len = StrLen( pvt->collect_text + pvt->collect_used );
		pvt->collect_used += len;
		break;
	}
	return len;
#  endif
#elif defined( __GNUC__ ) && !defined( _WIN32 )
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
#  ifdef __GNUC__
							, tmp_args
#  else
							, args
#  endif
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
#  ifdef __GNUC__
		va_end( tmp_args );
#  endif
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#  ifdef VERBOSE_DEBUG_VARTEXT
		Log3( "Print Length: %d into %d after %s", len, pvt->collect_used, pvt->collect_text );
#  endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#elif defined( __WATCOMC__ )
	{
		int destlen;
		va_list _args;
		_args[0] = args[0];
		do {
#  ifdef VERBOSE_DEBUG_VARTEXT
			Log2( "Print Length: ofs %d after %s"
				 , pvt->collect_used
				 , pvt->collect_text );
#  endif
			args[0] = _args[0];
			//va_start( args, format );
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, destlen = pvt->collect_avail - pvt->collect_used
								, format, args );
 // nothign to add... we'll get stuck looping if this is not checked.
			if( !len )
				return 0;
#  ifdef VERBOSE_DEBUG_VARTEXT
			lprintf( "result of vsnprintf: %d(%d) \'%s\' (%s)"
					 , len, destlen
					 , pvt->collect_text
					 , format );
#  endif
			if( len >= destlen )
			{
				// vsnwprintf() for NULL and 0 length returns -1
				// so, make length be something larger than -1, and keep expanding by that much.
				if( len == -1 )
					len = 256;
				VarTextExpand( pvt, len + pvt->expand_by );
			}
		} while( len >= destlen );
	}
#else
	// uhmm not sure what state this is then...
	{
		do {
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, pvt->collect_avail - pvt->collect_used
								, format, args );
			if( len < 0 )
				VarTextExpand( pvt, pvt->expand_by?pvt->expand_by:4096 );
			//					 VarTextExpandEx( pvt, 32 DBG_SRC );
		} while( len < 0 );
		//Log1( "Print Length: %d", len );
	}
#endif
#ifdef VERBOSE_DEBUG_VARTEXT
	Log2( "used: %d plus %d", pvt->collect_used , len );
#endif
	pvt->collect_used += len;
	return len;
}
//---------------------------------------------------------------------------
INDEX vtprintfEx( PVARTEXT pvt , CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vvtprintf( pvt, format, args );
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//
// PTEXT DumpText( PTEXT somestring )
//	 PTExT (single data segment with full description \r in text)
//
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static CTEXTSTR Ops[] = {
	"FORMAT_OP_CLEAR_END_OF_LINE",
	"FORMAT_OP_CLEAR_START_OF_LINE",
	"FORMAT_OP_CLEAR_LINE ",
	"FORMAT_OP_CLEAR_END_OF_PAGE",
	"FORMAT_OP_CLEAR_START_OF_PAGE",
	"FORMAT_OP_CLEAR_PAGE",
	"FORMAT_OP_CONCEAL"
 // background is how many to delete.
	  , "FORMAT_OP_DELETE_CHARS"
 // format.x, y are start/end of region -1,-1 clears.
	  , "FORMAT_OP_SET_SCROLL_REGION"
 // this works as a transaction...
	  , "FORMAT_OP_GET_CURSOR"
 // responce to getcursor...
	  , "FORMAT_OP_SET_CURSOR"
 // clear page, home page... result in page break...
	  , "FORMAT_OP_PAGE_BREAK"
 // break between paragraphs - kinda same as lines...
	  , "FORMAT_OP_PARAGRAPH_BREAK"
};
//---------------------------------------------------------------------------
static void BuildTextFlags( PVARTEXT vt, PTEXT pSeg )
{
	vtprintf( vt, "Text Flags: ");
	if( pSeg->flags & TF_STATIC )
		vtprintf( vt, "static " );
	if( pSeg->flags & TF_QUOTE )
		vtprintf( vt, "\"\" " );
	if( pSeg->flags & TF_SQUOTE )
		vtprintf( vt, "\'\' " );
	if( pSeg->flags & TF_BRACKET )
		vtprintf( vt, "[] " );
	if( pSeg->flags & TF_BRACE )
		vtprintf( vt, "{} " );
	if( pSeg->flags & TF_PAREN )
		vtprintf( vt, "() " );
	if( pSeg->flags & TF_TAG )
		vtprintf( vt, "<> " );
	if( pSeg->flags & TF_INDIRECT )
		vtprintf( vt, "Indirect " );
	/*
	if( pSeg->flags & TF_SINGLE )
	vtprintf( vt, "single " );
	*/
	if( pSeg->flags & TF_FORMATREL )
		vtprintf( vt, "format x,y(REL) " );
	if( pSeg->flags & TF_FORMATABS )
		vtprintf( vt, "format x,y " );
	else
		vtprintf( vt, "format spaces " );
	if( pSeg->flags & TF_COMPLETE )
		vtprintf( vt, "complete " );
	if( pSeg->flags & TF_BINARY )
		vtprintf( vt, "binary " );
	if( pSeg->flags & TF_DEEP )
		vtprintf( vt, "deep " );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_ENTITY )
		vtprintf( vt, "entity " );
	if( pSeg->flags & TF_SENTIENT )
		vtprintf( vt, "sentient " );
#endif
	if( pSeg->flags & TF_NORETURN )
		vtprintf( vt, "NoReturn " );
	if( pSeg->flags & TF_LOWER )
		vtprintf( vt, "Lower " );
	if( pSeg->flags & TF_UPPER )
		vtprintf( vt, "Upper " );
	if( pSeg->flags & TF_EQUAL )
		vtprintf( vt, "Equal " );
	if( pSeg->flags & TF_TEMP )
		vtprintf( vt, "Temp " );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_PROMPT )
		vtprintf( vt, "Prompt " );
	if( pSeg->flags & TF_PLUGIN )
		vtprintf( vt, "Plugin=%02x ", (uint8_t)(( pSeg->flags >> 26 ) & 0x3f ) );
#endif
	if( (pSeg->flags & TF_FORMATABS ) )
		vtprintf( vt, "Pos:%d,%d "
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else if( (pSeg->flags & TF_FORMATREL ) )
		vtprintf( vt, "Rel:%d,%d "
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else
		vtprintf( vt, "%d tabs %d spaces"
				  , pSeg->format.position.offset.tabs
				  , pSeg->format.position.offset.spaces
				  );
	if( pSeg->flags & TF_FORMATEX )
		vtprintf( vt, "format extended(%s) length:%d"
					  , Ops[ pSeg->format.flags.format_op
							 - FORMAT_OP_CLEAR_END_OF_LINE ]
					  , GetTextSize( pSeg ) );
	else
		vtprintf( vt, "Fore:%d Back:%d length:%d"
					, pSeg->format.flags.foreground
					, pSeg->format.flags.background
					, GetTextSize( pSeg ) );
}
PTEXT DumpText( PTEXT text )
{
	if( text )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT textsave = text;
		while( text )
		{
			BuildTextFlags( pvt, text );
			vtprintf( pvt, "\n->%s\n", GetText( text ) );
			text = NEXTLINE( text );
		}
		textsave = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		return textsave;
	}
	return NULL;
}
//---------------------------------------------------------------------------
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertAsciiEbdic( TEXTSTR text, INDEX length )
{
	static unsigned char a2e[256] = {
		0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 37, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
		64, 79,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
		240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
		124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
		215,216,217,226,227,228,229,230,231,232,233, 74,224, 90, 95,109,
		121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
		151,152,153,162,163,164,165,166,167,168,169,192,106,208,161,  7,
		32, 33, 34, 35, 36, 21,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
		48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,225,
		65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
		88, 89, 98, 99,100,101,102,103,104,105,112,113,114,115,116,117,
		118,119,120,128,138,139,140,141,142,143,144,154,155,156,157,158,
		159,160,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
		184,185,186,187,188,189,190,191,202,203,204,205,206,207,218,219,
		220,221,222,223,234,235,236,237,238,239,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = a2e[(unsigned)text[n]];
		}
	}
	return text;
}
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertEbcdicAscii( TEXTSTR text, INDEX length )
{
	static unsigned char e2a[256] = {
		0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
		16, 17, 18, 19,157,133,  8,135, 24, 25,146,143, 28, 29, 30, 31,
		128,129,130,131,132, 10, 23, 27,136,137,138,139,140,  5,  6,  7,
		144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
		32,160,161,162,163,164,165,166,167,168, 91, 46, 60, 40, 43, 33,
		38,169,170,171,172,173,174,175,176,177, 93, 36, 42, 41, 59, 94,
		45, 47,178,179,180,181,182,183,184,185,124, 44, 37, 95, 62, 63,
		186,187,188,189,190,191,192,193,194, 96, 58, 35, 64, 39, 61, 34,
		195, 97, 98, 99,100,101,102,103,104,105,196,197,198,199,200,201,
		202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
		209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
		216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
		123, 65, 66, 67, 68, 69, 70, 71, 72, 73,232,233,234,235,236,237,
		125, 74, 75, 76, 77, 78, 79, 80, 81, 82,238,239,240,241,242,243,
		92,159, 83, 84, 85, 86, 87, 88, 89, 90,244,245,246,247,248,249,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = e2a[(unsigned)text[n]];
		}
	}
	return text;
}
//---------------------------------------------------------------------------
#define NUM_RESERVED (sizeof(reserved_uri)/sizeof(reserved_uri[0]))
static TEXTCHAR reserved_uri[] = {'!','*','\'','(',')',';',':','@','&','=','+','$',',','/','?','#','[',']'
												  ,'<','>','~','.','"','{','}','|','\\','-','`','_','^','%',' '
												  , 0 };
static const TEXTCHAR *translated[] = { "%21","%2A","%27","%28","%29","%3B","%3A"
												,"%40","%26","%3D","%2B","%24","%2C","%2F"
												 ,"%3F","%23","%5B","%5D"
												 ,"%3C","%3E","%7E","%2E","%22","%7B","%7D","%7C","%5C","%2D","%60","%5F","%5E","%25","%20"
};
static int MeasureTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
			out_length++;
		else if( StrChr( reserved_uri, text[i] ) )
			out_length += 3;
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	int target_len = MeasureTextURI( text, length, skip_slash );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	const TEXTCHAR *char_pos;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
		{
			out_pos[0] = text[i];
			out_pos++;
		}
		else if( ( char_pos = StrChr( reserved_uri, text[i] ) ) )
		{
#ifdef __cplusplus
			sack::memory::
#endif
			StrCpyEx( out_pos, translated[char_pos - reserved_uri], target_len - ( out_pos - target ) );
			out_pos += 3;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	return target;
}
static int MeasureURIText( CTEXTSTR text, INDEX length )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			i += 2;
			out_length++;
		}
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertURIText( CTEXTSTR text, INDEX length )
{
	int target_len = MeasureURIText( text, length );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			char char_byte;
			// A 41
			// a 61
			// 0 30
			char_byte = (((text[i+1] & 10)?(text[i+1]-0x30)
							  : (text[i+1] & 20)?(text[i+1]-'a'+10)
							  : (text[i+1]-'A'+10)) << 4 )
				| (((text[i+2] & 10)?(text[i+2]-0x30)
					 : (text[i+2] & 20)?(text[i+2]-'a'+10)
					 : (text[i+2]-'A'+10)) );
			out_pos[0] = char_byte;
			out_pos++;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	//out_pos++;
	return target;
}
//---------------------------------------------------------------------------
int ConvertToUTF16( wchar_t *output, TEXTRUNE rune )
{
	if( !( rune & 0xFFFF0000 ) )
	{
		if( rune < 0xD800 || rune >= 0xE000 )
		{
			output[0] = (wchar_t)rune;
			return 1;
		}
		else
 // invalid rune specified.
			return 0;
	}
	else
	{
		rune -= 0x10000;
		if( !( rune & 0xFFFFF ) )
		{
			output[0] = 0xD800 + (wchar_t)( ( rune & 0xFFC00 ) >> 10 );
			output[1] = 0xDC00 + (wchar_t)( ( rune & 0x003FF ) );
			return 2;
		}
	}
 // invalid rune.
	return 0;
}
int ConvertToUTF8( char *output, TEXTRUNE rune )
{
	int ch = 1;
	if( !( rune & 0xFFFFFF80 ) )
	{
		// 7 bits
		(*output++) = (char)rune;
		goto plus0;
	}
	else if( !( rune & 0xFFFFF800 ) )
	{
		// 11 bits
		(*output++) = 0xC0 | ( ( ( rune & 0x07C0 ) >> 6 ) & 0xFF );
		goto plus1;
	}
	else if( !( rune & 0xFFFF0000 ) )
	{
		// 16 bits
		(*output++) = 0xE0 | ( ( ( rune & 0xF000 ) >> 12 ) & 0xFF );
		goto plus2;
	}
	else if( !( rune & 0xFFE00000 ) )
	{
		// 21 bits
		(*output++) = 0xF0 | ( ( ( rune & 0x1C0000 ) >> 18 ) & 0xFF );
		goto plus3;
	}
	else if( !( rune & 0xFC000000 ) )
	{
		// 26 bits
		(*output++) = 0xF8 | ( ( ( rune & 0x3000000 ) >> 24 ) & 0xFF );
		goto plus4;
	}
	else if( !( rune & 0x80000000 ) )
	{
		// 31 bits
		(*output++) = 0xFC | ( ( ( rune & 0x40000000 ) >> 30 ) & 0xFF );
		//goto plus5;
	}
	// invalid rune (out of range)
//plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
plus0:
	return ch;
}
int ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong )
{
	int ch = 1;
	if( !overlong ) return ConvertToUTF8( output, rune );
	if( !(rune & 0xFFFFFF80) )
	{
		// 11 bits
		(*output++) = 0xC0 | (((rune & 0x07C0) >> 6) & 0xFF);
		goto plus1;
	}
	else if( !(rune & 0xFFFFF800) )
	{
		// 16 bits
		(*output++) = 0xE0 | (((rune & 0xF000) >> 12) & 0xFF);
		goto plus2;
	}
	else if( !(rune & 0xFFFF0000) )
	{
		// 21 bits
		(*output++) = 0xF0 | (((rune & 0x1C0000) >> 18) & 0xFF);
		goto plus3;
	}
	else if( !(rune & 0xFFE00000) )
	{
		// 26 bits
		(*output++) = 0xF8 | (((rune & 0x3000000) >> 24) & 0xFF);
		goto plus4;
	}
	else if( !(rune & 0xFC000000) )
	{
		// 31 bits
		(*output++) = 0xFC | (((rune & 0x40000000) >> 30) & 0xFF);
		goto plus5;
	}
	else if( !(rune & 0x80000000) ) {
		(*output++) = 0xFEU;
	}
	ch++; (*output++) = 0x80 | (((rune & 0xC0000000) >> 30) & 0xFF);
plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
//plus0:
	return ch;
}
char * WcharConvert_v2 ( const wchar_t *wch, size_t len, size_t *outlen DBG_PASS )
{
	// Conversion to char* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInBytes;
	char  tmp[2];
	char	 *ch;
	char	 *_ch;
	const wchar_t *_wch = wch;
 // start with 1 for the ending nul
	sizeInBytes = 1;
	_ch = ch = tmp;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "wch = %04x", wch[0] );
			if( !( wch[0] & 0xFF80 ) )
			{
				//lprintf( "1 byte encode..." );
				sizeInBytes++;
			}
			else if( !( wch[0] & 0xF800 ) )
			{
				//lprintf( "2 byte encode..." );
				sizeInBytes += 2;
			}
			else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
					   && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
					 && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
					   && ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
			{
				int longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
				//lprintf( "3 or 4 byte encode..." );
				if( !(longer_value & 0xFFFF0000 ) )
					sizeInBytes += 3;
 // hack a way to encode D800-DFFF
				else if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					sizeInBytes += 2;
				else
					sizeInBytes += 4;
				wch++;
			}
			else
			{
				// just encode the 16 bits as it is.
				//lprintf( " 3 byte encode?" );
				sizeInBytes+= 3;
			}
			wch++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( char, sizeInBytes);
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			{
				if( !( wch[0] & 0xFF80 ) )
				{
					(*ch++) = ((unsigned char*)wch)[0];
				}
				else if( !( wch[0] & 0xFF00 ) )
				{
					//(*ch++) = ((unsigned char*)wch)[0];
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( !( wch[0] & 0xF800 ) )
				{
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
							 && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
						  && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
								&& ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
				{
					uint32_t longer_value;
					longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
 // hack a way to encode D800-DFFF
					if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					{
						longer_value = ( longer_value - 0xF0000 ) + 0xD800;
						sizeInBytes += 2;
					}
					wch++;
					if( !(longer_value & 0xFFFF ) )
					{
						// 16 bit encoding (shouldn't be hit
						(*ch++) = 0xE0 | (char)( ( longer_value >> 12 ) & 0x0F );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					else if( !( longer_value & 0xFFE00000 ) )
					{
						// 21 bit encoding ...
						(*ch++) = 0xF0 | (char)( ( longer_value >> 18 ) & 0x07 );
						(*ch++) = 0x80 | (char)( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					/*  ** functionally removed from spec ..... surrogates cannot be this long.
					else if( !( longer_value & 0xFC000000 ) )
					{
						(*ch++) = 0xF8 | ( longer_value >> 24 );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					else  if( !( longer_value & 0x80000000 ) )
					{
						// 31 bit encode
						(*ch++) = 0xFC | ( longer_value >> 30 );
						(*ch++) = 0x80 | ( ( longer_value >> 24 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					*/
					else
					{
						// too long to encode.
					}
				}
				else
				{
					   //lprintf( " 3 byte encode?  16 bits" );
 // mask just in case of stupid compiles that tread wchar as signed?
						(*ch++) = 0xE0 | ( ( wch[0] >> 12 ) & 0x0F );
						(*ch++) = 0x80 | ( ( wch[0] >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( wch[0] >> 0 ) & 0x3f );
				}
			}
			wch++;
		}
	}
	(*ch) = 0;
	if( outlen ) outlen[0] = ch - _ch;
	ch = _ch;
	return ch;
}
char * WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS )
{
	size_t outlen;
	return WcharConvert_v2( wch, len, &outlen DBG_RELAY );
}
char * WcharConvertEx ( const wchar_t *wch DBG_PASS )
{
	size_t len;
	for( len = 0; wch[len]; len++ );
	return WcharConvertExx( wch, len DBG_RELAY );
}
wchar_t * CharWConvertExx ( const char *wch, size_t len DBG_PASS )
{
	// Conversion to wchar_t* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInChars;
	const char *_wch;
	wchar_t	*ch;
	wchar_t   *_ch;
	if( !wch ) return NULL;
	sizeInChars = 0;
	_wch = wch;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( (wch[0] & 0xE0) == 0xC0 )
				wch += 2;
			else if( (wch[0] & 0xF0) == 0xE0 )
				wch += 3;
			else if( (wch[0] & 0xF0) == 0xF0 )
			{
				sizeInChars++;
				wch += 4;
			}
			else
				wch++;
			sizeInChars++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( wchar_t, sizeInChars + 1 );
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( ( wch[0] & 0xE0 ) == 0xC0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0x1F ) << 6 ) | ( (wchar_t)wch[1] & 0x3f );
				wch += 2;
			}
			else if( ( wch[0] & 0xF0 ) == 0xE0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0xF ) << 12 )
					| ( ( (wchar_t)wch[1] & 0x3F ) << 6 )
					| ( (wchar_t)wch[2] & 0x3f );
				wch += 3;
			}
			else if( ( wch[0] & 0xF0 ) == 0xF0 )
			{
				uint32_t literal_char =  ( ( (wchar_t)wch[0] & 0x7 ) << 18 )
				                 | ( ( (wchar_t)wch[1] & 0x3F ) << 12 )
				                 | ( (wchar_t)wch[2] & 0x3f ) << 6
				                 | ( (wchar_t)wch[3] & 0x3f );
				//lprintf( "literal char is %d (%08x", literal_char, literal_char );
// ((wchar_t*)&literal_char)[0];
				ch[0] = 0xD800 + ( ( ( literal_char - 0x10000 ) & 0xFFC00 ) >> 10 );
// ((wchar_t*)&literal_char)[1];
				ch[1] = 0xDC00 + ( ( literal_char - 0x10000 ) & 0x3ff );
				ch++;
				wch += 4;
			}
			else
			{
				ch[0] = wch[0] & 0x7f;
				wch++;
			}
			ch++;
		}
		ch[0] = 0;
	}
	return _ch;
}
wchar_t * CharWConvertEx ( const char *ch DBG_PASS )
{
	int len;
	if( !ch ) return NULL;
	for( len = 0; ch[len]; len++ );
	return CharWConvertExx( ch, len DBG_RELAY );
}
LOGICAL ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseStringVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (POINTER)(*pData) );
		}
		(*pData) = NewArray( CTEXTSTR, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			size_t len;
			start = end;
			end = StrChr( start, ',' );
			if( end )
			{
				end++;
				(*pData)[count] = NewArray( TEXTCHAR, len = end - start );
			}
			else
			{
				(*pData)[count] = NewArray( TEXTCHAR, len = StrLen( start ) + 1 );
			}
			StrCpyEx( (TEXTSTR)(*pData)[count], start, len );
			count++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfChar( const char * *from )
{
	TEXTRUNE result = (unsigned char)(*from)[0];
	//if( !result ) return result;
	if( (*from)[0] & 0x80 )
	{
		if( ( (*from)[0] & 0xE0 ) == 0xC0 )
		{
			if( ( (*from)[1] & 0xC0 ) == 0x80 )
			{
				result = ( ( (unsigned int)(*from)[0] & 0x1F ) << 6 ) | ( (unsigned int)(*from)[1] & 0x3f );
				(*from) += 2;
			}
			else
			{
				result = 0;
				//lprintf( "a 2 byte code with improper continuation encodings following it was found. %02x %02x"
				//		, (*from)[0]
				//		, (*from)[1]
				//		);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF0 ) == 0xE0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 ) )
			{
				result = ( ( (unsigned int)(*from)[0] & 0xF ) << 12 ) | ( ( (unsigned int)(*from)[1] & 0x3F ) << 6 ) | ( (unsigned int)(*from)[2] & 0x3f );
				(*from) += 3;
			}
			else
			{
				result = 0;
				//lprintf( "a 3 byte code with improper continuation encodings following it was found. %02x %02x %02x"
				//	, (*from)[0]
				//	, (*from)[1]
				//	, (*from)[2]
				//	);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF8 ) == 0xF0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 ) && ( ( (*from)[2] & 0xC0 ) == 0x80 ) && ( ( (*from)[3] & 0xC0 ) == 0x80 ) )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x7 ) << 18 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[2] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[3] & 0x3f );
				(*from) += 4;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFC ) == 0xF8 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x3 ) << 24 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[3] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[4] & 0x3f );
				(*from) += 5;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFE ) == 0xFC )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[5] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x1 ) << 30 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 24 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[3] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[4] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[5] & 0x3f );
				(*from) += 6;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xC0 ) == 0x80 )
		{
			// things like 0x9F, 0x9A is OK; is a single byte character, is a unicode application escape
			//lprintf( "a continuation encoding was found." );
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
		else
		{
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
	}
	else
	{
		result = (unsigned char)(*from)[0];
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexed( const char * pc, size_t *n, size_t length )
{
	if( length )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetUtfChar( &tmp );
		if( (size_t)( tmp - orig ) <= length ) {
			n[0] += tmp - orig;
			return result;
		}
		// if illformed character was at the end... return 0
	   // cap result to length.
		( *n ) = length;
	}
	return 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfChar( const char *start, const char * *from )
{
	TEXTRUNE result;
	if( (*from) == start ) return 0;
	result = (unsigned char)(*from)[-1];
	if( !result ) return result;
	if( (*from)[-1] & 0x80 )
	{
		CTEXTSTR end;
		while( (*from > start) && ( (*from)[-1] & 0xC0 ) == 0x80 )
			(*from)--;
		if( (*from > start) ) {
			(*from)--;
			end = (*from);
			result = GetUtfChar( from );
			(*from) = end;
		}
		else
			result = 0;
	}
	else
	{
		result = (unsigned char)(*from)[-1];
		(*from)--;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexed( const char *pc, size_t *n )
{
	if( *n )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetPriorUtfChar( pc, &tmp );
		if( tmp <= orig ) {
			n[0] -= orig - tmp;
			return result;
		}
	}
	return RUNE_BEFORE_START;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfCharW( const wchar_t * *from )
{
	TEXTRUNE result = (unsigned)(*from)[0];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[1] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexedW( const wchar_t* pc, size_t *n )
{
	const wchar_t * orig = pc + n[0];
	const wchar_t * tmp = orig;
	TEXTRUNE result = GetUtfCharW( &tmp );
	n[0] += tmp - orig;
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharW( const wchar_t*start, const wchar_t* *from )
{
	TEXTRUNE result = (unsigned)(*from)[-1];
	if( !result ) return result;
	if( ( ( (*from)[-2] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[-1] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[-2] & 0x3ff ) << 10 ) | ( ( (*from)[-1] & 0x3ff ) ) );
		(*from) -= 2;
	}
	else
	{
		(*from)--;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexedW( const wchar_t *pc, size_t *n )
{
	if( *n )
	{
		const wchar_t * orig = pc + n[0];
		const wchar_t * tmp = orig;
		TEXTRUNE result = GetPriorUtfCharW( pc, &tmp );
		n[0] += tmp - orig;
		return result;
	}
	return 0;
}
//---------------------------------------------------------------------------
// Return the integer character from the string
// using utf-8 or utf-16 decoding appropriately.  No more extended-ascii.
static int Step( CTEXTSTR *pc, size_t *nLen )
{
	CTEXTSTR _pc = (*pc);
	int ch;
	//lprintf( "Step (%s[%*.*s])", (*pc), nLen,nLen, (*pc) );
	if( nLen && !*nLen )
		return 0;
	ch = GetUtfChar( pc );
	//if( ch & 0xFFE00000 )
	//	DebugBreak();
	if( nLen )
		(*nLen) -= (*pc) - _pc;
	_pc = (*pc);
	if( ch )
	{
		while( ch == '\x9F' )
		{
			while( ch && ( ch != '\x9C' ) )
			{
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
			// if the string ended...
			if( !ch )
			{
				// this is done.  There's nothing left... command with no data is bad form, but not illegal.
				return FALSE;
			}
  // pc is now on the stop command, advance one....
			else
			{
				// this is in a loop, and the next character may be another command....
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
		}
	}
	return ch;
}
size_t GetDisplayableCharacterBytes( CTEXTSTR string, size_t character_count )
{
	CTEXTSTR original = string;
	int ch;
	if( !string ) return 0;
	while( character_count &&
		( ch = Step( &string, NULL ) ) )
	{
		character_count--;
	}
	return string - original;
}
size_t GetDisplayableCharacterCount( CTEXTSTR string, size_t max_bytes )
{
	int ch;
	size_t count = 0;
	if( !string ) return 0;
	while( ( ch = Step( &string, &max_bytes ) ) )
	{
		count++;
	}
	return count;
}
CTEXTSTR GetDisplayableCharactersAtCount( CTEXTSTR string, size_t nLen )
{
	int ch;
	if( !string ) return 0;
	while( nLen > 0 &&
		 ( ch = Step( &string, NULL ) ) )
	{
		nLen--;
	}
	return string;
}
LOGICAL ParseIntVector( CTEXTSTR data, int **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseIntVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (*pData) );
		}
		(*pData) = NewArray( int, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			start = end;
			(void)sscanf( start, "%d", (*pData) + count );
			count++;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
const char encodings[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_";
const char encodings2[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static TEXTCHAR b64xor_table[256][256];
static TEXTCHAR u8xor_table[256][256];
static TEXTCHAR b64xor_table2[256][256];
static TEXTCHAR u8xor_table2[256][256];
PRELOAD( initTables ) {
	size_t n, m;
	for( n = 0; n < (sizeof( encodings )-1); n++ )
		for( m = 0; m < (sizeof( encodings )-1); m++ ) {
			b64xor_table[(uint8_t)encodings[n]][(uint8_t)encodings[m]] = encodings[n^m];
			u8xor_table[n][(uint8_t)encodings[m]] = (TEXTCHAR)(n^m);
			b64xor_table2[(uint8_t)encodings2[n]][(uint8_t)encodings2[m]] = encodings2[n^m];
			u8xor_table2[n][(uint8_t)encodings2[m]] = (TEXTCHAR)(n^m);
	}
	//LogBinary( (uint8_t*)u8xor_table[0], sizeof( u8xor_table ) );
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wchar-subscripts"
	b64xor_table['=']['='] = '=';
#pragma clang diagnostic pop
}
char * b64xor( const char *a, const char *b ) {
	int n;
	char *out = NewArray( char, strlen(a) + 1);
	for( n = 0; a[n]; n++ ) {
		out[n] = b64xor_table[(uint8_t)a[n]][(uint8_t)b[n]];
	}
	out[n] = 0;
	return out;
}
char * u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs ) {
	size_t n;
	size_t keylen = blen-5;
	int o = ofs[0];
	size_t outlen;
	char *out = NewArray( char, (outlen=alen) + 1);
	char *_out = out;
	int l = 0;
	int _mask = 0x3f;
	for( n = 0; n < alen; n++ ) {
		char v = (*a++);
		int mask;
		mask = _mask;
		if( (v & 0x80) == 0x00 ) { if( l ) lprintf( "short utf8 sequence found" ); mask = 0x3f; _mask = 0x3f; }
		else if( (v & 0xC0) == 0x80 ) { if( !l ) lprintf( "invalid utf8 sequence" ); l--; _mask = 0x3f; }
		else if( (v & 0xE0) == 0xC0 ) { if( l )
  // 6 + 1 == 7 //-V640
			lprintf( "short utf8 sequence found" ); l = 1; mask = 0x1; _mask = 0x3f; }
		else if( (v & 0xF0) == 0xE0 ) { if( l )
  // 6 + 5 + 0 == 11 //-V640
			lprintf( "short utf8 sequence found" ); l = 2; mask = 0;  _mask = 0x1f; }
		else if( (v & 0xF8) == 0xF0 ) { if( l )
  // 6(2) + 4 + 0 == 16 //-V640
			lprintf( "short utf8 sequence found" ); l = 3; mask = 0;  _mask = 0x0f; }
		else if( (v & 0xFC) == 0xF8 ) { if( l )
  // 6(3) + 3 + 0 == 21 //-V640
			lprintf( "short utf8 sequence found" ); l = 4; mask = 0;  _mask = 0x07; }
		else if( (v & 0xFE) == 0xFC ) { if( l )
  // 6(4) + 2 + 0 == 26 //-V640
			lprintf( "short utf8 sequence found" ); l = 5; mask = 0;  _mask = 0x03; }
		// B is a base64 key; it would never be > 128 so char index is OK.
		char bchar = b[(n+o)%(keylen)]&0x7f;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wchar-subscripts"
		(*out) = (v & ~mask ) | ( u8xor_table[v & mask ][bchar] & mask );
#pragma clang diagnostic pop
		out++;
	}
	(*out) = 0;
	ofs[0] = (int)((ofs[0]+outlen)%keylen);
	return _out;
}
static const char * const _base642 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_=";
static const char * const _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static const char * _last_base64_set;
static char _base64_r[256];
static void encodeblock( unsigned char in[3], TEXTCHAR out[4], size_t len, const char *base64 )
{
	out[0] = base64[ in[0] >> 2 ];
	out[1] = base64[ ((in[0] & 0x03) << 4) | ( ( len > 0 ) ? ((in[1] & 0xf0) >> 4) : 0 ) ];
	out[2] = (len > 1 ? base64[ ((in[1] & 0x0f) << 2) | ( ( len > 2 ) ? ((in[2] & 0xc0) >> 6) : 0 ) ] : base64[64]);
	out[3] = (len > 2 ? base64[ in[2] & 0x3f ] : base64[64]);
}
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wchar-subscripts"
static void decodeblock( const char in[4], uint8_t out[3], size_t len, const char *base64 )
{
	int index[4];
	size_t n;
	for( n = 0; n < len; n++ )
	{
		// propagate terminator.
		if( n && ( index[n - 1] == 64 ) ) index[n] = 0;
		else index[n] = _base64_r[in[n]];
	}
	for( ; n < 4; n++ )
		index[n] = 0;
	out[0] = (char)(( index[0] ) << 2 | ( index[1] ) >> 4);
	out[1] = (char)(( index[1] ) << 4 | ( ( ( index[2] ) >> 2 ) & 0x0f ));
	out[2] = (char)(( index[2] ) << 6 | ( ( index[3] ) & 0x3F ));
	//out[] = (len > 2 ? base64[ in[2] & 0x3f ] : 0);
}
#pragma clang diagnostic pop
TEXTCHAR *EncodeBase64Ex( const uint8_t* buf, size_t length, size_t *outsize, const char *base64 )
{
	size_t fake_outsize;
	TEXTCHAR * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	real_output = NewArray( TEXTCHAR, 1 + ( ( length * 4 + 2) / 3 ) + 1 + 1 + 1 );
	{
		size_t n;
		for( n = 0; n < (length+2)/3; n++ )
		{
			size_t blocklen;
			blocklen = length - n*3;
			if( blocklen > 3 )
				blocklen = 3;
			encodeblock( ((uint8_t*)buf) + n * 3, real_output + n*4, blocklen, base64 );
		}
 // don't include the NUL.
		(*outsize) = n*4;
		real_output[n*4] = 0;
	}
	return real_output;
}
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wchar-subscripts"
static void setupDecodeBytes( const char *code ) {
	int n = 0;
	// default all of these, allow code to override them.
	if( _last_base64_set != code ) {
		_last_base64_set = code;
		memset( _base64_r, 0, 256 );
                // allow nul terminators (sortof)
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r[0] = 64;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['~'] = 64;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['='] = 64;
                // My JS Encoding $_ and = at the end.  allows most to be identifiers too.
                // 'standard' encoding +/
                // variants -/
                //          +,
                //          ._
                // variants -_
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['$'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['+'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['-'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['.'] = 62;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['_'] = 63;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r['/'] = 63;
 // = ix 64 (0x40) and mask is & 0x3F dropping the upper bit.
                _base64_r[','] = 63;
                while( *code ) {
                    _base64_r[*code] = n++;
                    code++;
                }
        }
}
#pragma clang diagnostic pop
uint8_t *DecodeBase64Ex( const char* buf, size_t length, size_t *outsize, const char *base64 )
{
	static const char *useBase64;
	size_t fake_outsize;
	uint8_t * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	if( useBase64 != base64 ) {
		useBase64 = base64;
		setupDecodeBytes( base64 );
	}
	real_output = NewArray( uint8_t, ( ( ( length + 1 ) * 3 ) / 4 ) + 1 );
	{
		size_t n;
		for( n = 0; n < (length+3)/4; n++ )
		{
			size_t blocklen;
			blocklen = length - n*4;
			if( blocklen > 4 )
				blocklen = 4;
			decodeblock( buf + n * 4, real_output + n*3, blocklen, base64 );
		}
		if( length % 4 == 1 )
			(*outsize) = (((length + 3) / 4) * 3) - 3;
		else if( length % 4 == 2 )
			(*outsize) = (((length + 3) / 4) * 3) - 2;
		else if( length % 4 == 3 )
			(*outsize) = (((length + 3) / 4) * 3) - 1;
		else if( buf[length - 1] == '=' ) {
			if( buf[length - 2] == '=' ) {
				(*outsize) = (((length + 3) / 4) * 3) - 2;
			}
			else
				(*outsize) = (((length + 3) / 4) * 3) - 1;
		}
		else
			(*outsize) = (((length + 3) / 4) * 3);
		real_output[(*outsize)] = 0;
	}
	return real_output;
}
#ifdef __cplusplus
 //namespace text {
}
 //namespace containers {
}
 // namespace sack {
}
#endif
#ifdef _MSC_VER
#  pragma warning( default:6011 26451 28182)
#  pragma warning( default:26451 )
#endif
/*
 *
 *   Crafted by Jim Buckeyne
 *    Purpose: Provide slab allocated set objects
 *      things like points, lines, etc, are cheaper to store
 *      in sets of 128, 256, instead of one at a time, since the
 *      allocation tracking block is larger than the object itself.
 *      Secondarily, this can result in compact, indexable, arrays
 *      for saving data - these resemble a PDATALIST
 *
 *  (c)1999-2006++ Freedom Collective
 */
/* SQL Option Interface. Gets and sets options; option interface
   resembles legacy windows INI interface.                       */
#ifndef SQL_OPTIONS_DEFINED
#define SQL_OPTIONS_DEFINED
/* more documentation at end */
/*
 *
 *   Creator: Panther   #implemented in Dekware
 *   Modified by: Jim Buckeyne #ported to service SQL via proxy.
 *   Returned to sack by: Jim Buckeyne
 *                  # stripped application specific
 *                  # features, returned to SACK.
 *
 *  Provides a simple, intuitive interface to SQL.  Used sensibly,
 *  provides garbage collection of resources.
 *
 *  Commands without an ODBC specifier are the perferred method to
 *  use this interface.  This allows the internal system to maintain
 *  a primary and a redundant backup connection to provide transparent
 *  reliability to the application.
 *
 *  Provides some slick table creation routines
 *     - check for existance, and drop  (CTO_DROP)
 *     - check for existance, and match (CTO_MATCH)
 *     - check for existance, and merge (CTO_MERGE)
 *     - create table if not exist.
 *
 *  Latest additions provide ...RecordQuery... functions which
 *  result with a const CTEXTSTR * of results;  (ie, result[0] = (CTEXTSTR)result1 )
 *  also available are the column names from the query.
 *  I strongly recommend passing NULL always to the field names, and
 *  using sensible enumerators that follow the query definition.
 *
 *  (c)Freedom Collective (Jim Buckeyne 2000-2016)
 *
 */
#ifndef PSSQL_STUB_DEFINED
/* multiple inclusion protection symbol */
#define PSSQL_STUB_DEFINED
#if defined( SQLSTUB_SOURCE ) || defined( SQLPROXY_LIBRARY_SOURCE )
#define PSSQL_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Macro declaring PSSQL procs. */
#define PSSQL_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _SQL_NAMESPACE   namespace sql {
#define _SQL_NAMESPACE_END   }
#define SQL_NAMESPACE   namespace sack { namespace sql {
#define SQL_NAMESPACE_END } }
#else
#define _SQL_NAMESPACE
#define _SQL_NAMESPACE_END
/* Marks the beginning of SQL Namespace. */
#define SQL_NAMESPACE
/* Marks the end of SQL Namespace. */
#define SQL_NAMESPACE_END
#endif
#ifdef __cplusplus
namespace sack {
#endif
/* SQL access library. This provides a simple access to ODBC
   connections, and to sqlite. If no database is specified,
   there is an internal database that can be used. These methods
   on the PODBC connection are NOT thread safe. Multiple threads
   shall never use the same PODBC; they can use seperate PODBC
   connections. Under linux this links to unixODBC.
   DoSQLCommandf
   DoSQLRecordQueryf
   GetSQLRecord
   ConnectToDatabase
   DoSQLCommandf
   DoSQLRecordQueryf
   FetchSQLRecord
   There is a configuration file for the default SQL connection,
   this is kept in a file 'sql.config' which is processed with
   ProcessConfigurationFile(); If this file does not exist, it
   will be automatically created with default values.
   (Need to describe this sql.config file)                       */
#ifdef __cplusplus
    namespace sql {
#endif
/* <combine PSSQL_PROC>
   \ \                    */
#define SQLPROXY_PROC PSSQL_PROC
/* This is the connection object that provides interface to the
   database. Can be NULL to specify the default connection
   interface. See namespace <link sack::sql, sql>.
   An ODBC connection handles commands as a stack. Each command
   is done as a temporary entry on the stack. A query is done as
   an entry on the stack, but the entry remains on the stack
   until the final result is retrieved or an early PopODBC is
   called.
   The structure of this is such that if a command is slow to a
   database, it would be possible to stack commands that are
   temporary and pending until the database connection is
   restored.
   Example
   <code lang="c++">
   int f( void )
   {
       // results from the query
       CTEXTSTR *results;
       // connect.
       PODBC odbc = ConnectToDatabase( "system_dsn_name" );
       // do a command, does a temporary entry on the stack, unless the database is slow
       SQLCommandf( odbc, "create temporary table my_test_table( ID int, value int )" );
       // start a new entry on the command stack.
       SQLRecordQueryf( odbc, NULL, &amp;results, NULL, "select 1+1" );
       // when this command is done, it is stacked on the query.
       SQLCommandf( odbc, "insert into my_test_table (value) values(%d)", 1234 );
       // at this point there is technically 2 entries on the command stack until the next
       // FetchSQLResult( odbc, &amp;results );
   }
	</code>                                                                                 */
#if !defined( __GNUC__ ) || !defined( SQLSTUB_SOURCE )
   // GCC doesn't identify this as exactly the same declaration
	typedef struct odbc_handle_tag *PODBC;
#endif
typedef struct odbc_handle_tag ODBC;
// recently added {} container braces for structure element
#define FIELDS(n) {( sizeof( n ) / sizeof( FIELD ) ), n}
/* a field definition can be a rename, and contain prior names,
   so that the rename can be tracked and migrated appropraitely.
   Unfortuntaly this sort of operation only affects this code,
   and not all auxiliary code.                                   */
#define MAX_PREVIOUS_FIELD_NAMES 4
/* <combine sack::sql::required_field_tag>
   <code lang="c++">
     FIELD fields[] = { { "ID", "int" }, ... };
   </code>                                            */
typedef struct required_field_tag
{
	/* This is the name of the column described in this table. */
	CTEXTSTR name;
	/* pointer to a string describing the type of this column.  */
	CTEXTSTR type;
	/* extra information about the field... grab all addtional
	   information like 'NOT NULL' "default 'zxa'" to describe a
	   field. Sometimes target databases don't understand extra
	   \parameters, and these can be translated as required or
	   ignored.                                                  */
	CTEXTSTR extra;
	// if you have renamed this column more than 1
	// times - you really need to stop messing around
	// and get a life.
	CTEXTSTR previous_names[MAX_PREVIOUS_FIELD_NAMES];
} FIELD, *PFIELD;
#if !defined( _MSC_VER ) || ( _MSC_VER >= 800 )
/* A macro to append a NULL automatically to a list of strings.
   Example
   <code lang="c++">
   CTEXTSTR strings[] = { KEY_COLUMNS( "one", "two", "three" ) };
   </code>
   strings will be set to 4 elements with the 3 strings listed
   in KEY_COLUMNS plus a NULL string.                             */
#define KEY_COLUMNS(...) { __VA_ARGS__, NULL }
#endif
/* sets the count and the array of a statically declared
   required_table_tag.
   Example
   <code lang="c++">
   </code>
   <code>
   FIELD fields[5];
   DB_KEY_DEF keys[3];
   TABLE table = { "table_name", FIELDS( fields ), TABLE_KEYS( keys ) };
   </code>
   This creates a static table definition with the name
   "table_name" and 5 fields with 3 keys. fields[] = { } is
   usally the declartion. Also DB_KEY_DEF keys[] = { ... }; for
   keys.
                                                                         */
#define TABLE_KEYS(n) {( sizeof( n ) / sizeof( DB_KEY_DEF ) ), n}
/* maximum columns that can be specified for a multicolumn index
   in required_key_def.                                          */
#define MAX_KEY_COLUMNS 8
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  DB_KEY_DEF;
enum uniqueResolutions {
  // no on conflict specification.
	UNIQRES_UNSET = 0,
	UNIQRES_REPLACE,
	UNIQRES_IGNORE,
	UNIQRES_FAIL,
	UNIQRES_ABORT,
	UNIQRES_ROLLBACK
};
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  *PDB_KEY_DEF;
struct required_key_def
{
	/* Flags describing attributes of this key */
	/* <combine sack::sql::required_key_def::flags@1>
	   \ \                                            */
	struct {
		/* this defines the primary key for the table */
		BIT_FIELD bPrimary : 1;
		/* the key is meant to be unique. */
		BIT_FIELD bUnique : 1;
		BIT_FIELD uniqueResolution : 3;
	} flags;
	/* Name of the key column. Can be NULL if primary. */
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
#ifdef __cplusplus
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = NULL; }
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = 0; }
	/* Just another required_key_def constructor. */
	required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2, CTEXTSTR colname3 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = colname3; colnames[3] = 0; }
#else
#define required_key_def( a,b,c,...) { {a,b}, c, {__VA_ARGS__} }
#endif
};
 /* Describes a key column of a table.
      <code lang="c++">
      DB_KEY_DEF keys[] = { { "lockey", KEY_COLUMNS("hall_id","charity_id") } };
      </code>                                                                    */
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  DB_CONSTRAINT_DEF;
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  *PDB_CONSTRAINT_DEF;
struct required_constraint_def
{
	struct {
		BIT_FIELD cascade_on_delete : 1;
		BIT_FIELD cascade_on_update : 1;
		BIT_FIELD restrict_on_delete : 1;
		BIT_FIELD restrict_on_update : 1;
		BIT_FIELD noaction_on_delete : 1;
		BIT_FIELD noaction_on_update : 1;
		BIT_FIELD setnull_on_delete : 1;
		BIT_FIELD setnull_on_update : 1;
		BIT_FIELD setdefault_on_delete : 1;
		BIT_FIELD setdefault_on_update : 1;
		BIT_FIELD foreign_key : 1;
	} flags;
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
	CTEXTSTR references;
 // uhm up to 5 colnames...
	CTEXTSTR foriegn_colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
 // Describes a constraint clause
};
/* Example
   By default, CreateTable( CTEXTSTR tablename, CTEXTSTR
   filename ) which reads a 'create table' statement from a file
   to create a table, this now parses the create table structure
   into an internal structure TABLE which has FIELDs and
   DB_KEY_DEFs. This structure is now passed to CheckODBCTable
   which is able to compare the structure with the table
   definition available from the database via DESCRIBE TABLE,
   and then update the table in the database to match the TABLE
   definition.
   One can use the table structure to define tables instead of
   maintaining external files... and without having to create a
   temporary external file which could then contain a create
   table statement to create the table.
   <code>
   // declare some fields...
   FIELD some_table_field_array_name[] = { { "field one", "int", NULL }
   , { "field two", "varchar(100)", NULL }
   , { "ID field", "int", "auto_increment" }
   , { "some other field", "int", "NOT NULL default '8'" }
   };
   // define some keys...
   DB_KEY_DEF some_table_key_array_name[] = { { .flags = { .bPrimary = 1 }, NULL, {"ID Field"} }
   , { {0}, "namekey", { "field two", NULL } }
   };
   </code>
   // the structure for DB_KEY_DEF takes an array of column
   names used to define the key, there should be a NULL to end
   the list. The value after the array of field names is called
   'null' which should always be set to NULL. If these are
   declared in global data space, then any unset value will be
   initialized to zero.
   <code>
   TABLE some_table_var_name = { "table name", FIELDS( some_table_field_array_name ), TABLE_KEYS( some_table_key_array_name ), 1 );
    LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
        PODBC odbc - may be left NULL to use the default database connection.
        PTABLE table - a pointer to a TABLE structure which has been initialized.
        uint32_t options - zero or more of  the following symbols or'ed together.
                   \#define CTO_MATCH 4  // attempt to figure out alter statements to drop or add columns to exact match definition
                   \#define CTO_MERGE 8  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
   </code>
   Then some routine later
   <code>
   {
      ...
      CheckODBCTable( NULL, &amp;some_table_var_name, CTO_MERGE );
      ..
   }
   </code>
   * ---------------------------------------------------------- *
   alternatively tables may be checked and updated using the
   following code, given an internal constant text string that
   is the create table statement, this may be parsed into a
   PTABLE structure which the resulting table can be used in
   CheckODBCTable();
   <code>
   static CTEXTSTR create_player_info = "CREATE TABLE `players_info` ("
         "  `player_id` int(11) NOT NULL auto_increment,           "
         "  PRIMARY KEY  (`player_id`),                            "
         ")                               ";
   PTABLE table = GetFieldsInSQL( create_player_info, FALSE );
   CheckODBCTable( NULL, table, CTO_MERGE );
   DestroySQLTable( table );
   </code>                                                                                                                          */
struct required_table_tag
{
	/* This is the name of the table. */
	CTEXTSTR name;
	/* describes the columns (fields) in a table. */
	struct pssql_table_fields {
		/* number of fields in the array pointed at by field. */
		int count;
		/* pointer to an array of FIELD. */
		PFIELD field;
	} fields;
	/* Describes the keys on the table.  */
	/* <combine sack::sql::required_table_tag::keys@1>
	   \ \                                             */
	struct pssql_table_key {
		/* number of keys pointed at by key. */
		int count;
      /* pointer to an array of DB_REQ_KEY. */
      PDB_KEY_DEF key;
	} keys;
	struct pssql_table_constraint {
		int count;
		PDB_CONSTRAINT_DEF constraint;
	} constraints;
	/* <combine sack::sql::required_table_tag::flags@1>
	   \ \                                              */
	/* flags controlling the table. */
		struct pssql_table_flags {
         // set this if defined dynamically (from getfields in SQL)
		BIT_FIELD bDynamic : 1;
		/* This is a table that is allocated in memory, static table
		   definitions should leave this 0.                          */
		BIT_FIELD bTemporary : 1;
		/* Issue the create statement always, but include 'if not
		   exists'. Don't try and compare the table structure.    */
		BIT_FIELD bIfNotExist : 1;
	} flags;
   /* name of another table that already exists. Creates this table
      using that table's description.                               */
   CTEXTSTR create_like_table_name;
   /* name of the database that contains this table. */
   CTEXTSTR database;
   /* an additional field that can specify the database storage
      engine to use. (Hmm maybe use this to specify sqlite target?) */
   CTEXTSTR type;
   /* This is an additional field to add as a description to the
      database if supported by the target database.              */
   CTEXTSTR comment;
};
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag TABLE;
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag *PTABLE;
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTableEx)( PODBC odbc, PTABLE table, uint32_t options DBG_PASS );
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTable)( PODBC odbc, PTABLE table, uint32_t options );
/* <combine sack::sql::CheckODBCTableEx@PODBC@PTABLE@uint32_t options>
   \ \                                                            */
#define CheckODBCTable(odbc,t,opt) CheckODBCTableEx(odbc,t,opt DBG_SRC )
/* Enable or disable logging SQL to the sql.log file and to the
   application's log.
   Parameters
   odbc :      connection to disable logging on
   bDisable :  if TRUE disables logging, else restores logging. */
PSSQL_PROC( void, SetSQLLoggingDisable )( PODBC odbc, LOGICAL bDisable );
/* Set required connection flag, this causes a connection that fails, to wait until
   the connection is reconnected before continuing.
*/
PSSQL_PROC( void, SetConnectionRequired )( PODBC odbc, LOGICAL require );
/* Get the required connection flag froma connection.
*/
PSSQL_PROC( LOGICAL, GetConnectionRequired )( PODBC odbc );
#ifndef SQLPROXY_INCLUDE
// result is FALSE on error
// result is TRUE on success
PSSQL_PROC( int, DoSQLCommandEx )( CTEXTSTR command DBG_PASS);
#endif
/* <combine sack::sql::DoSQLCommandEx@CTEXTSTR command>
   \ \                                                  */
#define DoSQLCommand(c) DoSQLCommandEx(c DBG_SRC )
/* Generate a commit for any outstanding transactions. Commit
   syntax is variable depending on the connection. Connections
   also have the feature to auto generate begin transaction, and
   flush after a period of idle.
   Parameters
   odbc :  connection to database to commit                      */
PSSQL_PROC( void, SQLCommit )( PODBC odbc );
/* generates the begin transaction for a commection.
   Parameters
   odbc :  connection to database to start a transaction        */
PSSQL_PROC( void, SQLBeginTransact )( PODBC odbc );
// parameters to this are pairs of "name", type, "value"
//  type == 0 - value is text, do not quote
//  type == 1 - value is text, add quotes appropriate for database
//  type == 2 - value is an integer, do not quote
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
#ifndef SQLPROXY_INCLUDE
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnection )( PODBC );
#endif
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnectionEx )( PODBC DBG_PASS );
/* <combine sack::sql::OpenSQLConnectionEx@PODBC>
   \ \                                            */
#define OpenSQLConnect(o) OpenSQLConnectionEx( o DBG_SRC )
// should pass to this a &(CTEXTSTR) which starts as NULL for result.
// result is FALSE on error
// result is TRUE on success, and **result is updated to
// contain the resulting data.
PSSQL_PROC( int, DoSQLQueryEx )( CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::DoSQLQueryEx@CTEXTSTR@CTEXTSTR *result>
   \ \                                                         */
#define DoSQLQuery(q,r) DoSQLQueryEx( q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
#define DoSQLRecordQuery(q,r,c,f) SQLRecordQueryEx( NULL,q,r,c,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define DoSQLQueryRecord(q,r,c)   DoSQLRecordQuery(q,r,c,NULL)
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLQueryRecord(o,q,r,c)   SQLRecordQuery(o,q,r,c,NULL)
/* <combine sack::sql::GetSQLRecord@CTEXTSTR **>
   \ \                                           */
#define GetSQLResultRecord(r,c)   GetSQLRecord(c)
/* <combine sack::sql::FetchSQLResult@PODBC@CTEXTSTR *>
   \ \                                                  */
PSSQL_PROC( int, GetSQLResult )( CTEXTSTR *result );
/* <combine sack::sql::FetchSQLRecord@PODBC@CTEXTSTR **>
   \ \                                                   */
PSSQL_PROC( int, GetSQLRecord )( CTEXTSTR **result );
/* Gets the last result on the default ODBC connection.
   Parameters
   result\ :  address of a string pointer to get set to the error
              string.
   Example
   <code>
   {
      CTEXTSTR error;
      GetSQLError( &amp;error );
      printf( "Error: %s", error );
   }
   </code>                                                        */
PSSQL_PROC( int, GetSQLError )( CTEXTSTR *result );
/* This is a test command that tests to see if the default
   database connection is able to work.                    */
PSSQL_PROC( int, IsSQLReady )( void );
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
PSSQL_PROC( int, PushSQLQuery )( void );
/* <combine sack::sql::PopODBCEx@PODBC>
   \ \                                  */
PSSQL_PROC( void, PopODBC )( void );
#ifndef SQLPROXY_INCLUDE
/* Clear the top non temporary sql statement from the PODBC
   stack.
   Parameters
   odbc :  connection to remove the statement from.
   Remarks
   A SQLCommand is temporary, a SQLQuery or a PushODBC is not. Pop
   MAY be used to clear a query early, but it is recommended to
   read to the end of it instead.                                  */
PSSQL_PROC( void, PopODBCExx )( PODBC, LOGICAL DBG_PASS );
PSSQL_PROC( void, PopODBCEx )( PODBC );
/* <combine sack::sql::PopODBCExx@PODBC@LOGICAL>
   \ \                                           */
#define PopODBCEx(o) PopODBCExx(o,FALSE DBG_SRC)
/* <combine sack::sql::PopODBCEx>
   \ \                            */
#define PopODBC() PopODBCExx(NULL,FALSE DBG_SRC)
#endif
/* This terminates a query on the PODBC stack. (It was mentioned
   in pop odbc that it could be used to terminate a query, but
   that will log that a pop is being done without a push. This
   is the proper way to prematurely end a query.)
   Parameters
   odbc :  connection to end a query on.                         */
PSSQL_PROC( void, SQLEndQuery )( PODBC odbc );
// release any open queries on the database... all result
// sets are now invalid... uhmm what about things like fields?
// could be messy...
PSSQL_PROC( void, ReleaseODBC )( PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
#ifndef SQLPROXY_INCLUDE
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   date :    string to parse
   year :    pointer to an int that will receive the year portion
             of the date
   month :   pointer to an int that will receive the month
             portion of the date
   day :     pointer to an int that will receive the day portion
             of the date
   hour :    pointer to an int that will receive the hours
             portion of the date
   minute :  pointer to an int that will receive the minutes
             portion of the date
   second :  pointer to an int that will receive the second
             portion of the date
   msec :    pointer to an int that will receive the milli\-second
             portion of the date
   nsec :    pointer to an int that will receive the nano second portion
             of the date                                                 */
PSSQL_PROC( void, ConvertSQLDateEx )( CTEXTSTR date
												  , int *year, int *month, int *day
												  , int *hour, int *minute, int *second
												  , int *msec, int32_t *nsec
												  , int *zone_hr, int *zone_mn
												  );
#endif
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDate( date, y,m,d) ConvertSQLDateEx( date,y,m,d,NULL,NULL,NULL,NULL,NULL)
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDateTime( date, y,mo,d,h,mn,s) ConvertSQLDateEx( date,y,mo,d,h,mn,s,NULL,NULL)
//------------------------------
// this set of functions will auto create a suitable name table
// providing table_name_id and table_name_name as the columns to query by standard
// previous defaults where "id" and "name" which results in inability to use natural join
//
PSSQL_PROC( INDEX, FetchSQLNameID )( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name );
/* A specialized function which takes a name, looks in a SQL
   table on the default database connection for in column
   'name', and returns the value in the 'ID' column. This
   function may create a table with the required fields. This
   table is very bad, if you have 3 tables all with the same
   'name' column reverse engineering and natural join clauses
   fail.
   Parameters
   table_name :  name of the table to get the name's ID from.
   name :        name to lookup its ID for.
   Returns
   the ID of the name or INVALID_INDEX if not found.          */
PSSQL_PROC( INDEX, GetSQLNameID )( CTEXTSTR table_name, CTEXTSTR name );
/* Still a bad function to use.... just don't.
   Parameters
   odbc :        _nt_
   table_name :  _nt_
   iName :       _nt_                          */
PSSQL_PROC( CTEXTSTR, FetchSQLName )( PODBC odbc, CTEXTSTR table_name, INDEX iName );
/* A specialized function which takes an ID, looks in a SQL
   table on the default database connection for in column 'ID',
   and returns the value in the 'name' column. This function may
   create a table with the required fields. This table is very
   bad, if you have 3 tables all with the same 'name' column
   reverse engineering and natural join clauses fail.
   Parameters
   table_name :  name of the database table to read from
   iName :       ID of the name to get                           */
PSSQL_PROC( CTEXTSTR, GetSQLName )( CTEXTSTR table_name, INDEX iName );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \
   Note
   If database connection is not specified or is NULL, uses the
   default SQL connection.                                                                         */
PSSQL_PROC( INDEX, ReadNameTableExEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTableExx( name,table,col,namecol,bCreate) ReadNameTableExEx( name,table,col,namecol,bCreate DBG_SRC )
//column name if NOT specified will be 'ID'
PSSQL_PROC( INDEX, ReadNameTableEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTable(n,t,c) ReadNameTableExEx( n,t,c, "name",TRUE DBG_SRC )
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
PSSQL_PROC( int, ReadFromNameTableEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS);
/* TRUE if name in result... again if !colname colname = 'ID'
   Parameters
   odbc :       connection to use
   id :         ID of the name to read
   table :      table to read from
   id_column :  name of the column that contains the ID
   colname :    name of the column that is where the name is
   result\ :    pointer to a CTEXTSTR which will be filled with
                the name in the table                           */
PSSQL_PROC( int, ReadFromNameTableExEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_column, CTEXTSTR colname, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
#define ReadFromNameTableExx(id,t,ic,nc,r) ReadFromNameTableExEx(id,t,ic,nc,r DBG_SRC )
/* <combine sack::sql::ReadFromNameTableEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                        */
#define ReadFromNameTable(id,t,c,r) ReadFromNameTableEx(id,t,c,"name",r DBG_SRC )
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( TEXTSTR, SQLReadNameTableKeyExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( INDEX, SQLReadNameTableExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTableExx( odbc,name,table,col,namecol,bCreate) SQLReadNameTableExEx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTable(o,n,t,c) SQLReadNameTableExEx( o,n,t,c,"name",TRUE DBG_SRC )
/* Reads a table that's assumed to be a primary key ID and a
   name sort of dictionary table. This also maintains an
   \internal cache of names queried, since it is assumed words
   in a dictionary don't move or change.
   Parameters
   odbc :      odbc connection to use
   name :      name to get the index of
   table :     table to get the index from
   col :       column name of the ID columns (macros allow this to
               be defaulted)
   namecol :   column name of the name column (macros allow this to
               be defaulted)
   bCreate :   If the name doesn't exist, setting this to TRUE will
               insert the new name, else return will be
               INVALID_INDEX.
   bQuote :    Indicates if the name should be quoted (else use no
               quotes)
   DBG_PASS :  _nt_                                                 */
PSSQL_PROC( INDEX, GetNameIndexExtended)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate, int bQuote DBG_PASS );
/* <combine sack::sql::GetNameIndexExtended@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int@int bQuote>
   \ \                                                                                                */
PSSQL_PROC( INDEX, GetNameIndexExx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndexEx( odbc,name,table,col,namecol,bCreate) GetNameIndexExx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndex(o,n,t,c) GetNameIndexExx( o,n,t,c,"name",TRUE DBG_SRC )
// table and col are not used if a MySQL backend is used...
// they are needed to get the last ID from a postgresql backend.
PSSQL_PROC( INDEX, GetLastInsertIDEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertID(t,c) GetLastInsertIDEx(t,c DBG_SRC )
/* Gets the ID of the primary key from the prior insert. This
   value can be used in subsequent inserts to relate detail
   records to a master.
   Parameters
   odbc :    database connection
   table :   if NULL, just get's the connection's last insert
             into whatever table. PostgreSQL requires a table
             name and column name to get the last insert for. So,
             proper portability for certain databases may use
             this parameter.
   column :  if NULL, just get's the connection's last insert id
             from the auto increment primary key. PostgreSQL
             requires a table name and column name to get the
             last insert for. So, proper portability for certain
             databases may use this parameter.
   Returns
   a 64 bit row identifier.                                       */
PSSQL_PROC( INDEX, FetchLastInsertIDEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertID(o,t,c) FetchLastInsertIDEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertKey(o,t,c) FetchLastInsertKeyEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
PSSQL_PROC( CTEXTSTR, FetchLastInsertKeyEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
PSSQL_PROC( CTEXTSTR, GetLastInsertKeyEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertKey(t,c) GetLastInsertKeyEx(t,c DBG_SRC )
// CreateTable Options (CTO_)
enum CreateTableOptions {
   // drop old table before create.
 CTO_DROP  = 1,
  // attempt to figure out alter statements to drop or add columns to exact match definition
 CTO_MATCH = 4,
  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
 CTO_MERGE = 8,
 // log changes to "changes.sql"
		CTO_LOG_CHANGES = 16
};
/* \ \
   Parameters
   odbc :          database connection to check table in
   filename :      name of file containing sql CREATE TABLE
                   statements.
   templatename :  name of the table specified by the CREATE
                   TABLE statement.
   tablename :     table name to use when actually creating this.
                   May be different from template table name.
   options :       Options from CreateTableOptions.               */
PSSQL_PROC( int, SQLCreateTableEx )(PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::SQLCreateTableEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                                        */
#define SQLCreateTable( odbc, file, table ) SQLCreateTableEx(odbc,file,table,table,0)
/* Creates a table in a database by reading an external file
   containing the table definition. It can also perform
   iterative updates to table structure if the template
   definition adds or deletes columns.
   Parameters
   filename :      filename to read the template from
   templatename :  name of the table in the create table template
                   statement.
   tablename :     the name of the table to create (may be
                   different than template)
   options :       Options from CreateTableOptions.
   Returns
   TRUE if success.
   FALSE if failure. (No further information)                     */
PSSQL_PROC( int, CreateTableEx )( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::CreateTableEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                               */
#define CreateTable( file, table ) CreateTableEx(file,table,table,0)
// results in a static buffer with escapes filled in for characterws
// which would otherwise conflict with string punctuators.
PSSQL_PROC( TEXTSTR ,EscapeStringEx )( CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeString(s) EscapeStringEx( s DBG_SRC )
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeStringOpt(s,q) EscapeSQLBinaryExx( NULL,s,StrLen(s),NULL, q DBG_SRC )
/* \ \
   Parameters
   odbc :  connection to escape the string appropriately for. Different
           database engines require different string escapes.
   name :  string to escape
   Returns
   a TEXTSTR that is the content of the string passed properly
   escaped.
   it is appropriate to Release( result );
   Example
   This is difficult to describe coorectly, since in C, you have
   to do escaping on the parameters anyhow....
   <code lang="c++">
   {
       TEXTSTR result = EscapeSQLString( "\\"test \\'escape\\'" );
       printf( "original : %s\\n"
               "result   : %s\\n"
             , "\\"test \\'escape\\'"
             , \result );
   }
   </code>
   \Output
   <code lang="c++">
   original : "test 'escape'
   \result   : \\"test \\'escape\\'
   </code>                                                              */
PSSQL_PROC( TEXTCHAR *,EscapeSQLStringEx )( PODBC odbc, CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeSQLStringEx@PODBC@CTEXTSTR name>
   \ \                                                        */
#define EscapeSQLString(odbc, s) EscapeSQLStringEx( odbc, s DBG_SRC )
// the following functions return an allcoated buffer which the application must Release()
PSSQL_PROC( TEXTSTR ,EscapeBinaryEx )( CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinary(b,bl) EscapeBinaryEx(b,bl DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinaryOpt(b,bl,q) EscapeSQLBinaryExx(NULL,b,bl,NULL,q DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
PSSQL_PROC( TEXTSTR,EscapeSQLBinaryExx )( PODBC odbc, CTEXTSTR blob, size_t bloblen, size_t *resultLen, LOGICAL bQuote DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
//PSSQL_PROC( TEXTSTR,EscapeSQLBinaryEx )( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinary(odbc,blob,len) EscapeSQLBinaryExx( odbc,blob,len, NULL, FALSE DBG_SRC )
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinaryOpt(odbc,blob,len,q) EscapeSQLBinaryExx( odbc,blob,len,NULL,q DBG_SRC )
#define EscapeSQLBinaryLen(odbc,blob,len,resLen,q) EscapeSQLBinaryExx( odbc,blob,len,resLen, q DBG_SRC )
/* Remove escape sequences which are inserted into a text
   string. (for things like quotes and binary characters?)
   Parameters
   name :  string to remove string escapes from
   Returns
   a copy of the string without quotes. This result should be
   freed with Release when user is done with it.              */
PSSQL_PROC( TEXTSTR ,RevertEscapeString )( CTEXTSTR name );
/* Remove escape sequences which are inserted into a binary
   string.
   Parameters
   blob :     pointer to data to remove binary escape sequences
              from
   bloblen :  length of the data block to handle
   Returns
   a pointer to the string without escapes. (Even though it says
   binary, it's still to and from text?) This result should be
   freed with Release when user is done with it.                 */
PSSQL_PROC( TEXTSTR ,RevertEscapeBinary )( CTEXTSTR blob, size_t *bloblen );
/* Parse a Blob string stored as hex... that is text character
   0-9 and A-F.
   Parameters
   blob :    pointer to the string containing the blob string
   buffer :  target buffer for data
   buflen :  length of target buffer                           */
PSSQL_PROC( TEXTSTR , DeblobifyString )( CTEXTSTR blob, TEXTSTR buffer, size_t buflen );
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   timestring :     string to parse
   endtimestring :  pointer to a pointer to a string to receive
                    the position of the character after the
                    timestring.
   year :           pointer to an int that will receive the year
                    portion of the date
   month :          pointer to an int that will receive the month
                    portion of the date
   day :            pointer to an int that will receive the day
                    portion of the date
   hour :           pointer to an int that will receive the hours
                    portion of the date
   minute :         pointer to an int that will receive the
                    minutes portion of the date
   second :         pointer to an int that will receive the
                    second portion of the date
   Returns
   A true/false status whether the string passed was a valid
   time string (?).                                               */
PSSQL_PROC( int, ConvertDBTimeString )( CTEXTSTR timestring
                                      , CTEXTSTR *endtimestring
                                      , int *pyr, int *pmo, int *pdy
                                      , int *phr, int *pmn, int *psc );
#ifndef SQLPROXY_INCLUDE
/* Issue a command to a SQL database. Things like Update and
   Insert are commands.
   Parameters
   odbc :     database connection to perform the command on. If
              NULL uses the default global connection.
   command :  text string to send to the database to execute.
   Returns
   TRUE if the statement succeeds.
   FALSE if the statement fails. See FetchSQLError.             */
PSSQL_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS);
#endif
PSSQL_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS);
/* <combine sack::sql::SQLCommandEx@PODBC@CTEXTSTR command>
   \ \                                                      */
#define SQLCommand(o,c) SQLCommandEx(o,c DBG_SRC )
#define SQLCommandLen(o,c,len) SQLCommandExx(o,c,len DBG_SRC )
   /* Begin collecting insert statements for batch output.
   Parameters
   odbc :  database connection to start collecting inserts for */
PSSQL_PROC( int, SQLInsertBegin )( PODBC odbc );
/* Generate a SQL insert statement from a variable parameter
   list.
   Parameters
   odbc :   connection to generate an insert on
   table :  table to insert into
   args :   a list of fields.
   Remarks
   args each column is a set of 3 parameters; the first
   parameter is the name of the column to insert into, the
   second is a value 0 or 1 whether to quote the value or not,
   and a string pointer.
   Inserts may be batched together and flushed as a whole to the
   database connection.                                          */
PSSQL_PROC( int, vSQLInsert )( PODBC odbc, CTEXTSTR table, va_list args );
/* Generate an insert to the database. Inserts to a single table
   can be cached internally and flushed.
   Parameters
   odbc :   database connection to use
   table :  name of table to insert into
   ... :    sets of column paramters.                            */
PSSQL_PROC( int, SQLInsert )( PODBC odbc, CTEXTSTR table, ... );
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
/* Flushes all cached inserts collected on a database
   connection.
   Parameters
   odbc :  database connection to flush inserts       */
PSSQL_PROC( int, SQLInsertFlush )( PODBC odbc );
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   query :    the string query to do
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code lang="c++">
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQuery( odbc, "select 1,2,3", &amp;result );
   printf( "result : %s" );
   </code>
   \Output
   <code lang="c++">
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQuery                                                */
PSSQL_PROC( int, SQLQueryEx )( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::SQLQueryEx@PODBC@CTEXTSTR@CTEXTSTR *result>
   \ \                                                             */
#define SQLQuery(o,q,r) SQLQueryEx( o,q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
PSSQL_PROC( int, SQLRecordQueryEx )( PODBC odbc
                                   , CTEXTSTR query
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , CTEXTSTR **fields DBG_PASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   PDATALIST* :  pointer to datalist pointer which will contain struct jsox_value_container.
			 for each result in this list until VALUE_UNDEFINED is used.
		.name is the field name (constant)
		.string is the text, value_type is the value type (so numbers can stay numbers)
	pdlParams : parameters to bind to the query.  (struct json_value_container types)
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_js )( PODBC odbc
	, CTEXTSTR query
	, size_t queryLen
	, PDATALIST *pdlResults
	, PDATALIST pdlParams
	DBG_PASS );
/*
	this properly releases the list and all allocated strings within the entires
 */
PSSQL_PROC( void, ReleaseSQLResults )( PDATALIST *ppdlResults );
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   resultLengths : pointer to a size_t* that will contain an array of
              lengths of the result values.
   fields :   address of a pointer to strings which will get the
              field names
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQuery_v4 )( PODBC odbc
                                   , CTEXTSTR query
                                   , size_t queryLength
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , size_t **resultLengths
                                   , CTEXTSTR **fields
                                   , PDATALIST pdlParameters
                                   DBG_PASS);
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQuery(o,q,prn,r,f) SQLRecordQueryEx( o,q,prn,r,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryExx@PODBC@CTEXTSTR@size_t@int *@CTEXTSTR **@size_t *@CTEXTSTR **fields>
   \ \                                                                                      */
#if defined _DEBUG || defined _DEBUG_INFO
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f, __FILE__,__LINE__ )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields ,file,line )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL ,file,line )
#else
#  define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f  )
#  define SQLRecordQueryExx(o,q,ql,ppr,res,reslen,fields )  SQLRecordQuery_v4(o,q,ql,ppr,res,reslen,fields,NULL )
#endif
   /* Gets the next result from a query.
   Parameters
   odbc :     database connection that the query was executed on
   result\ :  address of the result variable.
   Example
   See SQLRecordQueryf.                                          */
PSSQL_PROC( int, FetchSQLResult )( PODBC, CTEXTSTR *result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
              \internal static connection.
   result\ :  address of a CTEXTSTR *; to set to an array of
              CTEXTSTR results.
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecord )( PODBC, CTEXTSTR **result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
			  \internal static connection.
   result\ :  (unchanged; is same list as original)
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecordJS )(PODBC odbc, PDATALIST *ppdlRecord);
/* Gets the last result on the specified ODBC connection.
   Parameters
   odbc :     connection to get the last error of
   result\ :  address of a string pointer to receive the error
              \result.
   Example
   <code lang="c++">
   {
      CTEXTSTR error;
      FetchSQLError( NULL, &amp;error );
   </code>
   <code>
      printf( "Error: %s", error );
   </code>
   <code lang="c++">
   }
   </code>                                                     */
PSSQL_PROC( int, FetchSQLError )( PODBC, CTEXTSTR *result );
#ifndef SQLPROXY_INCLUDE
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpenEx )( PODBC DBG_PASS );
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpen )( PODBC );
/* <combine sack::sql::IsSQLOpenEx@PODBC>
   \ \                                    */
#define IsSQLOpen(odbc) IsSQLOpenEx(odbc DBG_SRC )
/* An PODBC connection handles commands as a stack, this saves
   the current query state (that you want to still get results
   from), so you can start a new query within the outer query.
   Parameters
   odbc :  database connection to save the current query state. */
PSSQL_PROC( int, PushSQLQueryExEx )(PODBC DBG_PASS);
PSSQL_PROC( int, PushSQLQueryEx )(PODBC);
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
// no application support for username/password, sorry, trust thy odbc layer, please
PSSQL_PROC( PODBC, ConnectToDatabase )( CTEXTSTR dsn );
// get a connection to a database by name.
PSSQL_PROC( PODBC, SQLGetODBC )( CTEXTSTR dsn );
// get a connection to the database specifying user and password.
PSSQL_PROC( PODBC, SQLGetODBCEx )( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass );
// drop an interface (no longer in use/close); these are in a pool, and the underlaying connection might not close.
PSSQL_PROC( void, SQLDropODBC )( PODBC odbc );
// Drop the odbc instance, and close the connection.
PSSQL_PROC( void, SQLDropAndCloseODBC )( CTEXTSTR dsn );
#endif
// default parameter to require is the global flag RequireConnection from sql.config....
PSSQL_PROC( PODBC, ConnectToDatabaseExx )( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS );
// default parameter to require is the global flag RequireConnection from sql.config....
// the require connection parameter indicates the connection must connect, and will block until connected.
PSSQL_PROC( PODBC, ConnectToDatabaseEx )( CTEXTSTR DSN, LOGICAL bRequireConnection );
// default parameter to require is the global flag RequireConnection from sql.config....
#define ConnectToDatabaseEx( dsn, required ) ConnectToDatabaseExx( dsn, required DBG_SRC )
// default parameter to require is the global flag RequireConnection from sql.config....
#define ConnectToDatabase( dsn ) ConnectToDatabaseExx( dsn, FALSE DBG_SRC )
// Extended connect to database function; provides user and password separate from the DSN
// which allows logging the SQL connection name, without dumping the username ans password.
// adds onOpen Callback, which, especially on reconnection, triggers a callback to condition
// the connection (issue pragmas, setup database options).
PSSQL_PROC( PODBC, ConnectToDatabaseLoginCallback)( CTEXTSTR DSN, CTEXTSTR user, CTEXTSTR pass, LOGICAL bRequireConnection
			, void (*onOpen)(uintptr_t,PODBC), uintptr_t psv DBG_PASS );
/* Close a database connection. Releases all resources
   associated with the odbc connection.
   Parameters
   odbc :  connection to database to close. Should not be NULL.  */
PSSQL_PROC( void, CloseDatabase)(PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
/* ODBC only (sqlite no support?). Gets the types of data that
   the ODBC connection supports.
   Parameters
   odbc :  database connection to get the types from.
   Example
   <code>
   PODBC odbc = NULL; // or do a ConnectToDatabsae
   CTEXTSTR result; // the singular line result
   if( FetchSQLTypes(odbc) )
       while( FetchSQLResult( &amp;result ) &amp;&amp; result )
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>
   <code lang="c++">
   if( GetSQLTypes() )
       while( GetSQLResult( &amp;result ) &amp;&amp; result )
   </code>
   <code>
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>                                                      */
PSSQL_PROC( int, FetchSQLTypes )( PODBC );
#define PSSQL_VARARG_PROC(a,b,c)  PSSQL_PROC(a,b)c; typedef a(CPROC * __f_##b)c; PSSQL_PROC( __f_##b, __##b )(DBG_VOIDPASS)
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_VARARG_PROC( int, DoSQLRecordQueryf ,( int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define DoSQLRecordQueryf   (__DoSQLRecordQueryf( DBG_VOIDSRC ))
/* <combine sack::sql::SQLQueryf@PODBC@CTEXTSTR *@CTEXTSTR@...>
   \ \                                                          */
PSSQL_VARARG_PROC( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define DoSQLQueryf   (__DoSQLQueryf( DBG_VOIDSRC ))
/* This does a command to the database as a formatted command.
   This allows the user to simply specify the command and
   \parameters, and not also maintain a buffer to build the
   string into before passing the string to the ODBC connection
   as a command.
   Parameters
   fmt :  format string appropriate for vsnprintf. ... \: extra
          \parameters to fill the format string.
   See Also
   SQLCommandf
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from GetSQLError.
	*/
PSSQL_VARARG_PROC( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) );
#define DoSQLCommandf   (__DoSQLCommandf( DBG_VOIDSRC ))
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     database connection to perform the query on
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names. May be ommited if you don't want to
              know the names. (is less work internally if this is
              not built).
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   <code lang="c++">
   PODBC odbc = ConnectToDatabase( "MySQL" );
   CTEXTSTR *results;
   CTEXTSTR *column_names;
   int columns;
   for( SQLRecordQueryf( odbc, &amp;columns, &amp;results, &amp;column_names
                       , "select a,b,c from %s where %s=%s"
                       , "table_name"
                       , "column_name"
                       , "'value'"
                       );
        results;
        FetchSQLRecord( odbc, &amp;results ) )
   {
      int n;
       // draw a seperator between rows returned
      printf( " ----- record data ----- \\n" );
      for( n = 0; n \< columns; n++ )
      {
         printf( "Result column '%s' = '%s'\\n", column_name[n], results[n] );
      }
   }
   CloseDatabase( odbc );
   </code>
   If the default connection is used, odbc can be NULL in the
   prior example, or the for staement could be
   <code>
   for( DoSQLRecordQueryf( &amp;columns, &amp;results, &amp;column_names
                         , "select a,b,c from %s where %s=%s"
                         , "table_name"
                         , "column_name"
                         , "'value'"
                         );
        results;
        GetSQLRecord( &amp;results ) )
   {
   }
   </code>                                                                     */
//PSSQL_PROC( int, SQLRecordQueryf )( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... );
PSSQL_VARARG_PROC( int, SQLRecordQueryf, ( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf   (__SQLRecordQueryf( DBG_VOIDSRC ))
PSSQL_VARARG_PROC( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf_v2   (__SQLRecordQueryf_v2( DBG_VOIDSRC ))
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   query :    the string query to do
   ... :      extra parameters for the query format string
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code>
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQueryf( odbc, &amp;result, "select %d,%d,%d", 1, 2, 3 );
   printf( "result : %s" );
   </code>
   \Output
   <code>
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQueryf                                               */
PSSQL_VARARG_PROC( int, SQLQueryf ,( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define SQLQueryf   (__SQLQueryf( DBG_VOIDSRC ))
/* This performs a command on a SQL connection.
   Parameters
   odbc :  database connection to do the command on
   fmt :   format string as appropriate for vsnprintf
   ... :   extra arguments as required by the format string
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from FetchSQLError.
                                                            */
PSSQL_VARARG_PROC( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) );
#define SQLCommandf   (__SQLCommandf( DBG_VOIDSRC ))
/* Function signature for the callback when the SQL layer can
   log a status about a database connection (connection,
   disconnected, failed...) See SQLSetFeedbackHandler.        */
typedef void (CPROC *HandleSQLFeedback)(CTEXTSTR message);
// register a feedback message for startup messages
//  allows external bannering of status... perhaps this can handle failures
//  and disconnects also...
PSSQL_PROC( void, SQLSetFeedbackHandler )( HandleSQLFeedback handler );
/* Parses a CREATE TABLE statement and builds a PTABLE from it.
   Parameters
   cmd :         a CREATE TABLE sql command. It is a little
                 sqlite/mysql centric, and may fail on column
                 types for SQL Server.
   writestate :  if writestate is TRUE, a file called
                 'sparse.txt' will be generated with a C
                 structure of the Create Table statement passed. This
                 \file could then be used to copy into code, and
                 have a code\-static definition instead of going
                 from the create table statement.
   Returns
   a PTABLE which represents the create table statement.              */
PSSQL_PROC( PTABLE, GetFieldsInSQLEx )( CTEXTSTR cmd, int writestate DBG_PASS );
/* <combine sack::sql::GetFieldsInSQLEx@CTEXTSTR@int writestate>
   \ \                                                           */
#define GetFieldsInSQL(c,w) GetFieldsInSQLEx( c, w DBG_SRC )
//PSSQL_PROC( PTABLE, GetFieldsInSQL )( CTEXTSTR cmd, int writestate);
// this is used to destroy the table returned by GetFieldsInSQL
PSSQL_PROC( void, DestroySQLTable )( PTABLE table );
// allow setting and getting of a bit of user data associated with the PODBC...
// though this can result in memory losses at the moment, cause there is no notification
// that the PODBC has gone away, and that the user needs to remove his data...
PSSQL_PROC( uintptr_t, SQLGetUserData )( PODBC odbc );
/* A PODBC may have a user data assigned to it.
   Parameters
   odbc :  connection to set the data for; shouldn't be NULL.
   psv :   user data to assign to the database connection.
   See Also
   SQLGetUserData                                             */
PSSQL_PROC( void, SQLSetUserData )( PODBC odbc, uintptr_t );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  */
PSSQL_PROC( CTEXTSTR, GetGUID )( void );
/* Returns a text string GUID, This uses UuidCreateSequential  */
PSSQL_PROC( CTEXTSTR, GetSeqGUID )( void );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  This tring is the constant 0 guid */
PSSQL_PROC( CTEXTSTR, GuidZero )( void );
/* convert a string GUID to a binary representation of 16 bytes.
   litte_endian will byte-swap the grouped portions of numbers in a guid so they can be printed appropriately*/
PSSQL_PROC( uint8_t*, GetGUIDBinaryEx )( CTEXTSTR guid, LOGICAL litte_endian );
#define GetGUIDBinary(g) GetGUIDBinaryEx(g, TRUE )
/* structure of a little endian UUID.  This allows formatting into the various
 size fields of a uuid text string.
 */
struct guid_binary {
	union {
		struct {
			uint8_t bytes[16];
			uint8_t zero[2];
		} b;
		struct {
			uint32_t l1;
			uint16_t w1;
			uint16_t w2;
			uint16_t w3;
			uint64_t ll1;
		} d;
	} u;
};
// snprintf( buf, 256, guid_format, guid_param_pass(&guid_binary) )
// snprintf( buf, 256, guid_format, guid_param_pass(binary_buffer_result) )
#define guid_format "%08" _32fx "-%04" _16fx "-%04" _16fx "-%04" _16fx "-%012" _64fx
#define guid_param_pass(n) ((struct guid_binary*)(n))->u.d.l1,((struct guid_binary*)(n))->u.d.w1,((struct guid_binary*)(n))->u.d.w2,((struct guid_binary*)(n))->u.d.w3,((struct guid_binary*)(n))->u.d.ll1
/* some internal stub-proxy linkage for generating remote
   responders..
   This was work in progress for providing a msgsvr service to
   SQL. One of the implementations of this library was across a
   windows message queue using ATOM types to transport results
   and commands. Was going to implement this on the abstract
   msgqueue interface.                                          */
typedef struct responce_tag
{
	struct {
		BIT_FIELD bSingleLine : 1;
		BIT_FIELD bMultiLine : 1;
		BIT_FIELD bFields : 1;
	} flags;
	PVARTEXT result_single_line;
	int nLines;
	CTEXTSTR *pLines;
	CTEXTSTR *pFields;
} SQL_RESPONCE, *PSQL_RESPONCE;
/* *WORK IN PROGRESS* function call signature for callback method passed to
   RegisterResponceHandler.                              */
typedef void (CPROC *result_responder)( int responce
									  , PSQL_RESPONCE result );
/* *WORK IN PROGRESS*
   result_responder :  callback function to get called with sql
                       global status messages.
   See Also
   <link sack::sql::result_responder, Result Responder Type>    */
PSSQL_PROC( void, RegisterResponceHandler )( result_responder );
/* Thread protect means to use critical sections to protect this
   connection against multiple thread access. Recommended usage
   is to not use a PODBC with more than one thread in the first
   place.
   Parameters
   odbc :     connection to enable; if null, references the
              \internal static connection.
   bEnable :  TRUE to enable, FALSE to disable.                  */
PSSQL_PROC( void, SetSQLThreadProtect )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
   to trigger this process early.
   Parameters
   odbc :     connection to set auto transact on
   bEnable :  TRUE to enable, FALSE to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransact )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
	to trigger this process early.
	if Callback is set, automatically enables AutoTransact
   if Callback is NULL, automatically clears AutoTransact
   Parameters
   odbc :     connection to set auto transact on
   callback :  not NULL to enable, NULL to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransactCallback )( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is closed (allowing the file to be
   not-in-use during idle). PODBC odject remains valid, and
   connection to database is re-enabled on next usage.
   Parameters
   odbc :     connection to enable auto close behavior on
   bEnable :  TRUE to enable auto close FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoClose )( PODBC odbc, LOGICAL bEnable );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is issued a PRAGMA wal_checkpoint
   Parameters
   odbc :     connection to enable auto checkpoint behavior on
   bEnable :  TRUE to enable auto checkpoint FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoCheckpoint )( PODBC odbc, LOGICAL bEnable );
/* returns the current value of auto checkpoint mode on a conneciton
   Parameters
   odbc :     connection to enable auto checkpoint behavior on */
PSSQL_PROC( LOGICAL, GetSQLAutoCheckpoint )( PODBC odbc );
/* A function to apply a time offset for fiscal time
   calculations; sometimes the day doesn't end at midnight, but
   a shift might last until 5 in the morning.
   Parameters
   odbc :            connection to get the appropriate SQL
                     expression for
   BeginOfDayType :  name of the type of beginning of the day
   default_begin :   the default time when a day begins.
   Note
   default_begin is a format sort of like a time. If this is a
   simple integer 5 then it's 5:00am, if it's more than 100,
   then it's assumed to be hours and minutes so 530 would be
   5:30 in the monring. this is also stored in the option
   databse, so the default value can be overridden; if the SQL
   value has a ':' in it then it is parsed as hours and minutes.
   Negative time may be used to indicate that the day begins
   before the day ends (-2 would be day end at 10pm).            */
PSSQL_PROC( CTEXTSTR, GetSQLOffsetDate )( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin );
/* Performs a low level backup of one database to another.  This API supports
   sqlite3 connections ONLY.
   Parameters
   source :            original database to copy from
   dest :    database to copy to
   */
PSSQL_PROC( LOGICAL, BackupDatabase )( PODBC source, PODBC dest );
/* return the underlaying native connection handle of the database connection
 */
// deprecated during dev, instead added function hook exports
//PSSQL_PROC( POINTER, GetODBCHandle )( PODBC odbc );
/* set a handler to be triggered when SQLite Database finds corruption type error...
 */
PSSQL_PROC( void, SetSQLCorruptionHandler )( PODBC odbc, void (CPROC*f)(uintptr_t psv, PODBC odbc), uintptr_t psv );
/* Utility function to parse DSN according to sack sqlite vfs rules... */
PSSQL_PROC( void, ParseDSN )( CTEXTSTR dsn, char **vfs, char **vfsInfo, char **dbFile );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#ifdef __cplusplus
SQL_NAMESPACE_END
#endif
struct sqlite3_value;
struct sqlite3_context;
#ifdef __cplusplus
SQL_NAMESPACE
#endif
PSSQL_PROC( int, PSSQL_AddSqliteFunction )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteProcedure )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteAggregate )( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( POINTER, PSSQL_GetSqliteFunctionData )( struct sqlite3_context*context );
PSSQL_PROC( void, PSSQL_ResultSqliteText )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteBlob )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteDouble )( struct sqlite3_context*context, double val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt )( struct sqlite3_context*context, int val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt64 )( struct sqlite3_context*context, int64_t val );
PSSQL_PROC( void, PSSQL_ResultSqliteNull )( struct sqlite3_context*context );
enum sqlite_data_types {
	PSSQL_TYPE_INTEGER= 1,
	PSSQL_TYPE_FLOAT= 2,
	PSSQL_TYPE_TEXT = 3,
	PSSQL_TYPE_BLOB  = 4,
	PSSQL_TYPE_NULL = 5,
};
PSSQL_PROC( enum sqlite_data_types, PSSQL_GetSqliteValueType )( struct sqlite3_value *val );
PSSQL_PROC( void, PSSQL_GetSqliteValueText )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueBlob )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueDouble )( struct sqlite3_value *val, double *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt )( struct sqlite3_value *val, int *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt64 )( struct sqlite3_value *val, int64_t *result );
PSSQL_PROC( const char *, PSSQL_GetColumnTableName )( PODBC odbc, int col );
PSSQL_PROC( const char *, PSSQL_GetColumnTableAliasName )( PODBC odbc, int col );
PSSQL_PROC( void, PSSQL_GetSqliteValue )( struct sqlite3_value *val, const char **text, int *textLen );
/*
 Get Database Provider (type of database).
   1=Sqlite, 2=MyQL, 3=PSQL, 4=Access, 5=MariaDB, 6=?, -1=unknown
*/
PSSQL_PROC( int, GetDatabaseProvider )( PODBC odbc );
#endif
SQL_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::sql;
#endif
#endif
#if 0
#endif
// sqloptint.h leaves namespace open.
// these headers should really be collapsed.
/* Provies SQL Option Interface. Options are implemented as a
   tree of nodes with names and values. Defines abstract
   interface that can be filled by varying providers.         */
#ifndef SQL_GET_OPTION_DEFINED
/* Inclusion protection; used to prevent duplicate inclusion of
   the same file.                                               */
#define SQL_GET_OPTION_DEFINED
#ifdef __cplusplus
#define _OPTION_NAMESPACE namespace options {
#define _OPTION_NAMESPACE_END }
#define USE_OPTION_NAMESPACE	 using namespace sack::sql::options;
#else
#define _OPTION_NAMESPACE
#define _OPTION_NAMESPACE_END
#define USE_OPTION_NAMESPACE
#endif
SACK_NAMESPACE
   _SQL_NAMESPACE
	/* Contains methods for saving and recovering options from a
	   database. If enabled, will use a local option.db sqlite
	   database. Use EditOptions application to modify options. Can
	   use any database connection, but sql.config file will specify
	   'option.db' to start.                                         */
	_OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE SACK_NAMESPACE _SQL_NAMESPACE _OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE_END _OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
#ifdef SQLGETOPTION_SOURCE
#define SQLGETOPTION_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SQLGETOPTION_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifndef __NO_INTERFACES__
   _INTERFACE_NAMESPACE
/* Defines a set of functions that can be registered as an
   interface, and the interface can be used for saving options. Module
   ideas might be to save into the windows registry system or
   into INI files.                                                     */
typedef struct option_interface_tag
{
   // these provide simple section, key, value queries.
	METHOD_PTR( size_t, GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame );
	METHOD_PTR( int32_t, GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
	METHOD_PTR( size_t, GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer );
	METHOD_PTR( int32_t, GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
   // these provide an additional level of abstraction - the ini file
	METHOD_PTR( LOGICAL, WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
	METHOD_PTR( int32_t, WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
	METHOD_PTR( LOGICAL, WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
	METHOD_PTR( int32_t, WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
   // these offer(expose) the option to be quiet
	METHOD_PTR( size_t, GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( size_t, GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
	METHOD_PTR( LOGICAL, WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush );
	METHOD_PTR( LOGICAL, WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL commit );
} *POPTION_INTERFACE;
#define GetOptionInterface() ((POPTION_INTERFACE)GetInterface( "options" ))
//POPTION_INTERFACE GetOptionInterface( void );
//void DropOptionInterface( POPTION_INTERFACE );
#ifndef DEFAULT_OPTION_INTERFACE
#define DEFAULT_OPTION_INTERFACE ((!pOptionInterface)?(pOptionInterface=GetOptionInterface()):pOptionInterface)
#ifdef USES_OPTION_INTERFACE
static POPTION_INTERFACE pOptionInterface;
#ifdef __WATCOMC__
static void UseInterface( void )
{
	// use the value of this function and set pOptionInterface with it
	// makes pOptionInterface marked as used so is UseInterface.
	// Visual Studio pucked on this because converting a function pointer to data pointer
   // but this function should never be called.
   pOptionInterface = (POPTION_INTERFACE)UseInterface;
}
#endif
#endif
#endif
   _INTERFACE_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::sql::options::Interface;
#endif
#endif
#define OptGetPrivateProfileString   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileString)
#define OptGetPrivateProfileInt      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileInt)
#define OptGetProfileString          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileString)
#define OptGetProfileInt             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileInt)
#define OptWritePrivateProfileString METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileString)
#define OptWritePrivateProfileInt    METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileInt)
#define OptWriteProfileString        METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileString)
#define OptWriteProfileInt           METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileInt)
#define OptGetPrivateProfileStringEx   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileStringEx)
#define OptGetPrivateProfileIntEx      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileIntEx)
#define OptGetProfileStringEx          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileStringEx)
#define OptGetProfileIntEx             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileIntEx)
#define OptWritePrivateProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileStringEx)
#define OptWriteProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileStringEx)
SACK_OPTION_NAMESPACE_END
#endif
SACK_OPTION_NAMESPACE
typedef struct sack_option_tree_family_node *POPTION_TREE_NODE;
typedef struct sack_option_tree_family *POPTION_TREE;
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
/* All gets eventually end up here. This function gets a value
   from a database. Functions which return an 'int' use this
   function, but has extra processing to convert the text into a
   number; also if the text is 'Y', or 'y' then the option's int
   value is 1.
   Parameters
   pSection :     Path of the option to retrieve.
   pOptname :     Actual option name to retrieve.
   pDefaultbuf :  Default value if the option doesn't exist
                  already.
   pBuffer :      Pointer to the buffer to get the result
   nBuffer :      size of the result buffer in characters (not
                  bytes).
   pININame :     This is the upper level name. If a function
                  does not have a pININame, then the name
                  "DEFAULT' is used. (pass NULL here for
                  non\-private)
   bQuiet :       Boolean, if configured to prompt the user for
                  option values, this overrides the default to
                  disable prompting.                             */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionStringEx )(PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush);
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL bFlush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIfile, LOGICAL flush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer,  CTEXTSTR app);
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pININame
																				, LOGICAL bQuiet
																				 DBG_PASS
																				);
#ifdef __NO_OPTIONS__
#define SACK_GetProfileInt( s,e,d ) (d)
#define SACK_GetProfileString( s,e,d,b,n ) ((d)?StrCpyEx( b,d,n ):0)
#endif
#define SACK_GetPrivateOptionString( odbc, section, option, default_buf, buf, buf_size, ini_name )	   SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionStringEx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet DBG_SRC )
#define SACK_GetOptionString( odbc, section, option, default_buf, buf, buf_size )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, FALSE DBG_SRC )
#define SACK_GetOptionStringEx( odbc, section, option, default_buf, buf, buf_size, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet DBG_PASS );
#define SACK_GetPrivateOptionInt( odbc, section, option, default_val, ini_name )	   SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionIntEx( odbc, section, option, default_val, ini_name, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, quiet DBG_SRC )
#define SACK_GetOptionInt( odbc, section, option, default_val )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, FALSE DBG_SRC )
#define SACK_GetOptionIntEx( odbc, section, option, default_val, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void );
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( POPTION_TREE, GetOptionTreeExxx )( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
/* Sets the option database to use (does not prevent
   preload/deadstart code from using the old database) but this
   can be used for comparison utilities.
   Parameters
   odbc :  The PODBC connection to use.
   See Also
   PODBC                                                        */
SQLGETOPTION_PROC( POPTION_TREE, SetOptionDatabase )( PODBC odbc );
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void );
SQLGETOPTION_PROC( void, SetOptionDatabaseOption )( PODBC odbc );
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void );
SQLGETOPTION_PROC( void, EndBatchUpdate )( void );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexExx )( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( size_t, GetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR value );
SQLGETOPTION_PROC( size_t, GetOptionStringValue )( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len );
SQLGETOPTION_PROC( LOGICAL, SetOptionStringValue )( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot );
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
 // flush the map cache.
SQLGETOPTION_PROC( void, ResetOptionMap )( PODBC odbc );
SQLGETOPTION_PROC( PODBC, GetOptionODBCEx )( CTEXTSTR dsn DBG_PASS );
SQLGETOPTION_PROC( void, DropOptionODBCEx )( PODBC odbc DBG_PASS );
SQLGETOPTION_PROC( PODBC, GetOptionODBC )( CTEXTSTR dsn );
SQLGETOPTION_PROC( void, DropOptionODBC )( PODBC odbc );
#define GetOptionODBC( b) GetOptionODBCEx( b DBG_SRC )
#define DropOptionODBC(a) DropOptionODBCEx( a DBG_SRC )
SQLGETOPTION_PROC( void, FindOptions )( PODBC odbc, PLIST *result_list, CTEXTSTR name );
_OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
	USE_OPTION_NAMESPACE
#endif
//#undef GetFromSet
//#undef GetArrayFromSet
//#undef DeleteFromSet
//#undef DeleteArrayFromSet
//#undef CountUsedInSet
//#undef GetLinearSetArray
//#undef ForAllInSet
//----------------------------------------------------------------------------
 // put into a global structure, and configure.
static int bLog;
#ifdef __cplusplus
namespace sack {
	namespace containers {
	namespace sets {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
#ifdef __64__
#  define FLAGSET_MIN_SIZE 64
#else
#  define FLAGSET_MIN_SIZE 64
#endif
#ifndef __NO_OPTIONS__
PRELOAD( InitSetLogging )
{
	bLog = SACK_GetProfileIntEx( "SACK", "type library/sets/Enable Logging", 0, TRUE );
}
#endif
void DeleteSet( GENERICSET **ppSet )
{
	GENERICSET *pSet;
	 if( !ppSet )
		 return;
	 pSet = *ppSet;
	if( bLog ) lprintf( "Deleted set %p", pSet );
	while( pSet )
	{
		GENERICSET *next;
		next = pSet->next;
		Release( pSet );
		pSet = next;
	}
	*ppSet = NULL;
}
//----------------------------------------------------------------------------
PGENERICSET GetFromSetPoolEx( GENERICSET **pSetSet, int setsetsizea, int setunitsize, int setmaxcnt
							 , GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS ){
	PGENERICSET set;
	uint32_t maxbias = 0;
	void *unit = NULL;
	uintptr_t ofs = ( ( ( maxcnt + (FLAGSET_MIN_SIZE-1) ) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8) );
	//if( pSet && (*pSet) && ( (*pSet)->nBias > 1000 ))
	//	_lprintf( DBG_RELAY )("GetFromSet: %p", pSet );
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		if( pSetSet )
		{
			set = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
			set->nBias = 0;
		}
		else
		{
			set = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
			set->nBias = 0;
			//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
			MemSet( set, 0, setsizea );
		}
		*pSet = set;
	}
	{
		int n;
		set = *pSet;
ExtendSet:
		while( (size_t)set->nUsed == (size_t)maxcnt )
		{
			if( !set->next )
			{
				PGENERICSET newset;
				if( pSetSet )
				{
					newset = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
				else
				{
					newset = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
					//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
					MemSet( newset, 0, setsizea );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
#if 1
				if( ( newset->next = (*pSet) ) )
				{
					newset->next->me = &newset->next;
				}
				// insert newset at nead of list - then next time through
				// free ones are the first checked...
				(*(newset->me = pSet)) = newset;
#else
				set->next = newset;
				newset->me = &set->next;
#endif
				set = newset;
				// new, empty set, it's going to fail nUsed == maxcnt
				break;
			}
			else
			{
				if( set->nBias > maxbias )
					maxbias = set->nBias;
			}
			set = set->next;
		}
		while( !unit && set )
		{
			uintptr_t base = ( (uintptr_t)set->bUsed ) + ofs;
			// quick skip for 32 bit blocks of used members...
			n = 0;
			for( n = 0; n < maxcnt && ((maxcnt-n) >= 32) && AllUsed( set,n ); n+=32 );
			if( n == maxcnt )
			{
				// occastionally the 'nUsed' counter may not be in sync with actual usage.
				// this set, after inspecing the bitmasks is actually full.   Update
				// the usage counter and go back up to where the set gets extended.
				set->nUsed = n;
				goto ExtendSet;
			}
 /*n = n*/
			for(; n < maxcnt; n++ )
			{
				if( !IsUsed( set, n ) )
				{
 // go to the appropriate offset
					unit = (void*)( base + n * unitsize );
					SetUsed( set, n );
					return (PGENERICSET)unit;
				}
			}
			if( n == maxcnt )
			{
				if( !set->next ) {
					// synchronize this; obviusly every member IS used.
					set->nUsed = n;
 // for some reason didn't find anything; maybe it's a small set of less than 32 elements?
					goto ExtendSet;
				}
				set = set->next;
			}
		}
#ifdef Z_DEBUG
		if( bLog ) _lprintf( DBG_RELAY )( "Unit result: %p from %p %d %d %d %d", unit, set, unitsize, maxcnt, n, ( ( (maxcnt +(FLAGSET_MIN_SIZE-1))) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8) )  );
#endif
	}
	return (PGENERICSET)unit;
}
//----------------------------------------------------------------------------
void *GetFromSetEx( GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS )
{
	return GetFromSetPoolEx( NULL, 0, 0, 0
								  , pSet, setsizea, unitsize, maxcnt DBG_RELAY );
}
static POINTER GetSetMemberExx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt, int *bUsed DBG_PASS )
{
	PGENERICSET set;
	uint32_t maxbias = 0;
	if( nMember == INVALID_INDEX )
		return NULL;
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		set = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
		//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
		MemSet( set, 0, setsize );
		set->nBias = 0;
		*pSet = set;
	}
	else
		set = (*pSet );
	while( 1 )
	{
		if( nMember >= set->nBias &&
			nMember < ( set->nBias + maxcnt ) )
		{
			nMember -= set->nBias;
			break;
		}
		if( !set->next )
		{
			PGENERICSET newset = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
			//Log4( "Allocating a Set for %d elements sized %d total %d %08x", maxcnt, unitsize, setsize, set );
			MemSet( newset, 0, setsize );
			if( set->nBias > maxbias )
				maxbias = set->nBias;
			newset->nBias = maxbias + maxcnt;
			set->next = newset;
			newset->me = &set->next;
		}
		else
		{
			if( set->nBias > maxbias )
				maxbias = set->nBias;
		}
		//nMember -= maxcnt;
		set = set->next;
	}
	if( !IsUsed( set, nMember ) )
		(*bUsed) = 0;
	else
		(*bUsed) = 1;
	if( bLog ) _lprintf(DBG_RELAY)( "Resulting unit %" _PTRSZVALfs,  ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +(FLAGSET_MIN_SIZE-1)) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8) )
						+ nMember * unitsize );
	return (void*)( ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +(FLAGSET_MIN_SIZE-1)) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8) )
 // go to the appropriate offset
						+ nMember * unitsize );
}
//----------------------------------------------------------------------------
POINTER GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		return NULL;
	return result;
}
//----------------------------------------------------------------------------
POINTER GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	if( nMember == INVALID_INDEX )
		return NULL;
	//if( nMember > 1000 )
	//	DebugBreak();
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		SetUsed( *pSet, nMember );
	return result;
}
//----------------------------------------------------------------------------
#undef GetMemberIndex
INDEX GetMemberIndex(GENERICSET **ppSet, POINTER unit, int unitsize, int max )
{
	GENERICSET *pSet = ppSet?*ppSet:NULL;
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + (FLAGSET_MIN_SIZE-1) ) / FLAGSET_MIN_SIZE) * (FLAGSET_MIN_SIZE/8);
	//int base = 0;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %" _PTRSZVALfs " of %d", n % unitsize, unitsize );
				DebugBreak();
				return INVALID_INDEX;
			}
			n /= unitsize;
			return (INDEX)(n + pSet->nBias);
		}
		//base += max;
		pSet = pSet->next;
	}
	return INVALID_INDEX;
}
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
//----------------------------------------------------------------------------
#undef MemberValidInSet
int MemberValidInSet( GENERICSET *pSet, void *unit, int unitsize, int max )
{
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + (FLAGSET_MIN_SIZE-1) ) / FLAGSET_MIN_SIZE) * (FLAGSET_MIN_SIZE/8);
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %" _PTRSZVALfs " of %d", n % unitsize, unitsize );
				DebugBreak();
				return FALSE;
			}
			n /= unitsize;
			return IsUsed( pSet, n );
		}
		pSet = pSet->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void DeleteFromSetExx( GENERICSET *pSet, void *unit, int unitsize, int max DBG_PASS )
{
	uintptr_t nUnit = (uintptr_t)unit;
	uintptr_t ofs = ( ( max + (FLAGSET_MIN_SIZE-1) ) / FLAGSET_MIN_SIZE) * (FLAGSET_MIN_SIZE/8);
	uintptr_t base;
	//if( bLog )
	//if( pSet && ((pSet)->nBias > 1000) )
	//	_lprintf(DBG_RELAY)( "Deleting from  %p of %p ", pSet, unit );
	while( pSet )
	{
		base = ( (uintptr_t)( pSet->bUsed ) + ofs );
		if( (nUnit >= base) &&
		    (nUnit < ( base + unitsize*max )) )
		{
			uintptr_t n = nUnit - base;
#ifdef Z_DEBUG
			if( n % unitsize )
			{
				lprintf( "Error in set member alignment! %p %p %p  %d %"_PTRSZVALfs " %"_PTRSZVALfs " of %d"
						 , unit
						 , pSet
						 , &pSet->bUsed
						, ofs
						 , n, n % unitsize, unitsize );
				DebugBreak();
				return;
			}
#endif
			n /= unitsize;
			ClearUsed( pSet, n );
			break;
		}
		pSet = pSet->next;
	}
#ifdef Z_DEBUG
	if( !pSet )
		Log( "Failed to find node in set!" );
#endif
}
//----------------------------------------------------------------------------
void DeleteSetMemberEx( GENERICSET *pSet, INDEX iMember, uintptr_t unitsize, INDEX max )
{
	//Log2( "Deleting from  %08x of %08x ", pSet, iMember );
	while( pSet )
	{
		if( iMember >= max )
		{
			iMember -= max;
			pSet = pSet->next;
			continue;
		}
		break;
	}
	if( pSet )
	{
		if( !IsUsed( pSet, iMember ) )
		{
			DebugBreak();
			lprintf( "Deleting set member which is already released? not decrementing used counter" );
		}
		else
		{
			ClearUsed( pSet, iMember );
			//pSet->nUsed--; // one not used - quick reference counter
		}
	}
	else
		Log( "Failed to find node in set!" );
}
#undef DeleteSetMember
void DeleteSetMember( GENERICSET *pSet, INDEX iMember, int unitsize, int max )
{
	DeleteSetMemberEx( pSet, iMember, unitsize, max );
}
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
//----------------------------------------------------------------------------
int CountUsedInSetEx( GENERICSET *pSet, int max )
{
	int cnt = 0, n;
	while( pSet )
	{
		for( n = 0; n < max; n++ )
			if( IsUsed( pSet, n ) )
				cnt++;
		pSet = pSet->next;
	}
	return cnt;
}
//----------------------------------------------------------------------------
void **GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max )
{
	void  **array;
	int items, cnt, n, ofs;
	INDEX nMin, nNewMin;
	GENERICSET *pCur;
 // useless initialization.  nNewMin will be set if this is valid; and there was no error generated for using THAT uninitialized.
	GENERICSET *pNewMin = NULL;
	//Log2( "Building Array unit size: %d(%08x)", unitsize, unitsize );
	items = CountUsedInSetEx( pSet, max );
	if( pCount )
		*pCount = items;
	ofs = ( ( max + (FLAGSET_MIN_SIZE-1)) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8);
	array = (void**)Allocate( sizeof( void* ) * items );
 // 0
	nMin = 0;
	do
	{
		pCur = pSet;
 // 0xFFFFFFFF (max)
		nNewMin = INVALID_INDEX;
		while( pCur )
		{
			// maybe instead of ordering elements
			// by ID - order by physical memory?
			// that allows findinarray to work better...
			if( (uintptr_t)pCur->nBias < nNewMin &&
				 (uintptr_t)pCur->nBias >= nMin )
			{
				pNewMin = pCur;
				nNewMin = pCur->nBias;
			}
			pCur = pCur->next;
		}
		if( (uintptr_t)nNewMin != INVALID_INDEX )
		{
			cnt = 0;
			for( n = 0; n < max; n++ )
				if( IsUsed( pNewMin, n ) )
				{
					array[cnt] = (void*)( ((uintptr_t)(pNewMin->bUsed))
												  + ofs
												  + n * unitsize );
					cnt++;
				}
		}
		nMin = nNewMin+1;
	}while( nNewMin != INVALID_INDEX );
	return array;
}
//----------------------------------------------------------------------------
void *StoreSetIntoEx( GENERICSET *pSet, void*unit, int unitsize, int max )
{
   // get a byte countable pointer
	uint8_t    *array = (uint8_t*)unit;
	int cnt, n, ofs;
	INDEX nMin, nNewMin;
	GENERICSET *pCur;
 // useless initialization.  nNewMin will be set if this is valid; and there was no error generated for using THAT uninitialized.
	GENERICSET *pNewMin = NULL;
	ofs = ( ( max + (FLAGSET_MIN_SIZE-1)) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8);
 // 0
	nMin = 0;
	uint8_t *base;
	  cnt = 0;
	do
	{
		pCur = pSet;
 // 0xFFFFFFFF (max)
		nNewMin = INVALID_INDEX;
		while( pCur )
		{
			if( (uintptr_t)pCur->nBias < nNewMin &&
				 (uintptr_t)pCur->nBias >= nMin )
			{
				pNewMin = pCur;
				nNewMin = pCur->nBias;
			}
			pCur = pCur->next;
		}
		if( (uintptr_t)nNewMin != INVALID_INDEX )
		{
			do {
				base = ((uint8_t*)pNewMin->bUsed) + ofs;
				for( n = 0; n < max; n++ )
					if( IsUsed( pNewMin, n ) )
					{
						memcpy( array+cnt*unitsize, base + n*unitsize, unitsize );
						cnt++;
					}
				nMin = nNewMin+1;
				// check if the next block is the continued bias
				if( pNewMin != pSet && ((GENERICSET *)pNewMin->me )->nBias == nMin ) {
					pNewMin = (GENERICSET *)pNewMin->me;
					nNewMin = pNewMin->nBias;
					continue;
				}
				break;
			} while(1);
		}
	}while( nNewMin != INVALID_INDEX );
	return array;
}
//----------------------------------------------------------------------------
int FindInArray( void **pArray, int nArraySize, void *unit )
{
	//int32_t idx;
	if( pArray )
	{
		int i, j, m;
		uintptr_t psvUnit, psvArray;
		i = 0;
		j = nArraySize-1;
		psvUnit = (uintptr_t)unit;
		do
		{
			m = (i+j)/2;
			psvArray = (uintptr_t)pArray[m];
			if( psvUnit < psvArray )
				j = m - 1;
			else if( psvUnit > psvArray )
				i = m + 1;
			else
				break;
		}
		while( i <= j );
		if( i > j )
			return -1;
		return m;
	}
	return -1;
}
//----------------------------------------------------------------------------
uintptr_t _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv )
{
	//Log2( "Doing all in set - size: %d setsize: %d", unitsize, max );
	if( f )
	{
		int ofs, n;
		ofs = ( ( max + (FLAGSET_MIN_SIZE-1)) / FLAGSET_MIN_SIZE ) * (FLAGSET_MIN_SIZE/8);
		while( pSet )
		{
			for( n = 0; n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					psvReturn = f( (void*)( ((uintptr_t)(pSet->bUsed))
											  + ofs
											  + n * unitsize ), psv );
					if( psvReturn )
					{
						//Log( "Return short? ");
						return psvReturn;
					}
				}
			pSet = pSet->next;
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
#undef ForEachSetMember
uintptr_t ForEachSetMember( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv )
{
	//Log2( "Doing all in set - size: %d setsize: %d", unitsize, max );
	if( f )
	{
		int total = 0;
		int n;
		while( pSet )
		{
			int nFound = 0;
			for( n = 0; nFound < (int)pSet->nUsed && n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					nFound++;
					psvReturn = f( total+n, psv );
					if( psvReturn )
					{
						//Log( "Return short? ");
						return psvReturn;
					}
				}
			total += n;
			pSet = pSet->next;
		}
	}
	return 0;
}
#ifdef __cplusplus
//	namespace sets {
	}
 //	namespace containers {
	}
 //namespace sack {
}
#endif
// $Log: sets.c,v $
// Revision 1.15  2005/05/20 21:47:10  jim
// Add base to get member index... so we don't get index of member in a set, but the actual index of the member in order... also fix a spot of set slab linking.  Also, fix resulting of the member for an index...
//
// Revision 1.14  2005/05/18 21:19:32  jim
// Define a method which will only get a valid set member from a set.
//
// Revision 1.13  2005/03/07 12:53:15  panther
// Only check what's used in a set instead of all memebers.
//
// Revision 1.12  2005/02/09 22:40:22  panther
// allow timers library to steal sets code....
//
// Revision 1.11  2005/02/04 19:25:30  panther
// Added iterator for sets that's a little different
//
// Revision 1.10  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.9  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.8  2004/10/04 03:56:26  d3x0r
// protect against null array passed to find_in_array
//
// Revision 1.7  2004/02/18 20:47:04  d3x0r
// Undef MemberInSet
//
// Revision 1.6  2004/02/14 01:19:04  d3x0r
// Extensions of Set structure in containers, C++ interface extension
//
// Revision 1.5  2003/04/11 16:03:53  panther
// Added  LogN for gcc.  Fixed set code to search for first available instead of add at end always.  Added MKCFLAGS MKLDFLAGS for lnx makes.
// Fixed target of APP_DEFAULT_DATA.
// Updated display to use a meta buffer between for soft cursors.
//
// Revision 1.4  2003/03/25 09:37:58  panther
// Fix file tails mangled by CVS logging
//
// Revision 1.3  2003/03/25 08:45:58  panther
// Added CVS logging tag
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree container storing a user pointer blob of some user defined structure
 *   and a uintptr_t key which is used to check for content matchin.
 *   Binary tree has algorithms to become balanced, if the input is known to be weighted,
 *   or if statistics are pulled that indicate that the tree should be balanced, this
 *   function is available on demand.  Also searching through the tree using
 *   Least, Greatest, lesser, and greater is available.
 *
 * see also - include/typelib.h
 *
 */
//#define DEFINE_BINARYLIST_PERF_COUNTERS
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
#endif
//#include <sack_types.h>
//#include <sharemem.h>
//#include <logging.h>
//#define DEBUG_STEPPING
#ifdef __cplusplus
namespace sack {
	namespace containers {
		namespace BinaryTree {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
// consider slab allocation... 32 bytes even.
struct treenode_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
	} flags;
	int depth;
  // required to know how many nodes are in the tree; especially with branch transplants.
	int children;
	CPOINTER userdata;
	uintptr_t key;
	struct treenode_tag *lesser;
	struct treenode_tag *greater;
	struct treenode_tag **me;
	struct treenode_tag *parent;
};
typedef struct treenode_tag TREENODE;
#define MAXTREENODESPERSET 4096
DeclareSet( TREENODE );
typedef struct treeroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // tree points to the real TREEROOT (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	int depth;
	int children;
	uint32_t lock;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	int maxHeights[30];
	int maxSwaps[10];
	int maxScans;
	int balancedFromLeft;
	int balancedFromRight;
#endif
	GenericDestroy Destroy;
	GenericCompare Compare;
	PTREENODE tree;
	PTREENODE prior, current, lastfound;
} TREEROOT;
static PTREENODESET TreeNodeSet;
//---------------------------------------------------------------------------
#define MAXTREEROOTSPERSET 128
DeclareSet( TREEROOT );
static PTREEROOTSET treepool;
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from );
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from );
//---------------------------------------------------------------------------
PTREEROOT FindTreeRoot( PTREENODE node )
{
	while( node && (!node->flags.bRoot) && node->parent )
	{
		node = node->parent;
	}
	return (PTREEROOT)node;
}
//---------------------------------------------------------------------------
int CPROC BinaryCompareInt( uintptr_t old, uintptr_t new_key )
{
	if( old > new_key )
		return 1;
	else if( old < new_key )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
void BalanceBinaryTree( PTREEROOT root )
{
#if SACK_BINARYLIST_USE_CHILD_COUNTS
	while( LockedExchange( &root->lock, 1 ) )
		Relinquish();
	while( BalanceBinaryBranch( root->tree ) > 1 && 0);
	root->lock = 0;
#endif
	//Log( "=========" );;
}
//---------------------------------------------------------------------------
#ifdef DEBUG_AVL_VALIDATION
//-------------------------------------------------------------------------- -
void ValidateTreeNode( PTREENODE node ) {
	if( node->parent && !node->parent->flags.bRoot ) {
		if( node->parent->children != ( ( node->parent->lesser ? ( node->parent->lesser->children + 1 ) : 0 )
			+ ( node->parent->greater ? ( node->parent->greater->children + 1 ) : 0 )
			) ) {
			lprintf( "child account is failed." );
			DebugBreak();
		}
		if( node->parent->depth <= node->depth ) {
			lprintf( "Depth tracking is failure." );
			DebugBreak();
		}
		else if( ( node->parent->depth - node->depth ) > 2 ) {
			lprintf( "Depth tracking is failure(2)." );
			DebugBreak();
		}
		if( node->parent->lesser != node && node->parent->greater != node ) {
			lprintf( "My parent is not pointing at me." );
			DebugBreak();
		}
	}
	if( node->lesser ) {
		if( node->lesser->parent != node ) {
			lprintf( "My Lesser does not point back to me as a parent." );
			DebugBreak();
		}
		ValidateTreeNode( node->lesser );
	}
	if( node->greater ) {
		if( node->greater->parent != node ) {
			lprintf( "My Greater does not point back to me as a parent." );
			DebugBreak();
		}
		ValidateTreeNode( node->greater );
	}
}
//-------------------------------------------------------------------------- -
void ValidateTree( PTREEROOT root ) {
	//lprintf( "--------------------------- VALIDATE TREE -----------------------------" );
	//DumpTree( root, NULL );
	ValidateTreeNode( root->tree );
}
#endif
//---------------------------------------------------------------------------
//static PTREENODE AVL_RotateToRight( PTREENODE node )
                                    /*lprintf( "RTR %p %p %p", node, left, T2 );     */
	                                                                                                              /* Perform rotation*/
	                                                                                                   /* Update heights */
#define AVL_RotateToRight(node)                                          {	                                                                        PTREENODE left = node->lesser;	                                   PTREENODE T2 = left->greater;	                   node->children -= (left->children + 1);	                                                                                                   node->me[0] = left;	                                              left->me = node->me;	                                             left->parent = node->parent;	                                            left->greater = node;	                                            node->me = &left->greater;	                                       node->parent = left;	                                                                                                                      node->lesser = T2;	                                               if( T2 ) {		                                                       T2->me = &node->lesser;		                                  T2->parent = node;		                                       node->children += (T2->children + 1);		         left->children -= (T2->children + 1);	         }	                                                                left->children += (node->children + 1);	                                             {		                                                                int leftDepth, rightDepth;		                               leftDepth = node->lesser ? node->lesser->depth : 0;		      rightDepth = node->greater ? node->greater->depth : 0;		   if( leftDepth > rightDepth )			                             node->depth = leftDepth + 1;		                     else			                                                     node->depth = rightDepth + 1;		                                                                                             leftDepth = left->lesser ? left->lesser->depth : 0;		      rightDepth = left->greater ? left->greater->depth : 0;		   if( leftDepth > rightDepth ) {			                           left->depth = leftDepth + 1;		                     }		                                                        else			                                                     left->depth = rightDepth + 1;	                    }                                                                }
//---------------------------------------------------------------------------
//static PTREENODE AVL_RotateToLeft( PTREENODE node )
	                                    /*lprintf( "RTL %p %p %p", node, right, T2 );  */
	                                                                                                             /* Perform rotation  */
	                         /*  Update heights */
#define AVL_RotateToLeft(node)                                           {	                                                                        PTREENODE right = node->greater;	                                 PTREENODE T2 = right->lesser;	                node->children -= (right->children + 1);	                                                                                                  node->me[0] = right;	                                             right->me = node->me;	                                            right->parent = node->parent;	                                          right->lesser = node;	                                            node->me = &right->lesser;	                                       node->parent = right;	                                            node->greater = T2;	                                              if( T2 ) {		                                                       T2->me = &node->greater;		                                 T2->parent = node;		                                       node->children += (T2->children + 1);		         right->children -= (T2->children + 1);	        }	                                                                right->children += (node->children + 1);	                                            {		                                                                int left, rightDepth;		                                    left = node->lesser ? node->lesser->depth : 0;		           rightDepth = node->greater ? node->greater->depth : 0;		   if( left > rightDepth )			                                  node->depth = left + 1;		                          else			                                                     node->depth = rightDepth + 1;		                                                                                             left = right->lesser ? right->lesser->depth : 0;		         rightDepth = right->greater ? right->greater->depth : 0;		 if( left > rightDepth )			                                  right->depth = left + 1;		                         else			                                                     right->depth = rightDepth + 1;	                   }                                                                }
//---------------------------------------------------------------------------
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
int zz;
PRIORITY_PRELOAD( InitReadyToLog, 999 ) {
	zz = 1;
}
#endif
static void AVLbalancer( PTREEROOT root, PTREENODE node ) {
	PTREENODE _x = NULL;
	PTREENODE _y = NULL;
	PTREENODE _z = NULL;
	PTREENODE tmp;
	int leftDepth;
	int rightDepth;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	int height = 0;
	int swaps = 0;
#endif
	_z = node;
	while( _z && !_z->flags.bRoot ) {
		int doBalance;
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
		height++;
#endif
		doBalance = FALSE;
		if( tmp = _z->greater )
			rightDepth = tmp->depth;
		else
			rightDepth = 0;
		if( tmp = _z->lesser )
			leftDepth = tmp->depth;
		else
			leftDepth = 0;
		if( leftDepth > rightDepth ) {
			if( (1 + leftDepth) == _z->depth ) {
				//if( zz )
				//	lprintf( "Stopped checking: %d %d %d", height, leftDepth, rightDepth );
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
				root->balancedFromLeft++;
#endif
				break;
			}
			_z->depth = 1 + leftDepth;
			if( (leftDepth -rightDepth) > 1 ) {
				doBalance = TRUE;
			}
		} else {
			if( (1 + rightDepth) == _z->depth ) {
				//if(zz)
				//	lprintf( "Stopped checking: %d %d %d", height, leftDepth, rightDepth );
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
				root->balancedFromRight++;
#endif
				break;
			}
			_z->depth = 1 + rightDepth;
			if( (rightDepth- leftDepth) > 1 ) {
				doBalance = TRUE;
			}
		}
		if( doBalance ) {
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
			swaps++;
#endif
			if( _x ) {
				if( _x == _y->lesser ) {
					if( _y == _z->lesser ) {
						// left/left
						AVL_RotateToRight( _z );
					}
					else {
						//left/rightDepth
						AVL_RotateToRight( _y );
						AVL_RotateToLeft( _z );
					}
				}
				else {
					if( _y == _z->lesser ) {
						AVL_RotateToLeft( _y );
						AVL_RotateToRight( _z );
						// rightDepth.left
					}
					else {
						//rightDepth/rightDepth
						AVL_RotateToLeft( _z );
					}
				}
			}
			else {
				//lprintf( "Not deep enough for balancing." );
			}
		}
		_x = _y;
		_y = _z;
		_z = _z->parent;
	}
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
	if( !node->parent->flags.bRoot
		&& node->parent->lesser != node
		&& node->parent->greater != node ) {
		*(int*)0 = 0;
	}
	if( height < 31 )
		root->maxHeights[height]++;
	else
		root->maxHeights[0]++;
	if( swaps < 10 )
		root->maxSwaps[swaps]++;
	else
		root->maxSwaps[0]++;
	if( !_z )
		root->maxScans++;
#endif
}
//---------------------------------------------------------------------------
int HangBinaryNode( PTREEROOT root, PTREENODE node )
{
	PTREENODE check;
	if( !node )
		return 0;
	root->children += ( node->children + 1 );
	if( !(root->tree) )
	{
		root->tree = node;
		node->me = &root->tree;
		node->parent = (PTREENODE)root;
#ifdef DEBUG_AVL_VALIDATION
		ValidateTree( root );
#endif
		return 1;
	}
	 check = root->tree;
	 while( check )
	 {
		 int dir = root->Compare( node->key, check->key );
		check->children += (node->children + 1);
		 if( dir < 0 )
		 {
			 if( check->lesser )
			 {
				 check = check->lesser;
			 }
			else
			{
				check->lesser = node;
				node->me = &check->lesser;
				node->parent = check;
				break;
			}
		 }
		 else if( dir > 0 )
			 if( check->greater )
			 {
				 check = check->greater;
			 }
			else
			{
				check->greater = node;
				node->me = &check->greater;
				node->parent = check;
				break;
			}
		else if( root->flags.bNoDuplicate )
		{
			while( check && !check->flags.bRoot )
			{
				check->children -= (node->children + 1);
				check = check->parent;
			}
			if( check )
				check->children -= (node->children + 1);
			DeleteFromSet( TREENODE, TreeNodeSet, node );
			return 0;
		}
		else
		{
			// allow duplicates; but link in as a near node, either left
			// or right... depending on the depth.
			int leftdepth = 0, rightdepth = 0;
			if( check->lesser )
				leftdepth = check->lesser->depth;
			if( check->greater )
				rightdepth = check->greater->depth;
			if( leftdepth < rightdepth )
			{
				if( check->lesser )
					check = check->lesser;
				else
				{
					check->lesser = node;
					node->me = &check->lesser;
					node->parent = check;
					break;
				}
			}
			else
			{
				if( check->greater )
					check = check->greater;
				else
				{
					check->greater = node;
					node->me = &check->greater;
					node->parent = check;
					break;
				}
			}
		}
	}
	if( node->parent->lesser != node && node->parent->greater != node ) {
#ifdef __clang__
		__builtin_trap();
#else
		*(int*)0 = 0;
#endif
	}
	AVLbalancer( root, node );
#ifdef DEBUG_AVL_VALIDATION
	ValidateTree( root );
#endif
	return 1;
}
//---------------------------------------------------------------------------
int AddBinaryNodeEx( PTREEROOT root
                   , CPOINTER userdata
                   , uintptr_t key DBG_PASS )
{
	PTREENODE node;
	if( !root )
		return 0;
//AllocateEx( sizeof( TREENODE ) DBG_RELAY );
	node = GetFromSet( TREENODE, &TreeNodeSet );
	node->lesser = NULL;
	node->greater = NULL;
	node->me = NULL;
	node->children = 0;
	node->depth = 0;
	node->userdata = userdata;
	node->key = key;
	node->flags.bUsed = 1;
	node->flags.bRoot = 0;
	return HangBinaryNode( root, node );
}
#undef AddBinaryNode
int AddBinaryNode( PTREEROOT root
                 , CPOINTER userdata
                 , uintptr_t key )
{
	return AddBinaryNodeEx( root, userdata, key DBG_SRC );
}
//---------------------------------------------------------------------------
static void NativeRemoveBinaryNode( PTREEROOT root, PTREENODE node )
{
	if( root )
	{
		CPOINTER userdata = node->userdata;
		uintptr_t userkey = node->key;
		LOGICAL no_children = FALSE;
		// lprintf( "Removing node from tree.. %p under %p", node, node->parent );
		if( !node->parent->flags.bRoot
			&& node->parent->lesser != node
			&& node->parent->greater != node ) {
#ifdef __clang__
			__builtin_trap();
#else
			*(int*)0=0;
#endif
		}
		PTREENODE least = NULL;
		PTREENODE backtrack;
  // deepest node a change was made on.
		PTREENODE bottom;
		if( !node->lesser ) {
			if( node->greater ) {
				bottom = (*node->me) = node->greater;
				bottom->parent = node->parent;
			} else {
				(*node->me) = NULL;
				bottom = node;
				no_children = TRUE;
			}
		} else if( !node->greater ) {
			bottom = (*node->me) = node->lesser;
			bottom->parent = node->parent;
		} else {
			node->children--;
			bottom = node;
			// have a lesser and a greater.
			if( node->lesser->depth > node->greater->depth ) {
				least = node->lesser;
				while( least->greater ) { bottom = least; least = least->greater; }
				if( least->lesser ) {
					(*(least->lesser->me =least->me)) = least->lesser;
					least->lesser->parent  = least->parent;
				} else {
					(*(least->me)) = NULL;
				}
			} else {
				least = node->greater;
				while( least->lesser ) { bottom = least; least = least->lesser; }
				if( least->greater ) {
					(*(least->greater->me = least->me)) = least->greater;
					least->greater->parent  = least->parent;
				} else {
					(*(least->me)) = NULL;
				}
			}
		}
		{
			LOGICAL updating = 1;
			backtrack = bottom;
			do {
				backtrack = backtrack->parent;
				while( backtrack && ( no_children || backtrack != node ) ) {
					backtrack->children--;
					if( updating )
						if( backtrack->lesser )
							if( backtrack->greater ) {
								int tmp1, tmp2;
/*, x_*/
								PTREENODE z_, y_;
								if( (tmp1=backtrack->lesser->depth) > (tmp2=backtrack->greater->depth) ) {
									if( backtrack->depth != ( tmp1 + 1 ) )
										backtrack->depth = tmp1 + 1;
									else
										updating = 0;
									if( (tmp1-tmp2) > 1 ) {
										// unblanced here...
										int tmp3, tmp4;
										tmp3 = backtrack->lesser->lesser?backtrack->lesser->lesser->depth:0;
										tmp4 = backtrack->lesser->greater?backtrack->lesser->greater->depth:0;
										z_ = backtrack;
										y_ = backtrack->lesser;
										if( tmp3 > tmp4 ) {
											//x_ = backtrack->lesser->lesser;
											// left-left Rotate Right(Z)
											AVL_RotateToRight( z_ );
										} else {
											// left-right
											//x_ = backtrack->lesser->greater;
											AVL_RotateToLeft( y_ );
											AVL_RotateToRight( z_ );
										}
									}
								} else {
									if( backtrack->depth != ( tmp2 + 1 ) )
										backtrack->depth = tmp2 + 1;
									else
										updating = 0;
									if( (tmp2-tmp1) > 1 ) {
										// unblanced here...
										int tmp3, tmp4;
										tmp3 = backtrack->greater->lesser?backtrack->greater->lesser->depth:0;
										tmp4 = backtrack->greater->greater?backtrack->greater->greater->depth:0;
										z_ = backtrack;
										y_ = backtrack->greater;
										if( tmp4 > tmp3 ) {
											//x_ = y_->greater;
											// right-right Rotate Right(Z)
											AVL_RotateToLeft( y_ );
										} else {
											// right-left
											//x_ = y_->lesser;
											AVL_RotateToRight( y_ );
											AVL_RotateToLeft( z_ );
										}
									}
								}
							} else
									if( backtrack->depth != ( backtrack->lesser->depth + 1 ) )
										backtrack->depth = backtrack->lesser->depth + 1;
									else
										updating = 0;
						else
							if( backtrack->greater )
									if( backtrack->depth != ( backtrack->greater->depth + 1 ) )
										backtrack->depth = backtrack->greater->depth + 1;
									else
										updating = 0;
							else
									if( backtrack->depth != 0 )
										backtrack->depth = 0;
									else
										updating = 0;
					backtrack = backtrack->parent;
				}
				if( least ) {
					node->userdata = least->userdata;
					node->key      = least->key;
					DeleteFromSet( TREENODE, TreeNodeSet, least );
					node   = NULL;
					least  = NULL;
				}
			} while( backtrack );
		}
		AVLbalancer( root, bottom );
		if( root->Destroy )
			root->Destroy( userdata, userkey );
		if( node )
			DeleteFromSet( TREENODE, TreeNodeSet, node );
#ifdef DEBUG_AVL_VALIDATION
		ValidateTree( root );
#endif
		return;
	}
	lprintf( "Fatal RemoveBinaryNode could not find the root!" );
}
//---------------------------------------------------------------------------
 void  RemoveBinaryNode ( PTREEROOT root, POINTER data, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
		{
			if( node->userdata == data )
			{
				NativeRemoveBinaryNode( root, node );
				break;
			}
			else
			{
				// hmm same key different data...
				break;
			}
		}
	}
	return ;
}
//---------------------------------------------------------------------------
void ResetBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
}
//---------------------------------------------------------------------------
static void DestroyBinaryTreeNode( PTREEROOT root, PTREENODE node )
{
	if( node ) {
		if( node->lesser )
			DestroyBinaryTreeNode( root, node->lesser );
		if( node->greater )
			DestroyBinaryTreeNode( root, node->greater );
		if( root->Destroy )
			root->Destroy( node->userdata, node->key );
		DeleteFromSet( TREENODE, TreeNodeSet, node );
	}
}
void DestroyBinaryTree( PTREEROOT root )
{
	DestroyBinaryTreeNode( root, root->tree );
	DeleteFromSet( TREEROOT, treepool, root );
}
//---------------------------------------------------------------------------
PTREEROOT CreateBinaryTreeExtended( uint32_t flags
									  , GenericCompare Compare
									  , GenericDestroy Destroy DBG_PASS )
{
	PTREEROOT root;
//(PTREEROOT)AllocateEx( sizeof( TREEROOT ) DBG_RELAY );
	root = GetFromSet( TREEROOT, &treepool );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	if( flags & BT_OPT_NODUPLICATES  )
		root->flags.bNoDuplicate = 1;
	root->Destroy = Destroy;
	//root->return  = NULL; // upgoing... (return from rightDepth )
	if( Compare )
		root->Compare = Compare;
	else
		root->Compare = BinaryCompareInt;
	return root;
}
#undef CreateBinaryTreeEx
PTREEROOT CreateBinaryTreeEx( GenericCompare Compare
								    , GenericDestroy Destroy )
{
	return CreateBinaryTreeExx( 0, Compare, Destroy );
}
//---------------------------------------------------------------------------
int maxlevel = 0;
void DumpNode( PTREENODE node, int level, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
#endif
	int print;
	if( !node )
		return;
	if( level > maxlevel )
		maxlevel = level;
	DumpNode( node->lesser, level+1, DumpMethod );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print ) {
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
		snprintf( buf, 256, "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
		puts( buf );
#else
		lprintf( "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
#endif
	}
	DumpNode( node->greater, level+1, DumpMethod );
}
//---------------------------------------------------------------------------
#ifdef DEFINE_BINARYLIST_PERF_COUNTERS
PUBLIC( void, GetTreePerf )( PTREEROOT root, int **heights, int **swaps, int *maxScans, int*bfl, int *bfr ) {
	if( heights ) heights[0] = root->maxHeights;
	if( swaps ) swaps[0] = root->maxSwaps;
	if( maxScans ) maxScans[0] = root->maxScans;
	if( bfl ) bfl[0] = root->balancedFromLeft;
	if( bfr ) bfr[0] = root->balancedFromRight;
}
#endif
void DumpTree( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
	maxlevel = 0;
	if( !Dump ) {
		snprintf( buf, 256, "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
		puts( buf );
	}
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) {
		snprintf( buf, 256, "Tree had %d levels.", maxlevel );
		puts( buf );
	}
	fflush( stdout );
#else
	maxlevel = 0;
	if( !Dump ) {
		lprintf(  "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
	}
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) {
		lprintf( "Tree had %d levels.", maxlevel );
	}
#endif
}
//---------------------------------------------------------------------------
void DumpNodeInOrder( PLINKQUEUE *queue, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
	PTREENODE node;
	while( node = (PTREENODE)DequeLink( queue ) )
	{
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
#endif
	int print;
	if( !node )
		return;
	if( node->lesser )
		EnqueLink( queue, node->lesser );
	if( node->greater )
		EnqueLink( queue, node->greater );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print ) {
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
		snprintf( buf, 256, "[%3d] %p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, level, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
		puts( buf );
#else
		lprintf( "%p Node has %3d depth  %3" _32f " children (%p %3" _32f ",%p %3" _32f "). %10" _PTRSZVALfs
			, node, node->depth, node->children
			, node->lesser
			, (node->lesser) ? (node->lesser->children + 1) : 0
			, node->greater
			, (node->greater) ? (node->greater->children + 1) : 0
			, node->key
		);
#endif
	}
	}
}
//---------------------------------------------------------------------------
void DumpInOrder( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
	PLINKQUEUE plq = CreateLinkQueue();
	EnqueLink( &plq, root->tree );
#ifdef SACK_BINARYLIST_USE_PRIMITIVE_LOGGING
	static char buf[256];
	if( !Dump ) {
		snprintf( buf, 256, "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
		puts( buf );
	}
	DumpNodeInOrder( &plq, root->tree, 1, Dump );
	fflush( stdout );
#else
	maxlevel = 0;
	if( !Dump ) {
		lprintf(  "Tree %p has %" _32f " nodes. %p is root", root, root->children, root->tree );
	}
	DumpNodeInOrder( &plq, Dump );
#endif
}
//---------------------------------------------------------------------------
CPOINTER FindInBinaryTree( PTREEROOT root, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return 0;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
int CPROC TextMatchLocate( uintptr_t key1, uintptr_t key2 )
{
	size_t k1len = StrLen( (CTEXTSTR)key1 );
	size_t k2len = StrLen( (CTEXTSTR)key2 );
	//lprintf( "COmpare %s(%d) vs %s(%d)", key1, k1len, key2, k2len );
	if( k2len < k1len )
	{
		// cannot match this.... but should
		// try to choose a direction
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k2len );
		if( dir == 0 )
			return 101;
		if( dir > 0 )
			return 1;
		return -1;
	}
	else if( k2len > k1len )
	{
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k1len );
		// is exact match, but only part of key2
		if( dir == 0 )
			return 100;
		// I doubt these will really matter...
		// could compute distance...
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
	else
	{
		int dir = StrCaseCmp( (CTEXTSTR)key1, (CTEXTSTR)key2 );
		if( dir == 0 )
			return 0;
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
}
// the key value passed does not have to be the same as the key in the tree
// it can be an abstrat reference of a strucutre that contains a key for the tree
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
CPOINTER LocateInBinaryTree( PTREEROOT root, uintptr_t key
                           , int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key )
                           )
{
	PTREENODE node;
	node = root->tree;
	if( !fuzzy )
		fuzzy = TextMatchLocate;
	while( node )
	{
		int _dir;
		int dir = fuzzy( key, node->key );
		if( dir == 100 || dir == 101 )
		{
			PTREENODE one_up;
			PTREENODE one_down;
			// this matched, in an inexact length.
			// to be really careful we should match one up and one down.
			// well, we'll match better only if we had exact length
			// so - go up one node, until we find exact length
			//lprintf( " - Found a near match..." );
			one_up = node;
			one_down = node;
			_dir = dir;
			do
			{
				GetLesserNodeExx( root, &one_up );
				if( one_up )
				{
					dir = fuzzy( key, one_up->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_up;
						return (one_up->userdata);
					}
					else
						one_up = NULL;
				}
				GetGreaterNodeExx( root, &one_down );
				if( one_down )
				{
					dir = fuzzy( key, one_down->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_down;
						return (one_down->userdata);
					}
					else
						one_down = NULL;
				}
			}
			while( one_up || one_down );
			if( _dir == 101 )
			{
				node = NULL;
			}
			root->lastfound = node;
			if( node )
				return( node->userdata );
			return 0;
		}
		if( dir > 0 )
		{
			node = node->greater;
		}
		else if( dir < 0 )
		{
			node = node->lesser;
		}
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
CPOINTER GetCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return NULL;
	return (*(struct treenode_tag **)cursor)->userdata;
}
CPOINTER GetCurrentNode( PTREEROOT root )
{
	return GetCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
void RemoveLastFoundNode( PTREEROOT root )
{
	if( !root || !root->lastfound )
		return;
	NativeRemoveBinaryNode( root, root->lastfound );
}
//---------------------------------------------------------------------------
void RemoveCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return;
	NativeRemoveBinaryNode( root, (PTREENODE)(*cursor) );
	(*cursor) = NULL;
}
void RemoveCurrentNode( PTREEROOT root )
{
	RemoveCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->greater && !(*from)->lesser )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->greater )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->greater )
	{
		// right
		(*from) = (*from)->greater;
		while( (*from)->lesser )
		{
			// Left
			(*from) = (*from)->lesser;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->greater == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetGreaterNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetGreaterNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetGreaterNode( PTREEROOT root )
{
	return GetGreaterNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->lesser && !(*from)->greater )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->lesser )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->lesser )
	{
		// right
		(*from) = (*from)->lesser;
		while( (*from)->greater )
		{
			// Left
			(*from) = (*from)->greater;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->lesser == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetLesserNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetLesserNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetLesserNode( PTREEROOT root )
{
	return GetLesserNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLeastNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	(*(struct treenode_tag **)cursor) = root->tree;
	root->prior = NULL;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->lesser )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetLeastNode( PTREEROOT root )
{
	return GetLeastNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreatestNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->greater )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetGreatestNode( PTREEROOT root )
{
	return GetGreatestNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetRootNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetRootNode( PTREEROOT root )
{
	return GetRootNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetParentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( !(*(struct treenode_tag **)cursor)->parent->flags.bRoot )
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->parent;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetParentNode( PTREEROOT root )
{
	return GetParentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( direction < 0 )
		{
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
		}
		else
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetChildNode( PTREEROOT root, int direction )
{
	return GetChildNodeEx( root, (POINTER*)&root->current, direction );
}
//---------------------------------------------------------------------------
CPOINTER GetPriorNodeEx( PTREEROOT root, POINTER *cursor )
{
	PTREENODE cur;
	if( !root ) return 0;
	cur = (*(struct treenode_tag **)cursor);
	(*(struct treenode_tag **)cursor) = root->prior;
	root->prior = cur;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetPriorNode( PTREEROOT root )
{
	return GetPriorNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
int GetNodeCount( PTREEROOT root )
{
	return root->children;
}
//---------------------------------------------------------------------------
PTREEROOT ShadowBinaryTree( PTREEROOT Original )
{
	PTREEROOT root;
	Log( "Use of binary tree shadows is fraught with danger!" );
	root = (PTREEROOT)Allocate( sizeof( TREEROOT ) );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	root->flags.bShadow = 1;
	root->children = 0;
	root->depth = 0;
	root->Compare = Original->Compare;
	root->Destroy = Original->Destroy;
	root->tree = Original->tree;
	return root;
}
#ifdef __cplusplus
 // namespace BinaryTree {
}
 //namespace containers {
}
 //namespace sack {
}
#endif
// not really, but close enough
#define HTTP_SOURCE
/* Generalized HTTP Processing. All POST, GET, RESPONSE packets
   all fit within this structure.
                                                                */
#ifndef HTTP_PROCESSING_INCLUDED
/* Multiple inclusion protection symbol */
#define HTTP_PROCESSING_INCLUDED
/* Networking interface to provide an event based dispatcher
   over berkley polled sockets. See <link network>           */
#ifndef NETWORK_HEADER_INCLUDED
#define NETWORK_HEADER_INCLUDED
#ifdef NETWORK_SOURCE
#define NETWORK_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define NETWORK_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _NETWORK_NAMESPACE  namespace network {
#define _NETWORK_NAMESPACE_END }
#define _TCP_NAMESPACE  namespace tcp {
#define _TCP_NAMESPACE_END }
#define USE_TCP_NAMESPACE using namespace tcp;
#define _UDP_NAMESPACE  namespace udp {
#define _UDP_NAMESPACE_END }
#define USE_UDP_NAMESPACE using namespace tcp;
#else
#define _NETWORK_NAMESPACE
#define _NETWORK_NAMESPACE_END
#define _TCP_NAMESPACE
#define _TCP_NAMESPACE_END
#define _UDP_NAMESPACE
#define _UDP_NAMESPACE_END
#define USE_TCP_NAMESPACE
#define USE_UDP_NAMESPACE
#endif
#define SACK_NETWORK_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE
#define SACK_NETWORK_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_TCP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _TCP_NAMESPACE
#define SACK_NETWORK_TCP_NAMESPACE_END _TCP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_UDP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _UDP_NAMESPACE
#define SACK_NETWORK_UDP_NAMESPACE_END _UDP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#ifdef __cplusplus
namespace sack {
#endif
	/* Event based networking interface.
	   Example
	   \Example One : A simple client side application. Reads
	   standard input, and writes it to a server it connects to. Read
	   the network and write as standard output.
	   <code lang="c++">
	   \#include \<network.h\>
	   </code>
	   <code>
	   \#include \<logging.h\>
	   \#include \<sharemem.h\>
	   </code>
	   <code lang="c++">
	   void CPROC ReadComplete( PCLIENT pc, void *bufptr, int sz )
	   {
	      char *buf = (char*)bufptr;
	       if( buf )
	       {
	           buf[sz] = 0;
	           printf( "%s", buf );
	           fflush( stdout );
	       }
	       else
	       {
	           buf = (char*)Allocate( 4097 );
	           //SendTCP( pc, "Yes, I've connected", 12 );
	       }
	       ReadTCP( pc, buf, 4096 );
	   }
	   PCLIENT pc_user;
	   void CPROC Closed( PCLIENT pc )
	   {
	      pc_user = NULL;
	   }
	   int main( int argc, char** argv )
	   {
	       SOCKADDR *sa;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<Telnet IP[:port]\>\\n", argv[0] );
	           return 0;
	       }
	       SystemLog( "Starting the network" );
	       NetworkStart();
	       SystemLog( "Started the network" );
	       sa = CreateSockAddress( argv[1], 23 );
	       pc_user = OpenTCPClientAddrEx( sa, ReadComplete, Closed, NULL, 0 );
	       if( !pc_user )
	       {
	           SystemLog( "Failed to open some port as telnet" );
	           printf( "failed to open %s%s\\n", argv[1], strchr(argv[1],':')?"":":telnet[23]" );
	           return 0;
	       }
	      //SendTCP( pc_user, "Some data here...", 12 );
	       while( pc_user )
	       {
	           char buf[256];
	           if( !fgets( buf, 256, stdin ) )
	           {
	               RemoveClient( pc_user );
	               return 0;
	           }
	           SendTCP( pc_user, buf, strlen( buf ) );
	       }
	       return -1;
	   }
	   </code>
	   \Example Two : A server application, opens a socket that it
	   accepts connections on. Reads the socket, and writes the
	   information it reads back to the socket as an echo.
	   <code lang="c++">
	   \#include \<stdhdrs.h\>
	   \#include \<sharemem.h\>
	   \#include \<timers.h\>
	   \#include \<network.h\>
	   void CPROC ServerRecieve( PCLIENT pc, POINTER buf, int size )
	   {
	       //int bytes;
	       if( !buf )
	       {
	           buf = Allocate( 4096 );
	           //SendTCP( pc, (void*)"Hi, welccome to...", 15 );
	       }
	       //else
	           //SendTCP( pc, buf, size );
	       // test for waitread support...
	       // read will not result until the data is read.
	       //bytes = WaitReadTCP( pc, buf, 4096 );
	       //if( bytes \> 0 )
	       //   SendTCP( pc, buf, bytes );
	       ReadTCP( pc, buf, 4095 );
	       // buffer does not have anything in it....
	   }
	   void CPROC ClientConnected( PCLIENT pListen, PCLIENT pNew )
	   {
	       SetNetworkReadComplete( pNew, ServerRecieve );
	   }
	   int main( int argc, char **argv )
	   {
	       PCLIENT pcListen;
	       SOCKADDR *port;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<listen port\> (defaulting to telnet)\\n", argv[0] );
	           port = CreateSockAddress( "localhost:23", 23 );
	       }
	       else
	           port = CreateSockAddress( argv[1], 23 );
	       NetworkStart();
	       pcListen = OpenTCPListenerAddrEx( port, ClientConnected );
	       if(pcListen)
	           while(1) WakeableSleep( SLEEP_FOREVER );
	       else
	           printf( "Failed to listen on port %s\\n", argv[1] );
	       return 0;
	   }
	   </code>                                                                                    */
#ifdef __cplusplus
	namespace network {
#endif
/*
  Opaque structure representing a network connection.
*/
typedef struct NetworkClient *PCLIENT;
/*
   Get the system name.
*/
NETWORK_PROC( CTEXTSTR, GetSystemName )( void );
/*
  Lock a network connection for read or for write.
*/
NETWORK_PROC( PCLIENT, NetworkLockEx )( PCLIENT pc, int readWrite DBG_PASS );
/*
  Unlock a network connection for read or for write.
*/
NETWORK_PROC( void, NetworkUnlockEx )( PCLIENT pc, int readWrite DBG_PASS );
/* <combine sack::network::NetworkLockEx@PCLIENT pc>
   \ \                                               */
#define NetworkLock(pc,rw) NetworkLockEx( pc,rw DBG_SRC )
/* <combine sack::network::NetworkUnlockEx@PCLIENT pc>
   \ \                                                 */
#define NetworkUnlock(pc,rw) NetworkUnlockEx( pc,rw DBG_SRC )
typedef void (CPROC*cReadComplete)(PCLIENT, POINTER, size_t );
typedef void (CPROC*cReadCompleteEx)(PCLIENT, POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cCloseCallback)(PCLIENT);
typedef void (CPROC*cWriteComplete)(PCLIENT, CPOINTER buffer, size_t len );
typedef void (CPROC*cNotifyCallback)(PCLIENT server, PCLIENT newClient);
typedef void (CPROC*cConnectCallback)(PCLIENT, int);
typedef void (CPROC*cppReadComplete)(uintptr_t, POINTER, size_t );
typedef void (CPROC*cppReadCompleteEx)(uintptr_t,POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cppCloseCallback)(uintptr_t);
typedef void (CPROC*cppWriteComplete)(uintptr_t, CPOINTER buffer, size_t len );
typedef void (CPROC*cppNotifyCallback)(uintptr_t, PCLIENT newClient);
typedef void (CPROC*cppConnectCallback)(uintptr_t, int);
enum NetworkAddressFlags {
	NETWORK_ADDRESS_FLAG_PREFER_NONE = 0,
	NETWORK_ADDRESS_FLAG_PREFER_V6 = 1,
	NETWORK_ADDRESS_FLAG_PREFER_V4 = 2,
};
enum SackNetworkErrorIdentifier {
	SACK_NETWORK_ERROR_,
 // error during control information exchange over TLS
	SACK_NETWORK_ERROR_SSL_HANDSHAKE,
 // error after first packet.
	SACK_NETWORK_ERROR_SSL_HANDSHAKE_2,
 // error verifying validity of certificate chain from server.
	SACK_NETWORK_ERROR_SSL_CERTCHAIN_FAIL,
 // other ssl error
	SACK_NETWORK_ERROR_SSL_FAIL,
 //
	SACK_NETWORK_ERROR_HTTP_CHUNK,
 // command parsing resulted in invalid command.  (HTTPS request to HTTP)
	SACK_NETWORK_ERROR_HTTP_UNSUPPORTED,
 // host name could not be resolved
	SACK_NETWORK_ERROR_HOST_NOT_FOUND,
};
typedef void (CPROC*cErrorCallback)(uintptr_t psvError, PCLIENT pc, enum SackNetworkErrorIdentifier error, ... );
NETWORK_PROC( void, SetNetworkWriteComplete )( PCLIENT, cWriteComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkWriteComplete )( PCLIENT, cppWriteComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
#define SetWriteCallback SetNetworkWriteComplete
NETWORK_PROC( void, SetNetworkReadComplete )( PCLIENT, cReadComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
NETWORK_PROC( void, SetCPPNetworkReadComplete )( PCLIENT, cppReadComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
#define SetReadCallback SetNetworkReadComplete
NETWORK_PROC( void, SetNetworkCloseCallback )( PCLIENT, cCloseCallback );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkCloseCallback )( PCLIENT, cppCloseCallback, uintptr_t );
#endif
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
#define SetCloseCallback SetNetworkCloseCallback
/* Sets an error event callback which is triggered during low level (SSL)
   operations.  Error code passed to callback will give more information.
   Parameters
   pc :              socket to set event handler on
   callback :        Address of error handling callback.
   psvUser :         data passed to callback for application purposes.
*/
NETWORK_PROC( void, SetNetworkErrorCallback )(PCLIENT pc, cErrorCallback callback, uintptr_t psvUser );
/*
   Trigger error callback with specified error code (meta code like http.c can trigger this(?))
   Parameters
   pc :              socket to set event handler on
   code :        Address of error handling callback.
 */
NETWORK_PROC( void, TriggerNetworkErrorCallback )(PCLIENT pc, enum SackNetworkErrorIdentifier error );
 // wwords is BYTES and wClients=16 is defaulted to 16
#ifdef __LINUX__
NETWORK_PROC( LOGICAL, NetworkWait )(POINTER unused,uint32_t wClients,int wUserData);
#else
NETWORK_PROC( LOGICAL, NetworkWait )(HWND hWndNotify,uint32_t wClients,int wUserData);
#endif
/* <combine sack::network::NetworkWait@HWND@uint16_t@int>
   \ \                                               */
#define NetworkStart() NetworkWait( NULL, 0, 0 )
 // returns true if network layer still active...
NETWORK_PROC( LOGICAL, NetworkAlive )( void );
/* Shutdown these network services, stop the network thread, and
   close all sockets open, releasing all internal resources.
   Parameters
   None.                                                         */
NETWORK_PROC( int, NetworkQuit )(void);
// preferred method is to call Idle(); if in doubt.
//NETWORK_PROC( int, ProcessNetworkMessages )( void );
// dwIP would be for 1.2.3.4  (0x01020304 - memory 04 03 02 01) - host order
// VERY RARE!
NETWORK_PROC( SOCKADDR *, CreateAddress_hton )( uint32_t dwIP,uint16_t nHisPort);
// dwIP would be for 1.2.3.4  (0x04030201 - memory 01 02 03 04) - network order
#ifndef WIN32
NETWORK_PROC( SOCKADDR *, CreateUnixAddress )( CTEXTSTR path );
#endif
/* obsolete */
NETWORK_PROC( SOCKADDR *, CreateAddress )( uint32_t dwIP,uint16_t nHisPort);
/* obsolete */
NETWORK_PROC( SOCKADDR *, SetAddressPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
/* obsolete */
NETWORK_PROC( SOCKADDR *, SetNonDefaultPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
/*
 * this is the preferred method to create an address
 * name may be "* / *" with a slash, then the address result will be a unix socket (if supported)
 * name may have an options ":port" port number associated, if there is no port, then the default
 * port is used.
 *
 */
NETWORK_PROC( SOCKADDR *, CreateSockAddress )( CTEXTSTR name, uint16_t nDefaultPort );
#define CreateSockAddress(name,port) CreateSockAddressV2( name, port, NETWORK_ADDRESS_FLAG_PREFER_NONE )
/*
 * this is the preferred method to create an address
 * name may be "* / *" with a slash, then the address result will be a unix socket (if supported)
 * name may have an options ":port" port number associated, if there is no port, then the default
 * port is used.
 *  flags controls whether to prefer V4 or V6 lookups.
 */
NETWORK_PROC( SOCKADDR *, CreateSockAddressV2 )( CTEXTSTR name, uint16_t nDefaultPort, enum NetworkAddressFlags flags );
/*
 * set (*data) and (*datalen) to a binary buffer representation of the sockete address.
 */
NETWORK_PROC( void, GetNetworkAddressBinary )( SOCKADDR *addr, uint8_t **data, size_t *datalen );
/*
 * create a socket address form data and datalen binary buffer representation of the sockete address.
 */
NETWORK_PROC( SOCKADDR *, MakeNetworkAddressFromBinary )( uintptr_t *data, size_t datalen );
NETWORK_PROC( SOCKADDR*, CreateRemoteV2 )( CTEXTSTR lpName, uint16_t nHisPort, enum NetworkAddressFlags flags );
NETWORK_PROC( SOCKADDR *, CreateRemote )( CTEXTSTR lpName,uint16_t nHisPort);
#define CreateRemote(name,port) CreateRemoteV2( name, port, NETWORK_ADDRESS_FLAG_PREFER_NONE )
NETWORK_PROC( SOCKADDR *, CreateLocal )(uint16_t nMyPort);
NETWORK_PROC( int, GetAddressParts )( SOCKADDR *pAddr, uint32_t *pdwIP, uint16_t *pwPort );
 // release a socket resource that has been created by an above routine
NETWORK_PROC( void, ReleaseAddress )(SOCKADDR *lpsaAddr);
NETWORK_PROC( SOCKADDR*, AllocAddrEx )( DBG_VOIDPASS );
#define AllocAddr() AllocAddrEx( DBG_VOIDSRC )
#define IN_SOCKADDR_LENGTH sizeof(struct sockaddr_in)
#define IN6_SOCKADDR_LENGTH sizeof(struct sockaddr_in6)
// this might have to be like sock_addr_len_t
#define SOCKADDR_LENGTH(sa) ( (int)*(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) )
#ifdef __MAC__
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size ), ( sa->sa_len = size ) )
#else
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size )
#endif
// result with TRUE if equal, else FALSE
NETWORK_PROC( LOGICAL, CompareAddress )(SOCKADDR *sa1, SOCKADDR *sa2 );
#define SA_COMPARE_FULL 1
#define SA_COMPARE_IP   0
NETWORK_PROC( LOGICAL, CompareAddressEx )(SOCKADDR *sa1, SOCKADDR *sa2, int method );
/*
 * compare this address to see if it is any of my IPv4 interfaces
 */
NETWORK_PROC( LOGICAL, IsThisAddressMe )( SOCKADDR *addr, uint16_t myport );
/*
 *  Get the list of SOCKADDR addresses that are on this box (for this name)
 */
NETWORK_PROC( PLIST, GetLocalAddresses )( void );
/*
 * Return the text of a socket's IP address
 */
NETWORK_PROC( const char *, GetAddrName )( SOCKADDR *addr );
/*
 * Return the numeric form of the address (might have been created by name).
 */
NETWORK_PROC( const char *, GetAddrString )(SOCKADDR *addr);
/*
 * test an address to see if it is v6 (switch connect From behavior at application level)
 */
NETWORK_PROC( LOGICAL, IsAddressV6 )( SOCKADDR *addr );
/*
 *  Duplicate a sockaddr appropriately for the specified network.
 *  SOCKADDR has in(near) it the size of the address block, so this
 * can safely duplicate the the right amount of memory.
 */
 // return a copy of this address...
NETWORK_PROC( SOCKADDR *, DuplicateAddressEx )( SOCKADDR *pAddr DBG_PASS );
#define DuplicateAddress(a) DuplicateAddressEx( a DBG_SRC )
/*
 *  Duplicate a sockaddr appropriately for the specified network.
 *  SOCKADDR has in(near) it the size of the address block, so this
 * can safely duplicate the the right amount of memory.
 * If the address is a v6 address, it will be converted to a v4 address.
 */
 // return a copy of this address...
NETWORK_PROC( SOCKADDR*, DuplicateAddress_6to4_Ex )( SOCKADDR *pAddr DBG_PASS );
#define DuplicateAddress_6to4(a) DuplicateAddress_6to4_Ex( a DBG_SRC )
/* Transmission Control Protocol connection methods. This
   controls opening sockets that are based on TCP.        */
_TCP_NAMESPACE
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerAddrExx )( SOCKADDR *, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerAddrEx(a,b,c)  CPPOpenTCPListenerAddrExx(a,b,c DBG_SRC )
#endif
/* Opens a TCP socket which listens for connections. Other TCP
   sockets may be connected to this one once it has been
   created.
   Parameters
   Address :         address to serve at. See
                     CreateSockAddress().
   Port :            specified the port to listen at. This family
                     that takes just a port FAILS if there are
                     multiple network interfaces and or virtual
                     private networks.
   NotifyCallback :  user callback which will be invoked when a
                     new connection to the TCP server has been
                     made.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPListenerAddrExx )( SOCKADDR *, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerAddrEx(sa,ca) OpenTCPListenerAddrExx( sa, ca DBG_SRC )
NETWORK_PROC( PCLIENT, OpenTCPListenerAddr_v2d )(SOCKADDR *, cNotifyCallback NotifyCallback, LOGICAL ready DBG_PASS);
#define OpenTCPListenerAddr_v2(sa,ca,ready) OpenTCPListenerAddr_v2d( sa, ca,ready DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPListenerAddr( pAddr ) OpenTCPListenerAddrExxx( paddr, NULL, FALSE DBG_SRC );
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerExx )( uint16_t wPort, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerEx(a,b,c) CPPOpenTCPListenerExx(a,b,c DBG_SRC )
#endif
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, OpenTCPListener_v2d )(uint16_t wPort, cNotifyCallback NotifyCallback, LOGICAL waitForReady DBG_PASS);
#define OpenTCPListener_v2(a,b) OpenTCPListener_v2d(a,b,FALSE DBG_SRC )
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerAddr_v2d )(SOCKADDR *pAddr
	, cppNotifyCallback NotifyCallback
	, uintptr_t psvConnect
	, LOGICAL waitForReady
	DBG_PASS);
#define CPPOpenTCPListenerAddr_v2(a,b,c,d)  CPPOpenTCPListenerAddr_v2d(a,b,c,d DBG_SRC )
// This is an extended version of v2 - that is used internally to open a second socket that can listen on 0.0.0.0 and ::0
// FALSE is passed to the first isAuto; and TRUE to the second, which prevents infinite recursion.
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerAddr_v3d )( SOCKADDR *pAddr
	, cppNotifyCallback NotifyCallback
	, uintptr_t psvConnect
	, LOGICAL waitForReady
	, LOGICAL isAuto
	DBG_PASS );
#define CPPOpenTCPListenerAddr_v3(a,b,c,d,e)  CPPOpenTCPListenerAddr_v3d(a,b,c,d,e DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, OpenTCPListenerExx )( uint16_t wPort, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerEx(a,b) OpenTCPListenerExx(a,b DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPListener( wPort )    OpenTCPListenerEx( wPort, NULL )
/*
  When opening a tcp listener socket, the socket ends up 'ready' and
  able to send events before the application may be finished.
  Adding an option to
 */
NETWORK_PROC( void, SetNetworkListenerReady )( PCLIENT pListen );
/* <combine sack::network::tcp::OpenTCPListener>
   \ \                                           */
#define OpenTCPServer OpenTCPListener
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerEx OpenTCPListenerEx
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPServerAddr OpenTCPListenerAddr
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerAddrEx OpenTCPListenerAddrEx
// used with OpenTCPClientAddrExx
// use NetworkConnectTCP to begin connection
#define OPEN_TCP_FLAG_DELAY_CONNECT 1
// Socket expects to be SSL client; defer initial read callback until SSL is enabled.
#define OPEN_TCP_FLAG_SSL_CLIENT 2
#define OPEN_TCP_FLAG_PREFER_V6  4
#define OPEN_TCP_FLAG_PREFER_V4  8
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
																  cppReadComplete  pReadComplete, uintptr_t,
																  cppCloseCallback CloseCallback, uintptr_t,
																  cppWriteComplete WriteComplete, uintptr_t,
																  cppConnectCallback pConnectComplete,  uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientAddrExx(a,b,c,d,e,f,g,h,i,j) CPPOpenTCPClientAddrExxx(a,b,c,d,e,f,g,h,i,j DBG_SRC )
#endif
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromAddrEx )( SOCKADDR *lpAddr, SOCKADDR *pFromAddr
                                                     , cReadComplete     pReadComplete
                                                     , cCloseCallback    CloseCallback
                                                     , cWriteComplete    WriteComplete
                                                     , cConnectCallback  pConnectComplete
                                                     , int flags
                                                     DBG_PASS
                                                     );
#define OpenTCPClientAddrFromAddr( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromAddrEx( a,f,r,cl,wr,cc, 0 DBG_SRC )
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromEx )( SOCKADDR *lpAddr, int port
                                                , cReadComplete     pReadComplete
                                                , cCloseCallback    CloseCallback
                                                , cWriteComplete    WriteComplete
                                                , cConnectCallback  pConnectComplete
                                                , int flags
                                                DBG_PASS
                                                );
#define OpenTCPClientAddrFrom( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromEx( a,f,r,cl,wr,cc,0 DBG_SRC )
/* Opens a socket which connects to an already existing,
   listening, socket.
   Parameters
   lpAddr :            _nt_
   lpName :            lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   wPort :             lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   pReadComplete :     user callback which is invoked when a
                       buffer now contains data.
   CloseCallback :     user callback when this socket is closed.
   WriteComplete :     user callback which is invoked when a
                       write operation completes.
   pConnectComplete :  user callback which is called when this
                       client connects. The callback gets this
                       network connection as the first parameter.
   Remarks
   WriteComplete is often unused, unless you are using bMsg
   option on do
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
                                               cReadComplete  pReadComplete,
                                               cCloseCallback CloseCallback,
                                               cWriteComplete WriteComplete,
                                               cConnectCallback pConnectComplete,
                                               int flags
                                               DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrExx(a,r,clo,w,con) OpenTCPClientAddrExxx( a,r,clo,w,con,0 DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrEx )(SOCKADDR *
                                               , cppReadComplete, uintptr_t
                                               , cppCloseCallback, uintptr_t
                                               , cppWriteComplete, uintptr_t
                                               , int flags
                                               );
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExEx )(SOCKADDR *, cReadComplete,
                         cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrEx(a,b,c,d) OpenTCPClientAddrExEx(a,b,c,d DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientExEx )(CTEXTSTR lpName,uint16_t wPort
                         , cppReadComplete  pReadComplete, uintptr_t
                         , cppCloseCallback CloseCallback, uintptr_t
                         , cppWriteComplete WriteComplete, uintptr_t
															, cppConnectCallback pConnectComplete, uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientExx(name,port,read,rd,close,cd,write,wd,connect,cod,flg) CPPOpenTCPClientExEx(name,port,read,rd,close,cd,write,wd,connect,cod,flg DBG_SRC)
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientExxx )(CTEXTSTR lpName,uint16_t wPort
                                           , cReadComplete  pReadComplete
                                           , cCloseCallback CloseCallback
                                           , cWriteComplete WriteComplete
                                           , cConnectCallback pConnectComplete
                                           , int flags
                                           DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientExx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete ) OpenTCPClientExxx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete, 0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClient( name, port, read ) OpenTCPClientExxx(name,port,read,NULL,NULL,NULL,0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, OpenTCPClientExEx )( CTEXTSTR, uint16_t, cReadComplete,
													  cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClientEx( addr,port,read,close,write ) OpenTCPClientExEx( addr,port,read,close,write DBG_SRC )
/* Do the connect to
*/
NETWORK_PROC( int, NetworkConnectTCPEx )( PCLIENT pc DBG_PASS );
#define NetworkConnectTCP( pc ) NetworkConnectTCPEx( pc DBG_SRC )
/* Drain is an operation on a TCP socket to just drop the next X
   bytes. They are ignored and not stored into any user buffer.
   Drain reads take precedence over any other queued reads.
   Parameters
   pClient :  network connection to drain data from.
   nLength :  how much data to skip.
   bExact :   if TRUE, will consume all of nLength bytes. if
              FALSE, if there are less than nLength bytes
              available right now, the drain will end when no
              further data is available now.                     */
NETWORK_PROC( LOGICAL, TCPDrainEx )( PCLIENT pClient, size_t nLength, int bExact );
/* <combine sack::network::tcp::TCPDrainEx@PCLIENT@int@int>
   \ \                                                      */
#define TCPDrain(c,l) TCPDrainEx( (c), (l), TRUE )
/* TCP sockets have what is called a NAGLE algorithm that helps
   them gather small packets into larger packets. This implies a
   latency on sent communications, but can provide a boost to
   overall speed.
   Parameters
   pClient :  network client to control the nagle algorithm.
   bEnable :  (TRUE)disable NAGLE or (FALSE)enable NAGLE
              (TRUE)nodelay (FALSE)packet gather delay           */
NETWORK_PROC( void, SetTCPNoDelay )( PCLIENT pClient, int bEnable );
/* TCP Connections have a keep-alive option, that data will be
   automatically sent to make sure the connection is still
   alive.
   Parameters
   pClient :  network connection enable or disable the keep alive
              on.
   bEnable :  TRUE to enable keep\-alive else disable keep\-alive. */
NETWORK_PROC( void, SetClientKeepAlive)( PCLIENT pClient, int bEnable );
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
					 notified later by callback.
	user_timeout : user specified timeout to be used if bWait is specified.
                uses internal configurable timeout if 0.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
NETWORK_PROC( size_t, doReadExx2)(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream, LOGICAL bWait, int user_timeout DBG_PASS );
#define doReadExx(p,b,n,s,w) DoReadExx2( p,b,n,s,w,0 )
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
                notified later by callback.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
//NETWORK_PROC( size_t, doReadExx )(PCLIENT lpClient, POINTER lpBuffer, size_t nBytes
//										, LOGICAL bIsStream, LOGICAL bWait );
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \    Remarks
   if bWait is not specifed, it is passed as FALSE.                            */
//NETWORK_PROC( size_t, doReadEx )(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream DBG_PASS );
#define doReadEx( p,b,n,s )  doReadExx2( p,b,n,s,FALSE, 0 DBG_SRC)
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadStream(pc,pBuf,nSize) doReadExx2( pc, pBuf, nSize, TRUE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define doRead(pc,pBuf,nSize)     doReadExx2(pc, pBuf, nSize, FALSE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCP ReadStream
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCPMsg doRead
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCP(pc,buf,nSize)    doReadExx2(pc,buf, nSize, TRUE, TRUE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCPMsg(pc,buf,nSize) doReadExx2(pc,buf, nSize, FALSE, TRUE, 0  DBG_SRC)
/* \#The buffer will be sent in the order of the writes to the
   socket, and released when empty. If the socket is immediatly
   able to write, the buffer will be sent, and any remai
   Parameters
   lpClient :     network connection to write to
   pInBuffer :    buffer to write
   nInLen :       Length of the buffer to send
   bLongBuffer :  if TRUE, then the buffer written is maintained
                  exactly by the network layer. A WriteComplete
                  callback will be invoked when the buffer has
                  been sent so the application might delete the
                  buffer.
   failpending :  Uhmm... maybe if it goes to pending, fail?
   Remarks
   If bLongBuffer is not set, then if the write cannot
   immediately complete, then a new buffer is allocated
   internally, and unsent data is buffered by the network
   collection. This allows the user to not worry about slowdowns
   due to blocking writes. Often writes complete immediately,
   and are not buffered other than in the user's own buffer
   passed to this write.                                         */
NETWORK_PROC( LOGICAL, doTCPWriteExx )( PCLIENT lpClient
						, CPOINTER pInBuffer
						, size_t nInLen, int bLongBuffer
                                   , int failpending
                                   DBG_PASS
                                  );
/* \#The buffer will be sent in the order of the writes to the
   socket, and released when empty. If the socket is immediatly
   able to write, the buffer will be sent, and any remai
   Parameters
   lpClient :     network connection to write to
   pInBuffer :    buffer to write
   nInLen :       Length of the buffer to send
   bLongBuffer :  if TRUE, then the buffer written is maintained
				  exactly by the network layer. A WriteComplete
				  callback will be invoked when the buffer has
				  been sent so the application might delete the
				  buffer.
   failpending :  Uhmm... maybe if it goes to pending, fail?
   pend_on_fail : True/false - if the write fails, should it be
				  pending until it can be sent.
   Remarks
   If bLongBuffer is not set, then if the write cannot
   immediately complete, then a new buffer is allocated
   internally, and unsent data is buffered by the network
   collection. This allows the user to not worry about slowdowns
   due to blocking writes. Often writes complete immediately,
   and are not buffered other than in the user's own buffer
   passed to this write.                                         */
NETWORK_PROC( LOGICAL,  doTCPWriteV2 )( PCLIENT lpClient
                     , CPOINTER pInBuffer
                     , size_t nInLen
                     , int bLongBuffer
                     , int failpending
                     , int pend_on_fail
                     DBG_PASS
                     );
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define doTCPWriteExx( c,b,l,f1,f2,fop,...) doTCPWriteV2( (c),(b),(l),(f1),(f2),(fop),##__VA_ARGS__ )
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define doTCPWriteEx( c,b,l,f1,f2) doTCPWriteV2( (c),(b),(l),(f1),(f2),TRUE DBG_SRC )
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPEx( c,b,l,p) doTCPWriteV2( c,b,l,FALSE,p,TRUE DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCP(c,b,l) doTCPWriteV2(c,b,l, FALSE, FALSE,TRUE DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPLong(c,b,l) doTCPWriteV2(c,b,l, TRUE, FALSE,TRUE DBG_SRC)
NETWORK_PROC( void, SetTCPWriteAggregation )( PCLIENT pc, int bAggregate );
_TCP_NAMESPACE_END
NETWORK_PROC( void, SetNetworkLong )(PCLIENT lpClient,int nLong,uintptr_t dwValue);
NETWORK_PROC( uintptr_t, GetNetworkLong )(PCLIENT lpClient, int nLong);
/* Obsolete. See SetNetworkLong. */
NETWORK_PROC( void, SetNetworkInt )(PCLIENT lpClient,int nLong, int value);
NETWORK_PROC( int, GetNetworkInt )(PCLIENT lpClient, int nLong);
NETWORK_PROC( void, SetNetworkWord )(PCLIENT lpClient,int nLong,uint16_t wValue);
NETWORK_PROC( uint16_t, GetNetworkWord )(PCLIENT lpClient,int nLong);
/* Symbols which may be passed to GetNetworkLong to get internal
   parts of the client.                                          */
enum GetNetworkLongAccessInternal{
 GNL_IP      = (-1),
 /* Gets the IP of the remote side of the connection, if
    applicable. UDP Sockets don't have a bound destination. */
 GNL_PORT    = (-4),
 /* Gets the port at the remote side of the connection that is
    being sent to.                                             */
 GNL_MYIP    = (-3),
 /* Gets the 4 byte IPv4 address that is what I am using on my
    side. After a socket has sent, it will have a set source IP
    under windows.                                              */
 GNL_MYPORT  = (-2),
 /* Gets the 16 bit port of the TCP or UDP connection that you
    are sending from locally.                                  */
 GNL_MAC_LOW = (-5),
 GNL_MAC_HIGH= (-6),
 GNL_REMOTE_ADDRESS = (-7),
 GNL_LOCAL_ADDRESS = (-8),
};
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( int, GetMacAddress)(PCLIENT pc, uint8_t* bufLocal, size_t *bufLocalLen, uint8_t* bufRemote, size_t *bufRemoteLen );
//NETWORK_PROC( int, GetMacAddress)(PCLIENT pc );
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( PLIST, GetMacAddresses)( void );
NETWORK_PROC( LOGICAL, sack_network_is_active )( PCLIENT pc );
// mark that a socket has outstanding work.  If a close is handled while in network read
// prevent the automatic close until work is cleared.
NETWORK_PROC( void, AddNetWork )( PCLIENT lpClient, uintptr_t psv );
// clear outstanding work on a socket.  Once all work is cleared, and the socket is flagged
// to close, then a oustanding close operation will be performed when the last work is cleared.
//
NETWORK_PROC( void, ClearNetWork )( PCLIENT lpClient, uintptr_t psv );
NETWORK_PROC( void, RemoveClientExx )(PCLIENT lpClient, LOGICAL bBlockNofity, LOGICAL bLinger DBG_PASS );
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClientEx(c,b,l) RemoveClientExx(c,b,l DBG_SRC)
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClient(c) RemoveClientEx(c, FALSE, FALSE )
/* Begin an SSL Connection.  This ends up replacing ReadComplete callback with an inbetween layer*/
NETWORK_PROC( LOGICAL, ssl_BeginClientSession )( PCLIENT pc, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen, CPOINTER rootCert, size_t rootCertLen );
NETWORK_PROC( LOGICAL, ssl_BeginServer )( PCLIENT pc, CPOINTER cert, size_t certlen, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen);
NETWORK_PROC( LOGICAL, ssl_BeginServer_v2 )( PCLIENT pc, CPOINTER cert, size_t certlen
	, CPOINTER keypair, size_t keylen
	, CPOINTER keypass, size_t keypasslen
	, char* hosts );
struct ssl_session;
// add more certificates to a server socket that it can use to resolve host requests
NETWORK_PROC( struct ssl_hostContext*, ssl_setupHostCert )( PCLIENT pc, CTEXTSTR host, CTEXTSTR cert, size_t certlen, CTEXTSTR keypair, size_t keylen, CTEXTSTR keypass, size_t keypasslen );
// add more certificates to a server socket that it can use to resolve host requests (uses internal)
NETWORK_PROC( struct ssl_hostContext*, ssl_setupHost )( struct ssl_session* session, CTEXTSTR host, CTEXTSTR cert, size_t certlen, CTEXTSTR keypair, size_t keylen, CTEXTSTR keypass, size_t keypasslen );
/*
* Get the SSL session for a client
*/
NETWORK_PROC( struct ssl_session*, ssl_GetSession )( PCLIENT pc );
/*
* add data to the SSL session ( this is new data from a network source)
* results with standard read/write callbacks (original set in the socket, but now?)
*/
NETWORK_PROC( void, ssl_WriteData )( struct ssl_session* session, POINTER buffer, size_t length );
/*
* Send data out ssl connection
*/
NETWORK_PROC( LOGICAL, ssl_SendPipe )( struct ssl_session** ses, CPOINTER buffer, size_t length );
/*
* set the send and receive work functions for an SSL connection
*/
NETWORK_PROC( void, ssl_SetSendRecvCallbacks )( struct ssl_session* session, void ( *send )( uintptr_t, CPOINTER, size_t ), void ( *recv )( uintptr_t, POINTER, size_t ), uintptr_t psvSendRecv );
NETWORK_PROC( LOGICAL, ssl_GetPrivateKey )(PCLIENT pc, POINTER *keydata, size_t *keysize);
NETWORK_PROC( LOGICAL, ssl_IsClientSecure )(PCLIENT pc);
NETWORK_PROC( void, ssl_SetIgnoreVerification )(PCLIENT pc);
NETWORK_PROC( CTEXTSTR, ssl_GetRequestedHostName )(PCLIENT pc);
// during ssl error callback, this can be used to revert (server) sockets to
// non SSL.
// a CLient socket will have already sent SSL Data on the socket, and it would
// be unclean to try to change protocol.
// the Server, however, fails the handshake on the first receive, and previously
// just closed, but new error handling allows fallback to HTTP in order to send
// a redirect to the HTTPS address proper.
NETWORK_PROC( void, ssl_EndSecure )(PCLIENT pc, POINTER buffer, size_t buflen );
/*
 For a ssl_session pipe, this is a close.
 */
NETWORK_PROC( void, ssl_EndSecurePipe )(struct ssl_session** session );
/* use this to send on SSL Connection instead of SendTCP. */
NETWORK_PROC( LOGICAL, ssl_Send )( PCLIENT pc, CPOINTER buffer, size_t length );
/* User Datagram Packet connection methods. This controls
   opening sockets that are based on UDP.                 */
_UDP_NAMESPACE
/* Open a UDP socket. Since the address to send to is implied on
   each message that is sent, all that is required is to setup
   where the UDP socket is listening.
   Parameters
   pAddr :          Pointer to a string address to listen at. Can
                    be NULL to listen on any interface, (also
                    specified as "0.0.0.0"), see
                    CreateSockAddress notes.
   wPort :          16 bit value for the port to listen at.
   pReadComplete :  user callback which is invoked when a read
                    completes on a UDP socket.
   Close :          close callback which is invoked when the new
                    network connection is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
	with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, CPPServeUDPAddrEx )( SOCKADDR *pAddr
                  , cReadCompleteEx pReadComplete
                  , uintptr_t psvRead
                  , cCloseCallback Close
													 , uintptr_t psvClose
													 , int bCPP DBG_PASS );
NETWORK_PROC( PCLIENT, ServeUDPEx )( CTEXTSTR pAddr, uint16_t wPort,
                  cReadCompleteEx pReadComplete,
                  cCloseCallback Close DBG_PASS );
#define ServeUDP( addr,port,read,close) ServeUDPEx( addr, port, read, close DBG_SRC )
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
/* Creates a client to listen for messages or to send UDP
   messages.
   Parameters
   pAddr :          address to listen for UDP messages on.
   pReadComplete :  user callback to received read events.
   Close :          user callback to be invoked when the network
                    connection is closed. (network interface
                    disabled?)
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
	specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ServeUDPAddrEx )( SOCKADDR *pAddr,
                     cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ServeUDPAddr(addr,read,close) ServeUDPAddrEx( addr,read,close DBG_SRC )
/* \    Parameters
   address :         Address to listen at (interface
                     specification). Can be NULL to specify ANY
                     address, See notes on CreateSockAddress.
   port :            16 bit port to listen at
   dest_address :    Address to connect to. Can be NULL to
                     specify ANY address, See notes on
                     CreateSockAddress.
   dest_port :       16 bit port to send to. Ignored if
                     dest_address is NULL.
   read_complete :   User event handler which is invoked when
                     data is read from the socket.
   close_callback :  user event handler which is invoked when
                     this socket is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete. */
NETWORK_PROC( PCLIENT, ConnectUDPEx )( CTEXTSTR , uint16_t ,
                    CTEXTSTR, uint16_t,
                    cReadCompleteEx,
												  cCloseCallback DBG_PASS );
#define ConnectUDP(a,b,c,d,e,f) ConnectUDPEx(a,b,c,d,e,f DBG_SRC )
/* \    Parameters
   sa :             address to listen for UDP messages at.
   saTo :           address to send UDP messages to, if the sa
                    parameter of send is NULL.
   pReadComplete :  user callback which will be invoked when
                    reads complete on the network connection.
   Close :          user callback which will be invoked when the
                    listening socket closes.
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
   specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ConnectUDPAddrEx )( SOCKADDR *sa,
                        SOCKADDR *saTo,
                    cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ConnectUDPAddr(a,b,c,d)  ConnectUDPAddrEx(a,b,c,d DBG_SRC )
/* Specify a different default address to send UDP messages to.
   Parameters
   pc :       network connection to change the default target
              address of.
   pToAddr :  text address to connect to. See notes in
              CreateSockAddress.
   wPort :    16 bit port address to connect to.
   Returns
   TRUE if it was a valid address specification.
   FALSE if it could not set the address.                       */
NETWORK_PROC( LOGICAL, ReconnectUDP )( PCLIENT pc, CTEXTSTR pToAddr, uint16_t wPort );
/* Sets the target default address of a UDP connection.
   Parameters
   pc :  network connection to set the target address of.
   sa :  See CreateSockAddress(), this is a network structure that
         is a struct sockaddr{} something.                         */
NETWORK_PROC( LOGICAL, GuaranteeAddr )( PCLIENT pc, SOCKADDR *sa );
/* A UDP message may be sent to a broadcast address or a subnet
   broadcast address, in either case, this must be called to
   enable broadcast communications, else the address must be a
   direct connection.
   Parameters
   pc :       network connection to enable broadcast on.
   bEnable :  TRUE to enable broadcast ability on this socket. FALSE
              to disable broadcast ability.                          */
NETWORK_PROC( void, UDPEnableBroadcast )( PCLIENT pc, int bEnable );
/* Sends to a UDP Network connection.
   Parameters
   pc :     pointer to a network connection to send on.
   pBuf :   buffer to send
   nSize :  size of the buffer to send
   sa :     pointer to a SOCKADDR which this message is destined
            to. Can be NULL, if GuaranteeAddr, or ConnectUDP is
            used.
   Returns
   The number of bytes in the buffer sent? Probably a TRUE if
   success else failure?                                         */
NETWORK_PROC( LOGICAL, SendUDPEx )( PCLIENT pc, CPOINTER pBuf, size_t nSize, SOCKADDR *sa );
/* <combine sack::network::udp::SendUDPEx@PCLIENT@CPOINTER@int@SOCKADDR *>
   \ \                                                                     */
#define SendUDP(pc,pbuf,size) SendUDPEx( pc, pbuf, size, NULL )
/* Queue a read to a UDP socket. A read cannot complete if it
   does not have a buffer to read into. A UDP socket will stall
   if the read callback returns without queuing a read.
   Parameters
   pc :        network connection to read from.
   lpBuffer :  buffer which the next data available on the network
               connection will be read into.
   nBytes :    size of the buffer.                                 */
NETWORK_PROC( int, doUDPRead )( PCLIENT pc, POINTER lpBuffer, int nBytes );
/* <combine sack::network::udp::doUDPRead@PCLIENT@POINTER@int>
   \ \                                                         */
#define ReadUDP doUDPRead
/* Logs to the log file the content of a socket address.
   Parameters
   name :  text leader to print before the address
   sa :    the socket address to dump.                   */
NETWORK_PROC( void, DumpAddrEx )( CTEXTSTR name, SOCKADDR *sa DBG_PASS );
/* <combine sack::network::udp::DumpAddrEx@CTEXTSTR@SOCKADDR *sa>
   \ \                                                            */
#define DumpAddr(n,sa) DumpAddrEx(n,sa DBG_SRC )
/*
* Convert a socket address to a string.
*/
NETWORK_PROC( CTEXTSTR, AddrToString )( CTEXTSTR name, SOCKADDR* sa DBG_PASS );
/*
* Free a string returned from AddrToString
*/
NETWORK_PROC( void, FreeAddrString )( CTEXTSTR string DBG_PASS );
#define FreeAddrString(s) FreeAddrString( s DBG_SRC )
#define AddrToString(n,s) AddrToString( n, s DBG_SRC )
NETWORK_PROC( int, SetSocketReuseAddress )( PCLIENT pClient, int32_t enable );
NETWORK_PROC( int, SetSocketReusePort )( PCLIENT pClient, int32_t enable );
_UDP_NAMESPACE_END
USE_UDP_NAMESPACE
struct interfaceAddress {
	SOCKADDR *sa;
	SOCKADDR *saBroadcast;
	SOCKADDR *saMask;
};
NETWORK_PROC( SOCKADDR*, GetBroadcastAddressForInterface )(SOCKADDR *addr);
NETWORK_PROC( SOCKADDR*, GetInterfaceAddressForBroadcast )(SOCKADDR *addr);
NETWORK_PROC( struct interfaceAddress*, GetInterfaceForAddress )( SOCKADDR *addr );
NETWORK_PROC( LOGICAL, IsBroadcastAddressForInterface )( struct interfaceAddress *address, SOCKADDR *addr );
NETWORK_PROC( void, LoadNetworkAddresses )(void);
// This initializes the libressl library, which registers the correct allocation methods...
NETWORK_PROC( LOGICAL, ssl_InitLibrary )( void );
//----- PING.C ------
NETWORK_PROC( LOGICAL, DoPing )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
             void (*ResultCallback)( SOCKADDR* dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops ) );
NETWORK_PROC( LOGICAL, DoPingEx )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
											 void (*ResultCallback)( uintptr_t psv, SOCKADDR* dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops )
											, uintptr_t psv );
//----- WHOIS.C -----
NETWORK_PROC( LOGICAL, DoWhois )( CTEXTSTR pHost, CTEXTSTR pServer, PVARTEXT pvtResult );
//----- NETSTAT ----
struct listener_pid_info {
	uint16_t port;
	uint64_t pid;
};
// list is filled with struct listener_pid_info entries
NETWORK_PROC( void, SackNetstat_GetListeners )( PDATALIST* ppList );
#ifdef __cplusplus
#  if defined( INCLUDE_SAMPLE_CPLUSPLUS_WRAPPERS )
typedef class network *PNETWORK;
/* <combine sack::network::network>
   \ \                              */
typedef class network
{
	PCLIENT pc;
	int TCP;
	static void CPROC WrapTCPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize );
	static void CPROC WrapUDPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize, SOCKADDR *sa );
	static void CPROC WrapWriteComplete( uintptr_t psv );
	static void CPROC WrapClientConnectComplete( uintptr_t psv, int nError );
	static void CPROC WrapServerConnectComplete( uintptr_t psv, PCLIENT pcNew );
	static void CPROC WrapCloseCallback( uintptr_t psv );
   // notify == server (listen)
	static void CPROC SetNotify( PCLIENT pc, cppNotifyCallback, uintptr_t psv );
   // connect == client (connect)
   static void CPROC SetConnect( PCLIENT pc, cppConnectCallback, uintptr_t psv );
   static void CPROC SetRead( PCLIENT pc, cppReadComplete, uintptr_t psv );
   static void CPROC SetWrite( PCLIENT pc, cppWriteComplete, uintptr_t psv );
   static void CPROC SetClose( PCLIENT pc, cppCloseCallback, uintptr_t psv );
public:
	network() { NetworkStart(); pc = NULL; TCP = TRUE; };
	network( PCLIENT _pc ) { NetworkStart(); this->pc = _pc; TCP = TRUE; };
	network( network &cp ) { cp.pc = pc; cp.TCP = TCP; };
	~network() { if( pc ) RemoveClientEx( pc, TRUE, FALSE ); pc = NULL; };
	inline void MakeUDP( void ) { TCP = FALSE; }
	virtual void ReadComplete( POINTER buffer, size_t nSize ) = 0;
	virtual void ReadComplete( POINTER buffer, size_t nSize, SOCKADDR *sa ) = 0;
	virtual void WriteComplete( void ) = 0;
	virtual void ConnectComplete( int nError ) =0;
	// received on the server listen object...
	virtual void ConnectComplete( class network &pNewClient ) =0;
	virtual void CloseCallback( void ) =0;
	inline int Connect( SOCKADDR *sa )
	{
		if( !pc )
		pc = CPPOpenTCPClientAddrExx( sa
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Connect( CTEXTSTR name, uint16_t port )
	{
		if( !pc )
		pc = CPPOpenTCPClientExx( name, port
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Listen( SOCKADDR *sa )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerAddrEx( sa
				                        , (cppNotifyCallback)WrapServerConnectComplete
												, (uintptr_t)this
														)  ) != NULL )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline int Listen( uint16_t port )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerEx( port
			                      , (cppNotifyCallback)WrapServerConnectComplete
											 , (uintptr_t)this ) ) )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline void Write( POINTER p, int size )
	{
		if( pc ) SendTCP( pc, p, size );
	};
	inline void WriteLong( POINTER p, int size )
	{
		if( pc ) SendTCPLong( pc, p, size );
	};
	inline void Read( POINTER p, int size )
	{
		if( pc ) ReadTCP( pc, p, size );
	};
	inline void ReadBlock( POINTER p, int size )
	{
		if( pc ) ReadTCPMsg( pc, p, size );
	};
	inline void SetLong( int l, uint32_t value )
	{
      if( pc ) SetNetworkLong( pc, l, value );
	}
	inline void SetNoDelay( LOGICAL bTrue )
	{
      if( pc ) SetTCPNoDelay( pc, bTrue );
	}
	inline void SetClientKeepAlive( LOGICAL bTrue )
	{
		if( pc ) sack::network::SetClientKeepAlive( pc, bTrue );
	}
	inline uintptr_t GetLong( int l )
	{
		if( pc )
			return GetNetworkLong( pc, l );
	      return 0;
	}
}NETWORK;
#  endif
#endif
#ifdef __cplusplus
 //SACK_NETWORK_NAMESPACE_END
} }
using namespace sack::network;
using namespace sack::network::tcp;
using namespace sack::network::udp;
#endif
#endif
//------------------------------------------------------------------
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.17  2002/12/22 00:14:11  panther
// Cleanup function declarations and project defines.
//
// Revision 1.16  2002/11/24 21:37:40  panther
// Mods - network - fix server->accepted client method inheritance
// display - fix many things
// types - merge chagnes from verious places
// ping - make function result meaningful yes/no
// controls - fixes to handle lack of image structure
// display - fixes to handle moved image structure.
//
// Revision 1.16  2002/11/21 19:13:11  jim
// Added CreateAddress, CreateAddress_hton
//
// Revision 1.15  2002/07/25 12:59:02  panther
// Added logging, removed logging....
// Network: Added NetworkLock/NetworkUnlock
// Timers: Modified scheduling if the next timer delta was - how do you say -
// to fire again before now.
//
// Revision 1.14  2002/07/23 11:24:26  panther
// Added new function to TCP networking - option on write to disable
// queuing of pending data.
//
// Revision 1.13  2002/07/17 11:33:26  panther
// Added new function to tcp network - dotcpwriteex - allows option to NOT pend
// buffers.
//
// Revision 1.12  2002/07/15 08:34:07  panther
// Include function to set udp broadcast or not.
//
//
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
/* and then we could be really evil
#define send(s,b,x,t,blah)
#define recv
#define socket
#define getsockopt ?
#define heh yeah these have exact equivalents ....
*/
#ifdef HTTP_SOURCE
#define HTTP_EXPORT EXPORT_METHOD
#else
/* Defines how external functions are referenced
   (dllimport/export/extern)                     */
#define HTTP_EXPORT IMPORT_METHOD
#endif
/* The API type of HTTP functions - default to CPROC. */
#define HTTPAPI CPROC
#ifdef __cplusplus
/* A symbol to define the sub-namespace of HTTP_NAMESPACE  */
#define _HTTP_NAMESPACE namespace http {
/* A macro to end just the HTTP sub namespace. */
#define _HTTP_NAMESPACE_END }
#else
#define _HTTP_NAMESPACE
#define _HTTP_NAMESPACE_END
#endif
/* HTTP full namespace  */
#define HTTP_NAMESPACE TEXT_NAMESPACE _HTTP_NAMESPACE
/* Macro to use to define where http utility namespace ends. */
#define HTTP_NAMESPACE_END _HTTP_NAMESPACE_END TEXT_NAMESPACE_END
SACK_CONTAINER_NAMESPACE
/* Text library functions. PTEXT is kept as a linked list of
   segments of text. Each text segment has a size and the data,
   and additional format flags. PTEXT may also be indirect
   segments (that is this segment points at another list of
   segments that are the actualy content for this place.
                                                                */
_TEXT_NAMESPACE
	/* Simple HTTP Packet processing state. Its only intelligence is
	   that there are fields of http header, and that one of those
	   fields might be content-length; so it can seperate individual
	   fields name-value pairs and the packet content.               */
	_HTTP_NAMESPACE
struct HttpField {
	PTEXT name;
	PTEXT value;
};
struct HTTPRequestHeader {
	char* field;
	char* value;
};
struct HTTPRequestOptions {
  // deafult GET
	const char* method;
     // path part of the request
	PTEXT url;
 // address part of request (ip:port)
	PTEXT address;
 // list of TEXTCAHR*
	PLIST headers;
  // content to send with request, if any
	CPOINTER content;
// lengt of content to send with request
	size_t contentLen;
 // set to true to request over SSL;
	LOGICAL ssl;
 // HTTP Version ("1.0" default)
	const char *httpVersion;
 // defaults to 3 seconds if set to 0.
	int timeout;
 // defaults to 3 retries if set to 0.
	int retries;
	enum NetworkAddressFlags addrFlags;
 //optionally this can be used to specify the certain, if not set, uses parameter, which will otherwise be NULL.
	const char* certChain;
	LOGICAL rejectUnauthorized;
	// specify the agent field, default to SACK(System)
	const char* agent;
	// if set, will be called when content buffer has been sent.
	void ( *writeComplete )( uintptr_t userData );
	uintptr_t userData;
 // did get a connect state, so connectError is not checked... (timeout before connect complete?)
	LOGICAL connected;
  // feedback to application if there was an error connecting.
	int connectError;
	const char *hostname;
};
typedef struct HttpState *HTTPState;
enum ProcessHttpResult{
	HTTP_STATE_RESULT_NOTHING = 0,
	HTTP_STATE_RESULT_CONTENT = 200,
	HTTP_STATE_RESULT_CONTINUE = 100,
	HTTP_STATE_INTERNAL_SERVER_ERROR=500,
	HTTP_STATE_RESOURCE_NOT_FOUND=404,
	HTTP_STATE_BAD_REQUEST=400,
};
/* Creates an empty http state, the next operation should be
   AddHttpData.                                              */
HTTP_EXPORT HTTPState  HTTPAPI CreateHttpState( PCLIENT *pc );
/*Get the http state associated with a network client */
HTTP_EXPORT HTTPState HTTPAPI GetHttpState( PCLIENT pc );
HTTP_EXPORT void HTTPAPI LockHttp( struct HttpState *state );
HTTP_EXPORT void HTTPAPI UnlockHttp( struct HttpState *state );
/* Destroys a http state, releasing all resources associated
   with it.                                                  */
HTTP_EXPORT void HTTPAPI DestroyHttpState( HTTPState pHttpState );
HTTP_EXPORT
 /* Add another bit of data to the block. After adding data,
   ProcessHttp should be called to see if the data has completed
   a packet.
   Parameters
   pHttpState :  state to add data to
   buffer :      pointer to some data bytes
   size :        length of data bytes
   Returns: TRUE if content is added... if collecting chunked encoding may return FALSE.
   */
LOGICAL HTTPAPI AddHttpData( HTTPState pHttpState, CPOINTER buffer, size_t size );
/* \returns TRUE if completed until content-length if
   content-length is not specified, data is still collected, but
   the status never results TRUE.
	Parameters
	pc : Occasionally the http processor needs to send data on the
	     socket without application being aware it did.
   pHttpState :  Http State to process (after having added data to
                 it)
   Return Value List
   TRUE :   A completed HTTP packet has been gathered \- according
            to 'content\-length' meta tag.
   FALSE :  Still collecting full packet                           */
//HTTP_EXPORT int HTTPAPI ProcessHttp( HTTPState pHttpState );
HTTP_EXPORT enum ProcessHttpResult HTTPAPI ProcessHttp( HTTPState pHttpState, int (*send)(uintptr_t psv, CPOINTER buf, size_t len), uintptr_t psv );
HTTP_EXPORT
 /* Gets the specific result code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
PTEXT HTTPAPI GetHttpResponse( HTTPState pHttpState );
/* Get the method of the request in ht e http state.
*/
HTTP_EXPORT PTEXT HTTPAPI GetHttpMethod( struct HttpState *pHttpState );
/*Get the value of a HTTP header field, by name
   Parameters
	pHttpState: the state to get the header field from.
	name: name of the field to get (checked case insensitive)
*/
HTTP_EXPORT PTEXT HTTPAPI GetHTTPField( HTTPState pHttpState, CTEXTSTR name );
/* Gets the specific request code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
HTTP_EXPORT PTEXT HTTPAPI GetHttpRequest( HTTPState pHttpState );
/* \Returns the body of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpContent( HTTPState pHttpState );
/* \Returns the resource path/name of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpResource( HTTPState pHttpState );
/* Returns a list of fields that were included in a request header.
   members of the list are of type struct HttpField.
   see also: ProcessHttpFields and ProcessCGIFields
*/
HTTP_EXPORT PLIST HTTPAPI GetHttpHeaderFields( HTTPState pHttpState );
//HTTP_EXPORT int HTTPAPI GetHttpVersion( HTTPState pHttpState );
/* get the version of the current reply which has been parsed into the state.
    will be 0 if it is a reply and not a reply.
*/
HTTP_EXPORT int HTTPAPI GetHttpReplyVersion( HTTPState pHttpState );
/* get the version of the current request which has been parsed into the state.
    will be 0 if it is a reply and not a request.
*/
HTTP_EXPORT int HTTPAPI GetHttpRequestVersion( HTTPState pHttpState );
// #define GetHttpVersion(state) GetHttpRequestVersion( state )
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessCGIFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessHttpFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Resets a processing state, so it can start collecting the
   next state. After a ProcessHttp results with true, this
   should be called after processing the packet content.
   Parameters
   pHttpState :  state to reset for next read...             */
void HTTPAPI EndHttp( HTTPState pHttpState );
HTTP_EXPORT
/* reply message - 200/OK with this body, sent as Content-Type that was requested */
void HTTPAPI SendHttpMessage( HTTPState pHttpState, PCLIENT pc, PTEXT body );
HTTP_EXPORT
/* generate response message, specifies the numeric (200), the text (OK), the content type field value, and the body to send */
void HTTPAPI SendHttpResponse ( HTTPState pHttpState, PCLIENT pc, int numeric, CTEXTSTR text, CTEXTSTR content_type, PTEXT body );
/* Callback type used when creating an http server.
 If there is no registered handler match, then this is called.
 This should return FALSE if there was no content, allowing a 404 status result.
 Additional ways of dispatching need to be implemented (like handlers for paths, wildcards...)
 */
typedef LOGICAL (CPROC *ProcessHttpRequest)( uintptr_t psv
												 , HTTPState pHttpState );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpsServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI PostHttp( PTEXT site, PTEXT resource, PTEXT content );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttp( PTEXT site, PTEXT resource, LOGICAL secure );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttps( PTEXT address, PTEXT url, const char *certChain );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState HTTPAPI GetHttpsQueryEx( PTEXT address, PTEXT url, const char* certChain, struct HTTPRequestOptions* options );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI PostHttpQuery( PTEXT site, PTEXT resource, PTEXT content );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI GetHttpQuery( PTEXT site, PTEXT resource );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState HTTPAPI GetHttpsQuery( PTEXT site, PTEXT resource, const char *certChain );
/* return the numeric response code of a http reply. */
HTTP_EXPORT int HTTPAPI GetHttpResponseCode( HTTPState pHttpState );
/* return the text response code of an http reply */
HTTP_EXPORT const char* HTTPAPI GetHttpResponseStatus( HTTPState pHttpState );
#define CreateHttpServer(interface_address,site,psv) CreateHttpServerEx( interface_address,NULL,site,NULL,psv )
#define CreateHttpServer2(interface_address,site,default_handler,psv) CreateHttpServerEx( interface_address,NULL,site,default_handler,psv )
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpGet( site, resource )	 DefineRegistryMethod("SACK/Http/Methods",OnHttpGet,site,resource,"Get",LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpPost( site, resource )	 DefineRegistryMethod("SACK/Http/Methods",OnHttpPost,site,resource,"Post",LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// define a specific handler for a specific resource name on a host
#define OnHttpRequest( site, resource )	 DefineRegistryMethod("SACK/Http/Methods",OnHttpRequest,"something",site "/" resource,"Get",void,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
//--------------------------------------------------------------
//  URL.c  (url parsing utility)
struct url_cgi_data
{
	CTEXTSTR name;
	CTEXTSTR value;
};
struct url_data
{
	CTEXTSTR protocol;
	CTEXTSTR user;
	CTEXTSTR password;
	CTEXTSTR host;
	int default_port;
  // encoding RFC3986 http://tools.ietf.org/html/rfc3986  specifies port characters are in the set of digits.
	int port;
	//CTEXTSTR port_data;  // during collection, the password may be in the place of 'port'
	CTEXTSTR resource_path;
	CTEXTSTR resource_file;
	CTEXTSTR resource_extension;
	CTEXTSTR resource_anchor;
	// list of struct url_cgi_data *
	PLIST cgi_parameters;
};
HTTP_EXPORT struct url_data * HTTPAPI SACK_URLParse( const char *url );
HTTP_EXPORT char *HTTPAPI SACK_BuildURL( struct url_data *data );
HTTP_EXPORT void HTTPAPI SACK_ReleaseURL( struct url_data *data );
	_HTTP_NAMESPACE_END
TEXT_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::text::http;
#endif
#endif
HTTP_NAMESPACE
struct default_port
{
	CTEXTSTR name;
	int number;
};
#define num_defaults (sizeof(default_ports)/sizeof(default_ports[0]))
static struct default_port default_ports[] = { { "http", 80 }
															, { "ftp", 21 }
															, { "ssh", 22 }
															, { "telnet", 23 }
															, { "https", 443 }
															, { "ws", 80 }
															, { "wss", 443 }
															, { "file", 0 }
															};
// TEXTSTR result = ConvertURIText( addr, length )
// SACK_ParseURL takes a URL string and gets the pieces it can identify
// if a piece is not specified, the result will be NULL.
enum URLParseState
{
  // find ':', store characters in buffer
	PARSE_STATE_COLLECT_PROTOCOL = 0
  // find '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_1
  // eat '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_2
	, PARSE_STATE_COLLECT_USER
	, PARSE_STATE_COLLECT_PASSWORD
	, PARSE_STATE_COLLECT_ADDRESS
	, PARSE_STATE_COLLECT_PORT
	, PARSE_STATE_COLLECT_RESOURCE_PATH
	, PARSE_STATE_COLLECT_RESOURCE_NAME
	, PARSE_STATE_COLLECT_RESOURCE_EXTENSION
	, PARSE_STATE_COLLECT_RESOURCE_ANCHOR
	, PARSE_STATE_COLLECT_CGI_NAME
	, PARSE_STATE_COLLECT_CGI_VALUE
	, PARSE_STATE_COLLECT_IPV6
};
static void AppendBuffer( CTEXTSTR *output, CTEXTSTR seperator, CTEXTSTR input )
{
	CTEXTSTR tmpbuf = ConvertURIText( input, StrLen( input ) + 1 );
	TEXTSTR newout;
	if( *output )
	{
		size_t len;
		len = StrLen( *output ) + StrLen( tmpbuf ) + 1;
		if( seperator )
			len += StrLen( seperator );
		newout = NewArray( TEXTCHAR, len );
		tnprintf( newout, len, "%s%s%s", (*output), seperator?seperator:"", tmpbuf );
		Release( (POINTER)*output );
		(*output) = newout;
		Release( (POINTER)tmpbuf );
	}
	else
	{
		(*output) = tmpbuf;
	}
}
struct url_data * SACK_URLParse( const char *url )
{
	const char *_url = url;;
	struct url_data *data = New( struct url_data );
 // another useless initialization.  This WILL be a value whereever the code needs to use it. NOT AN ERROR!
	struct url_cgi_data *cgi_data = NULL;
	TEXTRUNE ch;
	int outchar = 0;
	char * outbuf = NewArray( TEXTCHAR, StrLen( url ) + 1 );
	char *_outbuf = outbuf;
	int _state, state;
	char *newUrl = outbuf;
	int decode = 0;
	while( _url[0] ) {
		if( decode ) {
			ch *= 16;
			if( _url[0] >= '0' && _url[0] <= '9' )
				ch += _url[0] - '0';
			else if( _url[0] >= 'A' && _url[0] <= 'F' )
				ch += (_url[0] - 'A') + 10;
			else if( _url[0] >= 'a' && _url[0] <= 'f' )
				ch += (_url[0] - 'a' ) + 10;
			else {
				Deallocate( char *, outbuf );
				return NULL;
			}
			decode--;
			if( !decode )
				newUrl[0] = (char)decode;
			newUrl++;
		}
		else if( _url[0] == '%' ) {
			ch = 0;
			decode = 2;
		}
		else {
			newUrl[0] = _url[0];
			newUrl++;
		}
		_url++;
	}
	newUrl[0] = _url[0];
	_url = url = outbuf;
	_state = -1;
	state = PARSE_STATE_COLLECT_PROTOCOL;
	MemSet( data, 0, sizeof( struct url_data ) );
	while( ch = GetUtfChar(&url) )
	{
		int use_char;
		use_char = 0;
		switch( ch )
		{
		case '[':
			if( ( state == PARSE_STATE_COLLECT_ADDRESS )
				||( state == PARSE_STATE_COLLECT_USER ) ) {
				state = PARSE_STATE_COLLECT_IPV6;
				use_char = 1;
			}
			break;
		case ']':
			if( state == PARSE_STATE_COLLECT_IPV6 ) {
				// hit the colon between address and port
				outbuf[outchar++] = ch;
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
				continue;
			}
			break;
		case '&':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
  // same state, just a blank cgi param
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_CGI_VALUE )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->value, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '=':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_VALUE;
			}
			break;
		case '?':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
				continue;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_ANCHOR )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_anchor, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '#':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			else if( ( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
				|| ( state == PARSE_STATE_COLLECT_RESOURCE_PATH ) )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			break;
		case '.':
			// I just want to process the '.' when finding the extension.
			// just because we will always want to know it for other reasons later
			if( state == PARSE_STATE_COLLECT_RESOURCE_PATH
				|| state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_EXTENSION;
			}
			else
				use_char = 1;
			break;
		case '/':
			if( state == PARSE_STATE_COLLECT_PROTOCOL_1 )
			{
				if( outchar > 0 )
					lprintf( "Characters between protocol ':' and first slash" );
				state = PARSE_STATE_COLLECT_PROTOCOL_2;
			}
			else if( state == PARSE_STATE_COLLECT_PROTOCOL_2 )
			{
				if( outchar > 0 )
					lprintf( "Characters between protocol first and second slash" );
				state = PARSE_STATE_COLLECT_USER;
			}
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				// what was collected was really
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				// what was collected was really the ip:port not user:password
				data->host = data->user;
				data->user = NULL;
				outbuf[outchar] = 0;
				outchar = 0;
				// should validate port is in numeric.
				data->port = (int)IntCreateFromText( outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PORT )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				data->port = (int)IntCreateFromText( outbuf );
				//AppendBuffer( &data->port, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_PATH )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, "/", outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				// this isn't really the name, it's another part of the resource path
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, "/", outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			break;
		case '@':
  // hit the colon between user and password
			if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->password, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			break;
		case ':':
			if( state == PARSE_STATE_COLLECT_PROTOCOL )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->protocol, NULL, outbuf );
				{
					size_t n;
					for( n = 0; n < num_defaults; n++ )
					{
						if( strcmp( outbuf, default_ports[n].name ) == 0 )
						{
							data->default_port = default_ports[n].number;
						}
					}
				}
				state = PARSE_STATE_COLLECT_PROTOCOL_1;
				continue;
			}
  // hit the colon between user and password
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PASSWORD;
				continue;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_IPV6 )
			{
				use_char = 1;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PORT;
				continue;
			}
			else
			{
 // error
				;
			}
			break;
		default:
			switch( state )
			{
			case PARSE_STATE_COLLECT_PROTOCOL_1:
				// the thing after the ':' was not a '/', so this isn't the protocol.
				break;
			case PARSE_STATE_COLLECT_PROTOCOL_2:
				break;
			default:
				use_char = 1;
			}
			break;
		}
		if( use_char )
			outchar += ConvertToUTF8( outbuf + outchar, ch );
		else
		{
			if( _state == state
  // after starting the path, look for fliename, if the extension or other is not found
				&& ( state != PARSE_STATE_COLLECT_RESOURCE_NAME )
 // blank cgi names go & to & and stay in the same state
				&& ( state != PARSE_STATE_COLLECT_CGI_NAME )
				)
				lprintf( "Dropping character (%d) '%c' in %s", (int)(url - _outbuf), ch, _outbuf );
		}
		_state = state;
	}
	switch( state )
	{
	// this means user name, but if we hit the end of the buffer, it's the address
	case PARSE_STATE_COLLECT_USER:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->host, NULL, outbuf );
		break;
	// this is the first colon, but no @ found, but end of buffer name is host and this is port.
	case PARSE_STATE_COLLECT_PASSWORD:
		data->host = data->user;
		data->user = NULL;
		outbuf[outchar] = 0;
		outchar = 0;
		data->port = (int)IntCreateFromText( outbuf );
		//AppendBuffer( &data->port, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_NAME:
		cgi_data = New( struct url_cgi_data );
		cgi_data->name = NULL;
		cgi_data->value = NULL;
		AddLink( &data->cgi_parameters, cgi_data );
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->name, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_VALUE:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->value, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_RESOURCE_PATH:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->resource_file, NULL, outbuf );
		// this would be one word, no slashes, collecting a path . this is resource name
		break;
	default:
		if( outchar )
		{
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, "/", outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else
			{
				outbuf[outchar] = 0;
				lprintf( "Unused output: state %d [%s]", state, outbuf );
			}
		}
		break;
	}
	Release( outbuf );
	return data;
}
char *SACK_BuildURL( struct url_data *data )
{
	PVARTEXT pvt = VarTextCreate();
	CTEXTSTR tmp = NULL;
	CTEXTSTR tmp2 = NULL;
	if( data->protocol )
		vtprintf( pvt, "%s://", tmp = ConvertTextURI( data->protocol, StrLen( data->protocol ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	// must be a user to use the password, setting just a password is an error really
	if( data->user )
		vtprintf( pvt, "%s%s%s@"
				  , tmp = ConvertTextURI( data->user, StrLen( data->user ), 0 )
				  , data->password?":":""
				  , data->password?(tmp2 = ConvertTextURI( data->password, StrLen( data->password ), 0 )):"" );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( tmp2 )
	{
		Release( (POINTER)tmp2 );
		tmp2 = NULL;
	}
	if( data->host )
		vtprintf( pvt, "%s"
				  , tmp = ConvertTextURI( data->host, StrLen( data->host ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->port )
		vtprintf( pvt, ":%d", data->port );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_path )
		vtprintf( pvt, "/%s"
				  , tmp = ConvertTextURI( data->resource_path, StrLen( data->resource_path), 1 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_file )
		vtprintf( pvt, "/%s"
				  , tmp = ConvertTextURI( data->resource_file, StrLen( data->resource_file), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_extension )
		vtprintf( pvt, ".%s"
				  , tmp = ConvertTextURI( data->resource_extension, StrLen( data->resource_extension), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_anchor )
		vtprintf( pvt, "#%s"
				  , tmp = ConvertTextURI( data->resource_anchor, StrLen( data->resource_anchor), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->cgi_parameters )
	{
		int first = 1;
		INDEX idx;
		struct url_cgi_data *cgi_data;
		LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
		{
			if( cgi_data->value )
				vtprintf( pvt, "%s%s=%s", first?"?":"&", cgi_data->name, cgi_data->value );
			else
				vtprintf( pvt, "%s%s", first?"?":"&", cgi_data->name );
			first = 0;
		}
	}
	{
		PTEXT text_result = VarTextGet( pvt );
		char *result = StrDup( GetText( text_result ) );
		return result;
	}
}
void SACK_ReleaseURL( struct url_data *data )
{
	struct url_cgi_data *cgi_data;
	INDEX idx;
	LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
	{
		Release( (POINTER)cgi_data->name );
		Release( (POINTER)cgi_data->value );
	}
	DeleteList( &data->cgi_parameters );
	Release( (POINTER)data->protocol );
	Release( (POINTER)data->user );
	Release( (POINTER)data->password );
	Release( (POINTER)data->host );
	Release( (POINTER)data->resource_path );
	Release( (POINTER)data->resource_file );
	Release( (POINTER)data->resource_extension );
	Release( (POINTER)data->resource_anchor );
	Release( data );
}
HTTP_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree is often fine for sorting, but for relational things
 *   a Family tree that tracks parent, child, and peers is often required.
 *   The list of peers is a circular linked list based on LinkThing macros
 *   The List is actually broken foward cicularly, but not in a reverse direction
 *
 * see also - include/typelib.h
 *
 */
#define FAMILY_TREE_SOURCE_CODE
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace family {
//	using namespace sack::memory;
#endif
// consider slab allocation... 32 bytes even.
struct familynode_tag {
	struct {
		BIT_FIELD bUsed:1;
	} flags;
	POINTER userdata;
	uintptr_t key;
	struct familynode_tag *elder, *younger, *parent, *child;
};
typedef struct familynode_tag FAMILYNODE;
#define MAXFAMILYNODESPERSET 256
DeclareSet( FAMILYNODE );
struct familyroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // family points to the real FAMILYTREE (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	void (CPROC *Destroy)( POINTER user, uintptr_t key );
	int (CPROC *Compare)(uintptr_t old,uintptr_t newx);
	PFAMILYNODESET nodes;
	PFAMILYNODE family;
	PFAMILYNODE prior
		// current is where things are added
		// newly added nodes become current?
		// prior is the last state, so after adding
      // a child node, the parent may be returned to.
//, prior
										, current
	// hmm lastfound... enumeration from this value?
	// what sort of enumeration of family trees exist?
										, lastfound;
};
typedef struct familyroot_tag FAMILYTREE;
//----------------------------------------------------------------------------
 PFAMILYTREE  CreateFamilyTree ( int (CPROC*Compare)(uintptr_t old,uintptr_t new_key),
															 void (CPROC*Destroy)( POINTER user, uintptr_t key ) )
{
	PFAMILYTREE root = (PFAMILYTREE)Allocate( sizeof( FAMILYTREE ) );
	MemSet( root, 0, sizeof( FAMILYTREE ) );
	root->Compare = Compare;
	root->Destroy = Destroy;
	return root;
}
//----------------------------------------------------------------------------
enum {
	RELATE_CHILD_OF
      , RELATE
};
//----------------------------------------------------------------------------
 POINTER  FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey )
{
	PFAMILYNODE node = root_node;
	root->prior = root_node;
	if( node )
		node = node->child;
	else {
		//lprintf( "from Root of family..." );
		node = root->family;
	}
	while( node )
	{
		int d;
		//lprintf( "compare %s %s", node->key, psvKey );
		if( root->Compare )
			d = root->Compare( node->key, psvKey );
		else
			d = node->key > psvKey?1:node->key<psvKey?-1:0;
		if( !d )
			break;
		node = node->elder;
	}
	root->current = node;
	if( !node )
		return NULL;
	root->lastfound = node;
	return node->userdata;
}
POINTER  FamilyTreeFindChild ( PFAMILYTREE root, uintptr_t psvKey )
{
	return FamilyTreeFindChildEx( root, root->lastfound, psvKey );
}
//----------------------------------------------------------------------------
// scans the whole tree to find a node
LOGICAL FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData )
{
	if( !node )
		node = root->family;
	else
		node = node->child;
	while( node )
	{
		LOGICAL process_result;
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata );
		if( !process_result )
			return process_result;
		node = node->elder;
	}
	return TRUE;
}
// scans the whole tree to find a node
LOGICAL FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData )
{
	static int level;
	if( !node )
		node = root->family;
	else
		node = node->child;
	level++;
	while( node )
	{
		LOGICAL process_result;
		//lprintf( "node %p %s", node, node->key );
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata, level );
		if( !process_result )
			return process_result;
		if( node->child )
			FamilyTreeForEach( root, node, ProcessNode, psvUserData );
		node = node->elder;
	}
	level--;
	return TRUE;
}
static  uintptr_t CPROC DestroyNode(void* p,uintptr_t psvUser )
{
	PFAMILYTREE option_tree = (PFAMILYTREE)psvUser;
	if( option_tree->Destroy )
		option_tree->Destroy( ((PFAMILYNODE)p)->userdata, ((PFAMILYNODE)p)->key );
	DeleteFromSet( FAMILYNODE, option_tree->nodes, p );
	return 0;
}
void  FamilyTreeClear ( PFAMILYTREE option_tree )
{
	ForAllInSet( FAMILYNODE, option_tree->nodes, DestroyNode, (uintptr_t)option_tree );
	DeleteSetEx( FAMILYNODE, &option_tree->nodes );
	option_tree->family = NULL;
//	option_tree->nodes
}
//----------------------------------------------------------------------------
// resets the search conditions, and possibley makes aa tree if it isn't already.
void  FamilyTreeReset ( PFAMILYTREE *option_tree )
{
	if( !option_tree )
		return;
	if( !(*option_tree ) )
		(*option_tree) = CreateFamilyTree( NULL, NULL );
	(*option_tree)->lastfound = NULL;
	(*option_tree)->current = NULL;
}
//----------------------------------------------------------------------------
PFAMILYNODE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key )
{
	//lprintf( "Add TreeCHild: to %p %s %s", parent, parent?(char*)parent->key:"---", key );
	if( root )
	{
		PFAMILYNODE node;
		if( !(*root ) )
			(*root) = CreateFamilyTree( NULL, NULL );
 /*Allocate( sizeof( FAMILYNODE )*/
		node = (PFAMILYNODE)GetFromSet( FAMILYNODE, &(*root)->nodes );
		node->child = NULL;
		node->younger = NULL;
		node->flags.bUsed = 0;
		node->userdata = userdata;
		node->key = key;
//(*root)->prior;
		node->parent = parent;
		if( !node->parent )
		{
			/*if( (*root)->prior ) {
				if( ( node->elder = (*root)->prior->child ) )
					(*root)->family->younger = node;
			}
			else */
			{
				if( ( node->elder = (*root)->family) )
					node->elder->younger = node;
			}
			(*root)->family = node;
		}
		else
		{
			if( (*root)->prior ) {
				if( ( node->elder = (*root)->prior->child ) )
					node->elder->younger = node;
				(*root)->prior->child = node;
			}
		}
		(*root)->prior = node;
		(*root)->lastfound = node;
		(*root)->current = node;
		return node;
	}
	return NULL;
}
#ifdef __cplusplus
 //namespace family {
}
 //namespace containers {
}
 //namespace sack {
}
#endif
/* Defines a simple FRACTION type. Fractions are useful for
   scaling one value to another. These operations are handles
   continously. so iterating a fraction like 13 denominations of
   100 will be smooth.                                           */
#ifndef FRACTIONS_DEFINED
/* Multiple inclusion protection symbol. */
#define FRACTIONS_DEFINED
#ifdef __cplusplus
#  define _FRACTION_NAMESPACE namespace fraction {
#  define _FRACTION_NAMESPACE_END }
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE namespace math {
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END } } }
#else
#  define _FRACTION_NAMESPACE
#  define _FRACTION_NAMESPACE_END
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END
#endif
#ifdef __cplusplus
namespace sack {
#endif
	/* Namespace of custom math routines.  Contains operators
	 for Vectors and fractions. */
#ifdef __cplusplus
	namespace math {
#endif
	/* Fraction namespace contains a PFRACTION type which is used to
   store integer fraction values. Provides for ration and
   proportion scaling. Can also represent fractions that contain
   a whole part and a fractional part (5 2/3 : five and
	two-thirds).                                                  */
#ifdef __cplusplus
	namespace fraction {
#endif
/* Define the call type of the function. */
#define FRACTION_API CPROC
#  ifdef FRACTION_SOURCE
#    define FRACTION_PROC EXPORT_METHOD
#  else
/* Define the library linkage for a these functions. */
#    define FRACTION_PROC IMPORT_METHOD
#  endif
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
/* Pointer to a <link sack::math::fraction::FRACTION, FRACTION>. */
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
typedef struct fraction_tag {
	/* Numerator of the fraction. (This is the number on top of a
	   fraction.)                                                 */
	int numerator;
	/* Denominator of the fraction. (This is the number on bottom of
	   a fraction.) This specifies the denominations.                */
	int denominator;
} FRACTION, *PFRACTION;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct coordpair_tag {
	union {
		FRACTION x;
		FRACTION width;
	};
	union {
		FRACTION y;
		FRACTION height;
	};
} COORDPAIR, *PCOORDPAIR;
#else
/* A coordinate pair is a 2 dimensional fraction expression. can
   be regarded as x, y or width,height. Each coordiante is a
   Fraction type.                                                */
typedef struct coordpair_tag {
	       /* The x part of the coordpair. */
	       FRACTION x;
	       /* The y part of the coordpair. */
	       FRACTION y;
} COORDPAIR, *PCOORDPAIR;
#endif
/* \ \
   Parameters
   fraction :     the fraction to set
   numerator :    numerator of the fraction
   demoninator :  denominator of the fraction */
#define SetFraction(f,n,d) ((((f).numerator=((int)(n)) ),((f).denominator=((int)(d)))),(f))
/* Sets the value of a FRACTION. This is passed as the whole
   number and the fraction.
   Parameters
   fraction :  the fraction to set
   w :         this is the whole number to set
   n :         numerator of remainder to set
   d :         denominator of fraction to set.
   Example
   Fraction f = 3 1/2;
   <code lang="c++">
   FRACTION f;
   SetFractionV( f, 3, 1, 2 );
   // the resulting fraction will be 7/2
   </code>                                                   */
#define SetFractionV(f,w,n,d) (  (d)?	 ((((f).numerator=((int)((n)*(w))) )	  ,((f).denominator=((int)(d)))),(f))	  :	 ((((f).numerator=((int)((w))) )	  ,((f).denominator=((int)(1)))),(f))  )
/* \ \
   Parameters
   base :    origin point (content is modified by adding offset
             to it)
   offset :  offset point                                       */
FRACTION_PROC  void FRACTION_API  AddCoords ( PCOORDPAIR base, PCOORDPAIR offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  AddFractions ( PFRACTION base, PFRACTION offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  SubtractFractions ( PFRACTION base, PFRACTION offset );
/* NOT IMPLEMENTED */
FRACTION_PROC  PFRACTION FRACTION_API  MulFractions ( PFRACTION f, PFRACTION x );
/* Log a fraction into a string. */
FRACTION_PROC  int FRACTION_API  sLogFraction ( TEXTCHAR *string, PFRACTION x );
/* Unsafe log of a coordinate pair's value into a string. The
   string should be at least 69 characters long.
   Parameters
   string :  the string to print the fraction into
   pcp :     the coordinate pair to print                     */
FRACTION_PROC  int FRACTION_API  sLogCoords ( TEXTCHAR *string, PCOORDPAIR pcp );
/* Log coordpair to logfile. */
FRACTION_PROC  void FRACTION_API  LogCoords ( PCOORDPAIR pcp );
/* scales a fraction by a signed integer value.
   Parameters
   result\ :  pointer to a FRACTION to receive the result
   value :    the amount to be scaled
   f :        the fraction to multiply the value by
   Returns
   \result; the pointer the fraction to receive the result. */
FRACTION_PROC  PFRACTION FRACTION_API  ScaleFraction ( PFRACTION result, int32_t value, PFRACTION f );
/* Results in the integer part of the fraction. If the faction
   was 330/10 then the result would be 33.                     */
FRACTION_PROC  int32_t FRACTION_API  ReduceFraction ( PFRACTION f );
/* Scales a 32 bit integer value by a fraction. The result is
   the scaled value result.
   Parameters
   f :      pointer to the faction to multiply value by
   value :  the value to scale
   Returns
   The (value * f) integer value of.                          */
FRACTION_PROC  uint32_t FRACTION_API  ScaleValue ( PFRACTION f, int32_t value );
/* \ \
   Parameters
   f :      The fraction to scale the value by
   value :  the value to scale by (1/f)
   Returns
   the value of ( value * 1/ f )               */
FRACTION_PROC  uint32_t FRACTION_API  InverseScaleValue ( PFRACTION f, int32_t value );
#ifdef __cplusplus
 //	SACK_MATH_FRACTION_NAMESPACE_END
} } }
using namespace sack::math::fraction;
#endif
#endif
//---------------------------------------------------------------------------
// $Log: fractions.h,v $
// Revision 1.6  2004/09/03 14:43:40  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.4  2003/01/27 09:45:03  panther
// Fix lack of anonymous structures
//
// Revision 1.3  2002/10/09 13:16:02  panther
// Support for linux shared memory mapping.
// Support for better linux compilation of configuration scripts...
// Timers library is now Threads AND Timers.
//
//
#ifdef __cplusplus
	namespace sack { namespace math { namespace fraction {
#endif
//---------------------------------------------------------------------------
 int  sLogFraction ( TEXTCHAR *string, PFRACTION x )
{
	if( x->denominator < 0 )
	{
		if( x->numerator > -x->denominator )
			return tnprintf( string, 31, "-%d %d/%d"
						, x->numerator / (-x->denominator)
						, x->numerator % (-x->denominator), -x->denominator );
		else
			return tnprintf( string, 31, "-%d/%d", x->numerator, -x->denominator );
	}
	else
	{
		if( x->numerator > x->denominator )
			return tnprintf( string, 31, "%d %d/%d"
						, x->numerator / x->denominator
						, x->numerator % x->denominator, x->denominator );
		else
			return tnprintf( string, 31, "%d/%d", x->numerator, x->denominator );
	}
}
//---------------------------------------------------------------------------
 int  sLogCoords ( TEXTCHAR *string, PCOORDPAIR pcp )
{
	TEXTCHAR *start = string;
	string += tnprintf( string, 2*sizeof(TEXTCHAR), "(" );
	string += sLogFraction( string, &pcp->x );
	string += tnprintf( string, 2*sizeof(TEXTCHAR), "," );
	string += sLogFraction( string, &pcp->y );
	string += tnprintf( string, 2*sizeof(TEXTCHAR), ")" );
	return (int)(string - start);
}
 void  LogCoords ( PCOORDPAIR pcp )
{
	TEXTCHAR buffer[256];
	TEXTCHAR *string = buffer;
	string += tnprintf( string, 2*sizeof(TEXTCHAR), "(" );
	string += sLogFraction( string, &pcp->x );
	string += tnprintf( string, 2*sizeof(TEXTCHAR), "," );
	string += sLogFraction( string, &pcp->y );
	string += tnprintf( string, 2*sizeof(TEXTCHAR), ")" );
	Log( buffer );
}
//---------------------------------------------------------------------------
static void NormalizeFraction( PFRACTION f )
{
	int n;
	int target = ( (f->numerator < f->denominator) ?f->numerator:f->denominator) / 2;
	for( n = 2; n <target; n++ )
	{
		if( ( ( f->numerator % n) == 0 ) &&
		    ( ( f->denominator % n ) == 0 ) )
		{
			f->numerator /= n;
			f->denominator /= n;
 // one cause we add one before looping again;
			n = 1;
			target = ( ( f->numerator < f->denominator )?f->numerator:f->denominator) / 2;
			continue;
		}
	}
}
//---------------------------------------------------------------------------
 PFRACTION  AddFractions ( PFRACTION base, PFRACTION offset )
{
 // 0 addition either way is same.
	if( !offset->numerator )
		return base;
	//LogFraction( base );
	//fprintf( log, " + " );
	//LogFraction( offset );
	//fprintf( log, " = " );
	if( base->denominator < 0 )
	{
		if( offset->denominator < 0 )
		{
			// result is MORE negative when adding them... this is good.
			if( offset->denominator == base->denominator )
			{
				base->numerator += offset->numerator;
			}
			else
			{
				// results in a positive value
				base->numerator = -( ( base->numerator * offset->denominator ) +
				                     ( offset->numerator * base->denominator ) );
				base->denominator *= offset->denominator;
				// need to retain it's original sign....
				base->denominator = -base->denominator;
			}
		}
		else
		{
			// base (probably small negative) - offset + (probably a BIG positive)
			if( offset->denominator == -base->denominator )
			{
				base->numerator -= offset->numerator;
			}
			else
			{
				// result is positive - which is original sign.
				base->numerator = -( ( base->numerator * offset->denominator ) +
									      ( offset->numerator * base->denominator ) );
				base->denominator *= -offset->denominator;
			}
		}
	}
	else
	{
		if( offset->denominator < 0 )
		{
			// correct - base positive, offset negative
			// results in a positive addition from the origin...
			// making it less negative and closer to the bottom/right
			if( offset->denominator == -base->denominator )
			{
				base->numerator = offset->numerator - base->numerator;
				base->denominator = -base->denominator;
			}
			else
			{
				base->numerator = ( base->numerator * offset->denominator ) +
									   ( offset->numerator * base->denominator );
				base->denominator *= offset->denominator;
			}
		}
		else
		{
			if( offset->denominator == base->denominator )
			{
				base->numerator += offset->numerator;
			}
			else
			{
            //lprintf( "%d %d %d %d = %d", base->numerator,
				//		  base->denominator,
				//		  offset->denominator, offset->numerator, ( base->numerator * offset->denominator ) +
				//						( offset->numerator * base->denominator ) );
				base->numerator = ( base->numerator * offset->denominator ) +
										( offset->numerator * base->denominator );
				base->denominator *= offset->denominator;
			}
		}
	}
	NormalizeFraction( base );
	return base;
	//LogFraction( base );
	//fprintf( log, "\n" );
}
//---------------------------------------------------------------------------
 PFRACTION  SubtractFractions ( PFRACTION base, PFRACTION offset )
{
 // 0 addition either way is same.
	if( !offset->numerator )
		return base;
	//LogFraction( base );
	//fprintf( log, " + " );
	//LogFraction( offset );
	//fprintf( log, " = " );
	if( base->denominator < 0 )
	{
		if( offset->denominator < 0 )
		{
			// result is MORE negative when adding them... this is good.
			if( offset->denominator == base->denominator )
			{
				base->numerator -= offset->numerator;
			}
			else
			{
				// results in a positive value
				base->numerator = -( ( base->numerator * offset->denominator ) -
				                     ( offset->numerator * base->denominator ) );
				base->denominator *= offset->denominator;
				// need to retain it's original sign....
				base->denominator = -base->denominator;
			}
		}
		else
		{
			// base (probably small negative) - offset + (probably a BIG positive)
			if( offset->denominator == -base->denominator )
			{
				base->numerator += offset->numerator;
			}
			else
			{
				// result is positive - which is original sign.
				base->numerator = -( ( base->numerator * offset->denominator ) -
									      ( offset->numerator * base->denominator ) );
				base->denominator *= -offset->denominator;
			}
		}
	}
	else
	{
		if( offset->denominator < 0 )
		{
			// correct - base positive, offset negative
			// results in a positive addition from the origin...
			// making it less negative and closer to the bottom/right
			if( offset->denominator == -base->denominator )
			{
				base->numerator = offset->numerator + base->numerator;
				base->denominator = -base->denominator;
			}
			else
			{
				base->numerator = ( base->numerator * offset->denominator ) -
									   ( offset->numerator * base->denominator );
				base->denominator *= offset->denominator;
			}
		}
		else
		{
			if( offset->denominator == base->denominator )
			{
				base->numerator -= offset->numerator;
			}
			else
			{
				//lprintf( "%d %d %d %d = %d", base->numerator,
				//		  base->denominator,
				//		  offset->denominator, offset->numerator, ( base->numerator * offset->denominator ) +
				//						( offset->numerator * base->denominator ) );
				base->numerator = ( base->numerator * offset->denominator ) -
										( offset->numerator * base->denominator );
				base->denominator *= offset->denominator;
			}
		}
	}
	NormalizeFraction( base );
	return base;
	//LogFraction( base );
	//fprintf( log, "\n" );
}
//---------------------------------------------------------------------------
 void  AddCoords ( PCOORDPAIR base, PCOORDPAIR offset )
{
	AddFractions( &base->x, &offset->x );
	AddFractions( &base->y, &offset->y );
}
//---------------------------------------------------------------------------
 PFRACTION  ScaleFraction ( PFRACTION result, int32_t value, PFRACTION f )
{
	result->numerator = value * f->numerator;
	result->denominator = f->denominator;
	return result;
}
//---------------------------------------------------------------------------
 uint32_t  ScaleValue ( PFRACTION f, int32_t value )
{
	int32_t result = 0;
	if( f->denominator )
		result = ( value * f->numerator ) / f->denominator;
	return result;
}
//---------------------------------------------------------------------------
 uint32_t  InverseScaleValue ( PFRACTION f, int32_t value )
{
	int32_t result =0;
	if( f->numerator )
		result = ( value * f->denominator ) / f->numerator;
	return result;
}
//---------------------------------------------------------------------------
 int32_t  ReduceFraction ( PFRACTION f )
{
	return ( f->numerator ) / f->denominator;
}
#ifdef __cplusplus
//	namespace sack { namespace math { namespace fraction {
	}}}
#endif
//---------------------------------------------------------------------------
// $Log: fractions.c,v $
// Revision 1.6  2005/01/27 07:39:23  panther
// Linux cleaned.
//
// Revision 1.5  2004/09/03 14:43:47  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.4  2003/03/25 08:45:50  panther
// Added CVS logging tag
//
#define VECTOR_LIBRARY_SOURCE
 // all for outputdebug string
//#include <winbase.h>
/*
 *  Created By Jim Buckeyne
 *
 *  Purpose:
 *    Provides some cross platform/library functionatlity for
 *  filesystem activities.
 *  - File dates, times, stuff like that
 *  - make paths, change paths
 *  - path parsing (like strchr, strrchr, but looking for closest / or \)
 *  - scan a directory for a set of files... using a recursive callback method
 */
#ifndef FILESYSTEM_UTILS_DEFINED
/* Header multiple inclusion protection symbol. */
#define FILESYSTEM_UTILS_DEFINED
#if _MSC_VER >= 1600
#include <share.h>
#endif
#if !defined( UNDER_CE )
#include <fcntl.h>
#if !defined( __LINUX__ )
#include <io.h>
#else
#define LPFILETIME uint64_t*
#define FILETIME uint64_t
#endif
#endif
/* uhmm in legacy usage this was not CPROC, but was unspecified */
#define FILESYS_API CPROC
// DOM-IGNORE-BEGIN
#ifdef FILESYSTEM_LIBRARY_SOURCE
#  define FILESYS_PROC EXPORT_METHOD
#else
#  define FILESYS_PROC IMPORT_METHOD
#endif
// DOM-IGNORE-END
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _FILESYS_NAMESPACE  namespace filesys {
/* Define the ending symbol for file system namespace. */
#define _FILESYS_NAMESPACE_END }
/* Defined the namespace of file montior utilities. File monitor
   provides event notification based on file system changes.     */
#define _FILEMON_NAMESPACE  namespace monitor {
/* Define the end symbol for file monitor namespace. */
#define _FILEMON_NAMESPACE_END }
#else
#define _FILESYS_NAMESPACE
#define _FILESYS_NAMESPACE_END
#define _FILEMON_NAMESPACE
#define _FILEMON_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define FILESYS_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define FILESYS_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE
/* Define end file monitor namespace. */
#define FILEMON_NAMESPACE_END _FILEMON_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* Defines the file montior namespace when compiling C++. */
#define FILEMON_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE _FILEMON_NAMESPACE
#ifdef __cplusplus
namespace sack {
#endif
/* \File system abstractions. A few things like get current path
   may or may not exist on a function.
   Primarily this defines functions 'pathchr' and 'pathrchr'
   which resemble 'strchr' and 'strrchr' but search a string for
   a path character. A path character is either a / or a \\.
   Also in this area is file monitoring functions which support
   methods on windows and linux to get event notifications when
   directories and, by filtering, files that have changed.
                                                                 */
#ifdef __cplusplus
	namespace filesys {
#endif
	enum ScanFileFlags {
SFF_DEFAULT = 0,
 // go into subdirectories
SFF_SUBCURSE    = 1,
 // return directory names also
SFF_DIRECTORIES = 2,
 // don't concatenate base with filename to result.
SFF_NAMEONLY    = 4,
 // when matching filename - do not match case.
SFF_IGNORECASE  = 8,
 // don't concatenate base with filename to result, but do build path relative to root specified
SFF_SUBPATHONLY    = 16,
	};
 // flags sent to Process when called with a matching name
enum ScanFileProcessFlags{
 // is a directory...
SFF_DIRECTORY  = 1,
 // this is a drive...
		SFF_DRIVE      = 2,
};
struct file_system_mounted_interface;
/* Extended external file system interface to be able to use external file systems */
struct file_system_interface {
                                                  //filename
	void* (CPROC *open)(uintptr_t psvInstance, const char *, const char *);
                                                 //file *
	int (CPROC *_close)(void *);
                    //file *, buffer, length (to read)
	size_t (CPROC *_read)(void *,void *, size_t);
                    //file *, buffer, length (to write)
	size_t (CPROC *_write)(void*,const void *, size_t);
	size_t (CPROC *seek)( void *, size_t, int whence);
	void  (CPROC *truncate)( void *);
	int (CPROC *_unlink)( uintptr_t psvInstance, const char *);
 // get file size
	size_t (CPROC *size)( void *);
 // get file current position
	size_t (CPROC *tell)( void *);
	int (CPROC *flush )(void *kp);
	int (CPROC *exists)( uintptr_t psvInstance, const char *file );
	LOGICAL (CPROC*copy_write_buffer)(void );
	struct find_cursor *(CPROC *find_create_cursor )( uintptr_t psvInstance, const char *root, const char *filemask );
	int (CPROC *find_first)( struct find_cursor *cursor );
	int (CPROC *find_close)( struct find_cursor *cursor );
	int (CPROC *find_next)( struct find_cursor *cursor );
	char * (CPROC *find_get_name)( struct find_cursor *cursor );
	size_t (CPROC *find_get_size)( struct find_cursor *cursor );
	LOGICAL (CPROC *find_is_directory)( struct find_cursor *cursor );
	LOGICAL (CPROC *is_directory)( uintptr_t psvInstance, const char *cursor );
	LOGICAL (CPROC *rename )( uintptr_t psvInstance, const char *original_name, const char *new_name );
	uintptr_t (CPROC *ioctl)( uintptr_t psvInstance, uintptr_t opCode, va_list args );
	uintptr_t (CPROC *fs_ioctl)(uintptr_t psvInstance, uintptr_t opCode, va_list args);
	uint64_t( CPROC *find_get_ctime )(struct find_cursor *cursor);
	uint64_t( CPROC *find_get_wtime )(struct find_cursor *cursor);
	int ( CPROC* _mkdir )( uintptr_t psvInstance, const char* );
	int ( CPROC* _rmdir )( uintptr_t psvInstance, const char* );
                //file *
	int (CPROC* _lock)(void*);
              //file *
	int (CPROC* _unlock)(void*);
 // set chmod( filename, 0777 )
	int (CPROC* _make_public)( uintptr_t psvInstance, CTEXTSTR filename );
	int ( CPROC* _chdir )( uintptr_t psvInstance, const char* );
};
/* \ \
   Parameters
   mask :      This is the mask used to compare
   name :      this is the name to compare against using the mask.
   keepcase :  if TRUE, must match case also.
   Returns
   TRUE if name is matched by mask. Otherwise returns FALSE.
   Example
   <code lang="c++">
   if( CompareMask( "*.exe", "program.exe", FALSE ) )
   {
       // then program.exe is matched by the mask.
   }
   </code>
   Remarks
   The mask support standard 'globbing' characters.
   ? matches one character
   \* matches 0 or more characters
   otherwise the literal character must match, unless comparing
   case insensitive, in which case 'A' == 'a' also.                */
FILESYS_PROC  int FILESYS_API  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase );
// ScanFiles usage:
//   base - base path to scan
//   mask - file mask to process if NULL or "*" is everything "*.*" must contain a .
//   pInfo is a pointer to a void* - this pointer is used to maintain
//        internal information...
//   Process is called with the full name of any matching files
//   subcurse is a flag - set to go into all subdirectories looking for files.
// There is no way to abort the scan...
FILESYS_PROC  int FILESYS_API  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
		   , uintptr_t psvUser, LOGICAL begin_sub_path, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  ScanFiles ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
           , uintptr_t psvUser );
FILESYS_PROC  void FILESYS_API  ScanDrives ( void (CPROC *Process)(uintptr_t user, CTEXTSTR letter, int flags)
										  , uintptr_t user );
// pass the pointer (pInfo) from aobve; get find_cursor.
FILESYS_PROC struct find_cursor * FILESYS_API GetScanFileCursor( void *pInfo );
// result is length of name filled into pResult if pResult == NULL && nResult = 0
// the result will the be length of the name matching the file.
FILESYS_PROC  int FILESYS_API  GetMatchingFileName ( CTEXTSTR filemask, enum ScanFileFlags flags, TEXTSTR pResult, int nResult );
// searches a path for the last '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathrchr ( CTEXTSTR path );
// searches a path for the last '/' or '\'
FILESYS_PROC  const wchar_t* FILESYS_API  pathrchrW( const wchar_t* path );
#ifdef __cplusplus
FILESYS_PROC  TEXTSTR FILESYS_API  pathrchr ( TEXTSTR path );
FILESYS_PROC  wchar_t* FILESYS_API pathrchrW( wchar_t* path );
#endif
// searches a path for the first '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathchr ( CTEXTSTR path );
/*
   compares filenames case insensitively and slash agnostic
*/
FILESYS_PROC int FILESYS_API PathCmpEx( CTEXTSTR s1, CTEXTSTR s2, int maxlen );
/*
   compares filenames case insensitively and slash agnostic.  Uses PathCmpEx() with maxlen=65535
*/
FILESYS_PROC int FILESYS_API PathCmp( CTEXTSTR s1, CTEXTSTR s2 );
// returns pointer passed (if it worked?)
FILESYS_PROC  TEXTSTR FILESYS_API  GetCurrentPath ( TEXTSTR path, int buffer_len );
FILESYS_PROC  int FILESYS_API  SetCurrentPath ( CTEXTSTR path );
/* Creates a directory. If parent pieces of the directory do not
   exist, those parts are created also.
   Example
   <code lang="c#">
   MakePath( "c:\\where\\I'm/going/to/store/data" );
   </code>                                                       */
FILESYS_PROC  int FILESYS_API  MakePath ( CTEXTSTR path );
/* A boolean result function whether a specified name is a
   directory or not. (if not, assumes it's a file).
   Example
   <code lang="c#">
   if( IsPath( "c:/windows" ) )
   {
       // if yes, then c:\\windows is a directory.
   }
   </code>                                                 */
FILESYS_PROC LOGICAL  FILESYS_API  IsPath ( CTEXTSTR path );
FILESYS_PROC LOGICAL  FILESYS_API  IsAbsolutePath( CTEXTSTR path );
FILESYS_PROC  uint64_t     FILESYS_API  GetFileWriteTime ( CTEXTSTR name );
FILESYS_PROC  uint64_t     FILESYS_API  GetTimeAsFileTime ( void );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileWriteTime( CTEXTSTR name, uint64_t filetime );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileTimes( CTEXTSTR name
  // last modification time.
															  , uint64_t filetime_create
 // last modification time.
															  , uint64_t filetime_modify
  // last modification time.
															  , uint64_t filetime_access
															  );
FILESYS_PROC  void    FILESYS_API  SetDefaultFilePath ( CTEXTSTR path );
FILESYS_PROC  INDEX   FILESYS_API  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_prepend_path ( INDEX group, CTEXTSTR filename );
/* This is a new feature added for supporting systems without a
   current file location. This gets an integer ID of a group of
   files by name.
   the name 'default' is used to specify files to go into the
   'current working directory'
	There are some special symbols.
	. = use CurrentPath
	@ = use program path base
   ^ = use program startup path (may not be current)
   Parameters
   groupname :     name of the group
   default_path :  the path of the group, if the name is not
                   found.
   Returns
   the ID of a file group.
   Example
   <code lang="c++">
   int group = GetFileGroup( "fonts", "./fonts" );
   </code>                                                      */
FILESYS_PROC INDEX FILESYS_API  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path );
/*
   Get the path the filegroup is defined as; or has been reloaded from option
   database as.
*/
FILESYS_PROC TEXTSTR FILESYS_API GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars );
/*
ExpandPath() returns a string, which the caller must release.  The path is insepcted to see if it is
an absolute path ( '/' on unix or '?:/' on windows, where ? is any character).  All checks for slashes
check both `\` and `/` as the same character.
If it is absolute, it returns a copy of the path.
If the path starts with a special character followed by a slash, then the character is replaced.
|character| meaning|
|---|----|
|'./'| the current directory.  The dot is replaced with the full path to the current directory. |
|'~/'|the home directory.  The `~` is replaced with `HOME` (on *nix) or `HOMEPATH`(on windows), and '.' (on android). This is also checked after all of these have previously been checked. so ';' can use '~'|
|`@/`| the libraries path.  This is the path of the library or program currently running the filesystem abstraction. |
|'?/'| %resources%.  This is defaulted to the install location, and is the common resources instealled with SACK. |
|'^/'| Startup path.  This is the first path the application started in.  This is often the same as current directory, but current directoy can change. |
|'*' '/'| on linux this is /var/Freedom Collective/<application>, on windows this is c:/programdata/Freedom Collective/<application.  This is actually (common writeable data/<provider>/<application>/ and it is possible to set/change the provider name.  The application name is determined by the name used to run the program.|
|';/'| on linux this is ~/.[provider]/<application>, on windows this is c:/users/<user>/programdata/[provider]/[application].
The default `[provider]` is Freedom Collective (shrug) needed to come up with a company name at some point.  To date
there is no company other than in name only.
Varibles bounded by `%` are replaced with file group path, if there is no filepath, then the name is looked up
in the environment and that's used.
The path characters `/` and `\` are then forced to the host system preferred type of slash.  Although windows
has been agnositic, updating the interfaces on windows to the system to be unicode(since ascii isn't uft8),
the wide APIs require `\`; and really linux requires `/`.
Finally relative paths that are left are resolved, if there is a path part before the `..` to remove.
*/
FILESYS_PROC TEXTSTR FILESYS_API ExpandPathExx( CTEXTSTR path, struct file_system_interface* fsi DBG_PASS );
#define ExpandPathEx( path, fsi )  ExpandPathExx( path, fsi DBG_SRC )
#define ExpandPath(path) ExpandPathExx( path, NULL DBG_SRC )
FILESYS_PROC LOGICAL FILESYS_API SetFileLength( CTEXTSTR path, size_t length );
/* \Returns the size of the file.
   Parameters
   name :  name of the file to get information about
   Returns
   \Returns the size of the file. or -1 if the file did not
   exist.                                                   */
FILESYS_PROC  size_t FILESYS_API  GetSizeofFile ( TEXTCHAR *name, uint32_t* unused );
#ifndef __ANDROID__
/* An extended function, which returns a uint64_t bit time
   appropriate for the current platform. This is meant to
   replace 'stat'. It can get all commonly checked attributes of
   a file.
   Parameters
   name :              name of the file to get information about
   lpCreationTime :    pointer to a FILETIME type to get creation
                       time. can be NULL.
   lpLastAccessTime :  pointer to a FILETIME type to get access
                       time. can be NULL.
   lpLastWriteTime :   pointer to a FILETIME type to get write
                       time. can be NULL.
   IsDirectory :       pointer to a LOGICAL to receive indicator
                       whether the file was a directory. can be
                       NULL.
   Returns
   \Returns the size of the file. or -1 if the file did not
	exist.                                                         */
FILESYS_PROC  uint32_t FILESYS_API  GetFileTimeAndSize ( CTEXTSTR name
													, LPFILETIME lpCreationTime
													,  LPFILETIME lpLastAccessTime
													,  LPFILETIME lpLastWriteTime
													, int *IsDirectory
													);
FILESYS_PROC void FILESYS_API ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime );
FILESYS_PROC uint64_t FILESYS_API ConvertFileTimeToInt( const FILETIME *filetime );
#endif
// can use 0 as filegroup default - single 'current working directory'
#ifndef NEED_OLDNAMES
#define _NO_OLDNAMES
#endif
//#ifdef UNDER_CE
# ifndef O_RDONLY
#define O_RDONLY       0x0000
#define O_WRONLY       0x0001
#define O_RDWR         0x0002
#define O_APPEND       0x0008
#define O_CREAT        0x0100
#define O_TRUNC        0x0200
#define O_EXCL         0x0400
#endif
#ifndef __ANDROID__
#  ifndef S_IRUSR
#    define S_IRUSR 1
#    define S_IWUSR 2
#  endif
#endif
//# endif
#ifndef __LINUX__
// legacy 3.1 support.  Please use a FILE* instead.
FILESYS_PROC  HANDLE FILESYS_API  sack_open ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_set_eof ( HANDLE file_handle );
FILESYS_PROC  long  FILESYS_API   sack_tell( INDEX file_handle );
FILESYS_PROC  HANDLE FILESYS_API  sack_openfile ( INDEX group, CTEXTSTR filename, OFSTRUCT *of, int flags );
FILESYS_PROC  HANDLE FILESYS_API  sack_creat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  int FILESYS_API  sack_close ( HANDLE file_handle );
FILESYS_PROC  int FILESYS_API  sack_lseek ( HANDLE file_handle, int pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_read ( HANDLE file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_write ( HANDLE file_handle, CPOINTER buffer, int size );
#endif
FILESYS_PROC  INDEX FILESYS_API  sack_iopen ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  INDEX FILESYS_API  sack_iopenfile ( INDEX group, CTEXTSTR filename, int opts, int flags );
FILESYS_PROC  INDEX FILESYS_API  sack_icreat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_iset_eof ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_iclose ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_ilseek ( INDEX file_handle, size_t pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_iread ( INDEX file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_iwrite ( INDEX file_handle, CPOINTER buffer, int size );
/*
	Enable per-thread mounts.
	once you do this, you will have to provide the thread with some mounts.
*/
FILESYS_PROC void FILESYS_API sack_filesys_enable_thread_mounts( void );
/* internal (c library) file system is registered as prority 1000.... lower priorities are checked first for things like
  ScanFiles(), fopen( ..., "r" ), ... exists(), */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_mount_filesystem( const char *name, struct file_system_interface *, int priority, uintptr_t psvInstance, LOGICAL writable );
/*
  Mount filesystem again, using an existing mount as a reference.
  name is not required (NULL)
  priority, if 0, will use the priority of the existing mount.
  writeable will apply for writes through this mount.  If the previous mount
  is writable and writable != 0, the new mount can be written, if either
  is 0, this mount will not be writable.  (cannnot remount-write)
*/
FILESYS_PROC struct file_system_mounted_interface* FILESYS_API sack_remount_filesystem( const char* name, struct file_system_mounted_interface* oldMount, int priority, LOGICAL writable );
/*
  Remove a mount from chain of mounts.
*/
FILESYS_PROC void FILESYS_API sack_unmount_filesystem( struct file_system_mounted_interface *mount );
/*
   get a mounted filesystem by name.
*/
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_mounted_filesystem( const char *name );
/*
   returrn inteface used on the mounted filesystem.
*/
FILESYS_PROC struct file_system_interface * FILESYS_API sack_get_mounted_filesystem_interface( struct file_system_mounted_interface * );
/*
   Some file system interfaces might use this(?), This is probably already deprecated.
*/
FILESYS_PROC uintptr_t FILESYS_API sack_get_mounted_filesystem_instance( struct file_system_mounted_interface *mount );
/* sometimes you want scanfiles to only scan external files...
  so this is how to get that mount */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_default_mount( void );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted... */
FILESYS_PROC  FILE* FILESYS_API  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fsopenEx ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted...
   if mode is write/create only the first writable file system is used...
*/
FILESYS_PROC  FILE* FILESYS_API  sack_fsopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode );
FILESYS_PROC  struct file_system_interface * FILESYS_API sack_get_filesystem_interface( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_default_filesystem_interface( struct file_system_interface *fsi );
/*
 register a name for a file system interface object.
 This interface provides all the callbacks used to access file and directory objects
 */
FILESYS_PROC  void FILESYS_API sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi );
FILESYS_PROC  int FILESYS_API  sack_fclose ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount );
FILESYS_PROC  size_t FILESYS_API  sack_fseek ( FILE *file_file, size_t pos, int whence );
FILESYS_PROC  size_t FILESYS_API  sack_ftell ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fsize ( FILE *file_file );
FILESYS_PROC  LOGICAL FILESYS_API  sack_existsEx ( const char * filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  LOGICAL FILESYS_API  sack_exists ( const char *file_file );
// tests if the text passed is a directory or path to a file... for a specific mount.
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi );
// tests if the text passed is a directory or path to a file... for all mounts
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPath( const char * filename );
FILESYS_PROC  size_t FILESYS_API  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_fgets ( TEXTSTR  buffer, size_t size,FILE *file_file );
FILESYS_PROC  int FILESYS_API  sack_fflush ( FILE *file );
FILESYS_PROC  int FILESYS_API  sack_ftruncate ( FILE *file );
FILESYS_PROC int FILESYS_API sack_vfprintf( FILE *file_handle, const char *format, va_list args );
FILESYS_PROC int FILESYS_API sack_fprintf( FILE *file, const char *format, ... );
FILESYS_PROC int FILESYS_API sack_fputs( const char *format, FILE *file );
FILESYS_PROC  int FILESYS_API  sack_unlinkEx ( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_unlink ( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_rmdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount );
FILESYS_PROC  int FILESYS_API  sack_rmdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_mkdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount );
FILESYS_PROC  int FILESYS_API  sack_chdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount );
FILESYS_PROC  int FILESYS_API  sack_mkdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_rename ( CTEXTSTR file_source, CTEXTSTR new_name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_application( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_producer( CTEXTSTR name );
FILESYS_PROC  uintptr_t FILESYS_API  sack_ioctl( FILE *file, uintptr_t opCode, ... );
FILESYS_PROC  uintptr_t FILESYS_API  sack_fs_ioctl( struct file_system_mounted_interface *mount, uintptr_t opCode, ... );
FILESYS_PROC int FILESYS_API sack_flock( FILE* file );
FILESYS_PROC int FILESYS_API sack_funlock( FILE* file );
/*
  change permissions so everyone can read and write the file.
  result is < 0 and errno is set to ENOENT if there is no handler entry for the mount found.
*/
FILESYS_PROC int FILESYS_API make_public( CTEXTSTR filename );
/*
  change permissions so everyone can read and write the file; on a given mount.
  many mounts do not support this yet.
  result is < 0 and errno is set to ENOENT if there is no handler entry for the mount specified.
*/
FILESYS_PROC int FILESYS_API make_public_mount( CTEXTSTR filename, struct file_system_mounted_interface*mount );
#ifndef NO_FILEOP_ALIAS
#  ifndef NO_OPEN_MACRO
# define open(a,...) sack_iopen(0,a,##__VA_ARGS__)
# define set_eof(a)  sack_iset_eof(a)
#  endif
#ifdef WIN32
#if !defined( SACK_BAG_EXPORTS ) && !defined( BAG_EXTERNALS ) && !defined( FILESYSTEM_LIBRARY_SOURCE )
# define _lopen(a,...) sack_open(0,a,##__VA_ARGS__)
# define tell(a)      sack_tell(a)
# define lseek(a,b,c) sack_ilseek(a,b,c)
# define _llseek(a,b,c) sack_lseek(a,b,c)
# define HFILE HANDLE
# undef HFILE_ERROR
# define HFILE_ERROR INVALID_HANDLE_VALUE
# define creat(a,...)  sack_icreat( 0,a,##__VA_ARGS__ )
# define close(a)  sack_iclose(a)
# define OpenFile(a,b,c) sack_openfile(0,a,b,c)
# define _lclose(a)  sack_close(a)
# define read(a,b,c) sack_iread(a,b,c)
# define write(a,b,c) sack_iwrite(a,b,c)
# define _lread(a,b,c) sack_read(a,b,c)
# define _lwrite(a,b,c) sack_write(a,b,c)
# define _lcreat(a,b) sack_creat(0,a,b)
# define remove(a)   sack_unlink(0,a)
# define unlink(a)   sack_unlink(0,a)
# define rmdir(a)   sack_rmdir(0,a)
# define mkdir(a)   sack_mkdir(0,a)
#endif
#endif
 //NO_FILEOP_ALIAS
#endif
#ifdef __LINUX__
#define SYSPATHCHAR "/"
#else
#define SYSPATHCHAR "\\"
#endif
FILESYS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::filesys;
#endif
#endif
#include <math.h>
// assembly support is NOT currently...
// #define MSVC_ASSEMBLE
//----------------------------------------------------------------
#include <immintrin.h>
// double...
// __m256d
// single...
// __m128f
// one day I'd like to make a multidimensional library
// but for now - 3D is sufficient - it can handle everything
// under 2D ignoring the Z axis... although it would be more
// efficient to do 2D implementation alone...
// but without function overloading the names of all the functions
// become much too complex.. well perhaps - maybe I can
// make all the required functions with a suffix - and
// supply defines to choose the default based on the dimension number
#ifndef ROTATE_DECLARATION
// vector multiple inclusion protection
#define ROTATE_DECLARATION
#if !defined(__STATIC__) && !defined(__LINUX__)
#  ifdef VECTOR_LIBRARY_SOURCE
#    define MATHLIB_EXPORT EXPORT_METHOD
#    if defined( __WATCOMC__ ) || defined( _MSC_VER ) && !defined( __clang__ )
// data requires an extra extern to generate the correct code *boggle*
#      define MATHLIB_DEXPORT extern EXPORT_METHOD
#    else
#      define MATHLIB_DEXPORT EXPORT_METHOD
#    endif
#  else
#    define MATHLIB_EXPORT IMPORT_METHOD
#    if ( defined( __WATCOMC__ ) || defined( _MSC_VER ) || defined( __GNUC__ ) ) && !defined( __ANDROID__ )
// data requires an extra extern to generate the correct code *boggle*
#      ifndef __cplusplus_cli
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      else
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      endif
#    else
#      define MATHLIB_DEXPORT IMPORT_METHOD
#    endif
#  endif
#else
#ifndef VECTOR_LIBRARY_SOURCE
#define MATHLIB_EXPORT extern
#define MATHLIB_DEXPORT extern
#else
#define MATHLIB_EXPORT
#define MATHLIB_DEXPORT
#endif
#endif
#define DIMENSIONS 3
#if( DIMENSIONS > 0 )
   #define vRight   0
   #define _1D(exp)  exp
   #if( DIMENSIONS > 1 )
	  #define vUp      1
	  #define _2D(exp)  exp
	  #if( DIMENSIONS > 2 )
		 #define vForward 2
		 #define _3D(exp)  exp
		 #if( DIMENSIONS > 3 )
  // 4th dimension 'IN'/'OUT' since projection is scaled 3d...
			#define vIn      3
			#define _4D(exp)  exp
		 #else
			#define _4D(exp)
		 #endif
	  #else
		 #define _3D(exp)
		 #define _4D(exp)
	  #endif
   #else
	  #define _2D(exp)
	  #define _3D(exp)
	  #define _4D(exp)
   #endif
#else
   // print out a compiler message can't perform zero-D transformations...
#endif
#if defined( _D3D_DRIVER ) || defined( _D3D10_DRIVER )
#  ifndef MAKE_RCOORD_SINGLE
#    define MAKE_RCOORD_SINGLE
#  endif
#endif
#ifdef __cplusplus
#  ifndef MAKE_RCOORD_SINGLE
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _VECTOR_NAMESPACE namespace vector { namespace Double {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Double;
#  else
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Float {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { Float {
#    define _VECTOR_NAMESPACE namespace vector { namespace Float {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Float;
#  endif
#  define _MATH_NAMESPACE namespace math {
#  define VECTOR_NAMESPACE_END } } } SACK_NAMESPACE_END
#else
#  define VECTOR_NAMESPACE
#  define _MATH_VECTOR_NAMESPACE
#  define _MATH_NAMESPACE
#  define _VECTOR_NAMESPACE
#  define VECTOR_NAMESPACE_END
#  define USE_VECTOR_NAMESPACE
#endif
#undef EXTERNAL_NAME
#undef VECTOR_METHOD
#ifdef MAKE_RCOORD_SINGLE
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##f args
#  define EXTERNAL_NAME(n)  n##f
#else
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##d args
#  define EXTERNAL_NAME(n)  n##d
#endif
/* Describes Vector types for Vector Library. Bases vectors on a
   type RCOORD which is a real coordiante, that is either float
   or double. This optimizes the vector libarary for a specific
   type of value at a time, and compiles both. Functions of
   specific types are indiciated with a suffix and/or namespace. */
#ifndef VECTOR_TYPES_DEFINED
#define VECTOR_TYPES_DEFINED
// this file merely defines the basic calculation unit...
// more types are defined in VECTLIB.H which has the number
// of dimensions defined...
#include <float.h>
SACK_NAMESPACE
	_MATH_NAMESPACE
   _VECTOR_NAMESPACE
   // requires C++ to make RCOORD single - otherwise it is a double.
#ifndef MAKE_RCOORD_SINGLE
/* Define that an RCOORD is represented by the basic type
   'double' for platforms with smaller fast floating point
   types, this could be float.                             */
#define RCOORD_IS_DOUBLE 1
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef double RCOORD;
/* <combine sack::math::vector::double::RCOORD>
   \ \                                  */
	typedef double *PRCOORD;
#else
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef float RCOORD;
/* <combine sack::math::vector::float::RCOORD>
   \ \                                  */
typedef float *PRCOORD;
#endif
 // these SHOULD be dimension relative, but we lack much code for that...
typedef RCOORD MATRIX[4][4];
  // pointer to a matrix type, rather than the nestes arrays that look very similar
typedef MATRIX *PMatrix;
typedef RCOORD PMATRIX[][4];
 // RCOORD 4 vector quaternion.
typedef RCOORD RQUATERNION[4];
 // P RCOORD 4 vector quaternion.
typedef RCOORD PRQUATERNION[4];
#ifdef RCOORD_IS_DOUBLE
#define RCOORDBITS(v)  (*(uint64_t*)&(v))
#else
/* A macro to get the literal bits into an unsigned value of the
   same size. Shift and binary operators do not apply to
   floating point values, but floating point values are fields
   of bits that represent fractional parts of integers. This
   gets the bits so the fields can be tested.                    */
#define RCOORDBITS(v)  (*(uint32_t*)&(v))
#endif
/* a symbol which is effectively the largest negative value of
   the space, anything less than this is untrackable, and is the
   same as infinity.                                             */
#define NEG_INFINITY ((RCOORD)-9999999999.0)
/* a symbol which is effectively the largest value of the space,
   anything more than this is untrackable, and is the same as
   infinity.                                                     */
#define POS_INFINITY ((RCOORD)9999999999.0)
/* This is 'epsilon' that is used with by NearZero comparison
   macro.                                                     */
#define e1 (0.00001)
/* Checks to see if a coordinate is 0 or near 0. */
#define NearZero( n ) (fabs(n)<e1)
#ifndef __cplusplus
#endif
#ifdef RCOORD_IS_DOUBLE
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 16
#ifdef _MSC_VER
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000I64 ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000I64 ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000I64 ) >> (20+32)) - 1024)))
#else
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000LL ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000LL ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000LL ) >> (20+32)) - 1024)))
#endif
#else
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 10
/* Macro to extract the exponent part of a RCOORD.
                                                   */
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x40000000L ) ?                       (( RCOORDBITS(f) & 0x3F800000L ) >> 23) :                        ((( RCOORDBITS(f) & 0x3F800000L ) >> 23) - 128)))
#endif
#ifdef NEED_VECTLIB_COMPARE
//cpg26Dec2006 c:\work\sack\include\vectypes.h(75): Warning! W202: Symbol 'COMPARE' has been defined, but not referenced
static int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD tmp1, tmp2;
	int compare_result;
	tmp1=n1-n2;
	//lprintf( "exponents %ld %ld", EXPON( n1 ), EXPON( n2 ) );
	 //lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n1),(n2),(tmp1)
	//		 ,!RCOORDBITS(n1)?"zero":"    ",!RCOORDBITS(n2)?"zero":"    "
	  //	 ,EXPON(n1)-THRESHOLD
	//	    ,EXPON(n2)-THRESHOLD
	//		 ,EXPON(tmp1) );
	tmp2=n2-n1;
	//lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n2),(n1),(tmp2)
	//		 ,!RCOORDBITS(n2)?"zero":"    ",!RCOORDBITS(n1)?"zero":"    "
	//		 ,EXPON(n2)-THRESHOLD,EXPON(n1)-THRESHOLD,EXPON(tmp2));
	compare_result = ( ( !RCOORDBITS(n1) )?( (n2) <  0.0000001 &&
														 (n2) > -0.0000001 )?1:0
							:( !RCOORDBITS(n2) )?( (n1) <  0.0000001 &&
														 (n1) > -0.0000001 )?1:0
							:( (n1) == (n2) )?1
							:( ( EXPON(n1) - THRESHOLD ) >=
							  ( EXPON( tmp1 ) ) ) &&
							( ( EXPON(n2) - THRESHOLD ) >=
							 ( EXPON( tmp2) ) ) ? 1 : 0
						  );
	return compare_result;
}
/*
static RCOORD CompareTemp1, CompareTemp2;
#define COMPARE( n1, n2 ) ( RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1 )
*/
/*
                           ( ( ( RCOORDBITS(n1) & 0x80000000 ) !=                                      ( RCOORDBITS(n2) & 0x80000000 ) )                                       ? ( NearZero(n1)                                                           && ( ( RCOORDBITS(n1)&0x7FFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0x7FFFFFF0 ) ) )                               : ( ( RCOORDBITS(n1)&0xFFFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0xFFFFFFF0 ) ) )
*/
#if 1
#else
inline int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD CompareTemp1, CompareTemp2;
   return  RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1;
}
#endif
#endif
VECTOR_NAMESPACE_END
#endif
// $Log: vectypes.h,v $
// Revision 1.12  2005/01/27 08:21:39  panther
// Linux cleaned.
//
// Revision 1.11  2004/02/08 05:42:29  d3x0r
// associate comparetemp1, 2 with routine which needs it.
//
// Revision 1.10  2003/11/28 00:10:39  panther
// fix compare function...
//
// Revision 1.9  2003/11/23 08:42:41  panther
// Toying with the nearness floating point operator
//
// Revision 1.8  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.7  2003/08/29 10:26:17  panther
// Checkpoint - converted vectlib to be native double
//
// Revision 1.6  2003/08/29 02:07:41  panther
// Fixed logging, and nearness comparison
//
// Revision 1.5  2003/08/27 07:56:40  panther
// Replace COMPARE macro with one that works a little better
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
_MATH_NAMESPACE
/* Vector namespace contains methods for operating on vectors. Vectors
   are multi-dimensional scalar quantities, often used to
   represent coordinates and directions in space.
	PTRANSFORM can also be a MATRIX, however, instances of transforms should be
	created with CreateTransform and deleted with DeleteTransform.
	PTRANSFORM is an opaque type representing a transformation matrix. It has scaling
	internally separate from the orientation and position matrix.
   */
#ifdef __cplusplus
	namespace vector {
#  ifndef MAKE_RCOORD_SINGLE
		namespace Double {
#  else
		namespace Float {
#  endif
#endif
/* A 4 dimensional point type. Contains 4 values.
*  Rotation Vectors are saved as normalized axis-angle, with the angle as the 4th element.
*/
typedef RCOORD _POINT4[4];
/* A point type. Contains 3 values by default, library can
   handle 4 dimensional transformations(?)                  */
typedef RCOORD _POINT[DIMENSIONS];
/* pointer to a (DIMENSIONS) point. */
typedef RCOORD *P_POINT;
/* for consistency, a 4 dimensional point pointer. */
typedef RCOORD* P_POINT4;
/* pointer to a constant point. */
typedef const RCOORD *PC_POINT;
/* for consistency a pointer that should have 4 elements, pointer to a constant point. */
typedef const RCOORD* PC_POINT4;
/* A vector type. Contains 3 values by default, library can
   handle 4 dimensional transformations(?)                  */
typedef _POINT VECTOR;
/* A 4 dimensional vector type. Contains 4 values.
* Rotation Vectors are saved as normalized axis-angle, with the angle as the 4th element.
*/
typedef _POINT4 VECTOR4;
/* pointer to a vector. */
typedef P_POINT PVECTOR;
/* pointer to a 4 dimensional vector. */
typedef P_POINT4 PVECTOR4;
/* pointer to a constant vector. */
typedef PC_POINT PCVECTOR;
/* pointer to a constant 4 dimensional vector. */
typedef PC_POINT4 PCVECTOR4;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type *PRAY;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type RAY;
/* A ray is a type that has an origin and a direction. (It is a
   pair of vectors actually)                                    */
struct vectlib_ray_type {
 // origin
   _POINT o;
 // normal
   _POINT n;
};
/* <combinewith sack::math::vector::lineseg_tag>
   \ \                                           */
typedef struct lineseg_tag  LINESEG;
/* <combine sack::math::vector::lineseg_tag>
   \ \                                       */
typedef struct lineseg_tag *PLINESEG;
/* This is a pure abstraction of a Line. It is used in the basis
   of 3d graphics.                                               */
struct lineseg_tag {
   /* a ray type that is the origin and slope of the line. */
	RAY r;
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = end           */
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = start         */
	RCOORD dFrom, dTo;
};
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag ORTHOAREA;
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag *PORTHOAREA;
/* A representation of a rectangular 2 dimensional area. */
struct orthoarea_tag {
	/* x coorindate of a rectangular area. */
	/* y coordinate of a rectangular area. */
	RCOORD x, y;
	/* height (y + h = area end). height may be negative. */
	/* with (x + w = area end). with may be negative. */
	RCOORD w, h;
} ;
// relics from fixed point math dayz....
#define ZERO (0.0f)
/* Special symbol that is the unit quantity. */
#define ONE  (1.0f)
#ifndef M_PI
/* symbol to define a double precision value for PI if it
   doesn't exist in the compiler.                         */
#ifdef MAKE_RCOORD_SINGLE
#  define M_PI (3.1415926535f)
#else
#  define M_PI (3.1415926535)
#endif
#endif
/* a hard coded define that represents a 5 degree angle in
   radians.                                                */
#define _5  (RCOORD)((5.0/180.0)*M_PI )
/* a hard coded define that represents a 15 degree angle in
   radians.                                                 */
#define _15 (RCOORD)((15.0/180.0)*M_PI )
/* a hard coded define that represents a 30 degree angle in
   radians.                                                 */
#define _30 (RCOORD)((30.0/180.0)*M_PI )
/* a hard coded define that represents a 45 degree angle in
   radians.                                                 */
#define _45 (RCOORD)((45.0/180.0)*M_PI )
#define SetPoint( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2] )
#define SetPoint4( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2], (d)[3]=(s)[3] )
/* Inverts a vector. that is vector * -1. (a,b,c) = (-a,-b,-c)
   <b>Parameters</b>
															   */
VECTOR_METHOD( P_POINT, Invert, ( P_POINT a ) );
/* Macro which can be used to make a vector's direction be
   exactly opposite of what it is now.                     */
#define InvertVector( a ) ( a[0] = -a[0], a[1]=-a[1], a[2]=-a[2] )
/* Logs the vector and leader to log. the leader is called
   lpName, cause it was inteded to be used by just the vector
   name.
   Parameters
   lpName :  text leader to print before the vector.
   v :       vector to log
   Example
   <code lang="c++">
   PrintVector( _X );
   // expands to
   PrintVectorEx( "_X", _X DBG_SRC );
   </code>                                                    */
VECTOR_METHOD( void, PrintVectorEx, ( CTEXTSTR lpName, PCVECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorEx@CTEXTSTR@PCVECTOR v>
   \ \                                                               */
#define PrintVector(v) PrintVectorEx( #v, v DBG_SRC )
/* Same as PrintVectorEx, but prints to standard output using
   printf.                                                    */
VECTOR_METHOD( void, PrintVectorStdEx, ( CTEXTSTR lpName, VECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorStdEx@CTEXTSTR@VECTOR v>
   \ \                                                                */
#define PrintVectorStd(v) PrintVectorStd( #v, v DBG_SRC )
/* Dumps to syslog a current matrix. Shows both matrix content,
   and the cross products between the matrix that cross1 should
   be row 0, cross2 should be row 1 and cross3 should be row2.
   Pass a text name to identify this matrix from others.
   Parameters
   lpName :    Name to write into the log.
   m :         the matrix to dump.
   DBG_PASS :  standard debug paramters
   Remarks
   A PTRANSFORM is not a MATRIX; there is a matrix in a
   transform, and is the first member, so a ptransform can be
   cast to a matrix and logged with this function.              */
VECTOR_METHOD( void, PrintMatrixEx, ( CTEXTSTR lpName, MATRIX m DBG_PASS ) );
/* <combine sack::math::vector::PrintMatrixEx@CTEXTSTR@MATRIX m>
   \ \                                                             */
#define PrintMatrix(m) PrintMatrixEx( #m, m DBG_SRC )
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag *PTRANSFORM;
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag	 TRANSFORM;
/* Pointer to a constant transform. */
typedef const TRANSFORM *PCTRANSFORM;
/* Constant pointer to a constant transform. For things like _I
   transformation which is the identity translation.            */
typedef const PCTRANSFORM *CPCTRANSFORM;
#define VectorConst_0 EXTERNAL_NAME(VectorConst_0)
#define VectorConst_X EXTERNAL_NAME(VectorConst_X)
#define VectorConst_Y EXTERNAL_NAME(VectorConst_Y)
#define VectorConst_Z EXTERNAL_NAME(VectorConst_Z)
#define VectorConst_I EXTERNAL_NAME(VectorConst_I)
#ifdef __cplusplus
#define VECTLIBCONST
#else
#define VECTLIBCONST const
#endif
//------ Constants for origin(0,0,0), and axii
#if !defined( VECTOR_LIBRARY_SOURCE ) || defined( VECTOR_LIBRARY_IS_EXTERNAL )
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_0;
/* Specifies the coordinate system's X axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_X;
/* Specifies the coordinate system's Y axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_Y;
/* Specifies the coordinate system's Z axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT VECTLIBCONST PC_POINT VectorConst_Z;
/* This is a static constant identity matrix, which can be used
   to initialize a matrix transform (internally).               */
MATHLIB_DEXPORT VECTLIBCONST PCTRANSFORM VectorConst_I;
#define _0 ((PC_POINT)VectorConst_0)
#  ifndef _X
#    define _X ((PC_POINT)VectorConst_X)
#  else
#    warning _X previously defined, skipping definition for vectlib
#  endif
#define _Y ((PC_POINT)VectorConst_Y)
#define _Z ((PC_POINT)VectorConst_Z)
#define _I ((PC_POINT)VectorConst_I)
#endif
/* compares two vectors to see if they are near each other. Boundary
   \conditions exist around 0, when the values are on opposite
   sides, but it's pretty good.                                      */
#define Near( a, b ) ( COMPARE(a[0],b[0]) && COMPARE( a[1], b[1] ) && COMPARE( a[2], b[2] ) )
/* Add two vectors together. (a1,b1,c1) + (a2,b2,c2) =
   (a1+a2,b1+b2,c1+c2)
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, add, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* subtracts two vectors and stores the result in another
   vector.
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, sub, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* Scales a vector by a scalar
   Parameters
   pr :   \result vector
   pv1 :  vector to scale
   k :    constant scalar to apply to vector
   Example
   <code lang="c#">
   VECTOR result;
   VECTOR start;
   SetPoint( start, _X );
   scale( result, start, 3 );
   </code>                                   */
VECTOR_METHOD( P_POINT, scale, ( P_POINT pr, PC_POINT pv1, RCOORD k ) );
/* Adds a vector scaled by a scalar to another vector, results
   in a third vector.
   Parameters
   pr :   pointer to a result vector
   pv1 :  pointer to vector 1
   pv2 :  pointer to vector 2
   k :    scalar quantity to apply to vector 2 when adding to
		  vector 1.
   Remarks
   The pointer to the result vector may be the same vector as
   vector 1 or vector 2.
   Example
   <code lang="c++">
   _POINT result;
   P_POINT v1 = _X;
   P_POINT v2 = _Y;
   RCOORD k = 1.414;
   addscaled( result, v1, v2, k );
   // result is ( 1, 1.414, 0 )
   </code>                                                     */
VECTOR_METHOD( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ) );
/* Normalizes a non-zero vector. That is the resulting length of
   the vector is 1.0. Modifies the vector in place.              */
VECTOR_METHOD( P_POINT, normalize, ( P_POINT pv ) );
VECTOR_METHOD( P_POINT4, normalize4, ( P_POINT4 pv ) );
VECTOR_METHOD( P_POINT, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the sin of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                     */
VECTOR_METHOD( RCOORD, SinAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the cos (cosine) of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                      */
VECTOR_METHOD( RCOORD, CosAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
VECTOR_METHOD( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ) );
// result is the projection of project onto onto
VECTOR_METHOD( P_POINT, project, ( P_POINT pr, PC_POINT onto, PC_POINT project ) );
/* \Returns the scalar length of a vector. */
VECTOR_METHOD( RCOORD, Length, ( PC_POINT pv ) );
/* \Returns the distance between two points.
   Parameters
   v1 :  some point
   v2 :  another point
   Returns
   The distance between the two points.      */
VECTOR_METHOD( RCOORD, Distance, ( PC_POINT v1, PC_POINT v2 ) );
/* \Returns the distance a point is as projected on another
   vector. The result is the distance along that vector from the
   origin.
   Parameters
   pvOn :  Vector to project on
   pvOf :  vector to get projection length of.                   */
VECTOR_METHOD( RCOORD, DirectedDistance, ( PC_POINT pvOn, PC_POINT pvOf ) );
/* copies the value of a ray into another ray
   Parameters
   ray to set :   target value
   ray to copy :  value to copy.
   Example
   <code>
   RAY ray;
   RAY ray2;
   // set ray to ray2
   SetRay( ray, ray2 );
   </code>                                    */
#define SetRay( pr1, pr2 ) { SetPoint( (pr1)->o, (pr2)->o ),							   SetPoint( (pr1)->n, (pr2)->n ); }
		/* Allocates and initializes a new transform for the user.
		 if name is NULL, allocates an unnamed transform; otherwise
	   the transform is created in a known namespace that can be browsed.
		 */
VECTOR_METHOD( PTRANSFORM, CreateNamedTransform, ( CTEXTSTR name ) );
#define CreateTransform() CreateNamedTransform( NULL )
VECTOR_METHOD( PTRANSFORM, CreateTransformMotion, ( PTRANSFORM pt ) );
VECTOR_METHOD( PTRANSFORM, CreateTransformMotionEx, ( PTRANSFORM pt, int rocket ) );
VECTOR_METHOD( void, DestroyTransform     , ( PTRANSFORM pt ) );
/* Resets a transform back to initial conitions. */
VECTOR_METHOD( void, ClearTransform       , ( PTRANSFORM pt ) );
/* Badly named function.
   InvertTransform turns a transform sideways, that is takes
   axis-normal transforms and turns them for sending to other
   graphic systems.
   <code lang="c++">
	 \+-         -+
	 | 0   1   2 |
	 | 3   4   5 |
	 | 6   7   8 |
	 \+-         -+
   becomes
	 \+-         -+
	 | 0   3   6 |
	 | 1   4   7 |
	 | 2   5   8 |
	 \+-         -+
   Not entirely useful at all :)
   </code>                                                    */
VECTOR_METHOD( void, InvertTransform        , ( PTRANSFORM pt ) );
VECTOR_METHOD( void, Scale                 , ( PTRANSFORM pt, RCOORD sx, RCOORD sy, RCOORD sz ) );
VECTOR_METHOD( void, Translate             , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateV            , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, TranslateRel          , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateRelV         , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, RotateAbs, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
VECTOR_METHOD( void, RotateAbsV, ( PTRANSFORM pt, PC_POINT ) );
/* Updates the current rotation matrix of a transform by a
   relative amount. Amounts to rotate about the x, y and z axii
   are given in radians.
   Parameters
   pt :  transform to rotate
   rx :  amount around the x axis to rotate (pitch)(positive is
		 clockwise looking at the object from the right, axis up is
		 moved towards forward )
   ry :  amount around the y axis to rotate (yaw) (positive is
		 counter clockwise, moves right to forward)
   rz :  amount around the z axis to rotate (roll) (positive is
		 clockwise, moves up towards right )
   See Also
   RotateRelV                                                       */
VECTOR_METHOD( void, RotateRel, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
/* Update a transformation matrix by relative degress about the
   x axix, y axis and z axis.
   Parameters
   pt :  transform to update
   v :   vector containing x,y and z relative roll coordinate.  */
VECTOR_METHOD( void, RotateRelV, ( PTRANSFORM pt, PC_POINT ) );
/* Rotates a transform around some arbitrary axis. (any line may
   be used to rotate the transformation's rotation matrix)
   Parameters
   pt :      transform to update
   p :       P defines an axis around which the rotation portion
			 of the matrix is rotated by an amount. Can be any
			 arbitrary axis.
   amount :  an amount to rotate by.
   Note
   coded from
   http://www.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
   and
   http://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/3drota.htm
   and http://astronomy.swin.edu.au/~pbourke/geometry/rotate/.
																					   */
VECTOR_METHOD( void, RotateAround, ( PTRANSFORM pt, PC_POINT p, RCOORD amount ) );
/* Sets the current 'up' axis of a transformation. The forward
   axis is adjusted so that it remains perpendicular to the mast
   axis vs the right axis. After the forward axis is updated,
   the right axis is adjusted to be perpendicular to up and
   forward.
   Parameters
   pt :   transform to set the up direction of
   vup :  new direction for 'up'
   Remarks
   RotateMast is based on the idea that your current frame is
   something like a boat. As the boat moves along a surface,
   it's version of 'up' may change depending on the landscape. This
   keeps up up. (Actually, the computation was used for an
   object running along the interior of a sphere, and this
   normalizes their 'up' to the center of the sphere.               */
VECTOR_METHOD( void, RotateMast, ( PTRANSFORM pt, PCVECTOR vup ) );
/* Rotates around the 'up' of the current rotation matrix. Same
   as a yaw rotation.
   Parameters
   pt :     transformation to rotate
   angle :  angle to rotate \- positive should be clockwise,
			looking from top down.                              */
VECTOR_METHOD( void, RotateAroundMast, ( PTRANSFORM pt, RCOORD angle ) );
/* Recovers a transformation state from a file.
   Parameters
   pt :        transform to read into
   filename :  filename with the transform in it. */
VECTOR_METHOD( void, LoadTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
/* Provides a way to save a matrix ( direct binary file dump)
   Parameters
   pt :        transform matrix to save
   filename :  \file to save the transformation in.           */
VECTOR_METHOD( void, SaveTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
VECTOR_METHOD( void, RotateTo, ( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright ) );
VECTOR_METHOD( void, RotateRight, ( PTRANSFORM pt, int A1, int A2 ) );
VECTOR_METHOD( void, Apply           , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyR          , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyT          , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
/* row major multiplication
 ptd is destination
 pts is matrix to transform
 pt is matrix to transform pts with
 rows of pt apply to columns of pts
 */
VECTOR_METHOD( void, ApplyM          , ( PMatrix pt, PMatrix ptd, PMatrix pts ) );
/* column major multiplication
 ptd is destination
 pts is matrix to transform
 pt is matrix to transform pts with
 rows of pt apply to columns of pts
 */
VECTOR_METHOD( void, ApplyMcm        , ( PMatrix pt, PMatrix ptd, PMatrix pts ) );
// I know this was a result - unsure how it was implented...
//void ApplyT              (PTRANFORM pt, PTRANSFORM pt1, PTRANSFORM pt2 );
VECTOR_METHOD( void, ApplyInverse    , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseR   , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyInverseT   , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// again note there was a void ApplyInverseT
VECTOR_METHOD( void, ApplyRotation        , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyRotationT       , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseRotation , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseRotationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyTranslation     , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyTranslationT    , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseTranslationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
// after Move() these callbacks are invoked.
typedef void (*MotionCallback)( uintptr_t, PTRANSFORM );
/* When Move is called on the transform, these callbacks are
   invoked so user code can get even update for motion.
   Parameters
   pt :        PTRANSFORM transform matrix to hook to
   callback :  user callback routine
   psv :       pointer size value data to be passed to user
			   callback routine.                             */
VECTOR_METHOD( void, AddTransformCallback, ( PTRANSFORM pt, MotionCallback callback, uintptr_t psv ) );
/* Set the speed vector used when Move is applied to a
   PTRANSFORM.
   Parameters
   pt :  transform to set the current speed of.
   s :   the speed vector to set.                      */
VECTOR_METHOD( PC_POINT, SetSpeed, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetSpeed, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the acceleration applied to the speed when Move is
   called.                                                 */
VECTOR_METHOD( PC_POINT, SetAccel, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetAccel, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the forward direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Forward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveForward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveRight, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveUp, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the up direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Up, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the right direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Right, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( PC_POINT, SetRotation, ( PTRANSFORM pt, PC_POINT r ) );
VECTOR_METHOD( P_POINT, GetRotation, ( PTRANSFORM pt, P_POINT r ) );
VECTOR_METHOD( PC_POINT, SetRotationAccel, ( PTRANSFORM pt, PC_POINT r ) );
/* Set how long it takes, in milliseconds, to move 1 unit of
   speed vector or rotate 1 unit of rotation vector when Move is
   called. Each matrix maintains a last tick. If many thousands
   of matrixes were used, probably a batch move could be
   implemented that would maintain tick counts for a group of
   matrixes... don't know how long it takes to compute move, but
   timeGetTime will slow it down a lot.
   Parameters
   pt :                 transform to set the time interval on.
   speed_interval :     what the time interval should be for
						speed.
   rotation_interval :  what the time interval should be for
						rotation.
   Remarks
   A default interval of 1000 is used. So it will take 1000
   milliseconds to move one unit of speed. This could be set to
   3600000 and then it would take one hour to move one unit of
   speed. (miles per hour)
   Rotation has its own interval that affects rotation the same
   way; If your rotation was set to roll 2*pi radians, then it
   would revolve one full rotation in the said time.
																 */
VECTOR_METHOD( void, SetTimeInterval, ( PTRANSFORM pt, RCOORD speed_interval, RCOORD rotation_interval ) );
/* Updates a transform by it's current speed and rotation
   assuming speed and rotation are specified in x per 1 second.
   Applies the fraction of time between now and the prior time
   move was called and scales speed and rotation by that when
   applying it.
   Parameters
   pt :  Pointer to a transform to update.
   See Also
   <link sack::math::vector::SetTimeInterval@PTRANSFORM@RCOORD@RCOORD, SetTimeInterval> */
VECTOR_METHOD( LOGICAL, Move, ( PTRANSFORM pt ) );
#if 0
	VECTOR_METHOD( void, Unmove, ( PTRANSFORM pt ) );
#endif
VECTOR_METHOD( void, showstdEx, ( PTRANSFORM pt, const char *header ) );
VECTOR_METHOD( void, ShowTransformEx, ( PTRANSFORM pt, const char *header DBG_PASS ) );
/* <combine sack::math::vector::ShowTransformEx@PTRANSFORM@char *header>
   \ \                                                                   */
#define ShowTransform( n ) ShowTransformEx( n, #n DBG_SRC )
VECTOR_METHOD( void, showstd, ( PTRANSFORM pt, const char *header ) );
VECTOR_METHOD( void, GetOriginV, ( PTRANSFORM pt, P_POINT o ) );
VECTOR_METHOD( PC_POINT, GetOrigin, ( PTRANSFORM pt ) );
VECTOR_METHOD( void, GetAxisV, ( PTRANSFORM pt, P_POINT a, int n ) );
VECTOR_METHOD( PC_POINT, GetAxis, ( PTRANSFORM pt, int n ) );
VECTOR_METHOD( void, SetAxis, ( PTRANSFORM pt, RCOORD a, RCOORD b, RCOORD c, int n ) );
VECTOR_METHOD( void, SetAxisV, ( PTRANSFORM pt, PC_POINT a, int n ) );
// matrix is suitable to set as the first matrix for opengl rendering.
// it is an inverse application that uses the transform's origin as camera origin
// and the rotation matrix as what to look at.
VECTOR_METHOD( void, GetGLCameraMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, GetGLMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, SetGLMatrix, ( PMATRIX in, PTRANSFORM pt ) );
VECTOR_METHOD( void, SetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
VECTOR_METHOD( void, GetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
  // line m, b
VECTOR_METHOD( RCOORD, IntersectLineWithPlane, (PCVECTOR Slope, PCVECTOR Origin,
  // plane n, o
	PCVECTOR n, PCVECTOR o,
	RCOORD *time) );
VECTOR_METHOD( RCOORD, PointToPlaneT, (PCVECTOR n, PCVECTOR o, PCVECTOR p) );
/* convert basis matrix to rotation vector v */
VECTOR_METHOD( void, basis_lq, (PVECTOR4 v4, PMatrix basis) );
/* convert rotation vector v to quaternion q */
VECTOR_METHOD( void, lq_exp, (PVECTOR4 q, PCVECTOR4 v) );
/* convert rotation vector v to basismatrix  */
VECTOR_METHOD( PMatrix, lq_basis, ( PMatrix matrix, PCVECTOR4 v ) );
/* convert rotation vector v to basismatrix
   sets the origin, so the resulting matrix is a valid view matrix for Vulkan
 */
VECTOR_METHOD( PMatrix, lq_matrix, ( PMatrix matrix, PCVECTOR4 v, PCVECTOR position ) );
/* use a mouse sort of left-right/updown (yaw/pitch) input to update the orientation.
 This has no restrictions on the resulting output, and the rotation is already relative to the
 current viewpoint.
 put the output in out, and return out.
 */
VECTOR_METHOD( PVECTOR4, lq_free_look, ( PVECTOR4 out, PCVECTOR4 orientation, RCOORD pitch, RCOORD yaw, RCOORD roll ) );
/* use a mouse sort of left-right/updown (yaw/pitch) input to update the orientation.
 This restricts the roll, expecting you're on a level ground; whereas the free-look is more suited to space.
 put the output in out, and return out.
 k is the factor to adjust the roll by; 1.0 is immediate fix...
 */
VECTOR_METHOD( PVECTOR4, lq_level_look, ( PVECTOR4 out, PCVECTOR4 orientation, RCOORD pitch, RCOORD yaw, RCOORD k ) );
/* convert rotation vector v to colmajor (opengl) basismatrix
 this is probably redundant - native matrix is the correct direction already...
 */
VECTOR_METHOD( PMatrix, lq_gl_basis, ( PMatrix matrix, PCVECTOR4 v ) );
/* get a vector representing the up (y) direction from a rotation vector */
VECTOR_METHOD( PVECTOR, lq_up, ( PVECTOR out, PCVECTOR4 r ) );
/* get a vector representing the right (x) direction from a rotation vector */
VECTOR_METHOD( PVECTOR, lq_right, ( PVECTOR out, PCVECTOR4 r ) );
/* get a vector representing the forward (z) direction from a rotation vector */
VECTOR_METHOD( PVECTOR, lq_forward, ( PVECTOR out, PCVECTOR4 r ) );
/* get how much roll there is from the identity matrix orientation
 * The raw rotation angles of the axis-angle vector has a complex interaction over
 * 1 tick that results in an orientation, and it is that resulting orientation that
 * determines the roll, yaw, and pitch. So the values returned here are not
 * just the components of the axis-angle vector.
 */
VECTOR_METHOD( RCOORD, lq_roll, ( PCVECTOR4 r ) );
/* get how much yaw there is from the identity matrix orientation
 * The raw rotation angles of the axis-angle vector has a complex interaction over
 * 1 tick that results in an orientation, and it is that resulting orientation that
 * determines the roll, yaw, and pitch. So the values returned here are not
 * just the components of the axis-angle vector.
 *
 * this function does attempt to return +/- 360 degrees, which is closer to the spin angles.
 */
VECTOR_METHOD( RCOORD, lq_yaw, ( PCVECTOR4 r ) );
/* get how much pitch there is from the identity matrix orientation
 * The raw rotation angles of the axis-angle vector has a complex interaction over
 * 1 tick that results in an orientation, and it is that resulting orientation that
 * determines the roll, yaw, and pitch. So the values returned here are not
 * just the components of the axis-angle vector.
 */
VECTOR_METHOD( RCOORD, lq_pitch, ( PCVECTOR4 r ) );
// apply the rotation A to R and store in OUT
VECTOR_METHOD( PVECTOR4, lq_applyRotation, ( PVECTOR4 out, PCVECTOR4 r, PCVECTOR4 a ) );
// rotate vector V around R and store in out  (out and V could be the same?)
VECTOR_METHOD( void, lq_apply, ( PVECTOR out, PCVECTOR4 r, PCVECTOR v ) );
VECTOR_METHOD( PVECTOR4, lq_normalize, ( PVECTOR4 out ) );
// cross product between two vectors; result as a rotation vector
// this is the rotation that rotates one to the other.
VECTOR_METHOD( PVECTOR4, lq_cross, ( PVECTOR4 out, PCVECTOR a, PCVECTOR b ) );
VECTOR_METHOD( PVECTOR4, lq_set, ( PVECTOR4 out, RCOORD x, RCOORD y, RCOORD z, RCOORD angle ) );
/* sets rotation vector from pitch and roll (?) */
VECTOR_METHOD( PVECTOR4, lq_set_xy, ( PVECTOR4 out, RCOORD x, RCOORD z ) );
/* sets the rotataion vector, and normalizes it into axis&angle internal format */
VECTOR_METHOD( PVECTOR4, lq_set3, ( PVECTOR4 out, RCOORD x, RCOORD y, RCOORD z ) );
/* normalizes x,y,z axis part, and uses the specified angle */
VECTOR_METHOD( PVECTOR4, lq_set4, ( PVECTOR4 out, RCOORD x, RCOORD y, RCOORD z, RCOORD angle ) );
/* treats input as latitude and longitude on a sphere.
 Lat +/- 90  (+/-360)
 lng +/- 180 (+/-360)
 This will result in rotation coordinates that are unique for the specified over-latitude range.
 */
VECTOR_METHOD( PVECTOR4, lq_set_latlong, ( PVECTOR4 out, RCOORD lat, RCOORD lng ) );
#if ( !defined( VECTOR_LIBRARY_SOURCE ) && !defined( NO_AUTO_VECTLIB_NAMES ) ) || defined( NEED_VECTLIB_ALIASES )
#define add EXTERNAL_NAME(add)
#define sub EXTERNAL_NAME(sub)
#define scale EXTERNAL_NAME(scale)
#define Scale EXTERNAL_NAME(Scale)
#define Invert EXTERNAL_NAME(Invert)
#define GetOrigin EXTERNAL_NAME(GetOrigin)
#define GetOriginV EXTERNAL_NAME(GetOriginV)
#define GetAxis EXTERNAL_NAME(GetAxis)
#define GetAxisV EXTERNAL_NAME(GetAxisV)
#define GetGLCameraMatrix EXTERNAL_NAME(GetGLCameraMatrix)
#define ApplyInverse EXTERNAL_NAME(ApplyInverse)
#define Move EXTERNAL_NAME(Move)
#define MoveForward EXTERNAL_NAME(MoveForward)
#define MoveRight EXTERNAL_NAME(MoveRight)
#define MoveUp EXTERNAL_NAME(MoveUp)
#define Forward EXTERNAL_NAME(Forward)
#define Right EXTERNAL_NAME(Right)
#define Up EXTERNAL_NAME(Up)
#define PrintVectorEx EXTERNAL_NAME(PrintVectorEx)
#define PrintMatrixEx EXTERNAL_NAME(PrintMatrixEx)
#define ShowTransformEx EXTERNAL_NAME(ShowTransformEx)
#define addscaled EXTERNAL_NAME(addscaled)
#define Length EXTERNAL_NAME(Length)
#define PointToPlaneT EXTERNAL_NAME(PointToPlaneT)
#define normalize EXTERNAL_NAME(normalize)
#define normalize4 EXTERNAL_NAME(normalize4)
#define Translate EXTERNAL_NAME(Translate)
#define TranslateV EXTERNAL_NAME(TranslateV)
#define Apply EXTERNAL_NAME(Apply)
#define ApplyR EXTERNAL_NAME(ApplyR)
#define ApplyT EXTERNAL_NAME(ApplyT)
#define ApplyM EXTERNAL_NAME(ApplyM)
#define ApplyTranslation EXTERNAL_NAME(ApplyTranslation)
#define ApplyTranslationR EXTERNAL_NAME(ApplyTranslationR)
#define ApplyTranslationT EXTERNAL_NAME(ApplyTranslationT)
#define ApplyInverseRotation EXTERNAL_NAME(ApplyInverseRotation)
#define ApplyInverseR EXTERNAL_NAME(ApplyInverseR)
#define ApplyRotation EXTERNAL_NAME(ApplyRotation)
#define ApplyRotationT EXTERNAL_NAME(ApplyRotationT)
#define RotateAround EXTERNAL_NAME(RotateAround)
#define RotateRel EXTERNAL_NAME(RotateRel)
#define SetRotation EXTERNAL_NAME(SetRotation)
#define GetRotation EXTERNAL_NAME(GetRotation)
#define SetRotationAccel EXTERNAL_NAME(SetRotationAccel)
#define RotateRight EXTERNAL_NAME(RotateRight)
#define dotproduct EXTERNAL_NAME(dotproduct)
#define DestroyTransform EXTERNAL_NAME(DestroyTransform)
#define SinAngle EXTERNAL_NAME(SinAngle)
#define CosAngle EXTERNAL_NAME(CosAngle)
#define crossproduct EXTERNAL_NAME(crossproduct)
#define CreateTransformMotion EXTERNAL_NAME(CreateTransformMotion)
#define CreateTransformMotionEx EXTERNAL_NAME(CreateTransformMotionEx)
#define CreateNamedTransform EXTERNAL_NAME(CreateNamedTransform)
#define ClearTransform EXTERNAL_NAME(ClearTransform)
#define RotateTo EXTERNAL_NAME(RotateTo)
#define SetSpeed EXTERNAL_NAME(SetSpeed)
#define SetAccel EXTERNAL_NAME(SetAccel)
#define TranslateRel EXTERNAL_NAME( TranslateRel )
#define TranslateRelV EXTERNAL_NAME( TranslateRelV )
#define RotateAbs EXTERNAL_NAME(RotateAbs)
#define RotateAbsV EXTERNAL_NAME(RotateAbsV)
#define GetRotationMatrix EXTERNAL_NAME(GetRotationMatrix)
#define SetRotationMatrix EXTERNAL_NAME(SetRotationMatrix)
#define basis_lq EXTERNAL_NAME(basis_lq)
#define lq_exp EXTERNAL_NAME(lq_exp)
#define lq_basis EXTERNAL_NAME(lq_basis)
#define lq_gl_basis EXTERNAL_NAME(lq_gl_basis)
#define lq_up EXTERNAL_NAME(lq_up)
#define lq_right EXTERNAL_NAME(lq_right)
#define lq_forward EXTERNAL_NAME(lq_forward)
#define lq_roll EXTERNAL_NAME(lq_roll)
#define lq_yaw EXTERNAL_NAME(lq_yaw)
#define lq_pitch EXTERNAL_NAME(lq_pitch)
#define lq_normalize EXTERNAL_NAME(lq_normalize)
#define lq_cross EXTERNAL_NAME(lq_cross)
#define lq_set EXTERNAL_NAME(lq_set)
#define lq_set3 EXTERNAL_NAME(lq_set3)
#define lq_set4 EXTERNAL_NAME(lq_set4)
#define lq_set_xy EXTERNAL_NAME(lq_set_xy)
#define lq_set_latlong EXTERNAL_NAME(lq_set_latlong)
#define lq_applyRotation EXTERNAL_NAME(lq_applyRotation)
#define lq_apply EXTERNAL_NAME(lq_apply)
#define lq_matrix EXTERNAL_NAME(lq_matrix)
#define lq_free_look EXTERNAL_NAME(lq_free_look)
#define lq_level_look EXTERNAL_NAME(lq_level_look)
//#define lq_ EXTERNAL_NAME(lq_apply)
#endif
#ifdef __cplusplus
VECTOR_NAMESPACE_END
USE_VECTOR_NAMESPACE
#endif
#endif
// $Log: vectlib.h,v $
// Revision 1.13  2004/08/22 09:56:41  d3x0r
// checkpoint...
//
// Revision 1.12  2004/02/02 22:43:35  d3x0r
// Add lineseg type and orthoarea (min/max box)
//
// Revision 1.11  2004/01/11 23:24:15  panther
// Fix type warnings, conflicts, fix const issues
//
// Revision 1.10  2004/01/11 23:11:49  panther
// Fix const typings
//
// Revision 1.9  2004/01/11 23:10:38  panther
// Include keyboard to avoid windows errors
//
// Revision 1.8  2004/01/04 20:54:18  panther
// Use PCTRANSFORM for prototypes
//
// Revision 1.7  2003/12/29 08:10:18  panther
// Added more functions for applying transforms
//
// Revision 1.6  2003/11/22 23:27:11  panther
// Fix type passed to printvector
//
// Revision 1.5  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
VECTOR_NAMESPACE
struct motion_frame_tag
{
	// if rocket is 0, then it's virtual point camera mode.
	// that is motion is always forward, with rocket only
	// acceleration is applied forward, speed is constant to the world.
	int rocket;
	// this needs a better definition.
	// the acceleratino applied to this has no reference to the orientation
	// The acceleration is an absolute application to the origin...
	int fluff;
	// speed right, up, forward ( use vRight, vUp, vForward to index array )
	RCOORD speed[3];
	RCOORD prior_speed[3];
	// acceleration right, up and forward (after rotation matrix is applied, this is always relative
	// to the current transformation's forward, left and right.   ( use vRight, vUp, vForward to index array )
	RCOORD accel[3];
	RCOORD prior_accel[3];
	// pitch, yaw, roll delta ( use vRight, vUp, vForward to index array )
	RCOORD rotation[3];
	// rot_accel is not used... just rotation velocity. ( use vRight, vUp, vForward to index array )
	 // pitch, yaw, roll delta
	RCOORD rot_accel[3];
	RCOORD prior_rot_accel[3];
	// how long it takes to move one unit vector of speed
	RCOORD speed_time_interval;
	// how long it takes to rotate one unit vector of rotation
	RCOORD rotation_time_interval;
	// what time the last time we processed this matrix for Move.
	uint32_t last_tick;
	// rotation stepping for consistant rotation
	int nTime;
	// list of void(*)(uintptr_t,PTRANSFORM)
	PLIST callbacks;
	// actually uintptr_t storage...
	PLIST userdata;
};
/* This structure maintains basically an inertial frame for an
	object. It contains the current orientation and position of
	an object. But it also contains speed and acceleration
	factors.                                                    */
struct transform_tag
{
	// have to store partial values for rotation and
	// scale... since these terms may not be all together
	// specified... the remaining values in the matrix
	// can just be set - since they have no other dependant terms.
	// may have to keep matrix full symetry for multiplication
	// purposes... so that a sub-translation matrix may be modified
	// from a parent's...
	// requires [4][4] for use with opengl
  //   m[x][0] m[x][1] = partials... m[x][2] = multiplied value.
  // s*rcos[0][0]*rcos[0][1] sin sin   (0)
	                // sin s*rcos[1][0]*rcos[1][1] sin   (0)
	                // sin sin s*rcos[2][0]*rcos[2][0]   (0)
	                // tx  ty  tz                        (1)
//**************************************
//    AKA
//   MATRIX m;    // vRight   (n,n,n,n)
//                // vUp      (n,n,n,n)
//                // vForward (n,n,n,n)
//                // vIn      (n,n,n,n)
//*************************************
	MATRIX m;
	/* scalar, which can apply independant scalar values to
	   resulting x y and y transformation. */
	RCOORD s[3];
	// Optional extension for transforms that track things that move, or move themselves.
	struct motion_frame_tag *motions;
	int nMotion;
};
VECTOR_NAMESPACE_END
//#include "vectlib.h"
VECTOR_NAMESPACE
#undef _0
#undef _X
#undef _Y
#undef _Z
//static RCOORD EXTERNAL_NAME(time_scale) = ONE;
static const _POINT EXTERNAL_NAME(__0) = {ZERO, ZERO, ZERO};
static const _POINT EXTERNAL_NAME(__X) = { ONE, ZERO, ZERO};
static const _POINT EXTERNAL_NAME(__Y) = {ZERO,  ONE, ZERO};
static const _POINT EXTERNAL_NAME(__Z) = {ZERO, ZERO,  ONE};
#if (DIMENSIONS > 3 )
static const _POINT EXTERNAL_NAME(__W) = {ZERO, ZERO, ZERO, ONE};
#endif
#if defined( __GNUC__  ) && defined( __cplusplus )
#ifdef __STATIC__
#define PRE_EXTERN
#else
#define PRE_EXTERN extern
#endif
#else
#define PRE_EXTERN
#endif
#ifdef __cplusplus
#define VECTLIBCONST
#else
#define VECTLIBCONST const
#endif
PRE_EXTERN MATHLIB_DEXPORT VECTLIBCONST PC_POINT EXTERNAL_NAME(VectorConst_0) = (PC_POINT)&EXTERNAL_NAME(__0)[0];
PRE_EXTERN MATHLIB_DEXPORT VECTLIBCONST PC_POINT EXTERNAL_NAME(VectorConst_X) = (PC_POINT)&EXTERNAL_NAME(__X)[0];
PRE_EXTERN MATHLIB_DEXPORT VECTLIBCONST PC_POINT EXTERNAL_NAME(VectorConst_Y) = (PC_POINT)&EXTERNAL_NAME(__Y)[0];
PRE_EXTERN MATHLIB_DEXPORT VECTLIBCONST PC_POINT EXTERNAL_NAME(VectorConst_Z) = (PC_POINT)&EXTERNAL_NAME(__Z)[0];
#if (DIMENSIONS > 3 )
const PC_POINT _W = (PC_POINT)&__W;
#endif
static const TRANSFORM EXTERNAL_NAME(__I) = { { { 1, 0, 0, 0 }
								, { 0, 1, 0, 0 }
								, { 0, 0, 1, 0 }
								, { 0, 0, 0, 1 } }
 // s
							 , { 1, 1, 1 }
  //                    , NULL // motion
};
PRE_EXTERN MATHLIB_DEXPORT VECTLIBCONST PCTRANSFORM EXTERNAL_NAME(VectorConst_I) = &EXTERNAL_NAME(__I);
static struct {
	struct {
		BIT_FIELD bRegisteredTransform : 1;
		BIT_FIELD bRegisteredMotion : 1;
	} flags;
} local_vectlib_data;
#define l local_vectlib_data
//----------------------------------------------------------------
#if defined( _MSC_VER ) || defined( __WATCOMC__ )
#define INLINEFUNC(type, name, params) _inline type _##name params
#define REALFUNCT(type, name, params, callparams ) type EXTERNAL_NAME(name) params { return _##name callparams; }
#define REALVOIDFUNCT(type, name, params, callparams ) type EXTERNAL_NAME(name) params { _##name callparams; }
#define REALFUNC( name, params, callparams ) void EXTERNAL_NAME(name) params { _##name callparams; }
#define DOFUNC(name) _##name
#elif defined( __LCC__ )
#define INLINEFUNC(type, name, params) inline type _INL_##name params
#define REALFUNC( name, params, callparams ) void EXTERNAL_NAME(name) params { _INL_##name callparams; }
#define REALVOIDFUNCT(type, name, params, callparams ) type EXTERNAL_NAME(name) params { _INL_##name callparams; }
#define REALFUNCT(type, name, params, callparams ) type EXTERNAL_NAME(name) params { return _INL_##name callparams; }
#define DOFUNC(name) _INL_##name
#elif defined( __BORLANDC__ )
//#define INLINEFUNC(type, name, params) _inline type _INL_##name params
//#define REALFUNC( name, params, callparams ) void name params { _INL_##name callparams; }
//#define REALFUNCT(type, name, params, callparams ) void name params { return _INL_##name callparams; }
//#define DOFUNC(name) _INL_##name
#define INLINEFUNC(type, name, params) type EXTERNAL_NAME(name) params
#define REALFUNCT(type, name, params, callparams )
#define REALFUNC( name, params, callparams )
#define DOFUNC(name) name
#elif defined( __CYGWIN__ )
#define INLINEFUNC(type, name, params) inline type _INL_##name params
#define REALFUNC( name, params, callparams ) void EXTERNAL_NAME(name) params { _INL_##name callparams; }
#define REALFUNCT(type, name, params, callparams ) type EXTERNAL_NAME(name) params { return _INL_##name callparams; }
#define DOFUNC(name) _INL_##name
#else
// no inline support at all....
#define INLINEFUNC(type, name, params)  type EXTERNAL_NAME(name) params
#define REALVOIDFUNCT(type, name, params, callparams )
#define REALFUNCT(type, name, params, callparams )
#define REALFUNCT(type, name, params, callparams )
#define REALFUNC( name, params, callparams )
#define DOFUNC(name) EXTERNAL_NAME(name)
#endif
#undef SIN
#undef COS
#undef sqrt
#ifdef __BORLANDC__
#  define SIN sin
#  define COS cos
#else
#  ifdef MAKE_RCOORD_SINGLE
#    define sqrt(n) ((float)sqrt(n))
#    ifdef __WATCOMC__
#       define SIN (float)sin
#       define COS (float)cos
#    else
#       define SIN sinf
#       define COS cosf
#    endif
#  else
#    define sqrt sqrt
#    define SIN sin
#    define COS cos
#  endif
#endif
INLINEFUNC( P_POINT, add, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) )
{
   _1D( pr[0] = pv1[0] + pv2[0] );
   _2D( pr[1] = pv1[1] + pv2[1] );
   _3D( pr[2] = pv1[2] + pv2[2] );
   _4D( pr[3] = pv1[3] + pv2[3] );
   return pr;
}
REALFUNCT( P_POINT, add, ( PVECTOR pr, PCVECTOR pv1, PCVECTOR pv2 ), (pr, pv1, pv2 ) )
//----------------------------------------------------------------
INLINEFUNC( P_POINT, sub, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) )
{
   _1D( pr[0] = pv1[0] - pv2[0] );
   _2D( pr[1] = pv1[1] - pv2[1] );
   _3D( pr[2] = pv1[2] - pv2[2] );
   _4D( pr[3] = pv1[3] - pv2[3] );
   return pr;
}
REALFUNCT( P_POINT, sub, ( PVECTOR pr, PCVECTOR pv1, PCVECTOR pv2 ), ( pr, pv1, pv2 ) )
//----------------------------------------------------------------
INLINEFUNC( P_POINT, scale, ( P_POINT pr, PC_POINT pv1, RCOORD k ) )
{
   _1D( pr[0] = pv1[0] * k );
   _2D( pr[1] = pv1[1] * k );
   _3D( pr[2] = pv1[2] * k );
   _4D( pr[3] = pv1[3] * k );
   return pr;
}
REALFUNCT( P_POINT, scale, ( PVECTOR pr, PCVECTOR pv1, RCOORD k ), (pr, pv1, k ) )
INLINEFUNC( P_POINT4, scale4, ( P_POINT4 pr, PC_POINT4 pv1, RCOORD k ) )
{
   pr[0] = pv1[0] * k;
   pr[1] = pv1[1] * k;
   pr[2] = pv1[2] * k;
   pr[3] = pv1[3] * k;
   return pr;
}
REALFUNCT( P_POINT4, scale4, ( PVECTOR4 pr, PCVECTOR4 pv1, RCOORD k ), (pr, pv1, k ) )
INLINEFUNC( P_POINT, Invert, ( P_POINT a ) )
{
	a[0] = -a[0];
	a[1]=-a[1];
	a[2]=-a[2];
	return a;
}
REALFUNCT( P_POINT, Invert, ( P_POINT a ), (a) )
//----------------------------------------------------------------
INLINEFUNC( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ) )
{
	_1D( pr[0] = pv1[0] + ( pv2[0] * k ) );
	_2D( pr[1] = pv1[1] + ( pv2[1] * k ) );
	_3D( pr[2] = pv1[2] + ( pv2[2] * k ) );
	_4D( pr[3] = pv1[3] + ( pv2[3] * k ) );
	return pr;
}
REALFUNCT( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ), (pr, pv1, pv2, k ) )
//----------------------------------------------------------------
INLINEFUNC( RCOORD, Length, ( PC_POINT v ) )
{
   return sqrt( v[0] * v[0] +
                v[1] * v[1]
                _3D( + v[2] * v[2] )
                _4D( + v[3] * v[3] ) );
}
REALFUNCT( RCOORD, Length, ( PCVECTOR pv ), (pv) )
INLINEFUNC( RCOORD, Length4, ( PC_POINT v ) )
{
   return sqrt( v[0] * v[0] +
                v[1] * v[1]
                + v[2] * v[2]
                + v[3] * v[3] );
}
REALFUNCT( RCOORD, Length4, ( PCVECTOR pv ), (pv) )
//----------------------------------------------------------------
RCOORD EXTERNAL_NAME(Distance)( PC_POINT v1, PC_POINT v2 )
{
   VECTOR v;
   DOFUNC(sub)( v, v1, v2 );
   return DOFUNC(Length)( v );
}
//----------------------------------------------------------------
 INLINEFUNC( P_POINT, normalize, ( P_POINT pv ) )
{
	RCOORD k = DOFUNC(Length)( pv );
   if( k != 0 )
		DOFUNC(scale)( pv, pv, ONE / k );
   return pv;
}
 REALFUNCT( P_POINT,  normalize, ( P_POINT pv ), (pv) )
 INLINEFUNC( P_POINT4, normalize4, ( P_POINT4 pv ) )
{
	RCOORD k = DOFUNC(Length4)( pv );
   if( k != 0 )
		DOFUNC(scale4)( pv, pv, ONE / k );
   return pv;
}
 REALFUNCT( P_POINT4,  normalize4, ( P_POINT pv ), (pv) )
//----------------------------------------------------------------
 INLINEFUNC( P_POINT, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) )
{
   // this must be limited to 3D only, huh???
   // what if we are 4D?  how does this change??
  // evalutation of 4d matrix is 3 cross products of sub matriccii...
 //b2c1-c2b1
  pr[0] = pv2[2] * pv1[1] - pv2[1] * pv1[2];
 //a2c1-c2a1 ( - determinaent )
  pr[1] = pv2[0] * pv1[2] - pv2[2] * pv1[0];
 //b2a1-a2b1
  pr[2] = pv2[1] * pv1[0] - pv2[0] * pv1[1];
  return pr;
}
REALFUNCT( P_POINT, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ), (pr,pv1,pv2) )
// hmmm
// 2 4 dimensional vectors would be insufficient to determine
// a single perpendicular vector... as it could lay  in a perpendular
// plane
// but - 2 planes intersecting must form a line of intersection
// 2 lines form a point of intersection
//----------------------------------------------------------------
RCOORD EXTERNAL_NAME(SinAngle)( PC_POINT pv1, PC_POINT pv2 )
{
	_POINT r;
	RCOORD len;
	DOFUNC(crossproduct)( r, pv1, pv2 );
	len = DOFUNC(Length)( r ) / ( DOFUNC(Length)(pv1) * DOFUNC(Length)(pv2) );
	return len;
}
//----------------------------------------------------------------
INLINEFUNC( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ) )
{
  return pv2[0] * pv1[0] +
		     pv2[1] * pv1[1] +
		     pv2[2] * pv1[2] ;
}
REALFUNCT( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ), (pv1, pv2) )
//----------------------------------------------------------------
// returns directed distance of OF in the direction of ON
RCOORD EXTERNAL_NAME(DirectedDistance)( PC_POINT pvOn, PC_POINT pvOf )
{
	RCOORD len = DOFUNC(Length)(pvOn);
	if( len )
		return DOFUNC(dotproduct)(  pvOn, pvOf ) / len;
	return 0;
}
//----------------------------------------------------------------
#if 0
#undef LogVector
 static void LogVector( char *lpName, VECTOR v )
#define LogVector(v) LogVector( #v, v )
{
   Log4( "Vector %s = <%lg, %lg, %lg>",
            lpName, v[0], v[1], v[2] );
}
#endif
RCOORD EXTERNAL_NAME(CosAngle)( PC_POINT pv1, PC_POINT pv2 )
{
	RCOORD len = DOFUNC(Length)( pv1 ) * DOFUNC(Length)( pv2 );
	if( len )
		return DOFUNC(dotproduct)( pv1, pv2 ) / len;
 // as good an angle as any...
	return 0;
}
//----------------------------------------------------------------
P_POINT EXTERNAL_NAME(project)( P_POINT pr, PC_POINT onto, PC_POINT project )
{
	RCOORD dot;
	dot = DOFUNC(dotproduct)( onto, project ) / DOFUNC(dotproduct)( onto, onto );
	return DOFUNC(scale)( pr, onto, dot );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(ClearTransform)( PTRANSFORM pt )
{
	MemSet( pt, 0, sizeof( *pt ) );
	pt->m[0][0] = ONE;
	pt->m[1][1] = ONE;
	pt->m[2][2] = ONE;
	pt->m[3][3] = ONE;
	pt->s[0] = ONE;
	pt->s[1] = ONE;
	pt->s[2] = ONE;
}
//----------------------------------------------------------------
static void CPROC transform_created( void *data, uintptr_t size )
{
	PTRANSFORM pt = (PTRANSFORM)data;
	EXTERNAL_NAME( ClearTransform )( pt );
}
PTRANSFORM EXTERNAL_NAME(CreateNamedTransform)( CTEXTSTR name  )
{
	PTRANSFORM pt;
#ifndef __NO_VECTOR_NAMED_TRANSFORM__
	if( name )
	{
		if( !l.flags.bRegisteredTransform )
		{
			l.flags.bRegisteredTransform = 1;
#  undef TYPENAME
#ifdef MAKE_RCOORD_SINGLE
#  define TYPENAME "transformf"
#else
#  define TYPENAME "transformd"
#endif
			RegisterDataType( "SACK/vectlib", TYPENAME, sizeof( TRANSFORM ), transform_created, NULL );
		}
		pt = (PTRANSFORM)CreateRegisteredDataType( "SACK/vectlib", TYPENAME, name );
	}
	else
#endif
	{
		pt = New( struct transform_tag );
		pt->motions = NULL;
		EXTERNAL_NAME(ClearTransform)(pt);
	}
   return pt;
}
#undef CreateTransform
MATHLIB_EXPORT PTRANSFORM EXTERNAL_NAME(CreateTransform)( void )
{
   return EXTERNAL_NAME(CreateNamedTransform)( NULL );
}
//----------------------------------------------------------------
PTRANSFORM EXTERNAL_NAME(CreateTransformMotionEx)( PTRANSFORM pt, int rocket )
{
	if( !pt->motions )
	{
		pt->motions = NewArray( struct motion_frame_tag, 2 );
		MemSet( pt->motions, 0, 2*sizeof( struct motion_frame_tag ) );
		pt->motions->rocket = rocket;
 // speed_time_interval
		pt->motions->speed_time_interval = 1000;
		pt->motions->rotation_time_interval = 1000;
		pt->motions[1].fluff = 1;
		pt->nMotion = 2;
	}
	return pt;
}
//----------------------------------------------------------------
PTRANSFORM EXTERNAL_NAME(CreateTransformMotion)( PTRANSFORM pt )
{
   return EXTERNAL_NAME(CreateTransformMotionEx)( pt, 0 );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(DestroyTransform)( PTRANSFORM pt )
{
	Release( pt );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(Scale)( PTRANSFORM pt, RCOORD sx, RCOORD sy, RCOORD sz ) {
   pt->s[0] = sx;
   pt->s[1] = sy;
   pt->s[2] = sz;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(TranslateV)( PTRANSFORM pt, PC_POINT t )
{
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
	SetPoint( pt->m[3], t );
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(Translate)( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) {
   pt->m[3][0] = tx;
   pt->m[3][1] = ty;
   pt->m[3][2] = tz;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(TranslateRelV)( PTRANSFORM pt, PC_POINT t ) {
   DOFUNC(add)( pt->m[3], pt->m[3], t );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(TranslateRel)(PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz) {
	VECTOR v;
	v[0] = tx;
	v[1] = ty;
	v[2] = tz;
	DOFUNC(add)( pt->m[3], pt->m[3], v );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(RotateAround)( PTRANSFORM pt, PC_POINT p, RCOORD amount )
{
	// P defines an axis around which the rotation portion of the matrix
	// is rotated by an amount.
	// coded from http://www.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
	// and http://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/3drota.htm
   // and http://astronomy.swin.edu.au/~pbourke/geometry/rotate/
	TRANSFORM t;
	PTRANSFORM T = pt;
	RCOORD Len = EXTERNAL_NAME(Length)( p );
	RCOORD Cos = COS(amount);
	RCOORD Sin = SIN(amount);
	RCOORD normal;
	t.s[0] = 1;
	t.s[1] = 1;
	t.s[2] = 1;
	// actually the only parts of the matrix resulting
	// will only be the rotation matrix, for which we are
	// building an absolute translation... which may be saved by
	// passing an identity filled transform... but anyhow...
	// the noise in the speed, accel, etc resulting from uninitialized
	// stack space being used for the transform this is building, matters
   // not at all.
	pt = &t;
	//SetPoint( _v, p );
	//normalize( _v );
#define u p[0]
#define v p[1]
#define up p[2]
	// okay this is rude and ugly, and could be optimized a bit
   // but we do have a short stack and 3 are already gone.
   normal = u*u+v*v+up*up;
	pt->m[0][0] = u * u + ( v * v + up * up ) * Cos
      / normal;
	pt->m[0][1] = u*v * ( 1-Cos ) - up * Len * Sin
      / normal;
	pt->m[0][2] = u*up*(1-Cos) + v*Len * Sin
      / normal;
	pt->m[1][0] = u*v*(1-Cos) + up*Len * Sin
      / normal;
	pt->m[1][1] = v*v + (u*u+up*up)*Cos
      / normal;
	pt->m[1][2] = v*up*(1-Cos)-u*Len*Sin
      / normal;
	pt->m[2][0] = u*up*(1-Cos)-v*Len*Sin
      / normal;
	pt->m[2][1] = v*up*(1-Cos)+u*Len*Sin
      / normal;
	pt->m[2][2] = up*up+(u*u + v*v)*Cos
      / normal;
	// oh yeah , be nice, and release these symbols...
	// V is such a common vector variable :)
#undef u
#undef v
#undef up
	EXTERNAL_NAME(ApplyRotationT)( pt, T, T );
}
 void EXTERNAL_NAME(RotateAbsV)( PTRANSFORM pt, PC_POINT dv ) {
   // set rotation matrix to coordinates specified.
 // cos(rx), cos(ry), cos(rz)
   RCOORD rcos[3];
 // cos[2]*cos[1], cos[2]*cos[0], cos[1]*cos[0]
   RCOORD rcosf[3];
   pt->m[1][0] = -(pt->m[0][1] = (float)SIN(dv[vForward]));
   pt->m[2][0] = -(pt->m[0][2] = (float)SIN(dv[vUp]));
   pt->m[2][1] = -(pt->m[1][2] = (float)SIN(dv[vRight]));
 //pt->s[0] *  // scale???? ookay...
   pt->m[0][0] =
      ( rcosf[0] = ( rcos[2] = (float)COS(dv[vForward]) )
                 * ( rcos[1] = (float)COS(dv[vUp]) ) );
 //pt->s[1] *
   pt->m[1][1] =
      ( rcosf[1] = ( rcos[2] ) * ( rcos[0] = (float)COS( dv[vRight] ) ) );
 //pt->s[2] *
   pt->m[2][2] =
      ( rcosf[2] = ( rcos[1] ) * ( rcos[0] ) );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(RotateAbs)( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) {
	_POINT p;
	p[0] = rx;
	p[1] = ry;
   p[2] = rz;
   EXTERNAL_NAME(RotateAbsV)( pt, p );
}
//------------------------------------
INLINEFUNC( void, Rotate, ( RCOORD dAngle, P_POINT vaxis1, P_POINT vaxis2 ) )
{
   _POINT v1, v2;
   _POINT vsave;
   RCOORD dsin = (RCOORD)SIN( dAngle )
	     , dcos = (RCOORD)COS( dAngle );
   MemCpy( vsave, vaxis1, sizeof( _POINT ) );
   DOFUNC(scale)( v1, vaxis1, dcos );
   DOFUNC(scale)( v2, vaxis2, dsin );
   DOFUNC(sub)( vaxis1, v1, v2 );
   DOFUNC(scale)( v2, vsave, dsin );
   DOFUNC(scale)( v1, vaxis2, dcos );
   DOFUNC(add)( vaxis2, v2, v1 );
}
//----------------------------------------------------------------
#define RotateYaw(m,a)        if(a) DOFUNC(Rotate)( a,m[vRight],m[vForward] );
#define RotatePitch(m,a)      if(a) DOFUNC(Rotate)( a,m[vForward],m[vUp] );
#define RotateRoll(m,a)       if(a) DOFUNC(Rotate)( a,m[vUp],m[vRight] );
void EXTERNAL_NAME(RotateRelV)( PTRANSFORM pt, PC_POINT r )
 // depends on Scale function....
{
   if( !pt->motions )
	   EXTERNAL_NAME(CreateTransformMotion)( pt );
   switch( pt->motions->nTime++ )
   {
   case 0:
      RotateYaw   ( pt->m, r[vUp] );
      RotatePitch ( pt->m, r[vRight] );
      RotateRoll  ( pt->m, r[vForward] );
      break;
   case 1:
      RotateYaw   ( pt->m, r[vUp] );
      RotateRoll  ( pt->m, r[vForward] );
      RotatePitch ( pt->m, r[vRight] );
      break;
   case 2:
      RotatePitch ( pt->m, r[vRight] );
      RotateYaw   ( pt->m, r[vUp] );
      RotateRoll  ( pt->m, r[vForward] );
      break;
   case 3:
      RotatePitch ( pt->m, r[vRight] );
      RotateRoll  ( pt->m, r[vForward] );
      RotateYaw   ( pt->m, r[vUp] );
      break;
   case 4:
      RotateRoll  ( pt->m, r[vForward] );
      RotatePitch ( pt->m, r[vRight] );
      RotateYaw   ( pt->m, r[vUp] );
      break;
   default:
      pt->motions->nTime = 0;
      RotateRoll  ( pt->m, r[vForward] );
      RotateYaw   ( pt->m, r[vUp] );
      RotatePitch ( pt->m, r[vRight] );
      break;
   }
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(RotateRel)( PTRANSFORM pt, RCOORD x, RCOORD y, RCOORD z )
{
	_POINT p;
	p[0] = x;
	p[1] = y;
	p[2] = z;
	EXTERNAL_NAME(RotateRelV)( pt, p );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(RotateTo)( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright )
{
	SetPoint( pt->m[vForward], vforward );
	DOFUNC(normalize)( pt->m[vForward] );
	SetPoint( pt->m[vRight], vright );
	DOFUNC(normalize)( pt->m[vRight] );
	DOFUNC(crossproduct)( pt->m[vUp], pt->m[vForward], pt->m[vRight] );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(RotateMast)( PTRANSFORM pt, PCVECTOR vup )
{
	SetPoint( pt->m[vUp], vup );
	DOFUNC(normalize)( pt->m[vUp] );
	DOFUNC(crossproduct)( pt->m[vForward], pt->m[vUp], pt->m[vRight] );
	DOFUNC(normalize)( pt->m[vForward] );
	DOFUNC(crossproduct)( pt->m[vRight], pt->m[vForward], pt->m[vUp] );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(RotateAroundMast)( PTRANSFORM pt, RCOORD amount )
{
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
	{
		lprintf( "blah" );
	}
#endif
	RotateYaw( pt->m, amount );
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
	{
		lprintf( "blah" );
	}
#endif
}
//----------------------------------------------------------------
// Right as in Right Angle...
 void EXTERNAL_NAME(RotateRight)( PTRANSFORM pt, int Axis1, int Axis2 )
{
   VECTOR v;
   if( Axis1 == -1 )
   {
      DOFUNC(Invert)( pt->m[vForward] );
      DOFUNC(Invert)( pt->m[vRight] );
   }
   else
   {
      SetPoint( v, pt->m[Axis1] );
      SetPoint( pt->m[Axis1], pt->m[Axis2] );
      DOFUNC(Invert)( v );
      SetPoint( pt->m[Axis2], v );
   }
}
//----------------------------------------------------------------
INLINEFUNC( void, ApplyInverseRotation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) )
{
	#define i 0
	dest[i] = pt->m[i][vRight]   * src[vRight] +
             pt->m[i][vUp]      * src[vUp] +
             pt->m[i][vForward] * src[vForward];
	#undef i
	#define i 1
	dest[i] = pt->m[i][vRight]   * src[vRight] +
             pt->m[i][vUp]      * src[vUp] +
             pt->m[i][vForward] * src[vForward];
	#undef i
	#define i 2
	dest[i] = pt->m[i][vRight]   * src[vRight] +
             pt->m[i][vUp]      * src[vUp] +
             pt->m[i][vForward] * src[vForward];
	#undef i
}
REALFUNC( ApplyInverseRotation, (  PCTRANSFORM pt, P_POINT dest, PC_POINT src ), (pt, dest, src ) )
//----------------------------------------------------------------
INLINEFUNC( void, ApplyRotation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) )
{
   #define i 0
   dest[i] = pt->s[i] * ( pt->m[vRight]  [i] * src[vRight] +
             pt->m[vUp]     [i] * src[vUp] +
             pt->m[vForward][i] * src[vForward] );
   #undef i
   #define i 1
   dest[i] = pt->s[i] * ( pt->m[vRight]  [i] * src[vRight] +
             pt->m[vUp]     [i] * src[vUp] +
             pt->m[vForward][i] * src[vForward] );
   #undef i
   #define i 2
   dest[i] = pt->s[i] * ( pt->m[vRight]  [i] * src[vRight] +
             pt->m[vUp]     [i] * src[vUp] +
             pt->m[vForward][i] * src[vForward] );
   #undef i
}
REALFUNC( ApplyRotation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) , (pt, dest, src ) )
//----------------------------------------------------------------
void EXTERNAL_NAME(ApplyTranslation)( PCTRANSFORM pt, P_POINT dest, PC_POINT src )
{
   DOFUNC(add)( dest, src, pt->m[3] );
}
//----------------------------------------------------------------
INLINEFUNC( void, ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) )
{
   DOFUNC(sub)( dest, pt->m[3], src );
}
REALFUNC( ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ), (pt, dest, src ) )
//----------------------------------------------------------------
INLINEFUNC( void, ApplyInverse, ( PCTRANSFORM pt,  P_POINT dest, PC_POINT src ) )
{
   VECTOR v;
  // more then rotate....
   DOFUNC(sub)( v, src, pt->m[3] );
   DOFUNC(ApplyInverseRotation)( pt, dest, v );
}
REALFUNC( ApplyInverse, ( PCTRANSFORM pt,  P_POINT dest, PC_POINT src ), (pt, dest, src ) )
//----------------------------------------------------------------
INLINEFUNC( void, Apply, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src )  )
{
   //VECTOR v;
   //DOFUNC(add)( v, src, pt->m[3] );
   DOFUNC(ApplyRotation)( pt, dest, src );
   DOFUNC(add)( dest, dest, pt->m[3] );
}
REALFUNC( Apply, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ), (pt, dest, src ) )
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyR)( PCTRANSFORM pt, PRAY prd, PRAY prs )
{
	DOFUNC(Apply)( pt, prd->o, prs->o );
	DOFUNC(ApplyRotation)( pt, prd->n, prs->n );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(ApplyT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
	EXTERNAL_NAME(ClearTransform)( &t );
	DOFUNC(ApplyRotation)( pt, t.m[0], pts->m[0] );
	DOFUNC(ApplyRotation)( pt, t.m[1], pts->m[1] );
	DOFUNC(ApplyRotation)( pt, t.m[2], pts->m[2] );
	{
		//VECTOR v;
		//// align our translation with souce transform
		//ApplyRotation( pts, v, pt->m[3] );
		//add( t.m[3], pts->m[3], v );
		DOFUNC(Apply)( pt, t.m[3], pts->m[3] );
	}
#ifdef _MSC_VER
	if( _isnan( t.m[0][0] ) )
		lprintf( "blah" );
#endif
	MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(ApplyM)( PMatrix pt, PMatrix ptd, PMatrix pts )
{
	int i,k;
	for( k = 0; k < 4; k++ ) {
		for( i = 0; i < 4; i++ ) {
			ptd[0][i][k] = pt[0][0][k] * pts[0][i][0]
			             + pt[0][1][k] * pts[0][i][1]
			             + pt[0][2][k] * pts[0][i][2]
			             + pt[0][3][k] * pts[0][i][3];
		}
	}
}
//----------------------------------------------------------------
void EXTERNAL_NAME(ApplyMcm)( PMatrix pt, PMatrix ptd, PMatrix pts )
{
	RCOORD tmp;
	int i,j, k;
	for( k = 0; k < 4; k++ ) {
		for( i = 0; i < 4; i++ ) {
			tmp = 0;
			for( j = 0; j < 4; j++ ) {
				tmp += pt[0][j][k] * pts[0][i][j];
			}
			ptd[0][k][i] = tmp;
		}
	}
}
//----------------------------------------------------------------
void EXTERNAL_NAME(ApplyCameraT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
	EXTERNAL_NAME(ClearTransform)( &t );
	DOFUNC(ApplyRotation)( pt, t.m[0], pts->m[0] );
	DOFUNC(ApplyRotation)( pt, t.m[1], pts->m[1] );
	DOFUNC(ApplyRotation)( pt, t.m[2], pts->m[2] );
	{
		//VECTOR v;
		//// align our translation with souce transform
		//ApplyRotation( pts, v, pt->m[3] );
		//add( t.m[3], pts->m[3], v );
		DOFUNC(Apply)( pt, t.m[3], pts->m[3] );
	}
#ifdef _MSC_VER
	if( _isnan( t.m[0][0] ) )
		lprintf( "blah" );
#endif
	MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyTranslationT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
	EXTERNAL_NAME(ClearTransform)( &t );
	SetPoint( t.m[0], pts->m[0] );
	SetPoint( t.m[1], pts->m[1] );
	SetPoint( t.m[2], pts->m[2] );
	DOFUNC(Apply)(pt, t.m[3], pts->m[3] );
	MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
// may be called with the same transform for source and dest
// safely transforms such that the source is not destroyed until
// the value of dest is computed entirely, which is then set into dest.
 void EXTERNAL_NAME(ApplyRotationT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
	EXTERNAL_NAME(ClearTransform)( &t );
	DOFUNC(ApplyRotation)( pt, t.m[0], pts->m[0] );
	DOFUNC(ApplyRotation)( pt, t.m[1], pts->m[1] );
	DOFUNC(ApplyRotation)( pt, t.m[2], pts->m[2] );
	SetPoint( t.m[3], pts->m[3] );
	MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyInverseR)( PCTRANSFORM pt, PRAY prd, PRAY prs )
{
   DOFUNC(ApplyInverse)( pt, prd->o, prs->o );
   DOFUNC(ApplyInverseRotation)( pt, prd->n, prs->n );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyInverseT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
   EXTERNAL_NAME(ClearTransform)( &t );
   DOFUNC(ApplyInverseRotation)( pt, t.m[0], pts->m[0] );
   DOFUNC(ApplyInverseRotation)( pt, t.m[1], pts->m[1] );
	DOFUNC(ApplyInverseRotation)( pt, t.m[2], pts->m[2] );
   DOFUNC(ApplyInverse)( pt, t.m[3], pts->m[3] );
   MemCpy( ptd->m, t.m, sizeof( t.m ) );
   MemCpy( ptd->s, t.s, sizeof( t.s ) );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyInverseTranslationT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
	EXTERNAL_NAME(ClearTransform)( &t );
   SetPoint( t.m[0], pts->m[0] );
   SetPoint( t.m[1], pts->m[1] );
	SetPoint( t.m[2], pts->m[2] );
  // more then rotate....
   DOFUNC(sub)( t.m[3], pt->m[3], pt->m[3] );
   MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(ApplyInverseRotationT)( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts )
{
	TRANSFORM t;
   EXTERNAL_NAME(ClearTransform)( &t );
   DOFUNC(ApplyInverseRotation)( pt, t.m[0], pts->m[0] );
   DOFUNC(ApplyInverseRotation)( pt, t.m[1], pts->m[1] );
   DOFUNC(ApplyInverseRotation)( pt, t.m[2], pts->m[2] );
   SetPoint( t.m[3], pts->m[3] );
   MemCpy( ptd->m, t.m, sizeof( t.m ) );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(MoveForward)( PTRANSFORM pt, RCOORD distance )
{
	if( pt )
	{
			pt->m[3][0] += distance * pt->m[vForward][0];
			pt->m[3][1] += distance * pt->m[vForward][1];
			pt->m[3][2] += distance * pt->m[vForward][2];
	}
}
//----------------------------------------------------------------
void EXTERNAL_NAME(MoveRight)( PTRANSFORM pt, RCOORD distance )
{
	if( pt )
	{
			pt->m[3][0] += distance * pt->m[vRight][0];
			pt->m[3][1] += distance * pt->m[vRight][1];
			pt->m[3][2] += distance * pt->m[vRight][2];
	}
}
//----------------------------------------------------------------
void EXTERNAL_NAME(MoveUp)( PTRANSFORM pt, RCOORD distance )
{
	if( pt )
	{
			pt->m[3][0] += distance * pt->m[vUp][0];
			pt->m[3][1] += distance * pt->m[vUp][1];
			pt->m[3][2] += distance * pt->m[vUp][2];
	}
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(Forward)( PTRANSFORM pt, RCOORD distance )
{
	if( pt && pt->motions )
		pt->motions->speed[vForward] = distance;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(Up)( PTRANSFORM pt, RCOORD distance )
{
	if( pt && pt->motions )
		pt->motions->speed[vUp] = distance;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(Right)( PTRANSFORM pt, RCOORD distance )
{
	if( pt && pt->motions )
		pt->motions->speed[vRight] = distance;
}
//----------------------------------------------------------------
void EXTERNAL_NAME(AddTransformCallback)( PTRANSFORM pt, MotionCallback callback, uintptr_t psv )
{
	if( pt && pt->motions )
	{
		INDEX idx;
		AddLink( &pt->motions->callbacks, callback );
		idx = FindLink( &pt->motions->callbacks, (POINTER)callback );
		SetLink( &pt->motions->userdata, idx, psv );
	}
}
//----------------------------------------------------------------
static void InvokeCallbacks( PTRANSFORM pt )
{
	INDEX idx;
	MotionCallback callback;
	if( pt && pt->motions )
	{
		LIST_FORALL( pt->motions->callbacks, idx, MotionCallback, callback )
		{
			callback( (uintptr_t)GetLink( &pt->motions->userdata, idx ), pt );
#ifdef _MSC_VER
			if( _isnan( pt->m[0][0] ) )
				lprintf( "blah" );
#endif
		}
	}
}
//----------------------------------------------------------------
LOGICAL EXTERNAL_NAME(MoveEx)( PTRANSFORM pt, struct motion_frame_tag *motion)
{
	LOGICAL moved = FALSE;
	// this matrix of course....
	// clock the matrix one cycle....
	// this means - add one speed vector
	// and one rotation vector to the current
	// x-y-z-a-b-c position and orientation
	// matrix...  this is later referenced
	// to trasform the remaining points
	// (application of this matrix)
	if( pt && motion )
	{
		//VECTOR v;
		RCOORD speed_step;
		RCOORD rotation_step;
		if( !pt )
			return FALSE;
#ifdef _MSC_VER
		if( _isnan( pt->m[0][0] ) )
		{
			return FALSE;
			lprintf( "blah" );
		}
#endif
	{
		{
#if HAVE_CHEAP_CPU_FREQUENCY
			static uint64_t tick_freq_cpu;
			static uint64_t last_tick_cpu;
			static uint32_t tick_cpu;
#endif
			if( motion->last_tick )
			{
				// how much time passed between then and no
				// and what's our target resolution?
				static uint32_t now;
				uint32_t delta = ( now = timeGetTime() ) - motion->last_tick;
				if( !delta )
				{
  // on 0 time elapse, don't try this... cpu scaling will mess this up.
					return FALSE;
#if HAVE_CHEAP_CPU_FREQUENCY
					if( !tick_freq_cpu )
						tick_freq_cpu = GetCPUFrequency();
					{
						static uint64_t now_cpu;
						uint64_t delta_cpu = ( last_tick_cpu - (now_cpu = GetCPUTick() ) )
							- ( ( now - tick_cpu ) * tick_freq_cpu );
						RCOORD delta2 = ( (RCOORD)delta_cpu * 1000 ) / ( (RCOORD)tick_freq_cpu * 33 );
						pt->time_scale = ONE / (RCOORD)( delta2 );
			//					//);
						tick_cpu = now;
						last_tick_cpu = now_cpu;
					}
#endif
					// err we have a cycle rate greater than 1ms 1000/sec?
				}
				else
				{
 // times 1000 so we get extra precision.
					speed_step = delta / motion->speed_time_interval;
 // times 1000 so we get extra precision.
					rotation_step = delta / motion->rotation_time_interval;
				}
				motion->last_tick = now;
			}
			else
			{
				// don't move on the first tick.
#if CONSTANT_CPU_TICK
				tick_cpu = motion->last_tick = timeGetTime();
				last_tick_cpu = GetCPUTick();
				motion->time_scale = ONE;
#endif
				motion->last_tick = timeGetTime();
				return FALSE;
			}
		}
	}
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
	{
		VECTOR v;
		if( motion->rocket )
		{
			moved = TRUE;
			//DOFUNC(scale )(v, motion->accel, speed_step);
			DOFUNC(add)( v, motion->prior_accel, motion->accel );
			DOFUNC(scale)( v, v, (RCOORD)0.5 * speed_step );
			SetPoint( motion->prior_accel, motion->accel );
			// add the scaled acceleration in the current direction of this
			motion->speed[0] += v[0] * pt->m[0][0]
				+ v[1] * pt->m[1][0]
				+ v[2] * pt->m[2][0];
			motion->speed[1] += v[0] * pt->m[0][1]
				+ v[1] * pt->m[1][1]
				+ v[2] * pt->m[2][1];
			motion->speed[2] += v[0] * pt->m[0][2]
				+ v[1] * pt->m[1][2]
				+ v[2] * pt->m[2][2];
			DOFUNC(addscaled)( pt->m[3], pt->m[3], motion->speed, speed_step );
		}
		else if( motion->fluff )
		{
			if( motion->speed[0] || motion->speed[1] || motion->speed[2]
				|| motion->accel[0] || motion->accel[1] || motion->accel[2] )
			{
				moved = TRUE;
				DOFUNC( add )(v, motion->prior_accel, motion->accel);
				DOFUNC( addscaled )(motion->speed, motion->speed, v, (RCOORD)0.5*speed_step);
				SetPoint( motion->prior_accel, motion->accel );
				//DOFUNC(addscaled)( motion->speed, motion->speed, motion->accel, speed_step );
				DOFUNC( add )(v, motion->prior_speed, motion->speed);
				DOFUNC( addscaled ) (pt->m[3], pt->m[3], v, (RCOORD)0.5 * speed_step);
				SetPoint( motion->prior_speed, motion->speed );
			}
		}
		else
		{
			if( motion->speed[0] || motion->speed[1] || motion->speed[2]
				|| motion->accel[0] || motion->accel[1] || motion->accel[2] )
			{
				moved = TRUE;
				DOFUNC( add )(v, motion->prior_accel, motion->accel);
				DOFUNC( addscaled )(motion->speed, motion->speed, v, (RCOORD)0.5*speed_step);
				SetPoint( motion->prior_accel, motion->accel );
				//DOFUNC(addscaled)( motion->speed, motion->speed, motion->accel, speed_step );
				DOFUNC(scale)( v, motion->speed, speed_step );
				//scale( v, v, pt->time_scale ); // velocity applied across this time
				pt->m[3][0] += v[0] * pt->m[0][0]
					+ v[1] * pt->m[1][0]
					+ v[2] * pt->m[2][0];
				pt->m[3][1] += v[0] * pt->m[0][1]
					+ v[1] * pt->m[1][1]
					+ v[2] * pt->m[2][1];
				pt->m[3][2] += v[0] * pt->m[0][2]
					+ v[1] * pt->m[1][2]
					+ v[2] * pt->m[2][2];
			}
		}
#ifdef _MSC_VER
		if( _isnan( pt->m[0][0] ) )
			lprintf( "blah" );
#endif
		// include time scale for rotation also...
		if( motion->rotation[0] || motion->rotation[1] || motion->rotation[2]
			|| motion->rot_accel[0] || motion->rot_accel[1] || motion->rot_accel[2]
			)
		{
			VECTOR  r;
			//lprintf( "Time scale is not applied" );
			moved = TRUE;
			DOFUNC(addscaled)( motion->rotation, motion->rotation, motion->rot_accel, rotation_step );
			DOFUNC(scale)( r, motion->rotation, rotation_step );
			EXTERNAL_NAME(RotateRelV)( pt, r );
#ifdef _MSC_VER
			if( _isnan( pt->m[0][0] ) )
				lprintf( "blah" );
#endif
		}
#ifdef _MSC_VER
		if( _isnan( pt->m[0][0] ) )
			lprintf( "blah" );
#endif
		InvokeCallbacks( pt );
#ifdef _MSC_VER
		if( _isnan( pt->m[0][0] ) )
			lprintf( "blah" );
#endif
	}
	}
	return moved;
}
LOGICAL EXTERNAL_NAME( Move )(PTRANSFORM pt)
{
	int n;
	LOGICAL moved = FALSE;
	for( n = 0; n < pt->nMotion; n++ )
		moved |= EXTERNAL_NAME( MoveEx )(pt, pt->motions + n);
	return moved;
}
//----------------------------------------------------------------
#if 0
 void Unmove( PTRANSFORM pt )
{
   // this matrix of course....
   // clock the matrix one cycle....
   // this means - add one speed vector
   // and one rotation vector to the current
   // x-y-z-a-b-c position and orientation
   // matrix...  this is later referenced
   // to trasform the remaining points
	// (application of this matrix)
	VECTOR v;
	RCOORD speed_step;
   RCOORD rotation_step;
	if( !pt )
		return;
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
	{
		return;
		lprintf( "blah" );
	}
#endif
	{
		{
			static uint64_t tick_freq_cpu;
			static uint64_t last_tick_cpu;
			static uint32_t tick_cpu;
			if( pt->last_tick )
			{
				// how much time passed between then and no
				// and what's our target resolution?
				static uint32_t now;
				uint32_t delta = ( now = timeGetTime() ) - pt->last_tick;
				if( !delta )
				{
  // on 0 time elapse, don't try this... cpu scaling will mess this up.
					return FALSE;
#if HAVE_CHEAP_CPU_FREQUENCY
					if( !tick_freq_cpu )
						tick_freq_cpu = GetCPUFrequency();
					{
						static uint64_t now_cpu;
						uint64_t delta_cpu = ( last_tick_cpu - (now_cpu = GetCPUTick() ) )
							- ( ( now - tick_cpu ) * tick_freq_cpu );
						RCOORD delta2 = ( (RCOORD)delta_cpu * 1000 ) / ( (RCOORD)tick_freq_cpu * 33 );
						pt->time_scale = ONE / (RCOORD)( delta2 );
			//					//);
						tick_cpu = now;
						last_tick_cpu = now_cpu;
					}
#endif
					// err we have a cycle rate greater than 1ms 1000/sec?
				}
				else
				{
 // times 1000 so we get extra precision.
					speed_step = delta / pt->speed_time_interval;
 // times 1000 so we get extra precision.
					rotation_step = delta / pt->rotation_time_interval;
				}
            pt->prior_tick = pt->last_tick;
				pt->last_tick = now;
			}
			else
			{
				// don't move on the first tick.
#if CONSTANT_CPU_TICK
				tick_cpu = pt->last_tick = timeGetTime();
				last_tick_cpu = GetCPUTick();
				pt->time_scale = ONE;
#endif
				pt->last_tick = timeGetTime();
            pt->prior_tick = pt->last_tick - 1;
            return;
			}
		}
	}
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
	//add( v, pt->speed, pt->accel );
	DOFUNC(addscaled)( pt->speed, pt->speed, pt->accel, -speed_step );
	scale( v, pt->speed, -speed_step );
	//scale( v, v, pt->time_scale ); // velocity applied across this time
   pt->m[3][0] += v[0] * pt->m[0][0]
                + v[1] * pt->m[1][0]
                + v[2] * pt->m[2][0];
   pt->m[3][1] += v[0] * pt->m[0][1]
                + v[1] * pt->m[1][1]
                + v[2] * pt->m[2][1];
   pt->m[3][2] += v[0] * pt->m[0][2]
                + v[1] * pt->m[1][2]
		+ v[2] * pt->m[2][2];
#ifdef _MSC_VER
	   if( _isnan( pt->m[0][0] ) )
			lprintf( "blah" );
#endif
   // include time scale for rotation also...
	if( pt->rotation[0] || pt->rotation[1] || pt->rotation[2] )
	{
		VECTOR  r;
		//lprintf( "Time scale is not applied" );
		DOFUNC(addscaled)( pt->motion->rotation, pt->motion->rotation, pt->motion->rot_accel, -rotation_step );
		scale( r, pt->motion->rotation, -rotation_step );
		EXTERNAL_NAME(RotateRelV)( pt, r );
#ifdef _MSC_VER
	   if( _isnan( pt->m[0][0] ) )
			lprintf( "blah" );
#endif
	}
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
	InvokeCallbacks( pt );
#ifdef _MSC_VER
	if( _isnan( pt->m[0][0] ) )
		lprintf( "blah" );
#endif
}
#endif
//----------------------------------------------------------------
P_POINT EXTERNAL_NAME(GetSpeed)( PTRANSFORM pt, P_POINT s )
{
   SetPoint( s, pt->motions->speed );
   return s;
}
//----------------------------------------------------------------
PC_POINT  EXTERNAL_NAME(SetSpeed)( PTRANSFORM pt, PC_POINT s )
{
	SetPoint( pt->motions->speed, s );
   return s;
}
//----------------------------------------------------------------
void EXTERNAL_NAME(SetTimeInterval)( PTRANSFORM pt, RCOORD speed_interval, RCOORD rotation_interval )
{
 // application of motions uses this factor
   pt->motions->rotation_time_interval = rotation_interval;
 // application of motions uses this factor
   pt->motions->speed_time_interval = speed_interval;
}
//----------------------------------------------------------------
P_POINT  EXTERNAL_NAME(GetAccel)( PTRANSFORM pt, P_POINT s )
{
   SetPoint( s, pt->motions->accel );
   return s;
}
//----------------------------------------------------------------
 PC_POINT  EXTERNAL_NAME(SetAccel)( PTRANSFORM pt, PC_POINT s )
{
	SetPoint( pt->motions->accel, s );
	return s;
}
//----------------------------------------------------------------
 PC_POINT EXTERNAL_NAME(SetRotation)( PTRANSFORM pt, PC_POINT r )
{
	SetPoint( pt->motions->rotation, r );
	return r;
}
//----------------------------------------------------------------
P_POINT EXTERNAL_NAME(GetRotation)( PTRANSFORM pt, P_POINT r )
{
	SetPoint( r, pt->motions->rotation );
	return r;
}
//----------------------------------------------------------------
 PC_POINT EXTERNAL_NAME(SetRotationAccel)( PTRANSFORM pt, PC_POINT r )
{
	SetPoint( pt->motions->rot_accel, r );
	return r;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(GetOriginV)( PTRANSFORM pt, P_POINT o )
{
   SetPoint( o, pt->m[3] );
}
//----------------------------------------------------------------
 PC_POINT EXTERNAL_NAME(GetOrigin)( PTRANSFORM pt  )
{
	if( pt )
		return pt->m[3];
	return NULL;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(GetAxisV)( PTRANSFORM pt, P_POINT a, int n )
{
	SetPoint( a, pt->m[n] );
}
//----------------------------------------------------------------
 PC_POINT EXTERNAL_NAME(GetAxis)( PTRANSFORM pt, int n )
{
	if( pt )
		return pt->m[n];
	return NULL;
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(SetAxisV)( PTRANSFORM pt, PC_POINT a, int n )
{
   SetPoint( pt->m[n], a );
}
//----------------------------------------------------------------
 void EXTERNAL_NAME(SetAxis)( PTRANSFORM pt, RCOORD a, RCOORD b, RCOORD c, int n )
{
 //-V557
   SetPoint( pt->m[n], &a );
}
//----------------------------------------------------------------
void EXTERNAL_NAME(InvertTransform)( PTRANSFORM pt )
{
	RCOORD tmp;
	int i, j;
	// confusing loops - but this will invert top row
	// to left row - reversable operation...
	// unsure if I need to change signs during this
	// the matrix determinate should still be the same....???
	for( j = 0; j < 3; j++ )
	{
		for( i = j+1; i < 4; i++ )
		{
			tmp = pt->m[i][j];
			pt->m[i][j] = pt->m[j][i];
			pt->m[j][i] = tmp;
		}
	}
}
//----------------------------------------------------------------
void EXTERNAL_NAME(GetGLCameraMatrix)( PTRANSFORM pt, PMATRIX out )
{
    // ugly but perhaps there will be some optimization if I
    // do this linear like... sure it's a lot of code, but at
    // least there's no work to loop and multiply...
    out[0][0] = pt->m[0][0];
    out[0][1] = pt->m[1][0];
    out[0][2] = -pt->m[2][0];
	 //out[0][3] = pt->m[3][0];
	 out[0][3] = pt->m[0][3];
    out[1][0] = pt->m[0][1];
    out[1][1] = pt->m[1][1];
    out[1][2] = -pt->m[2][1];
	 //out[1][3] = pt->m[3][1];
	 out[1][3] = pt->m[1][3];
	 // z was inverted of what it should have been...
    out[2][0] = pt->m[0][2];
    out[2][1] = pt->m[1][2];
    out[2][2] = -pt->m[2][2];
	 //out[2][3] = pt->m[3][2];
	 out[2][3] = pt->m[2][3];
    //out[3][0] = pt->m[0][3];
    //out[3][1] = pt->m[1][3];
    //out[3][2] = pt->m[2][3];
	 //out[3][3] = pt->m[3][3];
	 // okay apparently opengl applies
	 // this origin, and then rotates according to the
	 // above matrix... so I need to undo having the correct
    // bias on the translation.
	 //DOFUNC(ApplyInverseRotation)( pt, out[3], pt->m[3] );
    DOFUNC(Invert)( pt->m[2] );
    DOFUNC(ApplyInverseRotation)( pt, out[3], pt->m[3] );
	DOFUNC(Invert)( pt->m[2] );
    DOFUNC(Invert)( out[3] );
    //ApplyRotation( pt, out[3], pt->m[3] );
    //out[3][0] = pt->m[3][0];
    //out[3][1] = pt->m[3][1];
    //out[3][2] = pt->m[3][2];
    out[3][3] = pt->m[3][3];
}
//----------------------------------------------------------------
void EXTERNAL_NAME(GetGLMatrix)( PTRANSFORM pt, PMATRIX out )
{
	// ugly but perhaps there will be some optimization if I
	// do this linear like... sure it's a lot of code, but at
	// least there's no work to loop and multiply...
	out[0][0] = pt->m[0][0];
	out[0][1] = pt->m[1][0];
	out[0][2] = -pt->m[2][0];
	//out[0][3] = pt->m[3][0];
	out[0][3] = pt->m[0][3];
	out[1][0] = pt->m[0][1];
	out[1][1] = pt->m[1][1];
	out[1][2] = -pt->m[2][1];
	//out[1][3] = pt->m[3][1];
	out[1][3] = pt->m[1][3];
	// z was inverted of what it should have been...
	out[2][0] = pt->m[0][2];
	out[2][1] = pt->m[1][2];
	out[2][2] = -pt->m[2][2];
	//out[2][3] = pt->m[3][2];
	out[2][3] = pt->m[2][3];
	//out[3][0] = pt->m[0][3];
	//out[3][1] = pt->m[1][3];
	//out[3][2] = pt->m[2][3];
	//out[3][3] = pt->m[3][3];
	 // okay apparently opengl applies
	 // this origin, and then rotates according to the
	 // above matrix... so I need to undo having the correct
    // bias on the translation.
	 //DOFUNC(ApplyInverseRotation)( pt, out[3], pt->m[3] );
	DOFUNC(Invert)( pt->m[2] );
	DOFUNC(ApplyInverseRotation)( pt, out[3], pt->m[3] );
	DOFUNC(Invert)( pt->m[2] );
	DOFUNC(Invert)( out[3] );
	out[3][3] = pt->m[3][3];
}
//----------------------------------------------------------------
void EXTERNAL_NAME(SetGLMatrix)( PMATRIX in, PTRANSFORM pt )
{
    // ugly but perhaps there will be some optimization if I
    // do this linear like... sure it's a lot of code, but at
    // least there's no work to loop and multiply...
    pt->m[0][0] =  in[0][0];
    pt->m[0][1] =  in[1][0];
    pt->m[0][2] =  in[2][0];
	pt->m[0][3] =  in[0][3];
    pt->m[1][0] =  in[0][1];
    pt->m[1][1] =  in[1][1];
    pt->m[1][2] =  in[2][1];
	 pt->m[1][3] =  in[1][3];
	 // z was inverted of what it should have been...
    pt->m[2][0] =  in[0][2];
    pt->m[2][1] =  in[1][2];
    pt->m[2][2] =  in[2][2];
	 pt->m[2][3] =  in[2][3];
	 pt->m[3][0] = in[3][0];
	 pt->m[3][1] = in[3][1];
	 pt->m[3][2] = in[3][2];
	 pt->m[3][3] = in[3][3];
    //DOFUNC(ApplyRotation)( pt, pt->m[3], in[3] );
	 // okay apparently opengl applies
	 // this origin, and then rotates according to the
	 // above matrix... so I need to undo having the correct
    // bias on the translation.
	 //DOFUNC(ApplyInverseRotation)( pt, in[3], pt->m[3] );
    //Invert( pt->m[2] );
    //DOFUNC(ApplyRotation)( pt, pt->m[3], in[3] );
	// Invert( pt->m[2] );
    //Invert( pt->m[3] );
    pt->m[3][3] = 1.0f;
}
void EXTERNAL_NAME(SetRotationMatrix)( PTRANSFORM pt, RCOORD *quat )
{
   /*
   Nq = w^2 + x^2 + y^2 + z^2
if Nq > 0.0 then s = 2/Nq else s = 0.0
X = x*s; Y = y*s; Z = z*s
wX = w*X; wY = w*Y; wZ = w*Z
xX = x*X; xY = x*Y; xZ = x*Z
yY = y*Y; yZ = y*Z; zZ = z*Z
[ 1.0-(yY+zZ)       xY-wZ        xZ+wY  ]
[      xY+wZ   1.0-(xX+zZ)       yZ-wX  ]
[      xZ-wY        yZ+wX   1.0-(xX+yY) ]
*/
	pt->m[0][0] = 1 - 2 * quat[2] * quat[2] - 2 * quat[3] * quat[3];
	pt->m[0][1] = 2 * quat[1] * quat[2] - 2 * quat[3] * quat[0];
	pt->m[0][2] = (2 * quat[1] * quat[3] + 2 * quat[2] * quat[0]);
	pt->m[1][0] = 2 * quat[1] * quat[2] + 2 * quat[3] * quat[0];
	pt->m[1][1] = 1 - 2 * quat[1] * quat[1] - 2 * quat[3] * quat[3];
	pt->m[1][2] = (2 * quat[2] * quat[3] - 2 * quat[1] * quat[0]);
	pt->m[2][0] = 2 * quat[1] * quat[3] - 2 * quat[2] * quat[0];
	pt->m[2][1] = 2 * quat[2] * quat[3] + 2 * quat[1] * quat[0];
	pt->m[2][2] = (1 - 2 * quat[1] * quat[1] - 2 * quat[2] * quat[2]);
	//pt->m[0][0] = quat[0]*quat[0] + quat[1]*quat[1] - quat[2]*quat[2] - quat[3]*quat[3];
	//pt->m[0][1] = 2*quat[1]*quat[2] - 2 * quat[0] * quat[3];
	//pt->m[0][2] = 2*quat[1]*quat[3] + 2 * quat[0] * quat[2];
	//pt->m[1][0] = 2*quat[1]*quat[2] + 2 * quat[0] * quat[3];
	//pt->m[1][1] = quat[0]*quat[0] - quat[1]*quat[1] + quat[2]*quat[2] - quat[3]*quat[3];
	//pt->m[1][2] = 2*quat[2]*quat[3] - 2 * quat[0] * quat[1];
	//pt->m[2][0] = 2*quat[1]*quat[3] - 2 * quat[0] * quat[2];
	//pt->m[2][1] = 2*quat[2]*quat[3] + 2 * quat[0] * quat[1];
	//pt->m[2][2] = quat[0]*quat[0] - quat[1]*quat[1] - quat[2]*quat[2] + quat[3]*quat[3];
	//  q^-1=q'/(q*q')
	//
	// (w,x,y,z)^-1 = (w,-x,-y,-z)/((w,-x,-y,-z)*(w,x,y,z))
	//
}
void EXTERNAL_NAME(GetRotationMatrix)( PTRANSFORM pt, RCOORD *quat )
{
//	t = Qxx+Qyy+Qzz (trace of Q)
//r = sqrt(1+t)
//w = 0.5*r
//x = copysign(0.5*sqrt(1+Qxx-Qyy-Qzz), Qzy-Qyz)
//y = copysign(0.5*sqrt(1-Qxx+Qyy-Qzz), Qxz-Qzx)
//z = copysign(0.5*sqrt(1-Qxx-Qyy+Qzz), Qyx-Qxy)
	/*
	where copysign(x,y) is x with the sign of y:
	copysign(x,y) = sign(y) |x|;
	*/
	/*
	t = Qxx+Qyy+Qzz
r = sqrt(1+t)
s = 0.5/r
w = 0.5*r
x = (Qzy-Qyz)*s
y = (Qxz-Qzx)*s
z = (Qyx-Qxy)*s
*/
	RCOORD t = pt->m[0][0] + pt->m[1][1] + pt->m[2][2];
	if( t > 0 )
	{
		RCOORD r = sqrt(1+t);
		RCOORD s = ((RCOORD)0.5)/r;
		quat[0] = s;
		quat[1] = (pt->m[2][1]-pt->m[1][2])*s;
		quat[2] = (pt->m[0][2]-pt->m[2][0])*s;
		quat[3] = (pt->m[1][0]-pt->m[0][1])*s;
	}
	else if ((pt->m[0][0] > pt->m[1][1])&&(pt->m[0][0] > pt->m[2][2])) {
 // S=4*qx
		RCOORD S = sqrt(1.0 + pt->m[0][0] - pt->m[1][1] - pt->m[2][2]) * ((RCOORD)2);
		quat[0] = (pt->m[2][1] - pt->m[1][2]) / S;
		quat[1] = ((RCOORD)0.25) * S;
		quat[2] = (pt->m[0][1] + pt->m[1][0]) / S;
		quat[3] = (pt->m[0][2] + pt->m[2][0]) / S;
	} else if (pt->m[1][1] > pt->m[2][2]) {
 // S=4*qy
		RCOORD S = sqrt(1.0 + pt->m[1][1] - pt->m[0][0] - pt->m[2][2]) * ((RCOORD)2);
		quat[0] = (pt->m[0][2] - pt->m[2][0]) / S;
		quat[1] = (pt->m[0][1] + pt->m[1][0]) / S;
		quat[2] = ((RCOORD)0.25) * S;
		quat[3] = (pt->m[1][2] + pt->m[2][1]) / S;
	} else {
 // S=4*qz
		RCOORD S = sqrt(1.0 + pt->m[2][2] - pt->m[0][0] - pt->m[1][1]) * ((RCOORD)2);
		quat[0] = (pt->m[1][0] - pt->m[0][1]) / S;
		quat[1] = (pt->m[0][2] + pt->m[2][0]) / S;
		quat[2] = (pt->m[1][2] + pt->m[2][1]) / S;
		quat[3] = ((RCOORD)0.25) * S;
	}
	{
	}
}
#ifdef WORKING_REVERSE_ANGLE_CODE
	double ZMatrix::pitch( void )
	{
		if( ( m[2][2] > 0.707 ) )
			return atan2( m[2][1], m[2][2] ) * (360 / (2*3.14159));
		else if( ( m[2][2] < -0.707 ) )
			return atan2( m[2][1], -m[2][2] ) * (360 / (2*3.14159));
		else
			if( m[2][0] < 0 )
				return atan2( m[2][1], -m[2][0] ) * (360 / (2*3.14159));
			else
				return atan2( m[2][1], m[2][0] ) * (360 / (2*3.14159));
		return atan2( -m[2][1], sqrt( 1-m[2][1] * m[2][1]) ) * (360 / (2*3.14159));
		// sohcah toa
		return asin( m[0][2] ) * (360 / (2*3.14159));
	}
	double ZMatrix::yaw( void )
	{
		if( m[2][1] < 0.707 && m[2][1] > -0.707 )
		{
			return atan2( m[2][0], m[2][2] ) * (360 / (2*3.14159));
		}
		else
		{
			if( m[1][2] < 0 )
				return atan2( m[1][0], m[1][2] ) * (360 / (2*3.14159));
			else
				return atan2( m[1][0], m[1][2] ) * (360 / (2*3.14159));
		}
		// sohcah toa
		//return atan2( m[0][1], m[0][0] ) * (360 / (2*3.14159));
		return asin( m[0][2] ) * (360 / (2*3.14159));
	}
	double ZMatrix::roll( void )
	{
		// sohcah toa
		if( ( m[0][0] > 0.707 ) )
			return atan2( m[0][1], m[0][0] ) * (360 / (2*3.14159));
		else if( ( m[0][0] < -0.707 ) )
			return atan2( m[0][1], -m[0][0] ) * (360 / (2*3.14159));
		else
			if( m[0][2] < 0 )
				return atan2( m[0][1], -m[0][2] ) * (360 / (2*3.14159));
			else
				return atan2( m[0][1], m[0][2] ) * (360 / (2*3.14159));
		return asin( m[0][1] ) * (360 / (2*3.14159));
	}
#endif
//----------------------------------------------------------------
#ifdef __BORLANDC__
#define PRINTF lprintf
#define SPRINTF sprintf
#else
#define PRINTF lprintf
#define SPRINTF(a,b,...) tnprintf(a,sizeof(a),b,##__VA_ARGS__)
#endif
#define DOUBLE_FORMAT  "%g"
void EXTERNAL_NAME(PrintVectorEx)( CTEXTSTR lpName, PCVECTOR v DBG_PASS )
{
   _xlprintf( 1 DBG_RELAY )( "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT,
            lpName, v[0], v[1], v[2], EXTERNAL_NAME(Length)( v ) );
}
#undef PrintVector
void EXTERNAL_NAME(PrintVector)( CTEXTSTR lpName, PCVECTOR v )
{
   EXTERNAL_NAME(PrintVectorEx)( lpName, v DBG_SRC );
}
 void EXTERNAL_NAME(PrintVectorStdEx)( CTEXTSTR lpName, VECTOR v DBG_PASS )
{
   TEXTCHAR byBuffer[256];
   tnprintf( byBuffer, sizeof( byBuffer ), "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT "\n",
            lpName, v[0], v[1], v[2], EXTERNAL_NAME(Length)(v) );
   PRINTF( "%s", byBuffer );
}
#undef PrintVectorStd
 void EXTERNAL_NAME(PrintVectorStd)( CTEXTSTR lpName, VECTOR v )
{
   EXTERNAL_NAME(PrintVectorStdEx)( lpName, v DBG_SRC );
}
#undef PrintMatrix
#undef PrintMatrixf
#undef PrintMatrixd
void EXTERNAL_NAME(PrintMatrix)( CTEXTSTR lpName, MATRIX m )
#define PrintMatrixd(m) PrintMatrixd( #m, m )
#define PrintMatrixf(m) PrintMatrixf( #m, m )
{
   EXTERNAL_NAME(PrintMatrixEx)( lpName, m DBG_SRC );
}
void EXTERNAL_NAME(PrintMatrixEx)( CTEXTSTR lpName, MATRIX m DBG_PASS )
{
   _xlprintf( 1 DBG_RELAY )( "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT,
            lpName, m[0][0], m[0][1], m[0][2], m[0][3], EXTERNAL_NAME(Length)( m[0] ) );
   _xlprintf( 1 DBG_RELAY )( "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT,
            lpName, m[1][0], m[1][1], m[1][2], m[1][3], EXTERNAL_NAME(Length)( m[1] ) );
   _xlprintf( 1 DBG_RELAY )( "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT,
            lpName, m[2][0], m[2][1], m[2][2], m[2][3], EXTERNAL_NAME(Length)( m[2] ) );
   _xlprintf( 1 DBG_RELAY )( "Vector  %s = <" DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT ", " DOUBLE_FORMAT "> " DOUBLE_FORMAT,
            lpName, m[3][0], m[3][1], m[3][2], m[3][3], EXTERNAL_NAME(Length)( m[3] ) );
   {
	   VECTOR v;
	   DOFUNC(crossproduct)( v, m[1], m[2] );
	   EXTERNAL_NAME(PrintVector)( "cross1", v );
	   DOFUNC(crossproduct)( v, m[2], m[0] );
	   EXTERNAL_NAME(PrintVector)( "cross2", v );
	   DOFUNC(crossproduct)( v, m[0], m[1] );
	   EXTERNAL_NAME(PrintVector)( "cross3", v );
   }
}
#undef ShowTransform
void EXTERNAL_NAME(ShowTransformEx)( PTRANSFORM pt, const char *header DBG_PASS )
{
   _xlprintf( 1 DBG_RELAY )( "transform %s", header );
	_xlprintf( 1 DBG_RELAY )( "     -----------------");
#define F4(name) _xlprintf( 1 DBG_RELAY )( #name " <" DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT "> " DOUBLE_FORMAT, pt->name[0], pt->name[1], pt->name[2], pt->name[3], EXTERNAL_NAME(Length)( pt->name ) )
#define F(name) _xlprintf( 1 DBG_RELAY )( #name " <" DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT "> " DOUBLE_FORMAT, pt->name[0], pt->name[1], pt->name[2], EXTERNAL_NAME(Length)( pt->name ) )
	if( pt->motions )
	{
		F(motions->speed);
		F(motions->rotation);
	}
   F4(m[0]);
   F4(m[1]);
   F4(m[2]);
   F4(m[3]);
//   F(rcosf);
   F(s);
}
void EXTERNAL_NAME(ShowTransform)( PTRANSFORM pt, const char *header )
{
	EXTERNAL_NAME(ShowTransformEx)( pt, header DBG_SRC );
}
void EXTERNAL_NAME(showstd)( PTRANSFORM pt, const char *header )
{
	TEXTCHAR byMsg[256];
#undef F4
#undef F
#define F4(name) SPRINTF( byMsg, #name " <" DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT ">", pt->name[0], pt->name[1], pt->name[2], pt->name[3] )
#define F(name) SPRINTF( byMsg, #name " <" DOUBLE_FORMAT " " DOUBLE_FORMAT " " DOUBLE_FORMAT ">", pt->name[0], pt->name[1], pt->name[2] )
   PRINTF( "%s", header );
   PRINTF( "%s", "     -----------------\n");
   F(motions->speed);
   PRINTF( "%s", byMsg );
   F(motions->rotation);
   PRINTF( "%s", byMsg );
   F(m[0]);
   PRINTF( "%s", byMsg );
   F(m[1]);
   PRINTF( "%s", byMsg );
   F(m[2]);
   PRINTF( "%s", byMsg );
   F(m[3]);
   PRINTF( "%s", byMsg );
//   F(rcosf);
//   PRINTF( "%s", byMsg );
   F(s);
   PRINTF( "%s", byMsg );
}
#undef F4
#undef F
#ifdef VECTLIB_FILEIO_SUPPORTED
void EXTERNAL_NAME(SaveTransform)( PTRANSFORM pt, CTEXTSTR filename )
{
	FILE *file;
	file = sack_fopen( 0, filename, "wb" );
	if( file )
	{
		sack_fwrite( pt, 1, sizeof( *pt ), file );
		sack_fclose( file );
	}
}
void EXTERNAL_NAME(LoadTransform)( PTRANSFORM pt, CTEXTSTR filename )
{
	FILE *file;
	file = sack_fopen( 0, filename, "rb" );
	if( file )
	{
		sack_fread( pt, 1, sizeof( *pt ), file );
		pt->motions = NULL;
		pt->nMotion = 0;
		sack_fclose( file );
	}
}
#endif
void EXTERNAL_NAME(GetPointOnPlane)( PRAY plane, PCVECTOR up, PCVECTOR size, PCVECTOR point )
{
	// plane is origin-normal specificatio of plane.
	// up is the direction of 'y' on the plane, right is the direction of 'x',
	// size  is the width/ehight of the plane from the origin
   // point is the x/y point (missing the z coordinate)
	VECTOR right;
	DOFUNC(crossproduct)( right, plane->n, up );
}
//-------------
// code to be moved to vectlib
//-------------
  // line m, b
RCOORD EXTERNAL_NAME(IntersectLineWithPlane)( PCVECTOR Slope, PCVECTOR Origin,
  // plane n, o
									 PCVECTOR n, PCVECTOR o,
										RCOORD *time )
//#define IntersectLineWithPlane( s,o,n,o2,t ) IntersectLineWithPlane(s,o,n,o2,t DBG_SRC )
{
 // time of intersection
	RCOORD a,b,c,cosPhi, t;
	// intersect a line with a plane.
//   v  w = (1/2)(|v + w|2 - |v|2 - |w|2)
//  (v  w)/(|v| |w|) = cos 
	//cosPhi = CosAngle( Slope, n );
	a = ( Slope[0] * n[0] +
			Slope[1] * n[1] +
			Slope[2] * n[2] );
	if( !a )
	{
		//Log1( DBG_FILELINEFMT "Bad choice - slope vs normal is 0" DBG_RELAY, 0 );
		//PrintVector( Slope );
		//PrintVector( n );
		return 0;
	}
	b = EXTERNAL_NAME(Length)( Slope );
	c = EXTERNAL_NAME(Length)( n );
	if( !b || !c )
	{
		Log( "Slope and or n are near 0" );
 // bad vector choice - if near zero length...
		return 0;
	}
	cosPhi = a / ( b * c );
	t = ( n[0] * ( o[0] - Origin[0] ) +
			n[1] * ( o[1] - Origin[1] ) +
			n[2] * ( o[2] - Origin[2] ) ) / a;
//   lprintf( " a: %g b: %g c: %g t: %g cos: %g pldF: %g pldT: %g \n", a, b, c, t, cosTheta,
//                  pl->dFrom, pl->dTo );
//   if( cosTheta > e1 ) //global epsilon... probably something custom
//#define
	if( cosPhi > 0 ||
 // at least some degree of insident angle
		 cosPhi < 0 )
	{
		*time = t;
		return cosPhi;
	}
	else
	{
		Log1( "Parallel... %g\n", cosPhi );
		EXTERNAL_NAME(PrintVector)( "Slope", Slope );
		EXTERNAL_NAME(PrintVector)( "n", n );
		// plane and line are parallel if slope and normal are perpendicular
		//lprintf("Parallel...\n");
		return 0;
	}
}
RCOORD EXTERNAL_NAME( PointToPlaneT )( PCVECTOR n, PCVECTOR o, PCVECTOR p ) {
	VECTOR i;
	RCOORD t;
	SetPoint( i, n );
	EXTERNAL_NAME( Invert)( i );
	EXTERNAL_NAME( IntersectLineWithPlane)( i, p, n, o, &t );
	return t;
}
void EXTERNAL_NAME(basis_lq)( PVECTOR4 v4, PMatrix basis ) {
	// tr(M)=2cos(theta)+1 .
	const RCOORD t = ( ( (*basis)[0][0] + (*basis)[1][1] + (*basis)[2][2] ) - 1 )/2;
	//console.log( "FB t is:", t, basis.right.x, basis.up.y, basis.forward.z );
	//	if( t > 1 || t < -1 )
	//  1,1,1 -1 = 2;/2 = 1
	// -1-1-1 -1 = -4 /2 = -2;
	/// okay; but a rotation matrix never gets back to the full rotation? so 0-1 is enough?  is that why evertyhing is biased?
	//  I thought it was more that sine() - 0->pi is one full positive wave... where the end is the same as the start
	//  and then pi to 2pi is all negative, so it's like the inverse of the rotation (and is only applied as an inverse? which reverses the negative limit?)
	//  So maybe it seems a lot of this is just biasing math anyway?
	const double angle = acos(t);
	if( !angle ) {
		//console.log( "primary rotation is '0'", t, angle, this., basis.right.x, basis.up.y, basis.forward.z );
		v4[0] = 0;
		v4[1] = 1;
		v4[2] = 0;
		v4[3] = 0;
		return;
	}
	/*
	https://stackoverflow.com/a/12472591/4619267
	x = (R21 - R12)/sqrt((R21 - R12)^2+(R02 - R20)^2+(R10 - R01)^2);
	y = (R02 - R20)/sqrt((R21 - R12)^2+(R02 - R20)^2+(R10 - R01)^2);
	z = (R10 - R01)/sqrt((R21 - R12)^2+(R02 - R20)^2+(R10 - R01)^2);
	*/
	RCOORD yz = (*basis)[1][2] - (*basis)[2][1];
	RCOORD xz = (*basis)[2][0] - (*basis)[0][2];
	RCOORD xy = (*basis)[0][1] - (*basis)[1][0];
	double tmp = 1 /sqrt(yz*yz + xz*xz + xy*xy );
	v4[3] = angle;
	v4[0] = yz *tmp;
	v4[1] = xz *tmp;
	v4[2] = xy *tmp;
}
void EXTERNAL_NAME(lq_exp)( PVECTOR4 q, PCVECTOR4 v) {
	RCOORD c = cos( v[3]/2 );
	RCOORD s = sin( v[3]/2 );
	q[0] = c;
	q[1] = v[0] * s;
	q[2] = v[1] * s;
	q[3] = v[2] * s;
}
PMatrix EXTERNAL_NAME(lq_basis)(PMatrix matrix, PCVECTOR4 v ) {
	const RCOORD nt = v[3];
 // sin/cos are the function of exp()
	const RCOORD s  = sin( nt );
 // sin/cos are the function of exp()
	const RCOORD c1 = cos( nt );
 // sin/cos are the function of exp()
	const RCOORD c = 1- c1;
  // x * y / (xx+yy+zz) * (1 - cos(2t))
	const RCOORD xy = c*v[0]*v[1];
  // y * z / (xx+yy+zz) * (1 - cos(2t))
	const RCOORD yz = c*v[1]*v[2];
  // x * z / (xx+yy+zz) * (1 - cos(2t))
	const RCOORD xz = c*v[0]*v[2];
     // x / sqrt(xx+yy+zz) * sin(2t)
	const RCOORD wx = s*v[0];
     // y / sqrt(xx+yy+zz) * sin(2t)
	const RCOORD wy = s*v[1];
     // z / sqrt(xx+yy+zz) * sin(2t)
	const RCOORD wz = s*v[2];
	(*matrix)[0][0] = c1 + c*v[0]*v[0];
	(*matrix)[0][1] =     ( xy + wz );
	(*matrix)[0][2] =     ( xz - wy );
	(*matrix)[1][0] =     ( xy - wz );
	(*matrix)[1][1] = c1 + c*v[1]*v[1];
	(*matrix)[1][2] =     ( wx + yz );
	(*matrix)[2][0] =     ( wy + xz );
	(*matrix)[2][1] =     ( yz - wx );
	(*matrix)[2][2] = c1 + c*v[2]*v[2];
	return matrix;
}
PMatrix EXTERNAL_NAME(lq_matrix)(PMatrix matrix, PCVECTOR4 v, PCVECTOR position ) {
	RCOORD nt = v[3];
 // sin/cos are the function of exp()
	RCOORD s  = sin( nt );
 // sin/cos are the function of exp()
	RCOORD c1 = cos( nt );
 // sin/cos are the function of exp()
	RCOORD c = 1- c1;
  // x * y / (xx+yy+zz) * (1 - cos(2t))
	RCOORD xy = c*v[0]*v[1];
  // y * z / (xx+yy+zz) * (1 - cos(2t))
	RCOORD yz = c*v[1]*v[2];
  // x * z / (xx+yy+zz) * (1 - cos(2t))
	RCOORD xz = c*v[0]*v[2];
     // x / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wx = s*v[0];
     // y / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wy = s*v[1];
     // z / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wz = s*v[2];
	(*matrix)[0][0] = c1 + c*v[0]*v[0];
	(*matrix)[0][1] =     ( xy + wz );
	(*matrix)[0][2] =     ( xz - wy );
	(*matrix)[1][0] =     ( xy - wz );
	(*matrix)[1][1] = c1 + c*v[1]*v[1];
	(*matrix)[1][2] =     ( wx + yz );
	(*matrix)[2][0] =     ( wy + xz );
	(*matrix)[2][1] =     ( yz - wx );
	(*matrix)[2][2] = c1 + c*v[2]*v[2];
	(*matrix)[3][0] = position[0] * (*matrix)[0][0] + position[1] * (*matrix)[1][0] + position[2] * (*matrix)[2][0];
	(*matrix)[3][1] = position[0] * (*matrix)[0][1] + position[1] * (*matrix)[1][1] + position[2] * (*matrix)[2][1];
	(*matrix)[3][2] = position[0] * (*matrix)[0][2] + position[1] * (*matrix)[1][2] + position[2] * (*matrix)[2][2];
	(*matrix)[0][3] = (*matrix)[1][3] = (*matrix)[2][3] = 0;
	(*matrix)[3][3] = 1;
	return matrix;
}
PMatrix EXTERNAL_NAME( lq_gl_basis )( PMatrix matrix, PCVECTOR4 v ) {
	RCOORD nt = v[3];
 // sin/cos are the function of exp()
	RCOORD s  = sin( nt );
 // sin/cos are the function of exp()
	RCOORD c1 = cos( nt );
 // sin/cos are the function of exp()
	RCOORD c = 1- c1;
  // x * y / (xx+yy+zz) * (1 - cos(2t))
	RCOORD xy = c*v[0]*v[1];
  // y * z / (xx+yy+zz) * (1 - cos(2t))
	RCOORD yz = c*v[1]*v[2];
  // x * z / (xx+yy+zz) * (1 - cos(2t))
	RCOORD xz = c*v[0]*v[2];
     // x / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wx = s*v[0];
     // y / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wy = s*v[1];
     // z / sqrt(xx+yy+zz) * sin(2t)
	RCOORD wz = s*v[2];
	(*matrix)[0][0] = c1 + c*v[0]*v[0];
	(*matrix)[1][0] =     ( xy + wz );
	(*matrix)[2][0] =     ( xz - wy );
	(*matrix)[0][1] =     ( xy - wz );
	(*matrix)[1][1] = c1 + c*v[1]*v[1];
	(*matrix)[2][1] =     ( wx + yz );
	(*matrix)[0][2] =     ( wy + xz );
	(*matrix)[1][2] =     ( yz - wx );
	(*matrix)[2][2] = c1 + c*v[2]*v[2];
	return matrix;
}
VECTOR_METHOD( PVECTOR, lq_up, ( PVECTOR out, PCVECTOR4 r ) ) {
 // double angle sin
	const RCOORD s  = sin( r[ 3 ] );
 // sin/cos are the function of exp()
	const RCOORD c1 = cos( r[ 3 ] );
	const RCOORD c  = 1 - c1;
	const RCOORD cn = c * r[ 1 ];
	out[ 0 ]        = -s * r[ 2 ] + cn * r[ 0 ];
	out[ 1 ]        = c1 + cn * r[ 1 ];
	out[ 2 ]        = s * r[ 0 ] + cn * r[ 2 ];
	return out;
}
VECTOR_METHOD( PVECTOR, lq_right, ( PVECTOR out, PCVECTOR4 r ) ) {
 // double angle sin
	const RCOORD s  = sin( r[ 3 ] );
 // sin/cos are the function of exp()
	const RCOORD c1 = cos( r[ 3 ] );
	const RCOORD c  = 1 - c1;
	const RCOORD cn = c * r[ 0 ];
	out[ 0 ]        = c1 + cn * r[ 0 ];
	out[ 1 ]        = s * r[ 2 ] + cn * r[ 1 ];
	out[ 2 ]        = -s * r[ 1 ] + cn * r[ 2 ];
	return out;
}
VECTOR_METHOD( PVECTOR, lq_forward, ( PVECTOR out, PCVECTOR4 r ) ) {
 // double angle sin
	const RCOORD s  = sin( r[ 3 ] );
 // sin/cos are the function of exp()
	const RCOORD c1 = cos( r[ 3 ] );
	const RCOORD c  = 1 - c1;
	const RCOORD cn = c * r[ 2 ];
	out[ 0 ]        = s * r[ 1 ] + cn * r[ 0 ];
	out[ 1 ]        = -s * r[ 0 ] + cn * r[ 1 ];
	out[ 2 ]        = c1 + cn * r[ 2 ];
	return out;
}
RCOORD EXTERNAL_NAME(lq_roll)( PCVECTOR4 r ) {
	// this is the inverse of the y coordinate of the x axis.
   // if x is not flat, then it has some position change in the y direction
	return asin( ( (1 - cos( r[ 3 ] )) * r[ 0 ] ) * r[ 1 ] - sin( r[ 3 ] ) * r[ 2 ] );
}
RCOORD EXTERNAL_NAME(lq_yaw)( PCVECTOR4 r ) {
 // double angle sin
	const RCOORD s         = sin( r[ 3 ] );
 // sin/cos are the function of exp()
	const RCOORD c1        = cos( r[ 3 ] );
	const RCOORD c         = 1 - c1;
	// this is the inverse  x coordinate of the Z axis.
	// if x is not 0 then there is a yaw.
	const RCOORD principal = -asin( -s * r[1] + ( 1 - c1 ) * r[0] * r[2] );
	// then we can look at the x of the x axis, and if it is negative
	const RCOORD rx        = c1 + c * r[ 0 ] * r[ 0 ];
	if( rx > 0 )
		return principal;
	return ( principal < 0 ) ? ( -M_PI - principal ) : ( M_PI - principal );
}
RCOORD EXTERNAL_NAME(lq_pitch)( PCVECTOR4 r ) {
	// this is the inverse coordinate for the z coordinate of the y axis
	// for the forward axis.
	// the negative is distributed, the way this works is inverted to
   // what a UI would want to see.
	return asin( sin( r[3] ) * r[ 0 ] - ( cos( r[3] ) - 1 ) * r[ 2 ] * r[ 1 ] );
}
VECTOR_METHOD( void, lq_apply, ( PVECTOR out, PCVECTOR4 r, PCVECTOR v ) ) {
	// rodrigues full angle multiply
	const RCOORD c = cos( r[ 3 ] );
	const RCOORD s = sin( r[ 3 ] );
	const RCOORD dot = ( 1 - c ) * ( ( r[ 0 ] * v[ 0 ] ) + ( r[ 1 ] * v[ 1 ] ) + ( r[ 2 ] * v[ 2 ] ) );
	// v *cos(theta) + sin(theta)*cross + q * dot * (1-c)
	out[ 0 ]  = v[ 0 ] * c + s * ( r[ 1 ] * v[ 2 ] - r[ 2 ] * v[ 1 ] ) + r[ 0 ] * dot;
	out[ 1 ]  = v[ 1 ] * c + s * ( r[ 2 ] * v[ 0 ] - r[ 0 ] * v[ 2 ] ) + r[ 1 ] * dot;
	out[ 2 ]  = v[ 2 ] * c + s * ( r[ 0 ] * v[ 1 ] - r[ 1 ] * v[ 0 ] ) + r[ 2 ] * dot;
}
VECTOR_METHOD( PVECTOR4, lq_applyRotation, ( PVECTOR4 out, PCVECTOR4 r, PCVECTOR4 a ) ) {
	// RCOORD oct         = oct || floor( r[3] ( M_PI * 2 ) );
	// A dot B   = cos( angle A->B )
	// cos( C/2 )
	//  cos(angle between the two rotation axii)
	const RCOORD AdotB = ( r[ 0 ] * a[ 0 ] + r[ 1 ] * a[ 1 ] + r[ 2 ] * a[ 2 ] );
	/*
	// orbital hopping mechanic...
	// hypothetical relation mass to orbital
	if( AdotB > 0.99 ) {
	   if( q. + th > M_PI*4 )
	      oct++;
	} else if( cosCo2 < -0.99 ){
	   if( q. - th < -M_PI*4 )
	      oct--;
	}
	*/
	// using sin(x+y)+sin(x-y)  expressions replaces multiplications with additions...
	// same sin/cos lookups sin(x),cos(x),sin(y),cos(y)
	//   or sin(x+y),cos(x+y),sin(x-y),cos(x-y)
 // X - Y  ('x' 'm'inus 'y')
	const RCOORD xmy   = ( a[ 3 ] - r[ 3 ] ) / 2;
 // X + Y  ('x' 'p'lus 'y' )
	const RCOORD xpy   = ( a[ 3 ] + r[ 3 ] ) / 2;
	const RCOORD cxmy  = cos( xmy );
	const RCOORD cxpy  = cos( xpy );
	// cos(angle result)
	// const cosCo2 = ( ( 1-AdotB )*cxmy + (1+AdotB)*cxpy )/2;
	// ( 2 cos(x) cos(y) - 2 A sin(x) sin(y) ) / 2
	const RCOORD cosCo2 = ( ( AdotB ) * ( cxpy - cxmy ) + cxmy + cxpy ) / 2;
	//   (1-cos(A))cos(x-y)+(1+cos(A))cos(x+y)
	//    cos(A) (cos(x + y) - cos(x - y)) + cos(x - y) + cos(x + y)
	// octive should have some sort of computation that gets there...s
	// would have to be a small change
/* + oct * ( M_PI * 2 )*/
	const RCOORD ang  = acos( cosCo2 ) * 2;
	if( ang ) {
		const RCOORD sxmy = sin( xmy );
		const RCOORD sxpy = sin( xpy );
		// vector rotation is just...
		// when both are large, cross product is dominant (pi/2)
 // 2 cos(y) sin(x)
		const RCOORD ss1  = sxmy + sxpy;
 // 2 cos(x) sin(y)
		const RCOORD ss2  = sxpy - sxmy;
 // 2 sin(x) sin(y)
		const RCOORD cc1  = cxmy - cxpy;
		// 1/2 (B sin(a/2) cos(b/2) - A sin^2(b/2) + A cos^2(b/2))
		//  the following expression is /2 (has to be normalized anywa[1] keep 1 bit)
		//  and is not normalized with sin of angle/2.
		const RCOORD crsX = ( a[ 1 ] * r[ 2 ] - a[ 2 ] * r[ 1 ] );
		const RCOORD crsY = ( a[ 2 ] * r[ 0 ] - a[ 0 ] * r[ 2 ] );
		const RCOORD crsZ = ( a[ 0 ] * r[ 1 ] - a[ 1 ] * r[ 0 ] );
		const RCOORD Cx   = ( crsX * cc1 + a[ 0 ] * ss1 + r[ 0 ] * ss2 );
		const RCOORD Cy   = ( crsY * cc1 + a[ 1 ] * ss1 + r[ 1 ] * ss2 );
		const RCOORD Cz   = ( crsZ * cc1 + a[ 2 ] * ss1 + r[ 2 ] * ss2 );
		// this is NOT /sin(theta);  it is, but only in some ranges...
		const RCOORD lensq = Cx * Cx + Cy * Cy + Cz * Cz;
		if( lensq > 0.0000000000000001 ) {
 /*( lnQuat.sinNormal ) ? ( 1 / ( 2 * sin( ang / 2 ) ) ) :*/
			const RCOORD Clx = 1 / sqrt(lensq);
			//RCOORD qrn       = Clx; // I'd like to save this to see what the normal actually was
			out[ 3 ]   = ang;
			out[ 0 ]   = Cx * Clx;
			out[ 1 ]   = Cy * Clx;
			out[ 2 ]   = Cz * Clx;
		} else {
			// result angle is 0
			out[ 0 ] = r[ 0 ];
			out[ 1 ] = r[ 1 ];
			out[ 2 ] = r[ 2 ];
			if( AdotB > 0 ) {
				out[ 3 ] = r[ 3 ] + a[3];
			} else {
				out[ 3 ] = r[ 3 ] - a[3];
			}
		}
	}
	return out;
}
PVECTOR4 EXTERNAL_NAME(lq_set4)( PVECTOR4 out, RCOORD x, RCOORD y, RCOORD z, RCOORD angle ) {
	const RCOORD len = sqrt( x * x + y * y + z * z );
	if( len > 0.00000001 ) {
		const RCOORD ilen = 1 / len;
		out[ 0 ]         = x * ilen;
		out[ 1 ]         = y * ilen;
		out[ 2 ]         = z * ilen;
	} else {
		out[ 0 ] = 0;
		out[ 1 ] = 1;
		out[ 2 ] = 0;
	}
	out[ 3 ] = angle;
	return out;
}
PVECTOR4 EXTERNAL_NAME(lq_set3)( PVECTOR4 out, RCOORD x, RCOORD y, RCOORD z ) {
	const RCOORD len = sqrt( x * x + y * y + z * z );
	if( len > 0.00000001 ) {
		const RCOORD ilen = 1 / len;
		out[ 0 ]          = x * ilen;
		out[ 1 ]          = y * ilen;
		out[ 2 ]          = z * ilen;
	} else {
		out[ 0 ] = 0;
		out[ 1 ] = 1;
		out[ 2 ] = 0;
	}
	out[ 3 ] = len;
	return out;
}
static PVECTOR4 alignZero( PVECTOR4 q ) {
	// const fN = 1/Math.sqrt( tz*tz+tx*tx );
	MATRIX b;
	EXTERNAL_NAME( lq_basis )( &b, q );
	const RCOORD ty       = b[ 1 ][ 1 ];
 // 1->-1 (angle from pole around this circle.
	const RCOORD cosTheta = acos( ty );
	const RCOORD txn = -q[ 2 ];
	const RCOORD tzn = q[ 0 ];
     // double angle substituted
	const RCOORD s = sin( cosTheta );
 // double angle substituted
	const RCOORD c = 1 - cos( cosTheta );
	// determinant coordinates
	const RCOORD angle = txn == 1 ? cosTheta : acos( ( ty + 1 ) * ( 1 - txn ) / 2 - 1 );
	// compute the axis
	const RCOORD yz           = s * q[0];
	const RCOORD xz       = ( 2 - c * ( q[0] * q[0] + q[2] * q[2] ) ) * tzn;
	const RCOORD xy = txn == 1 ? ( s * q[0] * tzn + s * q[2] * ( 1 ) ) : ( s * q[0] * tzn + s * q[2] * ( 1 - txn ) );
	// if( txn === 1 ) angle += M_PI*2;
	const RCOORD newlen       = sqrt( yz * yz + xz * xz + xy * xy );
	if( newlen > 0.00000001 ) {
		const RCOORD tmp = 1 / newlen;
		q[0]      = yz * tmp;
		q[1]      = xz * tmp;
		q[2]      = xy * tmp;
	} else {
		q[0] = 0;
		q[1] = 1;
		q[2] = 0;
	}
	q[ 3 ]             = angle;
	return q;
}
PVECTOR4 EXTERNAL_NAME( lq_set_xy )( PVECTOR4 out, RCOORD x, RCOORD y ) {
	out[ 0 ] = x;
	out[ 1 ] = 0;
	out[ 2 ] = y;
	return alignZero( EXTERNAL_NAME( lq_normalize )( out ) );
}
PVECTOR4 EXTERNAL_NAME(lq_normalize)( PVECTOR4 out ) {
	RCOORD len = out[ 0 ] * out[ 0 ] + out[ 1 ] * out[ 1 ] + out[ 2 ] * out[ 2 ];
	if( len > 0.00000001 ) {
		const RCOORD angle = sqrt( len );
		const RCOORD ilen  = 1 / angle;
		out[ 0 ]           = out[ 0 ] * ilen;
		out[ 1 ]           = out[ 1 ] * ilen;
		out[ 2 ]           = out[ 2 ] * ilen;
		out[ 3 ]           = angle;
	} else {
		out[ 0 ] = 0;
		out[ 1 ] = 1;
		out[ 2 ] = 0;
		out[ 3 ] = 0;
	}
	return out;
}
static const RCOORD p2 = 2 * M_PI;
 //            0-1 1-2 2-3 3-4
static
     const RCOORD grid[ 4 ][ 4 ]
 //>0 - 1
     = { { 0, p2, p2, 0 }
 // 1-2
       , { p2, 0, 0, p2 }
 // 2-3
       , { p2, 0, 0, p2 }
 // 3-4
       , { 0, p2, p2, 0 }
};
// it's hard to see this because they're all in the same plane...
// not sure this is really needed, because the twist is just around this
// same axis.
static const RCOORD grid2[ 4 ][ 4 ] = {
 //>0 - 1
     { 0, p2, 0, 0 }
 // 1-2
   , { p2, 0, 0, p2 }
 // 2-3
   , { 0, 0, 0, p2 * 2 }
 // 3-4
   , { 0, 0, 0, p2 * 2 }
};
PVECTOR4 EXTERNAL_NAME( lq_set_latlong )( PVECTOR4 out, RCOORD lat, RCOORD lng ) {
	if( !lat ) {
		out[ 0 ] = 0;
		out[ 2 ] = 0;
 // + twistDelta;
		out[ 1 ] = lng;
		return EXTERNAL_NAME(lq_normalize)( out );
	}
	const int d          = 0;
	const int gridlat    = floor( fabs( lat ) / M_PI );
	const int gridlng    = floor( fabs( lng ) / M_PI );
	const int gridlatoct = gridlat >> 2;
	const int gridlngoct = gridlng >> 2;
	const RCOORD spin
	     = ( ( d ) ? grid : grid2 )[ gridlat % 4 ][ gridlng % 4 ] + ( ( gridlatoct + gridlngoct ) * M_PI * 4 );
 //(!d)?gridn[gridlat%4][gridlng%4]:1;
	const RCOORD latmul = 1;
	const RCOORD x      = sin( lng );
	const RCOORD z      = cos( lng );
	out[ 3 ]            = ( latmul * lat + spin );
	out[ 0 ]            = x;
	out[ 1 ]            = 0;
	out[ 2 ]            = z;
	return out;
}
PVECTOR4 EXTERNAL_NAME(lq_cross)( PVECTOR4 out, PCVECTOR a, PCVECTOR b ) {
	const RCOORD alen         = sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
	const RCOORD blen  = sqrt( b[ 0 ] * b[ 0 ] + b[ 1 ] * b[ 1 ] + b[ 2 ] * b[ 2 ] );
	const RCOORD dot   = (a[0] * b[0] + a[1] * b[1] + a[2] * b[2])/(alen*blen);
 // returns 0 to pi; 0 to 1/2 turn.
	const RCOORD angle = acos( dot );
	const RCOORD norm  = sin( angle );
	const RCOORD crsX  = -( a[1] * b[2] - a[2] * b[1] );
	const RCOORD crsY  = -( a[2] * b[0] - a[0] * b[2] );
	const RCOORD crsZ  = -( a[0] * b[1] - a[1] * b[0] );
	if( norm ) {
		out[3] = angle;
		out[0] = crsX / norm;
		out[1] = crsY / norm;
		out[2] = crsZ / norm;
	} else {
		if( angle > M_PI ) {
			out[ 3 ]  = angle;
			out[ 0 ]  = a[0];
			out[ 1 ]  = a[1];
			out[ 2 ] = a[2];
		} else {
			out[ 3 ]  = angle;
			out[ 0 ]  = a[0];
			out[ 1 ]  = a[1];
			out[ 2 ]  = a[2];
		}
	}
	return out;
}
PVECTOR4 EXTERNAL_NAME( lq_free_look )( PVECTOR4 out, PCVECTOR4 orientation, RCOORD pitch, RCOORD yaw, RCOORD roll ) {
	VECTOR4 rotation;
	const RCOORD len2 = pitch*pitch + yaw*yaw + roll*roll;
	if( len2 < 0.00000000001 ) {
		if( out != orientation ) {
			out[0]=orientation[0];
			out[1]=orientation[1];
			out[2]=orientation[2];
			out[3]=orientation[3];
		}
		return out;
	}
	const RCOORD scalar = sqrt(len2);
	rotation[ 0 ] = pitch / scalar;
	rotation[ 1 ] = yaw   / scalar;
	rotation[ 2 ] = roll  / scalar;
	rotation[ 3 ] = scalar;
	EXTERNAL_NAME(lq_applyRotation)( out, orientation, rotation );
	return out;
}
PVECTOR4 EXTERNAL_NAME( lq_level_look )( PVECTOR4 out, PCVECTOR4 orientation, RCOORD pitch, RCOORD yaw, RCOORD k ) {
	VECTOR4 rotation;
	const RCOORD len2 = pitch*pitch + yaw*yaw;
	if( len2 < 0.00000000001 ) {
		const RCOORD orientation_roll = asin( ( 1 - cos( orientation[ 3 ] ) ) * orientation[ 0 ] * orientation[ 1 ] - sin( orientation[ 3 ] ) * orientation[ 2 ] ) * k;
		const int bigroll = fabs( orientation_roll ) > 0.000000001;
		if( out != orientation || bigroll ) {
			if( bigroll ) {
				rotation[0] = 0;
				rotation[1] = 0;
				rotation[2] = 1;
				rotation[3] = orientation_roll;
				// get inverse-x-axis y coordinate for roll
				//rotation[3] = asin( ( 1 - cos( out[ 3 ] ) ) * out[ 0 ] * out[ 1 ] - sin( out[ 3 ] ) * out[ 2 ] ) * k;
				EXTERNAL_NAME(lq_applyRotation)( out, orientation, rotation );
			} else {
				// not a big roll, and isn't same vector, copy
				out[0]=orientation[0];
				out[1]=orientation[1];
				out[2]=orientation[2];
				out[3]=orientation[3];
			}
		} else if( out != orientation ) {
			out[0]=orientation[0];
			out[1]=orientation[1];
			out[2]=orientation[2];
			out[3]=orientation[3];
		}
		return out;
	}
	const RCOORD scalar = sqrt(len2);
	rotation[ 0 ] = pitch / scalar;
	rotation[ 1 ] = yaw   / scalar;
	rotation[ 2 ] = 0;
	rotation[ 3 ] = scalar;
	EXTERNAL_NAME(lq_applyRotation)( out, orientation, rotation );
	rotation[0] = 0;
	rotation[1] = 0;
	rotation[2] = 1;
	// get inverse-x-axis y coordinate for roll
	rotation[3] = asin( ( 1 - cos( out[ 3 ] ) ) * out[ 0 ] * out[ 1 ] - sin( out[ 3 ] ) * out[ 2 ] ) * k;
	EXTERNAL_NAME(lq_applyRotation)( out, out, rotation );
	return out;
}
#undef l
VECTOR_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
//   DEBUG_SYMBOLS
// had some problems with OpenSpace opening a shared region under win98
// Apparently if a create happens with a size of 0, the name of the region
// becomes unusable, until a reboot happens.
//#define DEBUG_OPEN_SPACE
// this variable controls whether allocate/release is logged.
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#define NO_UNICODE_C
//#define USE_SIMPLE_LOCK_ON_OPEN
#ifdef __LINUX__
#include <sys/mman.h>
#endif
#ifdef _MSC_VER
#ifndef UNDER_CE
#endif
#endif
#define DEFINE_MEMORY_STRUCT
/* A header for doing .NET /CLR compatiblity changes. Things
   like fopen needing to be _fopen_s and junk.               */
#ifndef FILE_DOT_NET_COMPAT
/* Header multiple inclusion protection symbol. */
#define FILE_DOT_NET_COMPAT
#ifdef __cplusplus_cli
#define Fopen( result, name, opts ) { char *tmp1 = CStrDup( name ); char *tmp2 = CStrDup( opts ); result = fopen( tmp1, tmp2 ); Deallocate( char *, tmp1 ); Deallocate( char *, tmp2 ); }
#if asdfasdlfkajsdflkj
#define fputs( msg, file ) { char *tmp = CStrDup( msg ); fputs( tmp, file ); Release( tmp ); }
#define unlink( name ) { char *tmp = CStrDup( name ); unlink( tmp ); Release( tmp ); }
#define rename( name1, name2 ) { char *tmp1 = CStrDup( name1 ); char *tmp2 = CStrDup( name2 ); rename( tmp1, tmp2 ); Release( tmp1 ); Release( tmp2 ); }
#define fprintf Fprintf
#endif
//int Fprintf( FILE *file, CTEXTSTR fmt, ... );
/*
using namespace Win32;
#define CreateEvent(a,b,c,d) Win32::Kernel::CreateEvent((SECURITY_ATTRIBUTES)a,b,c,d)
#define OpenEvent(a,b,c)     Win32::Kernel::OpenEvent(a,b,c)
#define Sleep(a)             Win32::Kernel::Sleep(a)
#define GetTickCount()       Win32::Kernel::GetTickCount()
#define GetCurrentProcessId() Win32::Kernel::GetCurrentProcessId()
#define GetCurrentThreadId()  Win32::Kernel::GetCurrentThreadId()
#define GetLastError()  Win32::Kernel::GetLastError()
#define SetEvent(a) Win32::Kernel::SetEvent(a)
#define ResetEvent(a) Win32::Kernel::ResetEvent(a)
#define CloseHandle(a) Win32::Kernel::CloseHandle(a)
#define WaitForSingleObject(a,b) Win32::Kernel::WaitForSingleObject(a,b)
#define PeekMessage(a,b,c,d,e)  Win32::User::PeekMessage(a,b,c,d,e)
#define DispatchMessage(a)   Win32::User::DispatchMessage(a)
#define GetModuleFileName(a,b) Win32::Kernel::GetModuleFileName(a,b)
*/
#if 0
typedef struct MyFile MYFILE;
MYFILE *Fopen( CTEXTSTR filename, CTEXTSTR mode );
int Fread( POINTER data, int count, int size, MYFILE *file );
int Fwrite( POINTER data, int count, int size, MYFILE *file );
int Fclose( MYFILE *file );
int Fseek( MYFILE *file, int64_t pos, int whence );
uint64_t Ftell( MYFILE *file );
MYFILE *Fdopen( int fd, CTEXTSTR mode );
int Ferror( MYFILE *file );
int Fflush( MYFILE *file );
int Rewind( MYFILE *file );
int Fputc( int c, MYFILE *file );
int Fgets( TEXTSTR buf, int buflen, MYFILE *file );
int Fputs( CTEXTSTR but, MYFILE *file );
int Unlink( CTEXTSTR filename );
int Rename( CTEXTSTR from, CTEXTSTR to );
#define rename Rename
#define unlink Unlink
#define FILE MYFILE
#define fopen Fopen
#define fseek Fseek
#define fclose Fclose
#define fprintf Fprintf
#define ftell Ftell
#define fread Fread
#define fwrite Fwrite
//#define fdopen Fdopen
#define ferror Ferror
#define fflush Fflush
#define rewind Rewind
#define fputc Fputc
#define fgets Fgets
#define fputs Fputs
#endif
#else
/* A macro which can be translated into microsoft so-called safe
   methods.                                                      */
#define Fopen( result, name, opts ) result = sack_fopen( 0, name, opts )
//#define MYFILE  FILE
//#define Fopen   fopen
//#define Fread   fread
//#define Fwrite  fread
//#define Fclose  fclose
//#define Fprintf fprintf
//#define Fseek   fseek
//#define Ftell   ftell
#endif
#endif
// end with a newline please.
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
#ifdef __cplusplus
	}
}
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
struct malloc_chunk_tag
{
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
	PREFIX_PACKED struct {
   // if 0 - block is free
		uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
		uint16_t dwPad;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t to_chunk_start;
	} PACKED info;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
};
struct heap_chunk_tag
{
 // *next, **me; &next is also &this block.
	DeclareLink( struct heap_chunk_tag );
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
   // needed for release to find free linked list head
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag *pRoot;
	PREFIX_PACKED struct {
            // if 0 - block is free
		uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
		uint16_t dwPad;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t alignment;
      // to_chunk_start is computed from byData offset by alignment minus a uin16_t.
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t to_chunk_start;
	} PACKED info;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
};
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	}
}
#endif
#endif
#endif
#include <ctype.h>
#if defined __ANDROID__
#include <linux/ashmem.h>
#endif
#ifdef _MSC_VER
//>= 900
#include <crtdbg.h>
#include <new.h>
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
#endif
#ifdef __64__
#define CLEAR_MEMORY_TAG 0xDEADBEEFDEADBEEFULL
#define FREE_MEMORY_TAG 0xFACEBEADFACEBEADULL
#define LEAD_PROTECT_TAG 0xbabecafebabecafeULL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafebeefcafeULL
#else
#define CLEAR_MEMORY_TAG 0xDEADBEEFUL
#define FREE_MEMORY_TAG 0xFACEBEADUL
#define LEAD_PROTECT_TAG 0xbabecafeUL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafeUL
#endif
#ifdef g
#  undef g
#endif
#ifdef __64__
#  define makeULong(n) (~(n##ULL))
#else
#  define makeULong(n) (~(n##UL))
#endif
static uintptr_t masks[33] = { makeULong(0), makeULong(0), makeULong(1), 0
  // 4
                  , makeULong(3), 0, 0, 0
   // 8
	              , makeULong(7), 0, 0, 0, 0, 0, 0, 0
 // 16
	              , makeULong(15), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  // 32
	              , makeULong(31) };
#define BASE_MEMORY (POINTER)0x80000000
// golly allocating a WHOLE DOS computer to ourselves? how RUDE
#define SYSTEM_CAPACITY  g.dwSystemCapacity
#define MALLOC_CHUNK_SIZE(pData) ( (pData)?( ( ( (uint16_t*)(pData))[-1] ) + offsetof( MALLOC_CHUNK, byData ) ):0 )
//#define CHUNK_SIZE(pData) ( ( (pData)?( (uint16_t*)(pData))[-1]:0 ) +offsetof( CHUNK, byData ) ) )
#define CHUNK_SIZE ( offsetof( CHUNK, byData ) )
#define MEM_SIZE  ( offsetof( MEM, pRoot ) )
// using lower level syslog bypasses some allocation requirements...
//#undef lprintf
//#undef _lprintf
#ifndef NO_LOGGING
#  ifdef _DEBUG
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, FILELINE_FILELINEFMT f,_pFile,_nLine,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); } }
#    define ll__lprintf( a ) {const TEXTCHAR *_pFile = pFile; int _nLine = nLine; _lprintf2
#  else
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); } }
#    define ll__lprintf( a ) { _lprintf2
#  endif
#else
#  define lprintf( f,... )
#endif
// last entry in space tracking array will ALWAYS be
// another space tracking array (if used)
// (32 bytes)
typedef struct space_tracking_structure {
	PMEM pMem;
#ifdef _WIN32
	HANDLE  hFile;
	HANDLE  hMem;
#else
	struct {
		uint32_t bTemporary : 1;
	} flags;
	int hFile;
#endif
	uintptr_t dwSmallSize;
	DeclareLink( struct space_tracking_structure );
} SPACE, *PSPACE;
typedef struct space_pool_structure {
	DeclareLink( struct space_pool_structure );
	SPACE spaces[(4096 - sizeof( struct space_pool_structure * )
		- sizeof( struct space_pool_structure ** ))
		/ sizeof( SPACE )];
} SPACEPOOL, *PSPACEPOOL;
#define MAX_PER_BLOCK (4096 - sizeof( struct space_pool_structure *)	 - sizeof( struct space_pool_structure **) )	  / sizeof( SPACE )
#ifdef _WIN32
//(0x10000 * 0x1000) //256 megs?
#define FILE_GRAN g.si.dwAllocationGranularity
//static SYSTEM_INFO const zero_si = {{{0}}}; /* C++ is complicating how to inizialize this, {} used to work, now {0} is wanted, which then wants {{{0}}}... */
#else
#define FILE_GRAN g.pagesize
#endif
struct global_memory_tag {
 // basic OS block grabbed for allocation
	size_t dwSystemCapacity;
//#ifdef _DEBUG
// may define one or the other of these but NOT both
	int bDisableDebug;
	int bDisableAutoCheck;
	int bLogCritical;
	//#endif
	size_t nMinAllocateSize;
	int pagesize;
	int bLogAllocate;
	int bLogAllocateWithHold;
  // this option couldn't work; different block tracking methods are incompatible
	LOGICAL bCustomAllocer;
	LOGICAL bInit;
	LOGICAL allowLogging;
	PSPACEPOOL pSpacePool;
#ifdef _WIN32
	SYSTEM_INFO si;
#endif
 // don't add our tracking to ourselves...
	int InAdding;
 // set if anybody starts to DIG.
	uint32_t bMemInstanced;
	LOGICAL deadstart_finished;
	PMEM pMemInstance;
	uint32_t last_set_allocate;
	int nLogAllocateClears;
	int bDefaultLogAllocate;
};
#ifdef __STATIC__
static struct global_memory_tag global_memory_data = { 0x10000 * 0x08
#  ifdef _DEBUG
                                                     , 0, 0
#else
                                                     , 1, 1
#  endif
													, 0
													, 0
													, 0
													, 0
													, 0
																	  , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
#ifdef __cplusplus
																	  , {{0}}
#else
																	  , {}
#endif
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
#  define g (global_memory_data)
#else
#  ifdef _DEBUG
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 0
#    ifdef DEBUG_CRITICAL_SECTIONS
															, 1
#    else
															, 0
#    endif
															, 0
															, 0
															, 0
															, 0
															 , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
#ifdef __cplusplus
																	  , {{0}}
#else
																	  , {}
#endif
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  else
/* disable debug*/
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
 /* log crit */
 /* min alloc size */
															, 0, 0, 0
															, 0
															, 0
  // custom allocer
															, USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
#ifdef __cplusplus
																	  , {{0}}
#else
																	  , {}
#endif
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  endif
#define g global_memory_data
#endif
#ifndef NO_LOGGING
#  define ODSEx(s,pFile,nLine) SystemLogFL( s DBG_RELAY )
//#define ODSEx(s,pFile,nLine) SystemLog( s )
#  define ODS(s)  SystemLogFL(s FILELINE_SRC )
#else
#  define ODSEx(s,file,line)
#  define ODS(s)
#endif
#define MAGIC_SIZE sizeof( void* )
#define PRI64_COMPAT_SUFFIX L
#ifndef __PRI64_PREFIX
#  ifdef _MSC_VER
#    define __PRI64_PREFIX "ll"
#  endif
#endif
#ifdef __64__
#  define BLOCK_TAG(pc)  (*(uint64_t*)((pc)->byData + (pc)->dwSize - (pc)->info.dwPad ))
// so when we look at memory this stamp is 0123456789ABCDEF
#  define TAG_FORMAT_MODIFIER __PRI64_PREFIX
#  define BLOCK_TAG_ID pastejunk( 0xefcdab8967452301, PRI64_COMPAT_SUFFIX )
#else
#  define BLOCK_TAG(pc)  (*(uint32_t*)((pc)->byData + (pc)->dwSize - (pc)->info.dwPad ))
// so when we look at memory this stamp is 12345678
#  define TAG_FORMAT_MODIFIER __PRI32_PREFIX
#  define BLOCK_TAG_ID 0x78563412L
#endif
// file/line info are at the very end of the physical block...
// block_tag is at the start of the padding...
#define BLOCK_FILE(pc) (*(CTEXTSTR*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE*2))
#define BLOCK_LINE(pc) (*(int*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE))
#ifndef _WIN32
#endif
PRIORITY_PRELOAD( Deadstart_finished_enough, GLOBAL_INIT_PRELOAD_PRIORITY + 1 )
{
	g.deadstart_finished = 1;
	//g.bLogAllocate = 1;
}
PRIORITY_PRELOAD( InitGlobal, DEFAULT_PRELOAD_PRIORITY )
{
#ifndef __NO_OPTIONS__
	g.bLogCritical = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Log critical sections", g.bLogCritical, TRUE );
	g.bDefaultLogAllocate = g.bLogAllocate = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Enable Logging", g.bLogAllocate, TRUE );
	if( g.bLogAllocate )
		ll_lprintf( "Memory allocate logging enabled." );
	g.bLogAllocateWithHold = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Enable Logging Holds", g.bLogAllocateWithHold, TRUE );
	//USE_CUSTOM_ALLOCER = SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Custom Allocator", USE_CUSTOM_ALLOCER, TRUE );
	g.bDisableDebug = g.bDisableDebug || SACK_GetProfileIntEx( GetProgramName(), "SACK/Memory Library/Disable Debug", !USE_DEBUG_LOGGING, TRUE );
#else
	//g.bLogAllocate = 1;
#endif
	g.nMinAllocateSize = 32;
	g.allowLogging = 1;
}
#if __GNUC__
#pragma GCC warning "C Preprocessor got here!"
#  pragma message( "GNUC COMPILER" )
#  ifndef __ATOMIC_RELAXED
#    define __ATOMIC_RELAXED 0
#  endif
#  ifndef __GNUC_VERSION
#    define __GNUC_VERSION ( __GNUC__ * 10000 ) + ( __GNUC_MINOR__ * 100 )
#  endif
#  if  ( __GNUC_VERSION >= 40800 || __clang_major__ >= 18 ) || defined(__MAC__) || defined( __EMSCRIPTEN__ )
#    pragma GCC warning "gcc is going to use __atomic_exchange_n"
#    pragma message( "gcc is going to use __atomic_exchange_n")
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
///  for some reason __GNUC_VERSION doesn't exist from android ?
#  elif defined __ARM__ || defined __ANDROID__
#    pragma GCC warning "gcc is going to use __atomic_exchange_n(2)"
#    pragma message( "gcc is going to use __atomic_exchange_n")
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
#  else
#    pragma GCC warning "gcc is a version without __atomic_exchange_n"
#    pragma message( "gcc is a version without __atomic_exchange_n" )
inline uint32_t DoXchg( volatile uint32_t* p, uint32_t val ) { __asm__( "lock xchg (%2),%0" :"=a"(val) : "0"(val), "c"(p) ); return val; }
inline uint64_t DoXchg64( volatile int64_t* p, uint64_t val ) { __asm__( "lock xchg (%2),%0" :"=a"(val) : "0"(val), "c"(p) ); return val; }
#    define XCHG( p,val) ( ( sizeof( val ) > sizeof( uint32_t ) )?DoXchg64( (volatile int64_t*)p, (uint64_t)val ):DoXchg( (volatile uint32_t*)p, (uint32_t)val ) )
#  endif
//#  endif
#else
#  define XCHG(p,val)  LockedExchange( p, val )
#endif
//-------------------------------------------------------------------------
#if !defined( HAS_ASSEMBLY ) || defined( __CYGWIN__ )
uint32_t  LockedExchange( volatile uint32_t* p, uint32_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if ( defined( _WIN32 ) || defined( WIN32 ) ) && !defined( __ANDROID__ )
#  if !defined(_MSC_VER)
	return InterlockedExchange( (volatile LONG *)p, val );
#  else
	//return _InterlockedExchange_HLEAcquire( (volatile long*)p, val );
	return _InterlockedExchange( (volatile long*)p, val );
	// windows wants this as a LONG not ULONG
	//return InterlockedExchange( (volatile LONG *)p, val );
#  endif
#else
 //&& !( defined __ARM__ || defined __ANDROID__ )
#  if ( defined( __LINUX__ ) )
	return XCHG( p, val );
	//   return __atomic_exchange_n(p,val,__ATOMIC_RELAXED);
#  else
	{
		#warning compiling C fallback locked exchange.This is NOT atomic, and needs to be
		// swp is the instruction....
		uint32_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
uint32_t LockedIncrement( volatile uint32_t* p ) {
#ifdef _WIN32
	return InterlockedIncrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_add_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint32_t LockedDecrement( volatile uint32_t* p ) {
#ifdef _WIN32
	return InterlockedDecrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_sub_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint64_t  LockedExchange64( volatile uint64_t* p, uint64_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if defined WIN32 && !defined __ANDROID__
#ifdef _MSC_VER
#ifdef __64__
	uint64_t prior = (uint64_t)InterlockedExchange64( (volatile __int64 *)p, (int64_t)val );
#else
	// because the value is a LONG (signed) it has to be made unsigned of the same lenght (ULONG) then extended (uint64_t).
	// otherwise the sign extension was a bug.
	uint64_t prior = (uint64_t)(ULONG)InterlockedExchange( (DWORD*)p, (DWORD)val ) | ((uint64_t)InterlockedExchange( ((DWORD*)p) + 1, (DWORD)(val >> 32) ) << 32);
#endif
#else
	uint64_t prior = InterlockedExchange( (volatile LONG*)p, (int32_t)val ) | InterlockedExchange( ((volatile LONG*)p) + 1, (uint32_t)(val >> 32) );
#endif
	return prior;
#else
#  if defined __GNUC__
#     if !defined( __ANDROID__ ) || ( ANDROID_NDK_TARGET_PLATFORM > 16 )
//__atomic_exchange_n(p,val,__ATOMIC_RELAXED);
	return XCHG( p, val );
#else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#endif
#  else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
#endif
//-------------------------------------------------------------------------
#ifdef DEBUG_CRITICAL_SECTIONS
#if 0
static void DumpSection( PCRITICALSECTION pcs )
{
	ll_lprintf( "Critical Section....." );
	ll_lprintf( "------------------------------" );
	ll_lprintf( "Update: %08x", pcs->dwUpdating );
	ll_lprintf( "Current Process: %16" _64fx, pcs->dwThreadID );
	ll_lprintf( "Next Process:    %16" _64fx, pcs->dwThreadWaiting );
	ll_lprintf( "Last update: %s(%d)", pcs->pFile ? pcs->pFile : "unknown", pcs->nLine );
}
#endif
#endif
#ifdef __cplusplus
 // namespace memory {
}
 // begin timer namespace
	namespace timers {
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
		uint32_t  CriticalSecOwners( PCRITICALSECTION pcs )
		{
			return pcs->dwLocks;
		}
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
		int32_t  EnterCriticalSecNoWaitEx( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS )
		{
			THREAD_ID dwCurProc = GetThisThreadID();
			// need to aquire lock on section...
			// otherwise our old mechanism allowed an enter in another thread
			// to falsely identify the section as its own while the real owner
			// tried to exit...
			if( XCHG( &pcs->dwUpdating, 1 ) ) return -1;
			if( !pcs->dwLocks ) {
				// section is unowned...
				if( pcs->dwThreadWaiting ) {
					// someone was waiting for it...
					if( pcs->dwThreadWaiting != dwCurProc ) {
						if( prior && (*prior ) ) {
							// prior is set, so someone has set their prior to me....
							pcs->dwUpdating = 0;
							return 0;
						}
					}
 //  waiting is me
					else {
						if( prior && (*prior) ) {
							if( (*prior) == 1 ) pcs->dwThreadWaiting = 0;
							else pcs->dwThreadWaiting = (*prior);
							(*prior) = 0;
						}
						else
							pcs->dwThreadWaiting = 0;
					}
				}
				else {
					if( prior && *prior ) {
						// shouldn't happen, if there's no waiter set, then there shouldn't be a prior.
						if( *prior != 1 )
							DebugBreak();
					}
					//ll_lprintf( "Claimed critical section." );
				}
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 11;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
 // claim the section and return success
				pcs->dwThreadID = dwCurProc;
				pcs->dwLocks = 1;
				pcs->dwUpdating = 0;
				return 1;
			}
			else if( dwCurProc == pcs->dwThreadID )
			{
				// otherwise 1) I won the thread already... (threadID == me )
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 11;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				pcs->dwLocks++;
				pcs->dwUpdating = 0;
				return 1;
			}
			// if the prior is wanted to be saved...
			if( prior )
			{
				if( *prior )
				{
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( !pcs->dwThreadWaiting ) {
							ll_lprintf( "@@@ Someone stole the critical section that we were wiating on before we reentered. fail. %" _64fx " %" _64fx " %" _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
							DebugBreak();
							// go back to sleep again.
							pcs->dwThreadWaiting = dwCurProc;
						}
						else {
							if( (*prior) == pcs->dwThreadWaiting ) {
								ll_lprintf( "prior is same as thread waiting (normal?!) %" _64fx " %" _64fx, pcs->dwThreadWaiting, *prior );
								DebugBreak();
								(*prior) = 0;
							}
						}
						// assume that someone else kept our waiting ID...
						// cause we're not the one waiting, and we have someone elses ID..
						// we are awake out of order..
						pcs->dwUpdating = 0;
						return 0;
					}
				}
				else if( pcs->dwThreadWaiting != dwCurProc )
				{
					if( pcs->dwThreadWaiting ) *prior = pcs->dwThreadWaiting;
					else *prior = 1;
					pcs->dwThreadWaiting = dwCurProc;
				}
			}
			// else no prior... so don't set the dwthreadwaiting...
			pcs->dwUpdating = 0;
			return 0;
		}
#endif
		//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
		static LOGICAL LeaveCriticalSecNoWakeEx( PCRITICALSECTION pcs DBG_PASS )
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSecNoWakeEx( pcs DBG_SRC )
		{
			THREAD_ID dwCurProc;
			while( XCHG( &pcs->dwUpdating, 1 ) )
				Relinquish();
			dwCurProc = GetThisThreadID();
			if( !pcs->dwLocks )
			{
				ll_lprintf( DBG_FILELINEFMT "Leaving a blank critical section (excessive leaves?)" DBG_RELAY );
				DebugBreak();
				pcs->dwUpdating = 0;
				return FALSE;
			}
			if( pcs->dwThreadID == dwCurProc )
			{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 10;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				pcs->dwLocks--;
				if( !pcs->dwLocks )
				{
					pcs->dwThreadID = 0;
					if( pcs->dwThreadWaiting )
					{
						pcs->dwUpdating = 0;
 // allow whoever was waiting to go now...
						Relinquish();
						return TRUE;
					}
				}
			}
			else
			{
				lprintf( "Sorry - you can't leave a section you don't own...(shouldn't have been past your Enter anyway?)" );
				DebugBreak();
				pcs->dwUpdating = 0;
				return FALSE;
			}
			// allow other locking threads immediate access to section
			// but I know when that happens - since the waiting process
			// will flag - SECTION_LOGGED_WAIT
			pcs->dwUpdating = 0;
			return TRUE;
		}
#else
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSection(pcs)
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
		void  InitializeCriticalSec( PCRITICALSECTION pcs )
		{
			memset( pcs, 0, sizeof( CRITICALSECTION ) );
			return;
		}
#endif
#ifdef __cplusplus
 // namespace timers {
	}
 // resume memory namespace
	namespace memory {
#endif
//-------------------------------------------------------------------------
#ifdef _DEBUG
 // last values from getmemstats...
static uint32_t dwBlocks;
static uint32_t dwFreeBlocks;
static uint32_t dwAllocated;
static uint32_t dwFree;
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
static void DoCloseSpace( PSPACE ps, int bFinal );
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
LOGICAL OpenRootMemory()
{
	uintptr_t size = sizeof( SPACEPOOL );
	uint32_t created;
	char spacename[32];
	if( g.pSpacePool != NULL )
	{
		// if local already has something, just return.
		return FALSE;
	}
#ifdef DEBUG_GLOBAL_REGISTRATION
	ll_lprintf( "Opening space..." );
#endif
#ifdef WIN32
	snprintf( spacename, sizeof( spacename ), "memory:%" _32fx, GetCurrentProcessId() );
#else
	snprintf( spacename, sizeof( spacename ), "memory:%08X", getpid() );
#endif
	// hmm application only shared space?
	// how do I get that to happen?
#ifdef __STATIC_GLOBALS__
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( NULL, NULL, 0, &size, &created );
#else
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( spacename, NULL, 0, &size, &created );
#endif
	// I myself must have a global space, which is kept sepearte from named spaces
	// but then... blah
	return created;
}
#endif
// hmm this runs
PRIORITY_ATEXIT(ReleaseAllMemory,ATEXIT_PRIORITY_SHAREMEM)
{
#if defined( __SKIP_RELEASE_OPEN_SPACES__ ) || defined( __NO_MMAP__ )
	// actually, under linux, it releases /tmp/.shared files.
	//ll_lprintf( "No super significant reason to release all memory blocks?" );
	//ll_lprintf( "Short circuit on memory shutdown." );
	return;
#else
	// need to try and close /tmp/.shared region files...  so we only close
	// temporary spaces
	PSPACEPOOL psp;
	PSPACE ps;
	while( ( psp = g.pSpacePool ) )
	{
		int i;
		// I didn't allocate at the root; someone else is responsible.
		if( psp->me != &g.pSpacePool )
			break;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			ps = psp->spaces + i;
			if( ps->pMem )
			{
				/*
				* if we do this, then logging will attempt to possibly use memory which was allocated from this?
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					ll_lprintf( "Space: %p mem: %p-%p", ps, ps->pMem, (uint8_t*)ps->pMem + ps->dwSmallSize );
					ll_lprintf( "Closing tracked space..." );
				}
#endif
*/
#ifndef _WIN32
				if( ps->flags.bTemporary )
#endif
					DoCloseSpace( ps, TRUE );
			}
		}
		if( !(*psp->me) )
			break;
		if( ( (*psp->me) = psp->next ) )
			psp->next->me = psp->me;
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		//ll_lprintf( "unmaping space tracking structure..." );
		munmap( ps, MAX_PER_BLOCK * sizeof( SPACE ) );
		//close( (int)ps->pMem );
		//if( ps->hFile >= 0 )
		//	close( ps->hFile );
#endif
	}
#endif
	g.bInit = FALSE;
}
//------------------------------------------------------------------------------------------------------
void InitSharedMemory( void )
{
#ifndef __NO_MMAP__
	if( !g.bInit )
	{
#ifdef _WIN32
		GetSystemInfo( &g.si );
#else
		g.pagesize = sysconf( _SC_PAGESIZE );
#endif
	// this would be really slick to do
	// especially in the case where files have been used
	// to back storage...
	// so please do make releaseallmemory smarter and dlea
	// only with closing those regions which have a file
		// backing, espcecially those that are temporary chickens.
		//atexit( ReleaseAllMemory );
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( "CHUNK: %d  MEM:%d", CHUNK_SIZE(0), MEM_SIZE );
#endif
  // onload was definatly a zero.
		g.bInit = TRUE;
		{
			if( OpenRootMemory() )
			{
				MemSet( g.pSpacePool, 0, sizeof( SPACEPOOL ) );
				g.pSpacePool->me = &g.pSpacePool;
#ifdef VERBOSE_LOGGING
				if( !g.bDisableDebug )
					Log1( "Allocated Space pool %lu", dwSize );
#endif
			}
		}
	}
	else
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			ODS( "already initialized?" );
#endif
	}
#endif
}
//------------------------------------------------------------------------------------------------------
// private
#ifndef __NO_MMAP__
static PSPACE AddSpace( PSPACE pAddAfter
#if defined( WIN32 ) || defined( __CYGWIN__ )
							, HANDLE hFile
							, HANDLE hMem
#else
							, int hFile
							, int hMem
#endif
							, POINTER pMem, uintptr_t dwSize, int bLink )
{
	PSPACEPOOL psp;
	PSPACEPOOL _psp = NULL;
	PSPACE ps;
	int i;
	if( !g.pSpacePool || g.InAdding )
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( "No space pool(%p) or InAdding(%d)", g.pSpacePool, g.InAdding );
#endif
		return NULL;
	}
	g.InAdding = 1;
	//_ps = NULL;
	psp = g.pSpacePool;
Retry:
	do {
		ps = psp->spaces;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			if( !ps[i].pMem )
			{
				ps += i;
				break;
			}
		}
		if( i == (MAX_PER_BLOCK-1) )
		{
			_psp = psp;
			psp = psp->next;
		}
		else
			break;
	} while( psp );
	if( !psp )
	{
		//DebugBreak(); // examine conditions for allocating new space block...
		dwSize = sizeof( SPACEPOOL );
		if( _psp )
		{
			psp = _psp->next = (PSPACEPOOL)OpenSpace( NULL, NULL, &dwSize );
			MemSet( psp, 0, dwSize );
			psp->me = &_psp->next;
		}
		goto Retry;
	}
	//Log7( "Managing space (s)%p (pm)%p (hf)%08" _32fx " (hm)%08" _32fx " (sz)%" _32f " %08" _32fx "-%08" _32fx ""
	//				, ps, pMem, (uint32_t)hFile, (uint32_t)hMem, dwSize
	//				, (uint32_t)pMem, ((uint32_t)pMem + dwSize)
	//				);
	ps->pMem = (PMEM)pMem;
	// okay yes I made this line ugly.
	ps->hFile =
#ifdef _WIN32
					(HANDLE)
#endif
								hFile;
#ifdef _WIN32
	ps->hMem = hMem;
#endif
	ps->dwSmallSize = dwSize;
	/*
	if( bLink )
	{
		while( AddAfter && AddAfter->next )
			AddAfter = AddAfter->next;
		//Log2( "Linked into space...%p after %p ", ps, AddAfter );
		if( AddAfter )
		{
			ps->me = &AddAfter->next;
			AddAfter->next = ps;
		}
		  ps->next = NULL;
	}
	*/
	g.InAdding = 0;
	return ps;
}
//------------------------------------------------------------------------------------------------------
PSPACE FindSpace( POINTER pMem )
{
	PSPACEPOOL psp;
	INDEX idx;
 // if 0; the block of spaces may be empty and matches 0.
	if( pMem )
		for( psp = g.pSpacePool;psp; psp = psp->next)
			for( idx = 0; idx < MAX_PER_BLOCK; idx++ ) {
				//if( g.bLogAllocate)
				//	lprintf( "Finding space %p %p", pMem, psp->spaces[idx].pMem);
				if( psp->spaces[idx].pMem == pMem )
					return psp->spaces + idx;
			}
	//if( g.bLogAllocate)
	//	lprintf( "Failed to find space %p", pMem );
	return NULL;
}
//------------------------------------------------------------------------------------------------------
static void DoCloseSpace( PSPACE ps, int bFinal )
{
	if( ps )
	{
		//Log( "Closing a space..." );
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		munmap( ps->pMem, ps->dwSmallSize );
		if( (ps->hFile >= 0) )
		{
			if( ps->flags.bTemporary && bFinal )
			{
				char file[256];
				char fdname[64];
				snprintf( fdname, sizeof(fdname), "/proc/self/fd/%d", (int)ps->hFile );
				file[readlink( fdname, file, sizeof( file ) )] = 0;
				remove( file );
			}
			close( (int)ps->hFile );
		}
#endif
		MemSet( ps, 0, sizeof( SPACE ) );
	}
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpaceEx ( POINTER pMem, int bFinal )
{
	if( pMem )
		DoCloseSpace( FindSpace( pMem ), bFinal );
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpace ( POINTER pMem )
{
	if( pMem )
		DoCloseSpace( FindSpace( pMem ), TRUE );
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  GetSpaceSize ( POINTER pMem )
{
	PSPACE ps;
	ps = FindSpace( pMem );
	if( ps )
		return ps->dwSmallSize;
	return 0;
}
#endif
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
uintptr_t GetFileSize( int fd )
{
	uintptr_t len = lseek( fd, 0, SEEK_END );
	lseek( fd, 0, SEEK_SET );
	return len;
}
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
 POINTER  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize, uint32_t* bCreated )
{
	POINTER pMem = NULL;
#ifdef USE_SIMPLE_LOCK_ON_OPEN
	static uint32_t bOpening;
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	static CRITICALSECTION cs;
	static int first = 1;
#endif
	int readonly = FALSE;
	if( !dwSize ) return NULL;
	if( !g.bInit )
	{
		//ODS( "Doing Init" );
		InitSharedMemory();
	}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		if( first )
		{
			InitializeCriticalSection( &cs );
			first = 0;
		}
		while( !EnterCriticalSecNoWait( &cs, NULL ) )
			Relinquish();
	}
#else
	while( XCHG( &bOpening, 1 ) )
		Relinquish();
#endif
	{
#ifdef __LINUX__
		char *filename = NULL;
		int fd = -1;
		int bTemp = FALSE;
		int exists = FALSE;
		if( !pWhat && !pWhere)
		{
#ifndef MAP_ANONYMOUS
#define MAP_ANONYMOUS 0x20
#endif
			pMem = mmap( 0, *dwSize
						 , PROT_READ|PROT_WRITE
						 , MAP_SHARED|MAP_ANONYMOUS
						 ,
#ifdef __QNX__
  // QNX Note; NOFD = -1
							NOFD
 // other systems were quite happy to have a 0 here for the handle.
#else
							0
#endif
						  , 0 );
 // anonymous spaces are always created
			if( bCreated) bCreated[0] = TRUE;
			if( pMem == (POINTER)-1 )
			{
				if( errno == ENODEV ) {
					pMem = malloc( *dwSize );
				} else {
				ll_lprintf( "Something bad about this region sized %" _PTRSZVALfs "(%d)", *dwSize, errno );
				DebugBreak();
				}
			}
			if( pMem != (POINTER)-1 )
			{
				//ll_lprintf( "Clearing anonymous mmap %p %" _size_f "", pMem, *dwSize );
				MemSet( pMem, 0, *dwSize );
			}
		}
 // name doesn't matter, same file cannot be called another name
		else if( pWhere )
		{
			filename = (char*)pWhere;
		 }
		else if( pWhat )
		{
#ifndef __STATIC_GLOBALS__
			int len;
		         char tmpbuf[256];
#ifdef __ANDROID__
			//if( !IsPath( "./tmp" ) )
			//	if( !MakePath( "./tmp" ) )
			//		ll_lprintf( "Failed to create a temporary space" );
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "./tmp.shared.%s", pWhat );
#else
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "/tmp/.shared.%s", pWhat );
#endif
			bTemp = TRUE;
#endif
		}
		//ll_lprintf( "Open Space: %s", filename?filename:"anonymous" );
		if( !pMem && filename )
		{
#ifdef __ANDROID__
			//fd = ashmem_create_region( filename , size );
			if( pWhat )
			{
				fd = open(filename, O_RDWR);
				if (fd < 0 )
				{
					int ret;
					if( !(*dwSize ) )
					{
						ll_lprintf( "Region didn't exist... and no size... return" );
						return NULL;
					}
#   ifdef DEBUG_SHARED_REGION_CREATE
					ll_lprintf( "Shared region didn't already exist...: %s", filename );
#   endif
					fd = open("/dev/ashmem", O_RDWR);
					if( fd < 0 )
					{
						ll_lprintf( "Failed to open core device..." );
						return NULL;
					}
					if( bCreated )
						(*bCreated) = 1;
 // skip 11 for the "/dev/ashmem/"
					ret = ioctl(fd, ASHMEM_SET_NAME, filename + 12 );
					if (ret < 0)
					{
						ll_lprintf( "Failed to set the name of ashmem region: %s", filename + 12 );
						//							goto error;
					}
					ret = ioctl(fd, ASHMEM_SET_SIZE, (*dwSize) );
					if (ret < 0)
					{
						ll_lprintf( "Failed to set IOCTL size to %d", (*dwSize) );
						//goto error;
					}
					/*
					 {
						// unpin; pages will be pined to start (I think)
						struct ashmem_pin pin = {
							.offset = 0,
							.len    = (*dwSize)
						};
						ret = ioctl(fd, ASHMEM_UNPIN, &pin);
					}
					*/
				}
				else
				{
					if( bCreated )
						(*bCreated) = 1;
				}
			}
			else
#endif
			{
				mode_t prior;
				if( bCreated )
					(*bCreated) = 1;
				prior = umask( 0 );
				fd = open( filename, O_RDWR|O_CREAT|O_EXCL, 0600 );
				umask(prior);
			}
			if( fd == -1 )
			{
				//ll_lprintf( "open is %d %s %d", errno, filename, prior );
				// if we didn't create the file...
				// then it can't be marked as temporary...
				bTemp = FALSE;
				if( GetLastError() == EEXIST )
				{
					exists = TRUE;
					fd = open( filename, O_RDWR );
					bTemp = FALSE;
					if( bCreated )
						(*bCreated) = 0;
				}
				if( fd == -1 )
				{
					readonly = TRUE;
					fd = open( filename, O_RDONLY );
				}
				if( fd == -1 )
				{
#ifdef DEBUG_OPEN_SPACE
					Log2( "Sorry - failed to open: %d %s"
						, errno
						, filename );
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
			}
			if( exists )
			{
				if( GetFileSize( fd ) < (uintptr_t)*dwSize )
				{
					// expands the file...
					ftruncate( fd, *dwSize );
					//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				}
				else
				{
					// expands the size requested to that of the file...
					(*dwSize) = GetFileSize( fd );
				}
			}
			else
			{
				if( !*dwSize )
				{
					// can't create a 0 sized file this way.
 // not zero.
					(*dwSize) = 1;
					close( fd );
					unlink( filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
				//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				ftruncate( fd, *dwSize );
			}
			pMem = mmap( 0, *dwSize
			          , PROT_READ|(readonly?(0):PROT_WRITE)
			          , MAP_SHARED|((fd<0)?MAP_ANONYMOUS:0)
			          , fd, 0 );
 // anonymous spaces are always created
			if( bCreated) bCreated[0] = !exists;
			if( !exists && pMem )
			{
				MemSet( pMem, 0, *dwSize );
			}
		}
		if( pMem )
		{
			PSPACE ps = AddSpace( NULL, fd, 0, pMem, *dwSize, TRUE );
			if( ps )
				ps->flags.bTemporary = bTemp;
		}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = FALSE;
#endif
		//if(filename)Release( filename );
		return pMem;
#elif defined( _WIN32 )
#ifndef UNDER_CE
		LOGICAL didCreate = FALSE;
		HANDLE hFile;
		HANDLE hMem = NULL;
		*dwSize = ( ( (*dwSize) + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
		if( !pWhat && !pWhere )
		{
			//ll_lprintf( "ALLOCATE %" _64fx"d", (*dwSize)>>32, 0 );
			hMem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL
											, PAGE_READWRITE
											|SEC_COMMIT
#if __64__
 // dwSize is sometimes 64 bit... this should be harmless
											, (*dwSize)>>32
											, (*dwSize) & (0xFFFFFFFF)
#else
											, 0
											, (*dwSize)
#endif
 // which should be NULL... but is consistant
											, pWhat );
			if( !hMem )
			{
				//ll_lprintf( "Failed to allocate pagefile memory?! %p %d", *dwSize, GetLastError() );
				{
					POINTER p = malloc( *dwSize );
					//ll_lprintf(" but we could allocate it %p", p  );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return p;
				}
			}
			else
			{
			// created and this size is right...
				if( bCreated )
					(*bCreated) = TRUE;
			}
		}
		else if( pWhat )
		{
			hMem = OpenFileMapping( FILE_MAP_READ|FILE_MAP_WRITE
										, FALSE
										, pWhat );
			if( hMem )
			{
				if( bCreated )
					(*bCreated) = FALSE;
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Failed to open region named %s %d", pWhat, GetLastError() );
#endif
  // don't continue... we're expecting open-existing behavior
				if( (*dwSize) == 0 )
				{
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return FALSE;
				}
			}
		}
		hFile = INVALID_HANDLE_VALUE;
		// I would have hmem here if the file was validly opened....
		if( !hMem )
		{
			hFile = CreateFile( pWhere, GENERIC_READ|GENERIC_WRITE
									,FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
 // default security
									,NULL
									,(dwSize&&(*dwSize)) ? OPEN_ALWAYS : OPEN_EXISTING
 //|FILE_ATTRIBUTE_TEMPORARY
									,FILE_ATTRIBUTE_NORMAL
									//| FILE_FLAG_WRITE_THROUGH
									//| FILE_FLAG_NO_BUFFERING
									// must access on sector bournds
									// must read complete sectors
									//| FILE_FLAG_DELETE_ON_CLOSE
									, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "Create file %s result %d", pWhere, hFile );
			ll_lprintf( "File result is %ld (error %ld)", hFile, GetLastError() );
#endif
			if( hFile == INVALID_HANDLE_VALUE )
			{
				readonly = 1;
				if( ( dwSize && (!(*dwSize )) ) && ( GetLastError() == ERROR_PATH_NOT_FOUND || GetLastError() == ERROR_FILE_NOT_FOUND ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "File did not exist, and we're not creating the file (0 size passed)" );
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return NULL;
				}
				hFile = CreateFile( pWhere, GENERIC_READ
										,FILE_SHARE_READ|FILE_SHARE_DELETE
 // default security
										,NULL
										,OPEN_ALWAYS
 //|FILE_ATTRIBUTE_TEMPORARY
										,FILE_ATTRIBUTE_NORMAL
										//| FILE_FLAG_WRITE_THROUGH
										//| FILE_FLAG_NO_BUFFERING
										// must access on sector bournds
										// must read complete sectors
										//| FILE_FLAG_DELETE_ON_CLOSE
										, NULL );
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Create file %s result %d", pWhere, hFile );
#endif
				if( hFile != INVALID_HANDLE_VALUE ) {
 // lie...
					SetLastError( ERROR_ALREADY_EXISTS );
				}
			}
			else {
 // lie...
				SetLastError( ERROR_ALREADY_EXISTS );
			}
			if( hFile == INVALID_HANDLE_VALUE )
			{
				// might still be able to open it by shared name; even if the file share is disabled
				readonly = 0;
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "file is still invalid(alreadyexist?)... new size is %d %d on %p", (*dwSize), FILE_GRAN, hFile );
#endif
 // is INVALID_HANDLE_VALUE, but is consistant
				hMem = CreateFileMapping( hFile
												, NULL
												, (readonly?PAGE_READONLY:PAGE_READWRITE)
												/*|SEC_COMMIT|SEC_NOCACHE*/
#ifdef __64__
												, (uint32_t)((*dwSize)>>32)
#else
												, 0
#endif
												, (uint32_t)(*dwSize)
												, pWhat );
				if( hMem )
				{
					if( bCreated )
						(*bCreated) = 1;
					goto isokay;
				}
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Sorry - Nothing good can happen with a filename like that...%s %d", pWhat, GetLastError());
#endif
					 //bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
			if( GetLastError() == ERROR_ALREADY_EXISTS )
			{
				LARGE_INTEGER lSize;
				GetFileSizeEx( hFile, &lSize );
			// mark status for memory... dunno why?
				// in theory this is a memory image of valid memory already...
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Getting existing size of region..." );
#endif
				if( SUS_LT( lSize.QuadPart, LONGLONG, (*dwSize), uintptr_t ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "Expanding file to size requested." );
#endif
					didCreate = 1;
					SetFilePointer( hFile, (LONG) * (int32_t*)dwSize, (sizeof(dwSize[0])>4)?(PLONG)(((int32_t*)dwSize) + 1):NULL, FILE_BEGIN );
					SetEndOfFile( hFile );
				}
				else
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( "Setting size to size of file (which was larger.." );
#endif
					if( *dwSize ) {
						SetFilePointer( hFile, (LONG) * (int32_t*)dwSize, (sizeof( dwSize[0] ) > 4) ? (PLONG)(((int32_t*)dwSize) + 1) : NULL, FILE_BEGIN );
						SetEndOfFile( hFile );
					}
					else
						(*dwSize) = (uintptr_t)(lSize.QuadPart);
				}
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "New file, setting size to requested %d", *dwSize );
#endif
				SetFilePointer( hFile, (LONG)*(int32_t*)dwSize, (sizeof( dwSize[0] ) > 4) ? (PLONG)(((int32_t*)dwSize)+1) : NULL, FILE_BEGIN );
				SetEndOfFile( hFile );
				didCreate = 1;
			}
			if( bCreated )
				(*bCreated) = didCreate;
			//(*dwSize) = GetFileSize( hFile, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "%s Readonly? %d  hFile %d", pWhat, readonly, hFile );
#endif
			hMem = CreateFileMapping( hFile
											, NULL
											, (readonly?PAGE_READONLY:PAGE_READWRITE)
											/*|SEC_COMMIT|SEC_NOCACHE*/
											, 0, 0
											, pWhat );
			if( pWhat && !hMem )
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( "Create of mapping failed on object specified? %d %p", GetLastError(), hFile );
#endif
				(*dwSize) = 1;
				CloseHandle( hFile );
				//bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
		}
	isokay:
      /*
		if( !hMem )
		{
			pMem = VirtualAlloc( address, (*dwSize), 0 ,PAGE_READWRITE );
			if( !VirtualLock( pMem, (*dwSize ) ) )
            DebugBreak();
		}
		else
      */
		{
			pMem = MapViewOfFileEx( hMem
										, FILE_MAP_READ| ((readonly)?(0):(FILE_MAP_WRITE))
  // offset high, low
										, 0, 0
	 // size of file to map
										, 0
 // don't specify load location... irrelavent...
										, (POINTER)address );
		}
	if( !pMem )
	{
#ifdef DEBUG_OPEN_SPACE
		Log1( "Create view of file for memory access failed at %p", (POINTER)address );
#endif
		CloseHandle( hMem );
		if( hFile != INVALID_HANDLE_VALUE )
			CloseHandle( hFile );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = 0;
#endif
		return NULL;
	}
	else
	{
		if( bCreated && !(*bCreated) && ((*dwSize) == 0) )
		{
			MEMORY_BASIC_INFORMATION meminfo;
			VirtualQuery( pMem, &meminfo, sizeof( meminfo ) );
			(*dwSize) = meminfo.RegionSize;
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( "Fixup memory size to %ld %s:%s(reported by system on view opened)"
					, *dwSize, pWhat?pWhat:"ANON", pWhere?pWhere:"ANON" );
#endif
		}
	}
	// store information about this
	// external to the space - do NOT
	// modify content of memory opened!
	AddSpace( NULL, hFile, hMem, pMem, *dwSize, TRUE );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		LeaveCriticalSecNoWake( &cs );
	}
#else
      bOpening = 0;
#endif
	return pMem;
#else
	if( bCreated )
		(*bCreated) = 1;
	return malloc( *dwSize );
#endif
#endif
	}
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpaceEx
 POINTER  OpenSpaceEx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize )
{
	uint32_t bCreated;
	return OpenSpaceExx( pWhat, pWhere, address, dwSize, &bCreated );
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpace
 POINTER  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize )
{
	return OpenSpaceEx( pWhat, pWhere, 0, dwSize );
}
#endif
//------------------------------------------------------------------------------------------------------
 int  InitHeap( PMEM pMem, uintptr_t dwSize )
{
	//pMem->dwSize = *dwSize - MEM_SIZE;
	// size of the PMEM block is all inclusive (from pMem(0) to pMem(dwSize))
	// do NOT need to substract the size of the tracking header
	// otherwise we would be working from &pMem->pRoot + dwSize
	if( pMem->dwSize )
	{
		if( pMem->dwHeapID != 0xbab1f1ea )
		{
			ll_lprintf( "Memory has content, and is NOT a heap!" );
			return FALSE;
		}
		ll_lprintf( "Memory was already initialized as a heap?" );
		return FALSE;
	}
#ifndef __NO_MMAP__
	if( !FindSpace( pMem ) )
	{
		//ll_lprintf( "space for heap has not been tracked yet...." );
		// a heap must be in the valid space pool.
		// it may not have come from a file, and will not have
		// a file or memory handle.
		AddSpace( NULL, 0, 0, pMem, dwSize, TRUE );
	}
#endif
	// the size passed is the full size of the memory, so we need to remove sizeof(MEM)
	// so there is room to track heap info at the start of the heap.
	dwSize -= sizeof( MEM );
	pMem->dwSize = dwSize;
	pMem->dwHeapID = 0xbab1f1ea;
	pMem->pFirstFree = NULL;
	pMem->dwFlags = 0;
        // this uses the address of next to assign a member.
        // next is the first member of this structure;
        // even if it is packed, there's no issue surely with taking the address of the first member?
	LinkThing( pMem->pFirstFree, pMem->pRoot );
	InitializeCriticalSec( &pMem->cs );
	pMem->pRoot[0].dwSize = dwSize - MEM_SIZE - CHUNK_SIZE;
	pMem->pRoot[0].info.dwPad = MAGIC_SIZE;
	pMem->pRoot[0].info.dwOwners = 0;
	pMem->pRoot[0].pRoot  = pMem;
	pMem->pRoot[0].pPrior = NULL;
#ifdef _DEBUG
	if( !g.bDisableDebug )
	{
#ifdef VERBOSE_LOGGING
		ll_lprintf( "Initializing %p %d"
				, pMem->pRoot[0].byData
				, pMem->pRoot[0].dwSize );
#endif
		MemSet( pMem->pRoot[0].byData, 0x1BADCAFE, pMem->pRoot[0].dwSize );
		BLOCK_TAG( pMem->pRoot ) = BLOCK_TAG_ID;
	}
	{
		pMem->pRoot[0].info.dwPad += 2*MAGIC_SIZE;
		BLOCK_FILE( pMem->pRoot ) = __FILE__;
		BLOCK_LINE( pMem->pRoot ) = __LINE__;
	}
#endif
	return TRUE;
}
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
PMEM DigSpace( TEXTSTR pWhat, TEXTSTR pWhere, uintptr_t *dwSize )
{
	PMEM pMem = (PMEM)OpenSpace( pWhat, pWhere, dwSize );
	if( !pMem )
	{
		// did reference BASE_MEMORY...
		ll_lprintf( "Create view of file for memory access failed at %p %p", pWhat, pWhere );
		CloseSpace( (POINTER)pMem );
		return NULL;
	}
#ifdef VERBOSE_LOGGING
	Log( "Go to init the heap..." );
#endif
	pMem->dwSize = 0;
#if USE_CUSTOM_ALLOCER
	InitHeap( pMem, *dwSize );
#endif
	return pMem;
}
//------------------------------------------------------------------------------------------------------
int ExpandSpace( PMEM pHeap, uintptr_t dwAmount )
{
	PSPACE pspace = FindSpace( (POINTER)pHeap ), pnewspace;
	PMEM pExtend;
	//ll_lprintf( "Expanding by %d %d", dwAmount );
	pExtend = DigSpace( NULL, NULL, &dwAmount );
	if( !pExtend )
	{
		ll_lprintf( "Failed to expand space by %" _PTRSZVALfs, dwAmount );
		return FALSE;
	}
	pnewspace = FindSpace( pExtend );
	if( pnewspace )
	{
		while( pspace && pspace->next )
			pspace = pspace->next;
		if( ( pspace->next = pnewspace ) )
		{
			pnewspace->me = &pspace->next;
		}
	}
	return TRUE;
}
#endif
//------------------------------------------------------------------------------------------------------
static PMEM InitMemory( void ) {
	uintptr_t MinSize = SYSTEM_CAPACITY;
	// generic internal memory, unnamed, unshared, unsaved
#ifndef __NO_MMAP__
	g.pMemInstance = DigSpace( NULL, NULL, &MinSize );
	if( !g.pMemInstance )
	{
		g.bMemInstanced = FALSE;
		ODS( "Failed to allocate memory - assuming fatailty at Allocation service level." );
		return NULL;
	}
#endif
	return g.pMemInstance;
}
//------------------------------------------------------------------------------------------------------
static PMEM GrabMemEx( PMEM pMem DBG_PASS )
#define GrabMem(m) GrabMemEx( m DBG_SRC )
{
	if( !pMem )
	{
		// use default heap...
		if( !XCHG( &g.bMemInstanced, TRUE ) )
			pMem = InitMemory();
		else {
			pMem = g.pMemInstance;
		}
	}
	//ll_lprintf( "grabbing memory %p", pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		while( !TryEnterCriticalSection( &pMem->cs ) )
		{
			Relinquish();
		}
#else
		while( EnterCriticalSecNoWaitEx( &pMem->cs, NULL DBG_RELAY ) <= 0 )
		{
			Relinquish();
		}
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
	return pMem;
}
//------------------------------------------------------------------------------------------------------
static void DropMemEx( PMEM pMem DBG_PASS )
#define DropMem(m) DropMemEx( m DBG_SRC)
{
	if( !pMem )
		return;
	//ll_lprintf( "dropping memory %p", pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSection( &pMem->cs );
#else
		LeaveCriticalSecNoWakeEx( &pMem->cs DBG_RELAY );
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateAlignedEx( PMEM pHeap, size_t dwSize, uint16_t alignment DBG_PASS )
{
   // if a heap is passed, it's a private heap, and allocation is as normal...
	uint32_t dwAlignPad = 0;
#if defined( __64__ )
	if( !alignment ) alignment = 8;
#endif
	if( alignment ) {
		dwSize += (alignment - 1);
		dwAlignPad = (alignment - 1);
	}
	if( !pHeap && !USE_CUSTOM_ALLOCER )
	{
		PMALLOC_CHUNK pc;
		uintptr_t mask;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + alignment + dwSize + sizeof( pc->LeadProtect ) );
		if( !pc )
			DebugBreak();
		MemSet( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) );
		MemSet( pc->byData + dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) );
#else
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + dwSize );
#endif
		pc->info.dwOwners = 1;
		pc->info.dwPad = dwAlignPad;
		pc->dwSize = dwSize;
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate )
		{
			ll__lprintf(DBG_RELAY)( "alloc %p(%p) %zd", pc, pc->byData, dwSize );
		}
#  endif
#endif
		if( alignment > (sizeof( masks ) / sizeof( masks[0] )) )
			mask = (~((uintptr_t)(alignment-1)));
		else
			mask = masks[alignment];
		if( alignment && ( (uintptr_t)pc->byData & ~mask) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & mask);
			//pc->info.dwPad = (uint16_t)( dwAlignPad - sizeof(uintptr_t) );
			// to_chunk_start is the last thing in chunk, so it's pre-allocated space
			((uint16_t*)(retval - sizeof(uint32_t)))[0] = alignment;
			((uint16_t*)(retval - sizeof(uint32_t)))[1] = (uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & mask) - (uintptr_t)pc->byData);
 //-V773
			return (POINTER)retval;
		}
		else {
			pc->info.alignment = 0;
			pc->info.to_chunk_start = 0;
			return pc->byData;
		}
	}
#if USE_CUSTOM_ALLOCER
	else
	{
		PHEAP_CHUNK pc;
		PMEM pMem, pCurMem = NULL;
		PSPACE pMemSpace;
		uint32_t dwPad = 0;
		uint32_t dwMin = 0;
		intptr_t mask;
		if( alignment > ( sizeof( masks ) / sizeof( masks[0] ) ) )
			mask = ( ~( (uintptr_t)( alignment - 1 ) ) );
		else
			mask = masks[alignment];
		//ll__lprintf(DBG_RELAY)( "..." );
#ifdef _DEBUG
		if( !g.bDisableAutoCheck )
			GetHeapMemStatsEx(pHeap, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
 // no size is NO space!
		if( !dwSize )
		{
			return NULL;
		}
		// if memstats is used - memory could have been initialized there...
		// so wait til now to grab g.pMemInstance.
		if( !pHeap )
			pHeap = g.pMemInstance;
		pMem = GrabMem( pHeap );
		dwPad = dwAlignPad;
#ifdef __64__
		dwPad += (uint32_t)( (((dwSize + 7) & 0xFFFFFFFFFFFFFFF8) - dwSize) );
 // fix size to allocate at least _32s which
		dwSize += 7;
		dwSize &= 0xFFFFFFFFFFFFFFF8;
#else
		dwPad += (((dwSize + 3) & 0xFFFFFFFC) -dwSize);
 // fix size to allocate at least _32s which
		dwSize += 3;
		dwSize &= 0xFFFFFFFC;
#endif
#ifdef _DEBUG
		if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
		{
			dwPad += MAGIC_SIZE * 2;
 // pFile, nLine per block...
			dwSize += MAGIC_SIZE * 2;
									  //ll_lprintf( "Adding 8 bytes to block size..." );
		}
		if( !g.bDisableDebug )
		{
			dwPad += MAGIC_SIZE;
  // add a uint32_t at end to mark, and check for application overflow...
			dwSize += MAGIC_SIZE;
		}
		dwMin = dwPad;
#endif
		// re-search for memory should step long back...
	search_for_free_memory:
		for( pc = NULL, pMemSpace = FindSpace( pMem ); !pc && pMemSpace; pMemSpace = pMemSpace->next )
		{
			// grab the new memory (might be old, is ok)
			GrabMem( (PMEM)pMemSpace->pMem );
			// then drop old memory, don't need that anymore.
 // first time through, there is no current.
			if( pCurMem )
				DropMem( pCurMem );
			// then mark that this block is our current block.
			pCurMem = (PMEM)pMemSpace->pMem;
			//ll_lprintf( "region %p is now owned.", pCurMem );
			for( pc = pCurMem->pFirstFree; pc; pc = pc->next )
			{
 // if free block size is big enough...
				if( pc->dwSize >= dwSize )
				{
					// split block
 // must allocate it all.
					if( ( pc->dwSize - dwSize ) <= ( dwMin + CHUNK_SIZE + g.nMinAllocateSize ) )
					{
						pc->info.dwPad = (uint16_t)(dwPad + ( pc->dwSize - dwSize ));
						UnlinkThing( pc );
						pc->info.dwOwners = 1;
 // successful allocation....
						break;
					}
					else
					{
  // cleared, NEW, uninitialized block...
						PHEAP_CHUNK pNew;
						PHEAP_CHUNK next;
						next = (PHEAP_CHUNK)( pc->byData + pc->dwSize );
						pNew = (PHEAP_CHUNK)(pc->byData + dwSize);
						pNew->info.dwPad = 0;
						pNew->dwSize = ((pc->dwSize - CHUNK_SIZE) - dwSize);
#ifdef _DEBUG
						if( pNew->dwSize > 0x80000000 )
							DebugBreak();
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							pNew->info.dwPad += MAGIC_SIZE * 2;
						}
						if( !g.bDisableDebug )
						{
							pNew->info.dwPad += MAGIC_SIZE;
							BLOCK_TAG( pNew ) = BLOCK_TAG_ID;
						}
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							BLOCK_FILE( pNew ) = pFile;
							BLOCK_LINE( pNew ) = nLine;
						}
#endif
						pc->info.dwPad = (uint16_t)dwPad;
 // set old size?  this can wait until we have the block.
						pc->dwSize = dwSize;
						if( pc->dwSize & 0x80000000 )
							DebugBreak();
  // not beyond end of memory...
						if( (uintptr_t)next - (uintptr_t)pCurMem < (uintptr_t)pCurMem->dwSize )
							next->pPrior = pNew;
						pNew->info.dwOwners = 0;
//#ifdef _DEBUG
						pNew->pRoot = pc->pRoot;
//#endif
						pNew->pPrior = pc;
						// copy link...
						if( ( pNew->next = pc->next ) )
							pNew->next->me = &pNew->next;
						pNew->me = pc->me;
						pc->me[0] = pNew;
  // set owned block.
						pc->info.dwOwners = 1;
 // successful allocation....
						break;
					}
				}
			}
		}
		if( !pc )
		{
			if( dwSize < SYSTEM_CAPACITY )
			{
				if( ExpandSpace( pMem, SYSTEM_CAPACITY ) )
					goto search_for_free_memory;
			}
			else
			{
				// after 1 allocation, need a free chunk at end...
				// and let's just have a couple more to spaere.
				if( ExpandSpace( pMem, dwSize + 4096 + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE ) )
				{
#ifndef NO_LOGGING
					//ll__lprintf(DBG_RELAY)( "Creating a new expanded space... %" _size_fs, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE );
#endif
					goto search_for_free_memory;
				}
			}
			DropMem( pCurMem );
			pCurMem = NULL;
#ifdef _DEBUG
			if( !g.bDisableDebug )
				ODS( "Remaining space in memory block is insufficient.  Please EXPAND block.");
#endif
			DropMem( pMem );
			return NULL;
		}
 //|| !defined( __NO_WIN32API__ )
#if defined( _DEBUG )
		if( !g.bDisableDebug )
		{
			// set end of block tag(s).
			// without disabling memory entirely, blocks are
			// still tagged and trashed in debug mode.
			MemSet( pc->byData, CLEAR_MEMORY_TAG, pc->dwSize );
			BLOCK_TAG(pc) = BLOCK_TAG_ID;
		}
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			if( pc->info.dwPad < 2*sizeof( uintptr_t) )
				DebugBreak();
			BLOCK_FILE(pc) = pFile;
			BLOCK_LINE(pc) = nLine;
		}
#endif
		DropMem( pCurMem );
		DropMem( pMem );
/*
		if( pCurMem->cs.dwLocks ) {
			fprintf( stderr, "(pcurmem) Memory block %p has %d locks on it.", pCurMem, pCurMem->cs.dwLocks );
			//DebugBreak();
		}
		if( pMem->cs.dwLocks ) {
			fprintf( stderr, "(pmem) Memory block %p has %d locks on it.", pMem, pMem->cs.dwLocks );
			//DebugBreak();
		}
*/
		//#if DBG_AVAILABLE
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate && g.allowLogging )
		{
			_xlprintf( 2 DBG_RELAY )("Allocate : %p(%p) - %" _PTRSZVALfs " bytes", pc->byData, pc, pc->dwSize);
		}else
		{
			//fprintf(stderr, DBG_FILELINEFMT " (disabled %d)Allocate : %p(%p) - %" _PTRSZVALfs " bytes\n" DBG_RELAY, global_memory_data.last_set_allocate, pc->byData, pc, pc->dwSize);
		}
#  endif
#endif
		//#endif
		if( alignment && ((uintptr_t)pc->byData & ~mask ) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & mask );
			((uint16_t*)(retval - sizeof( uint32_t )))[0] = alignment;
			((uint16_t*)(retval - sizeof( uint32_t )))[1] = (uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & mask ) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->info.alignment = 0;
			pc->info.to_chunk_start = 0;
			return pc->byData;
		}
	}
#endif
	return NULL;
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateEx( PMEM pHeap, uintptr_t dwSize DBG_PASS ) {
	return HeapAllocateAlignedEx( pHeap, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
#undef AllocateEx
POINTER  AllocateEx ( uintptr_t dwSize DBG_PASS )
{
	return HeapAllocateAlignedEx( g.pMemInstance, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( dest, source, minSize );
		if( minSize < size )
			MemSet( ((uint8_t*)dest) + minSize, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( pHeap, source, size, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapPreallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( (uint8_t*)dest + (size-minSize), source, minSize );
		if( minSize < size )
			MemSet( dest, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
POINTER  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS ){
	return HeapPreallocateAlignedEx( pHeap, source, size, AlignOfMemBlock(source) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  HeapMoveEx( PMEM pNewHeap, POINTER source DBG_PASS )
{
	return HeapReallocateAlignedEx( pNewHeap, source, SizeOfMemBlock( source ), AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  ReallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  PreallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapPreallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
#if USE_CUSTOM_ALLOCER
static void Bubble( PMEM pMem )
{
	// handle sorting free memory to be least signficant first...
	PCHUNK temp, next;
	PCHUNK *prior;
	prior = &pMem->pFirstFree;
	temp = *prior;
	if( !temp )
		return;
	next = temp->next;
	while( temp && next )
	{
		if( (uintptr_t)next < (uintptr_t)temp )
		{
			UnlinkThing( temp );
			UnlinkThing( next );
			LinkThing( *prior, next );
			LinkThing( next->next, temp );
			prior = &next->next;
			temp = *prior;
			next = temp->next;
		}
		else
		{
			prior = &temp->next;
			temp = *prior;
#ifdef _DEBUG
			if( temp->next == temp )
			{
				ll_lprintf( "OOps this block is way bad... how'd that happen? %s(%d)", BLOCK_FILE( temp ), BLOCK_LINE( temp ) );
				DebugBreak();
			}
#endif
			next = temp->next;
		}
	}
}
#endif
//------------------------------------------------------------------------------------------------------
 uintptr_t  SizeOfMemBlock ( CPOINTER pData )
{
	if( pData )
	{
		if( USE_CUSTOM_ALLOCER )
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
			return pc->dwSize - pc->info.dwPad;
		}
		else
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData));
			return pc->dwSize - pc->info.dwPad;
		}
	}
	return 0;
}
//------------------------------------------------------------------------------------------------------
uint16_t  AlignOfMemBlock( CPOINTER pData )
{
	if( pData )
	{
		return (((uint16_t*)pData)[-2]);
	}
	return 0;
 }
//------------------------------------------------------------------------------------------------------
 POINTER  MemDupEx ( CPOINTER thing DBG_PASS )
{
	uintptr_t size = SizeOfMemBlock( thing );
	POINTER result;
	result = HeapAllocateAlignedEx( g.pMemInstance, size, AlignOfMemBlock( thing ) DBG_RELAY );
	MemCpy( result, thing, size );
	return result;
}
#undef MemDup
 POINTER  MemDup (CPOINTER thing )
{
	return MemDupEx( thing DBG_SRC );
}
//------------------------------------------------------------------------------------------------------
POINTER ReleaseEx ( POINTER pData DBG_PASS )
{
	if( !g.bInit ) {
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate )
		{
			ll__lprintf(DBG_RELAY)( "Skip Release - already shutdown %p", pData );
		}
#  endif
#endif
		return NULL;
	}
	if( pData )
	{
#ifndef __NO_MMAP__
		// how to figure if it's a CHUNK or a HEAP_CHUNK?
		if( !( ((uintptr_t)pData) & 0x3FF ) )
		{
			// system allocated blocks ( OpenSpace ) will be tracked as spaces...
			// and they will be aligned on large memory blocks (4096 probably)
			PSPACE ps = FindSpace( pData );
			if( ps )
			{
				DoCloseSpace( ps, TRUE );
				return NULL;
			}
		}
#endif
		if( !USE_CUSTOM_ALLOCER )
		{
			//PMEM pMem = (PMEM)(pData - offsetof( MEM, pRoot ));
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData) );
			pc->info.dwOwners--;
			if( !pc->info.dwOwners )
			{
				extern int  MemChk ( POINTER p, uintptr_t val, size_t sz );
#ifndef NO_LOGGING
#  ifdef _DEBUG
				if( g.bLogAllocate )
				{
					ll__lprintf(DBG_RELAY)( "Release %p(%p)", pc, pc->byData );
				}
#  endif
#endif
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
				if( !MemChk( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) ) ||
					!MemChk( pc->byData + pc->dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) ) )
				{
					ll_lprintf( "overflow block (%p) %p", pData, pc );
					DebugBreak();
				}
#endif
				free( pc );
				return NULL;
			}
			else
			{
#ifndef NO_LOGGING
				if( g.bLogAllocate && g.bLogAllocateWithHold )
				{
					ll__lprintf(DBG_RELAY)( "Release(holding) %p(%p)", pc, pc->byData );
				}
#endif
			}
			return pData;
		}
#if USE_CUSTOM_ALLOCER
		else
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - ( ( (uint16_t*)pData)[-1] +
													offsetof( CHUNK, byData ) ) );
			PMEM pMem, pCurMem;
			PSPACE pMemSpace;
			// Allow a simple release() to close a shared memory file mapping
			// this is a slight performance hit for all deallocations
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
#ifndef NO_LOGGING
#  ifdef _DEBUG
			if( g.bLogAllocate )
			{
				if( !g.bDisableDebug )
					_xlprintf( 2 DBG_RELAY )("Release  : %p(%p) - %" _PTRSZVALfs " bytes %s(%d)", pc->byData, pc, pc->dwSize, BLOCK_FILE( pc ), BLOCK_LINE( pc ));
				else
					_xlprintf( 2 DBG_RELAY )("Release  : %p(%p) - %" _PTRSZVALfs " bytes", pc->byData, pc, pc->dwSize);
			}
			else
//fprintf(stderr, DBG_FILELINEFMT " (disabled %d)Release  : %p(%p) - %" _PTRSZVALfs " bytes\n" DBG_RELAY,  global_memory_data.last_set_allocate, pc->byData, pc, pc->dwSize);
				;
#  endif
#endif
			pMem = GrabMem( pc->pRoot );
#ifdef _DEBUG
			if( !pMem )
			{
#  ifndef NO_LOGGING
				ll__lprintf( DBG_RELAY )( "ERROR: Chunk to free does not reference a heap!" );
#  endif
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
			}
#endif
			pMemSpace = FindSpace( pMem );
#ifdef _DEBUG
			//if( g.bLogAllocate )
			//	lprintf( "Got space back:%p", pMemSpace );
			while( pMemSpace && ( ( pCurMem = (PMEM)pMemSpace->pMem ),
										(	( (uintptr_t)pData < (uintptr_t)pCurMem )
										||  ( (uintptr_t)pData > ( (uintptr_t)pCurMem + pCurMem->dwSize ) ) )
									 )
				 )
			{
				Log( "ERROR: This block should have immediatly referenced it's correct heap!" );
				pMemSpace = pMemSpace->next;
			}
#endif
			if( !pMemSpace )
			{
#ifndef NO_LOGGING
#  ifdef _DEBUG
				ll__lprintf( DBG_RELAY )( "This Block is NOT within the managed heap! : %p", pData );
#  endif
#endif
				ll_lprintf( "this may not be an error.  This could be an old block from not using customallocer..." );
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
				DropMem( pMem );
				return NULL;
			}
#ifdef _DEBUG
			pCurMem = (PMEM)pMemSpace->pMem;
#endif
			if( pData && pc )
			{
				if( !pc->info.dwOwners )
				{
#ifndef NO_LOGGING
#  ifdef _DEBUG
					if( !g.bDisableDebug &&
						!(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
						_xlprintf( 2
									, BLOCK_FILE(pc)
									, BLOCK_LINE(pc)
									)( "Block is already Free! %p "
									, pc );
					else
#  endif
						// CRITICAL ERROR!
						_xlprintf( 2 DBG_RELAY)( "Block is already Free! %p ", pc );
#endif
					DebugBreak();
					DropMem( pMem );
					return pData;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug )
					if( BLOCK_TAG( pc ) != BLOCK_TAG_ID )
					{
						ll_lprintf( "Application overflowed memory:%p", pc->byData );
						DebugDumpHeapMemEx( pc->pRoot, 1 );
						DebugBreak();
					}
#endif
				pc->info.dwOwners--;
				if( pc->info.dwOwners )
				{
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
#endif
					DropMem( pMem );
					return pData;
				}
				else
				{
					LOGICAL bCollapsed = FALSE;
					PCHUNK next, nextNext, pPrior;
					uintptr_t nNext;
					// fill memory with a known value...
					// this will allow me to check usage after release....
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
					if( !g.bDisableDebug )
					{
						BLOCK_TAG(pc)=BLOCK_TAG_ID;
						MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->info.dwPad );
					}
#endif
					next = (PCHUNK)(pc->byData + pc->dwSize);
#ifndef _DEBUG
					pCurMem = (PMEM)pMemSpace->pMem;
#endif
					if( (nNext = (uintptr_t)next - (uintptr_t)pCurMem) >= pCurMem->dwSize )
					{
						// if next is NOT within valid memory...
						next = NULL;
					}
 // is not root chunk...
					if( ( pPrior = pc->pPrior ) )
					{
 // prior physical is free
						if( !pPrior->info.dwOwners )
						{
 // add this header plus size
							pPrior->dwSize += CHUNK_SIZE + pc->dwSize;
#ifdef _DEBUG
							//if( bLogAllocate )
							{
								//ll_lprintf( "Collapsing freed block with prior block...%p %p", pc, pPrior );
							}
							if( !g.bDisableDebug )
							{
								pPrior->info.dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->info.dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
								BLOCK_TAG( pPrior ) = BLOCK_TAG_ID;
								MemSet( pPrior->byData, FREE_MEMORY_TAG, pPrior->dwSize - pPrior->info.dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pPrior->info.dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->info.dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
#endif
							}
							if( pPrior->dwSize & 0x80000000 )
								DebugBreak();
 // use prior block as base ....
							pc = pPrior;
							if( next )
								next->pPrior = pPrior;
							bCollapsed = TRUE;
						}
					}
					// begin checking NEXT physical memory block for conglomerating
					if( next )
					{
						if( !next->info.dwOwners )
						{
							pc->dwSize += CHUNK_SIZE + next->dwSize;
							if( bCollapsed )
							{
								// pc is already in free list...
								UnlinkThing( next );
							}
							else
							{
								// otherwise need to use next's link spot
								// for this pc...
								if( (pc->next = next->next) )
									pc->next->me = &pc->next;
								pc->me = next->me;
								pc->me[0] = pc;
								bCollapsed = TRUE;
							}
#ifdef _DEBUG
							//if( bLogAllocate )
								//ll_lprintf( "Collapsing freed block with next block...%p %p", pc, next );
							if( !g.bDisableDebug )
							{
								pc->info.dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->info.dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
								BLOCK_TAG( pc ) = BLOCK_TAG_ID;
								MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->info.dwPad );
							}
							else
#endif
							{
								pc->info.dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
                            // *** NEEDFILELINE ***
									pc->info.dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
#endif
							}
							if( pc->dwSize & 0x80000000 )
								DebugBreak();
							nextNext = (PCHUNK)(pc->byData + pc->dwSize );
							if( (((uintptr_t)nextNext) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
							{
								nextNext->pPrior = pc;
							}
						}
					}
 // no block near this one was free...
					if( !bCollapsed )
					{
						LinkThing( pc->pRoot->pFirstFree, pc );
					}
				}
			}
			Bubble( pMem );
			DropMem( pMem );
#  ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pMem, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#  endif
		}
#endif
	}
	return NULL;
}
		//------------------------------------------------------------------------------------------------------
 POINTER  HoldEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
		if( !USE_CUSTOM_ALLOCER )
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)((uintptr_t)pData - MALLOC_CHUNK_SIZE(pData));
			//ll__lprintf( DBG_RELAY )( "holding block %p", pc );
#ifndef NO_LOGGING
			if( g.bLogAllocate && g.bLogAllocateWithHold )
				_xlprintf( 2 DBG_RELAY)( "Hold	 : %p - %" _PTRSZVALfs " bytes",pc, pc->dwSize );
#endif
			pc->info.dwOwners++;
		}
		else
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - ( ( (uint16_t*)pData)[-1] +
													offsetof( CHUNK, byData ) ) );
#ifndef NO_LOGGING
			if( g.bLogAllocate )
			{
				_xlprintf( 2 DBG_RELAY)( "Hold	 : %p - %" _PTRSZVALfs " bytes",pc, pc->dwSize );
			}
#endif
			PMEM pMem = GrabMem( pc->pRoot );
			if( !pc->info.dwOwners )
			{
				_xlprintf( 2 DBG_RELAY)( "Held block has already been released!  too late to hold it!" );
				DebugBreak();
				DropMemEx( pMem DBG_RELAY );
				return pData;
			}
			pc->info.dwOwners++;
			DropMemEx(pMem DBG_RELAY );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
	}
	return pData;
}
//------------------------------------------------------------------------------------------------------
 POINTER  GetFirstUsedBlock ( PMEM pHeap )
{
	return pHeap->pRoot[0].byData;
}
//------------------------------------------------------------------------------------------------------
void  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose )
{
#if USE_CUSTOM_ALLOCER
	if( USE_CUSTOM_ALLOCER )
	{
		PCHUNK pc, _pc;
		uintptr_t nTotalFree = 0;
		uintptr_t nChunks = 0;
		uintptr_t nTotalUsed = 0;
		PSPACE pMemSpace;
		if( !pHeap ) pHeap = g.pMemInstance;
		PMEM pMem = GrabMem( pHeap ), pCurMem;
		pc = pMem->pRoot;
		ll_lprintf(" ------ Memory Dump ------- " );
		{
			xlprintf(LOG_ALWAYS)( "FirstFree : %p",
										pMem->pFirstFree );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
#ifndef __LINUX__
 // allow debug log to work... (OutputDebugString() Win32, also network streams may require)
				Relinquish();
#endif
				nChunks++;
				if( !pc->info.dwOwners )
				{
					nTotalFree += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( "Free at %p size: %" _PTRSZVALfs "(%" _PTRSZVALfx ") Prior:%p NF:%p",
																 pc, pc->dwSize, pc->dwSize,
																 (POINTER)pc->pPrior,
																 pc->next );
					}
#endif
				}
				else
				{
					nTotalUsed += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( "Used at %p(%zx) size: %" _PTRSZVALfs "(%" _PTRSZVALfx ") Prior:%p",
																 pc, ((uintptr_t)pc)+pc->info.to_chunk_start + offsetof( CHUNK, byData ), pc->dwSize, pc->dwSize,
																 (POINTER)pc->pPrior );
					}
#endif
				}
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
					ll_lprintf( "Next block is the current block..." );
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		xlprintf(LOG_ALWAYS)( "Total Free: %" _PTRSZVALfs "  TotalUsed: %" _PTRSZVALfs "  TotalChunks: %" _PTRSZVALfs " TotalMemory:%" _PTRSZVALfs,
									nTotalFree, nTotalUsed, nChunks,
									(nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		DropMem( pMem );
	}
	else
#endif
		xlprintf(LOG_ALWAYS)( "Cannot log chunks allocated that are not using custom allocer." );
}
	//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemEx ( LOGICAL bVerbose )
{
	DebugDumpHeapMemEx( g.pMemInstance, bVerbose );
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename )
{
#if USE_CUSTOM_ALLOCER
	FILE *file;
#endif
	if( !USE_CUSTOM_ALLOCER )
		return;
#if USE_CUSTOM_ALLOCER
	Fopen( file, pFilename, "wt" );
	if( file )
	{
		PCHUNK pc, _pc;
		PMEM pMem, pCurMem;
		PSPACE pMemSpace;
		size_t nTotalFree = 0;
		size_t nChunks = 0;
		size_t nTotalUsed = 0;
		char byDebug[256];
		if( !pHeap ) pHeap = g.pMemInstance;
		pMem = GrabMem( pHeap );
		fprintf( file, " ------ Memory Dump ------- \n" );
		{
			char  byDebug[256];
			snprintf( byDebug, sizeof( byDebug ), "FirstFree : %p",
						pMem->pFirstFree );
			byDebug[255] = 0;
			fprintf( file, "%s\n", byDebug );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
				//Relinquish(); // allow debug log to work...
				nChunks++;
				if( !pc->info.dwOwners )
				{
					nTotalFree += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p NF:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior,
						pc->next );
					byDebug[255] = 0;
				}
				else
				{
					nTotalUsed += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Used at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior );
					byDebug[255] = 0;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug && !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
#endif
					fprintf( file, "%s\n", byDebug );
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		fprintf( file, "--------------- FREE MEMORY LIST --------------------\n" );
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pFirstFree;
 // while PC not off end of memory
			while( pc )
			{
				snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" c_size_fs "(%" c_size_fx ") ",
							pc, pc->dwSize, pc->dwSize );
				byDebug[255] = 0;
	#ifdef _DEBUG
 /*!g.bDisableDebug && */
				if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					const char * pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?CStrDup(BLOCK_FILE(pc))
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
	#endif
					fprintf( file, "%s\n", byDebug );
				pc = pc->next;
			}
		}
		snprintf( byDebug, sizeof(byDebug), "Total Free: %" c_size_f "  TotalUsed: %" c_size_f "  TotalChunks: %" c_size_f " TotalMemory:%" c_size_f
					, nTotalFree, nTotalUsed, nChunks
					, (nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		byDebug[255] = 0;
		fprintf( file, "%s\n", byDebug );
		//Relinquish();
		DropMem( pMem );
		 fclose( file );
	}
#endif
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemFile ( CTEXTSTR pFilename )
{
	DebugDumpHeapMemFile( g.pMemInstance, pFilename );
}
//------------------------------------------------------------------------------------------------------
 // returns true/false, updates pointer
 LOGICAL  Defragment ( POINTER *ppMemory )
{
	// this is broken... needs
	// to fixup BLOCK_TAG, BLOCK_FILE, etc...
#if 1
	return FALSE;
#else
	// pass an array of allocated memory... for all memory blocks in list,
	// check to see if they can be reallocated lower, and or just moved to
	// a memory space lower than they are now.
	PCHUNK pc, pPrior;
	PMEM pMem;
	if( !ppMemory || !*ppMemory)
		return FALSE;
	pc = (PCHUNK)(((uintptr_t)(*ppMemory)) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
	pMem = GrabMem( pc->pRoot );
		// check if prior block is free... if so - then...
		// move this data down, and reallocate the freeness at the end
		// this reallocation may move the free next to another free, which
		// should be collapsed into this one...
	pPrior = pc->pPrior;
 // not HELD by others... no way to update their pointers
	if( ( pc->info.dwOwners == 1 ) &&
		pPrior &&
		!pPrior->info.dwOwners )
	{
		CHUNK Free = *pPrior;
		CHUNK Allocated, *pNew;
 // save this chunk...
		Allocated = *pc;
		MemCpy( pPrior->byData, pc->byData, Allocated.dwSize );
		pNew = (PCHUNK)(pPrior->byData + Allocated.dwSize);
		pNew->dwSize = Free.dwSize;
		pNew->info.dwOwners = 0;
 // now pAllocated...
		pNew->pPrior = pPrior;
		pNew->pRoot = Free.pRoot;
		if( ( pNew->next = Free.next ) )
			pNew->next->me = &pNew->next;
		if( ( pNew->me = Free.me ) )
			(*pNew->me) = pNew;
#ifdef _DEBUG
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			BLOCK_FILE(pNew) = BLOCK_FILE(&Free);
			BLOCK_LINE(pNew) = BLOCK_LINE(&Free);
		}
#endif
		pPrior->dwSize = Allocated.dwSize;
		pPrior->info.dwOwners = 1;
		pPrior->next = NULL;
		pPrior->me = NULL;
		// update NEXT NEXT real block...
		{
			PCHUNK next;
			next = (PCHUNK)( pNew->byData + pNew->dwSize );
			if( (((uintptr_t)next) - ((uintptr_t)pMem)) < (uintptr_t)pMem->dwSize )
			{
 // if next is free.....
				if( !next->info.dwOwners )
				{
					// consolidate...
					if( (pNew->next = next->next) )
						pNew->next->me = &pNew->next;
					pNew->me = next->me;
					pNew->me[0] = pNew;
					pNew->dwSize += next->dwSize + CHUNK_SIZE;
					next = (PCHUNK)( pNew->byData + pNew->dwSize );
					if( (uint32_t)(((char *)next) - ((char *)pMem)) < pMem->dwSize )
					{
						next->pPrior = pNew;
					}
				}
				else
					next->pPrior = pNew;
			}
		}
		*ppMemory = pPrior->byData;
		DropMem( pMem );
		GetHeapMemStats( g.pMemInstance, NULL, NULL, NULL, NULL );
		return TRUE;
	}
	DropMem( pMem );
	return FALSE;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS )
{
#if USE_CUSTOM_ALLOCER
	int nChunks = 0, nFreeChunks = 0;
	//int nSpaces = 0;
	uintptr_t nFree = 0, nUsed = 0;
	PCHUNK pc, _pc;
	PMEM pMem;
	PSPACE pMemSpace;
#endif
	if( !USE_CUSTOM_ALLOCER )
      return;
#if USE_CUSTOM_ALLOCER
	if( !pHeap )
		pHeap = g.pMemInstance;
	//fprintf( stderr, "Grab Heap: %d %p\n", nLine, pHeap );
	pMem = GrabMem( pHeap );
	//fprintf( stderr, "Grabbed Heap: %p\n", pMem );
	pMemSpace = FindSpace( pMem );
	while( pMemSpace )
	{
		PMEM pMemCheck = ((PMEM)pMemSpace->pMem);
		pc = pMemCheck->pRoot;
		GrabMem( pMemCheck );
 // while PC not off end of memory
		while( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize )
		{
			nChunks++;
			if( !pc->info.dwOwners )
			{
				nFree += pc->dwSize;
				nFreeChunks++;
			}
			else
			{
				nUsed += pc->dwSize;
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					if( pc->dwSize > pMemCheck->dwSize )
					{
						ll_lprintf( "Memory block %p has a corrupt size.", pc->byData );
						DebugBreak();
					}
					else
					{
						int minPad = MAGIC_SIZE;
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
							minPad += MAGIC_SIZE * 2;
						if( ( pc->info.dwPad >= minPad ) && ( BLOCK_TAG(pc) != BLOCK_TAG_ID ) )
						{
#ifndef NO_LOGGING
							ll_lprintf( "memory block: %p(%p) %08" TAG_FORMAT_MODIFIER "x instead of %08" TAG_FORMAT_MODIFIER "x", pc, pc->byData, BLOCK_TAG(pc), BLOCK_TAG_ID );
							if( !(pMemCheck->dwFlags & HEAP_FLAG_NO_DEBUG ) )
							{
								CTEXTSTR file = BLOCK_FILE(pc);
#  ifdef _WIN32
								if( IsBadReadPtr( file, 4 ) )
									file = "(corrupt)";
#  endif
								if( g.deadstart_finished )
									_xlprintf( 2, file, BLOCK_LINE(pc) )( "Application overflowed allocated memory." );
								else
									ODS( "Application overflowed allocated memory." );
							}
							else
								ODS( "Application overflowed allocated memory." );
#endif
							DebugDumpHeapMemEx( pHeap, 1 );
							DebugBreak();
						}
					}
				}
#endif
			}
			_pc = pc;
			pc = (PCHUNK)(pc->byData + pc->dwSize );
			if( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize  )
			{
				if( pc == _pc )
				{
					Log( "Current block is the same as the last block we checked!" );
					DebugDumpHeapMemEx( pHeap, 1 );
 // broken memory chain
					DebugBreak();
					break;
				}
				if( pc->pPrior != _pc )
				{
					ll_lprintf( "Block's prior is not the last block we checked! prior %p sz: %" _PTRSZVALfs " current: %p currentprior: %p"
						, _pc
						, _pc->dwSize
						, pc
						, pc->pPrior );
					DebugDumpHeapMemEx( pHeap, 1 );
					DebugBreak();
					break;
				}
			}
		}
		_pc = NULL;
		pc = pMemCheck->pFirstFree;
		while( pc )
		{
			if( pc->info.dwOwners )
  // owned block is in free memory chain ! ?
			{
				ll_lprintf( "Owned block %p is in free memory chain!", pc );
				DebugBreak();
				break;
			}
			_pc = pc;
			pc = pc->next;
		}
		//nSpaces++;
		pMemSpace = pMemSpace->next;
		DropMemEx( pMemCheck DBG_RELAY );
	}
	DropMemEx( pMem DBG_RELAY );
	//if( pMem->cs.dwLocks) {
	//	fprintf( stderr, "Locks is still set?\n");
	//	//DebugBreak();
	//}
	//fprintf( stderr, "Dropped Mem: %d %p\n", nLine, pMem );
	if( pFree )
		*pFree = (uint32_t)nFree;
	if( pUsed )
		*pUsed = (uint32_t)nUsed;
	if( pChunks )
		*pChunks = nChunks;
	if( pFreeChunks )
		*pFreeChunks = nFreeChunks;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStats( g.pMemInstance, pFree, pUsed, pChunks, pFreeChunks );
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS )
{
	LOGICAL prior = g.bLogAllocate;
#ifdef _DEBUG
	g.last_set_allocate = nLine;
#endif
	g.bDefaultLogAllocate = g.bLogAllocate = bTrueFalse;
	//_lprintf(DBG_RELAY)( "--------- USE CLEAR OR RESET LOGGING!" );
	return prior;
}
//------------------------------------------------------------------------------------------------------
int  ClearAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS )
{
	LOGICAL prior = g.bLogAllocate;
	g.nLogAllocateClears++;
#ifdef _DEBUG
	g.last_set_allocate = nLine;
#endif
	g.bLogAllocate = 0;
	return prior;
}
//------------------------------------------------------------------------------------------------------
int  ResetAllocateLoggingEx ( LOGICAL bTrueFalse DBG_PASS )
{
	LOGICAL prior = g.bLogAllocate;
#ifdef _DEBUG
	g.last_set_allocate = nLine;
#endif
	g.nLogAllocateClears--;
	if( !g.nLogAllocateClears )
		g.bLogAllocate = g.bDefaultLogAllocate;
	return prior;
}
//------------------------------------------------------------------------------------------------------
 int  SetCriticalLogging ( LOGICAL bTrueFalse )
{
#ifdef _DEBUG
	int prior = g.bLogCritical;
	g.bLogCritical = bTrueFalse;
	return prior;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateDebug ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableDebug;
	g.bDisableDebug = !bDisable;
	g.bDisableAutoCheck = !bDisable;
	return save;
#else
	return 1;
#endif
}
 int  SetManualAllocateCheck ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableAutoCheck;
	g.bDisableAutoCheck = bDisable;
	return save;
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  SetMinAllocate ( size_t nSize )
{
	g.nMinAllocateSize = nSize;
}
//------------------------------------------------------------------------------------------------------
 void  SetHeapUnit ( size_t dwSize )
{
	g.dwSystemCapacity = dwSize;
}
//------------------------------------------------------------------------------------------------------
#undef GetHeapMemStats
 void  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStatsEx( pHeap, pFree, pUsed, pChunks, pFreeChunks DBG_SRC );
}
#if 0
#  ifdef _MSC_VER
//>= 900
_CRT_ALLOC_HOOK prior_hook;
int allocHook(int allocType, void *userData, size_t size, int
blockType, long requestNumber, const unsigned char *filename, int
lineNumber)
{
	static int logging;
	if( logging )
		return TRUE;
	logging = 1;
	switch( allocType )
	{
	case _HOOK_ALLOC:
		ll_lprintf( "CRT Alloc: %d bytes %s(%d)"
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_REALLOC:
		ll_lprintf( "CRT Realloc: %d bytes %s(%d)"
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_FREE:
		ll_lprintf( ( "CRT Free: %p[%" _PTRSZVALfs "](%d) %s(%d)" )
			, userData
			, (uintptr_t)userData
			, size
			, filename, lineNumber
			);
		break;
	default:
		DebugBreak();
	}
	logging = 0;
	if( prior_hook )
		return prior_hook( allocType, userData, size, blockType, requestNumber, filename, lineNumber );
	return TRUE;
}
//int handle_program_memory_depletion( size_t )
//{
   // Your code
//}
PRELOAD( ShareMemToVSAllocHook )
{
	//_CRT_ALLOC_HOOK allocHook;
	//allocHook = 0 ;
	/* this is about useless... the free doesn't report the correct address
	* the allocate doesn't report the block
	* the free doesn't reprot the size
	* there is no way to relate what is freed with what is allocated
	*/
	//prior_hook = _CrtSetAllocHook(	allocHook );
	//_set_new_handler( pn );
}
#  endif
#endif
#ifdef __cplusplus
//namespace sack {
}
//	namespace memory {
}
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
SACK_MEMORY_NAMESPACE
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#if defined( __GNUC__ )
#  pragma GCC push_options
#  pragma GCC optimize ("O0")
#endif
void  MemSet ( POINTER p, uintptr_t n, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
#  if defined( _WIN64 )
	//__asm cld;
	__stosq( (uint64_t*)p, n, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#  else
#    ifdef __64__
	__stosq( (uint64_t*)p, n, sz / 4 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    else
	__stosd( (DWORD*)p, n, sz / 4 );
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    endif
#  endif
#elif defined( __GNUC__ )
	{
      uintptr_t tmp = (uintptr_t)p;
#  ifdef __64__
		{
			int m; int len = sz/8;
			for( m = 0; m < len; m++ ) {
				((uint64_t*)tmp)[0] = n;
				tmp += 8;
			}
		}
		if( sz & 4 )
			(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  else
		{
			int m; int len = sz/4;
			for( m = 0; m < len; m++ ) {
				((uint32_t*)tmp)[0] = n;
				tmp += 4;
			}
		}
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  endif
	}
#else
   memset( p, n, sz );
#endif
}
#if defined( __GNUC__ )
#  pragma GCC pop_options
#endif
int  MemChk ( POINTER p, uintptr_t val, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
	size_t n;
	uintptr_t *data = (uintptr_t*)p;
	for( n = 0; n < sz/sizeof(uintptr_t); n++, data++ )
		if( data[0] != val )
			return 0;
   return 1;
#else
	//   memset( p, n, sz );
   return 1;
#endif
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 void  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ )&& !defined( UNDER_CE )
#  ifdef _WIN64
	__movsq( (uint64_t*)pTo, (uint64_t*)pFrom, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)pTo) + sz - (sz&7) ) ) = (*(uint32_t*)( ((uintptr_t)pFrom) + sz - (sz&7) ) );
#  else
	__movsd( (DWORD*)pTo, (DWORD*)pFrom, sz/4 );
#  endif
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)pTo) + sz - (sz&3) ) ) = (*(uint16_t*)( ((uintptr_t)pFrom) + sz - (sz&3) ) );
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)pTo) + sz - (sz&1) ) ) = (*(uint8_t*)( ((uintptr_t)pFrom) + sz - (sz&1) ) );
#else
	memcpy( pTo, pFrom, sz );
#endif
}
int  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz )
{
   // zero byte comparison, always same.
	if( !sz )
      return 0;
	if( !pOne && !pTwo )
		return 0;
	if( !pOne )
 // NULL < "anything"
		return -1;
	if( !pTwo )
  // "anything" > NULL
		return 1;
	return memcmp( pOne, pTwo, sz );
}
TEXTSTR StrCpyEx( TEXTSTR s1, CTEXTSTR s2, size_t n )
{
	size_t x;
	if( !s1 ) return s1;
	if( !s2 ) { if( s1 ) { s1[0] = 0; return s1; } }
	for( x = 0; x < n && (s1[x]=s2[x]); x++ );
	if( n )
		s1[n-1] = 0;
	return s1;
}
#undef StrCpy
TEXTSTR StrCpy( TEXTSTR s1, CTEXTSTR s2 )
{
	int x;
	for( x = 0; (s1[x]=s2[x]); x++ );
	return s1;
}
CTEXTSTR StrChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
CTEXTSTR StrRChr( CTEXTSTR s1, TEXTRUNE c )
{
	TEXTRUNE c1;
	CTEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( GetUtfChar( &p1 ) )
		;
 // go back to \0
	p1--;
 // not a string, can't have a char in it.
	if( s1 == p1 ) return NULL;
	while( p1 != s1 && ( c1 = GetPriorUtfChar( s1, &p1 ) ) != c );
	if( c1 == c )
		return p1;
	return NULL;
}
const wchar_t* StrRChrW( const wchar_t* s1, TEXTRUNE c ) {
	TEXTRUNE c1;
	const wchar_t* p1 = s1;
	if( !p1 ) return NULL;
	while( GetUtfCharW( &p1 ) )
		;
 // go back to \0
	p1--;
	while( p1 != s1 && ( c1 = GetPriorUtfCharW( s1, &p1 ) ) != c );
	if( c1 == c )
		return p1;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
TEXTSTR StrRChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
wchar_t* StrRChrW( wchar_t* s1, TEXTRUNE c ) {
	TEXTRUNE c1;
	wchar_t* p1 = s1;
	if( !p1 ) return NULL;
	while( GetUtfCharW( (const wchar_t**)&p1 ) )
		;
 // go back to \0
	p1--;
	while( p1 != s1 && ( c1 = GetPriorUtfCharW( s1, (const wchar_t**) & p1) ) != c );
	if( c1 == c )
		return p1;
	return NULL;
}
#endif
CTEXTSTR StrCaseStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] ||
         (p1[0] == '/' && p2[0] == '\\' ) ||
         (p1[0] == '\\' && p2[0] == '/' ) ||
			(((p1[0] >='a' && p1[0] <='z' )?p1[0]-('a'-'A'):p1[0])
			 == ((p2[0] >='a' && p2[0] <='z' )?p2[0]-('a'-'A'):p2[0]) ))
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
CTEXTSTR StrStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrStr( TEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	TEXTSTR p1, began_at;
	CTEXTSTR p2;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
 // set began_at here too..
	began_at = p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#endif
//------------------------------------------------------------------------------------------------------
// result in 0(equal), 1 above, or -1 below
// *r contains the position of difference
 int  CmpMem8 ( void *s1, void *s2, unsigned long n, unsigned long *r )
{
	int t1, t2;
	uint32_t pos;
	{
		pos = 0;
		while( pos < n )
		{
			t1 = *(unsigned char*)s1;
			t2 = *(unsigned char*)s2;
			if( ( t1 ) == ( t2 ) ) {
				(pos)++;
				s1 = (void*)(((uintptr_t)s1) + 1);
				s2 = (void*)(((uintptr_t)s2) + 1);
			} else if( t1 > t2 ) {
				if( r )
					*r = pos;
				return 1;
			} else {
				if( r )
					*r = pos;
				return -1;
			}
		}
	}
	if( r )
		*r = pos;
	return 0;
}
//------------------------------------------------------------------------------------------------------
 TEXTSTR  StrDupEx ( CTEXTSTR original DBG_PASS )
{
	if( original )
	{
		uintptr_t len = (uintptr_t)StrLen( original ) + 1;
		TEXTCHAR *result;
		result = (TEXTCHAR*)AllocateEx( sizeof(TEXTCHAR)*len  DBG_RELAY );
		MemCpy( result, original, sizeof(TEXTCHAR)*len );
		return result;
	}
	return NULL;
}
size_t StrLen( CTEXTSTR s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++, s++);
	return l;
}
size_t StrBytesW( wchar_t const* s ) {
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0]; s++ ) {
		l += 2;
	}
	return l+2;
}
size_t StrBytesWu8( wchar_t const* s ) {
	size_t l;
	char ch[4];
	TEXTRUNE r;
	if( !s )
		return 0;
	for( l = 0; r = GetUtfCharW( &s ); s++ ) {
		l += ConvertToUTF8( ch, r );
	}
	return l + 1;
}
size_t CStrLen( char const* s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++,s++);
	return l;
}
#ifdef _UNICODE
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	return WcharConvertEx( original DBG_RELAY );
}
TEXTSTR  DupCStrEx ( const char * original DBG_PASS )
{
	if( original )
		return CharWConvertEx( original DBG_RELAY );
	return NULL;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	if( original )
		return CharWConvertExx( original, chars DBG_RELAY );
	return NULL;
}
#else
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	INDEX len;
	char *result;
	if( !original )
		return NULL;
	for( len = 0; original[len]; len++ );
	result = (char*)AllocateEx( (len+1) * sizeof( result[0] ) DBG_RELAY );
	len = 0;
	while( ( result[len] = original[len] ) != 0 ) len++;
	return result;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	size_t len = 0;
	TEXTSTR result, _result;
	if( !original )
		return NULL;
 /*NewArray( TEXTCHAR, chars + 1 );//*/
	_result = result = (TEXTSTR)AllocateEx( (chars + 1) * sizeof( result[0] )  DBG_RELAY );
	len = 0;
	while( len < chars ) ((*result++) = (*original++)), len++;
	result[0] = 0;
	return _result;
}
TEXTSTR  DupCStrEx( const char * original DBG_PASS )
{
	size_t len = 0;
	const char *_original;
	if( !original )
		return NULL;
	_original = original;
	while( (*original++) ) len++;
	return DupCStrLenEx( _original, len DBG_RELAY );
}
#endif
wchar_t *   DupTextToWideEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return CharWConvertEx( original DBG_RELAY );
#endif
}
char *     DupTextToCharEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return WcharConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupWideToTextEx( const wchar_t * original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return WcharConvertEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupCharToTextEx( const char * original DBG_PASS )
{
#ifdef _UNICODE
   return CharWConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
 int  StrCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ); s1++, s2++ );
	return s1[0] - s2[0];
}
 int  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) );
		  s1++, s2++ );
	return tolower(s1[0]) - tolower(s2[0]);
}
int  StrCaseCmp_u8u16( const char* s1, const wchar_t* s2 ) {
	TEXTRUNE c1;
	TEXTRUNE c2;
	if( !s1 )
		 if( s2 )
			 return -1;
		 else
			 return 0;
	 else
		 if( !s2 )
			 return 1;
	 //if( s1 == s2 )
	//	 return 0; // ==0 is success.
	 while( s1[0] && s2[0] ) {
		 c1 = GetUtfChar( &s1 );
		 c2 = GetUtfCharW( &s2 );
		 if( c1 >= 'a' && c1 <= 'z' ) c1 -= ( 'a' - 'A' );
		 if( c2 >= 'a' && c2 <= 'z' ) c2 -= ( 'a' - 'A' );
		 if( c1 != c2 ) break;
	 }
	 return c1-c2;
 }
int  StrCaseCmpEx_u8u16( const char* s1, const wchar_t* s2, size_t maxLen ) {
	TEXTRUNE c1;
	TEXTRUNE c2;
	if( !s1 )
		if( s2 ) return -1;
		else return 0;
	else
		if( !s2 ) return 1;
	while( maxLen-- && (c1 = GetUtfChar( &s1 )) && (c2 = GetUtfCharW( &s2 )) ) {
		if( c1 >= 'a' && c1 <= 'z' ) c1 -= ( 'a' - 'A' );
		if( c2 >= 'a' && c2 <= 'z' ) c2 -= ( 'a' - 'A' );
		if( c1 != c2 ) break;
	}
	return c1-c2;
 }
int  StrCaseCmpW( const wchar_t* s1, const wchar_t* s2 ) {
	TEXTRUNE c1;
	TEXTRUNE c2;
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	while( s1[0] && s2[0] ) {
		c1 = GetUtfCharW( &s1 );
		c2 = GetUtfCharW( &s2 );
		if( c1 >= 'a' && c1 <= 'z' ) c1 -= ( 'a' - 'A' );
		if( c2 >= 'a' && c2 <= 'z' ) c2 -= ( 'a' - 'A' );
		if( c1 != c2 ) break;
	}
	return c1 - c2;
}
 int  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ) && maxlen; s1++, s2++, maxlen-- );
	if( maxlen )
		return s1[0] - s2[0];
	return 0;
}
 int  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
 int  StriCmp ( CTEXTSTR pOne, CTEXTSTR pTwo )
{
   return -1;
}
SACK_MEMORY_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   Adds functionality of timers that run dispatched from a single thread
 *   timer delay is trackable to provide self adjusting reliable frequency dispatch.
 *
 *   RemoveTimer( AddTimer( tick_frequency, timer_callback, user_data ) );
 *
 */
//#define ENABLE_CRITICALSEC_LOGGING
#define NO_UNICODE_C
// this is a cheat to get the critical section
// object... otherwise we'd have had circular
// linking reference between this and sharemem
// which would prefer to implement wakeablesleep
// for critical section waiting...
// must be included before memlib..
//#undef UNICODE
#define MEMORY_STRUCT_DEFINED
#define DEFINE_MEMORY_STRUCT
//#define DEBUG_TIMER_RESCHEDULE
#define THREAD_STRUCTURE_DEFINED
 // Sleep()
 // SimpleRegisterAndCreateGlobal
// sorry if this causes problems...
// maybe promote this include into stdhdrs when this fails to compile
#ifdef __WATCOMC__
// _beginthread
#undef exit
#undef getenv
// process.h redefines exit
#include <process.h>
#endif
/* Provide a mechanism to register idle() callbacks. These are
   callbacks that might need to be called when a application is
   waiting for a result. This is utilized by code that wants to
   block its state, but requires other events on its own thread
   to still be dispatched. This will only dispatch events to
   proper threads to handle the idle callback.                  */
#ifndef IDLE_FUNCTIONS_DEFINED
#define IDLE_FUNCTIONS_DEFINED
# ifdef IDLE_SOURCE
#  define IDLE_PROC(type,name) EXPORT_METHOD type CPROC name
# else
#  define IDLE_PROC(type,name) IMPORT_METHOD type CPROC name
# endif
#ifdef __cplusplus
namespace sack {
	_TIMER_NAMESPACE
#endif
// return -1 if not the correct thread
// return 0 if no events processed
// return 1 if events were processed
typedef int (CPROC *IdleProc)(uintptr_t);
IDLE_PROC( void, AddIdleProc )( IdleProc Proc, uintptr_t psvUser );
IDLE_PROC( int, RemoveIdleProc )( IdleProc Proc );
IDLE_PROC( int, Idle )( void );
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds );
#ifdef __cplusplus
	_TIMER_NAMESPACE_END
 //SACK_NAMESPACE_END
}
using namespace sack::timers;
#endif
#endif
#ifndef __NO_OPTIONS__
#endif
#define DO_LOGGING
// display pause/resume support.
#ifndef __NO_GUI__
/* <link sack::image::render::PRENDERER, Render> provides a
   method to display images on a screen. It is the interface
   between memory images and the window desktop or frame buffer
   the user is viewing on a monitor.
   Under windows, this is implemented as an HWND and an HBITMAP
   used to allow the application to draw. Updates are done
   directly from the drawable surface to the HWND as appropriate
   for the type of service. This is implemented with Vidlib.dll.
   Under Linux, this is mounted against SDL. SDL, however, does
   not give multiple display surfaces, so a more direct method
   should be used someday, other than SDL does a good job of
   aliasing frame buffer and X display windows to a consistant
   interface. This is implemented wit DisplayLib (as yet outside
   of the documentation). Display lib can interface either
   directly, or be mounted as a service across from a shared
   memory message service, and host multiple applications on a
   single frame buffer surface.
   TODO
   Implement displays as direct X displays, and allow managment
   there under linux.
   Displaylib was a good project, and although suffers from
   code-rot, it is probably still mostly usable. Message
   services were easily transported across a network, but then
   location services started failing.
   Example
   <code lang="c++">
   // get a render display, just a default window of some size
   // extended features are available for more precision.
   Render render = OpenDisplay(0);
   </code>
   A few methods of using this surface are available. One, you
   may register for events, and be called as required.
   <code lang="c++">
   RedrawCallback MyDraw = DrawHandler;
   MouseCallback MyMouse;
   </code>
   <code>
   KeyProc MyKey;
   CloseCallback MyClose;
   </code>
   <code lang="c++">
   // called when the surface is initially shown, or when its surface changes.
   // otherwise, the image drawn by the application is static, and does
   // not get an update event.
   SetRedrawHandler( render, MyDraw, 0 );
   // This will get an event every time a mouse event happens.
   // If no Key handler is specified, key strokes will also be mouse events.
   SetMouseHandler( render, MyMouse, 0 );
   // If the window was closed, get an event.
   SetCloseHandler( render, MyClose, 0 );
   // specify a handler to get keyboard events...
   SetKeyboardHandler( render, MyKey, 0 );
   </code>
   Or, if you don't really care about any events...
   <code lang="c++">
   // load an image
   Image image = LoadImageFile( "sample.jpg" );
   // get the image target of render
   Image display = GetDisplayImage( render );
   // copy the loaded image to the display image
   BlotImage( display, image );
   // and update the display
   UpdateDisplay( render );
   </code>
   <code lang="c++">
   void CPROC DrawHandler( uintptr_t psvUserData, 31~PRENDERER render )
   {
       Image display = GetDisplayImage( render );
       // the display image may change, because of an external resize
       // update the image to display as desired...
       // when done, the draw handler should call UpdateDisplay or...
       UpdateDisplayPortion( render, 0, 0, 100, 100 );
   }
   </code>
   Oh! And most importantly! Have to call this to put the window
   on the screen.
   <code lang="c++">
   UpdateDisplay( render );
   </code>
   Or maybe can pretend it was hidden
   <code lang="c++">
   RestoreDisplay( render );
   </code>                                                                     */
// this shouldprobably be interlocked with
//  display.h or vidlib.h(video.h)
#ifndef RENDER_INTERFACE_INCLUDED
// multiple inclusion protection symbol.
#define RENDER_INTERFACE_INCLUDED
#ifdef __cplusplus
#ifdef _D3D_DRIVER
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d {
#define _RENDER_NAMESPACE namespace render { namespace d3d {
#define RENDER_NAMESPACE_END }}}}
#define RENDER_EXTRA_CLOSE
#elif defined( _D3D10_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d10 {
#define _RENDER_NAMESPACE namespace render { namespace d3d10 {
#define RENDER_NAMESPACE_END }}}}
#define RENDER_EXTRA_CLOSE
#elif defined( _D3D11_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d11 {
#define _RENDER_NAMESPACE namespace render { namespace d3d11 {
#define RENDER_NAMESPACE_END }}}}
#define RENDER_EXTRA_CLOSE
#else
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render {
/* <copy render.h>
   \ \             */
#define _RENDER_NAMESPACE namespace render {
#define RENDER_NAMESPACE_END }}}
#endif
#else
#define RENDER_NAMESPACE
#define _RENDER_NAMESPACE
#define RENDER_NAMESPACE_END
#endif
/* Define symbols for keyboard inputs on various systems. */
#ifndef KEYBOARD_DEFINITION
#  define KEYBOARD_DEFINITION
#  ifdef __cplusplus
#    define _RENDER_KEYBOARD_NAMESPACE namespace keyboard {
#    define _RENDER_KEYBOARD_NAMESPACE_END }
#  else
#    define _RENDER_KEYBOARD_NAMESPACE
#    define _RENDER_KEYBOARD_NAMESPACE_END
#  endif
RENDER_NAMESPACE
   _RENDER_KEYBOARD_NAMESPACE
			/* Keyboard state tracking structure... not very optimal...
			   \internal usage might be different.                      */
			enum KeyUpDownState {
KEYISUP   =2,
KEYISDOWN =1
			};
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag KEYBOARD;
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag *PKEYBOARD;
struct keyboard_tag
{
#define NUM_KEYS 256
   /* one byte index... more than sufficient
      if character in array is '1' key is down, '2' key is up. */
   char keyupdown[NUM_KEYS];
   /* Indicator that the key is a double-tap, not just a single.
      "!! is different that "!" "!                               */
   char keydouble[NUM_KEYS];
   /* time of the last key event */
   unsigned int  keytime[NUM_KEYS];
   /* I'm not sure, maybe it's the printable key char? */
		unsigned char key[NUM_KEYS];
#if 0
	// void (*Proc)(uintptr_t psv)[NUM_KEYS][8];
#endif
};
_RENDER_KEYBOARD_NAMESPACE_END
RENDER_NAMESPACE_END
#ifdef __cplusplus
#  ifdef _D3D_DRIVER
     using namespace sack::image::render::d3d::keyboard;
#  elif defined( _D3D10_DRIVER )
     using namespace sack::image::render::d3d10::keyboard;
#  elif defined( _D3D11_DRIVER )
     using namespace sack::image::render::d3d11::keyboard;
#  else
     using namespace sack::image::render::keyboard;
#  endif
#endif
//#include "vidlib.h"
	// some common things which are specific to this
   // library, and independant of implementation (so far)
#define KEY_MOD_SHIFT 1
#define KEY_MOD_CTRL  2
#define KEY_MOD_ALT   4
#define KEY_MOD_META  64
// call trigger on release also...
#define KEY_MOD_RELEASE  8
 // application wants both press and release events.
#define KEY_MOD_ALL_CHANGES  16
//#define KEY_MOD_EXTENDED 32 // key match must be extended also... (extra arrow keys for instance.. what about SDL)
 // key match must be extended also... (extra arrow keys for instance.. what about SDL)
#define KEY_MOD_EXTENDED 256
#define KEY_PRESSED         0x80000000
#define IsKeyPressed( keycode ) ( (keycode) & 0x80000000 )
#define KEY_ALT_DOWN        0x40000000
#define KEY_CONTROL_DOWN    0x20000000
#define KEY_SHIFT_DOWN      0x10000000
#define KEY_MOD_DOWN (KEY_ALT_DOWN|KEY_CONTROL_DOWN)
#define KEY_ALPHA_LOCK_ON   0x08000000
#define KEY_NUM_LOCK_ON     0x04000000
#define KEY_MOD(key)        ( ( (key) & 0x70000000 ) >> 28 )
#define KEY_REAL_CODE(key)  ( ( (key) & 0x00FF0000 ) >> 16 )
#define KEY_CODE(key)       ( (key) & 0xFF )
#define IsKeyExtended(key)  ( ( (key) & 0x00000100 ) >> 8 )
#if defined( _WIN32 ) || defined( WIN32 ) || defined( __CYGWIN__ ) || defined( USE_WIN32_KEY_DEFINES )
// mirrored KEY_ definitions from allegro.H library....
//#include <windows.h>
#  define BIT_7           0x80
#  define KEY_TAB          9
#  define KEY_CENTER       12
#  define KEY_KP5       12
#  define KEY_PAD5         12
#  define KEY_ENTER        13
#  define KEY_LSHIFT       16
#  define KEY_SHIFT        16
#  define KEY_LEFT_SHIFT   0x10
 // maybe?
#  define KEY_RIGHT_SHIFT  0x10
#  define KEY_SHIFT_LEFT KEY_LEFT_SHIFT
#  define KEY_SHIFT_RIGHT KEY_RIGHT_SHIFT
#  define KEY_CTRL         17
#  define KEY_CONTROL      17
#  define KEY_LEFT_CONTROL  17
#  define KEY_RIGHT_CONTROL 17
 // can't get usually under windows?(keyhook!)
#  define KEY_ALT          18
#  define KEY_LEFT_ALT      18
#  define KEY_RIGHT_ALT     18
#  define KEY_CAPS_LOCK    20
#  define KEY_ESC          27
#  define KEY_ESCAPE       27
#  define KEY_PGUP         33
#  define KEY_PAGE_UP     KEY_PGUP
#  define KEY_PGDN         34
#  define KEY_PAGE_DOWN   KEY_PGDN
#  define KEY_END          35
#  define KEY_HOME         36
#  define KEY_LEFT         37
#  define KEY_UP           38
#  define KEY_RIGHT        39
#  define KEY_DOWN         40
#  define KEY_GRAY_UP  38
#  define KEY_GRAY_LEFT   37
#  define KEY_GRAY_RIGHT  39
#  define KEY_GRAY_DOWN    40
//#  define KEY_GRAY_UP      BIT_7+0x48
#  define KEY_GRAY_PGUP   BIT_7+0x49
#  define KEY_GRAY_MINUS  BIT_7+0x4A
//#  define KEY_GRAY_LEFT BIT_7+0x4B
//#  define KEY_GRAY_RIGHT   BIT_7+0x4D
#  define KEY_GRAY_PLUS   BIT_7+0x4E
#  define KEY_GRAY_END    BIT_7+0x4F
#  define KEY_PAD_PLUS   BIT_7+0x4E
//#  define KEY_GRAY_DOWN BIT_7+0x50
#  define KEY_GRAY_PGDN   BIT_7+0x51
#  define KEY_GRAY_INS    BIT_7+0x52
#  define KEY_GRAY_DEL    BIT_7+0x53
#  define KEY_GRAY_DELETE    BIT_7+0x53
#  define KEY_GREY_DELETE    BIT_7+0x53
#  define KEY_INSERT       45
#  define KEY_DEL          46
#  define KEY_DELETE       KEY_DEL
#  define KEY_PRINT_SCREEN1  VK_PRINT
#  define KEY_PRINT_SCREEN2  VK_SNAPSHOT
 // windows keys keys
#  define KEY_WINDOW_2     0x50
 // windows keys keys
#  define KEY_WINDOW_1     0x5c
#  define KEY_GRAY_STAR     0x6a
#  define KEY_PLUS_PAD     0x6b
//#  define KEY_GRAY_MINUS    0x6d
#  define KEY_GRAY_SLASH    VK_OEM_5
//#  define KEY_GRAY_PLUS     107
#  define KEY_NUM_LOCK      VK_NUMLOCK
#  define KEY_SCROLL_LOCK VK_SCROLL
#  define KEY_SLASH        VK_OEM_2
#  define KEY_BACKSPACE   '\b'
#  define KEY_SPACE        ' '
#  define KEY_COMMA      0xBC
 // should be some sort of VK_ definitions....
#  define KEY_STOP       0xBE
#  define KEY_PERIOD     KEY_STOP
#  define KEY_A         'A'
#  define KEY_B         'B'
#  define KEY_C         'C'
#  define KEY_D         'D'
#  define KEY_E         'E'
#  define KEY_F         'F'
#  define KEY_G         'G'
#  define KEY_H         'H'
#  define KEY_I         'I'
#  define KEY_J         'J'
#  define KEY_K         'K'
#  define KEY_L         'L'
#  define KEY_F12  VK_F12
#  define KEY_F11  VK_F11
#  define KEY_F10  VK_F10
#  define KEY_F9  VK_F9
#  define KEY_F8  VK_F8
#  define KEY_F7  VK_F7
#  define KEY_F6  VK_F6
#  define KEY_F5  VK_F5
#  define KEY_F4  VK_F4
#  define KEY_F3  VK_F3
#  define KEY_F2  VK_F2
#  define KEY_F1  VK_F1
#  define KEY_M        77
#  define KEY_N         78
#  define KEY_O         79
#  define KEY_P        80
#  define KEY_Q         'Q'
#  define KEY_R         'R'
#  define KEY_S         'S'
#  define KEY_T         'T'
#  define KEY_U         'U'
#  define KEY_V         'V'
#  define KEY_W         'W'
#  define KEY_X         'X'
#  define KEY_Y         'Y'
#  define KEY_Z         'Z'
#  define KEY_1         '1'
#  define KEY_2         '2'
#  define KEY_3         '3'
#  define KEY_4         '4'
#  define KEY_5         '5'
#  define KEY_6         '6'
#  define KEY_7         '7'
#  define KEY_8         '8'
#  define KEY_9         '9'
#  define KEY_0         '0'
#  define KEY_MINUS    KEY_DASH
#  ifndef VK_OEM_1
// native windows OEM definitions
#    define VK_OEM_1   186
#    define VK_OEM_2   191
#    define VK_OEM_4   219
#    define VK_OEM_5   220
#    define VK_OEM_6   221
#    define VK_OEM_7   222
#    define VK_OEM_MINUS  189
#    define VK_OEM_PLUS    187
#  endif
#  define KEY_SEMICOLON     VK_OEM_1
#  define KEY_QUOTE         VK_OEM_7
#  define KEY_LEFT_BRACKET  VK_OEM_4
#  define KEY_RIGHT_BRACKET VK_OEM_6
#  define KEY_BACKSLASH     VK_OEM_5
//'-'
#  define KEY_DASH     VK_OEM_MINUS
#  define KEY_EQUAL    VK_OEM_PLUS
#  define KEY_EQUALS   KEY_EQUAL
#  define KEY_ACCENT 192
#  define KEY_GRAVE  KEY_ACCENT
#  define KEY_APOSTROPHE  KEY_ACCENT
#  define KEY_F1  VK_F1
#  define KEY_F2  VK_F2
#  define KEY_F3  VK_F3
#  define KEY_F4  VK_F4
#  define KEY_F5  VK_F5
#  define KEY_F6  VK_F6
#  define KEY_F7  VK_F7
#  define KEY_F8  VK_F8
#  define KEY_F9  VK_F9
#  define KEY_F10  VK_F10
#  define KEY_F1  VK_F1
#  define VK_NUMPAD0        0x60
#  define VK_NUMPAD1        0x61
#  define VK_NUMPAD2        0x62
#  define VK_NUMPAD3        0x63
#  define VK_NUMPAD4        0x64
#  define VK_NUMPAD5        0x65
#  define VK_NUMPAD6        0x66
#  define VK_NUMPAD7        0x67
#  define VK_NUMPAD8        0x68
#  define VK_NUMPAD9        0x69
#  define VK_MULTIPLY       0x6A
#  define VK_ADD            0x6B
#  define VK_SEPARATOR      0x6C
#  define VK_SUBTRACT       0x6D
#  define VK_DECIMAL        0x6E
#  define VK_DIVIDE         0x6F
#  define KEY_PAD_MULT VK_MULTIPLY
#  define KEY_PAD_DOT VK_DECIMAL
#  define KEY_PAD_DIV VK_DIVIDE
#  define KEY_PAD_0 VK_NUMPAD0
#  define KEY_GREY_INSERT VK_NUMPAD0
#  define KEY_PAD_1 VK_NUMPAD1
#  define KEY_PAD_2 VK_NUMPAD2
#  define KEY_PAD_3 VK_NUMPAD3
#  define KEY_PAD_4 VK_NUMPAD4
#  define KEY_PAD_5 VK_NUMPAD5
#  define KEY_PAD_6 VK_NUMPAD6
#  define KEY_PAD_7 VK_NUMPAD7
#  define KEY_PAD_8 VK_NUMPAD8
#  define KEY_PAD_9 VK_NUMPAD9
#  define KEY_PAD_ENTER VK_RETURN
#  define KEY_PAD_DELETE VK_SEPARATOR
#  define KEY_PAD_MINUS VK_SUBTRACT
#endif
#if defined( __EMSCRIPTEN__ ) || defined( __EMSCRIPTEN__ )
	  /*   https://w3c.github.io/uievents/#fixed-virtual-key-codes
      // for keyCode
      */
#define KEY_BACKSPACE 8
#define KEY_TAB 9
#define KEY_ENTER 13
#define KEY_SHIFT 16
#define KEY_LEFT_SHIFT 16
#define KEY_RIGHT_SHIFT 16
#define KEY_CTRL 17
#define KEY_CONTROL 17
#define KEY_LEFT_CONTROL 17
#define KEY_RIGHT_CONTROL 17
#define KEY_ALT 18
#define KEY_LEFT_ALT 18
#define KEY_RIGHT_ALT 18
#define KEY_F1  112
#define KEY_F2  113
#define KEY_F3  114
#define KEY_F4  115
#define KEY_F5  116
#define KEY_F6  117
#define KEY_F7  118
#define KEY_F8  119
#define KEY_F9  120
#define KEY_F10  121
#define KEY_F11  122
#define KEY_F12  123
#  undef KEY_SPACE
#  define KEY_SPACE        ' '
#  define KEY_A         'A'
#  define KEY_B         'B'
#  define KEY_C         'C'
#  define KEY_D         'D'
#  define KEY_E         'E'
#  define KEY_F         'F'
#  define KEY_G         'G'
#  define KEY_H         'H'
#  define KEY_I         'I'
#  define KEY_J         'J'
#  define KEY_K         'K'
#  define KEY_L         'L'
#  define KEY_M        77
#  define KEY_N         78
#  define KEY_O         79
#  define KEY_P        80
#  define KEY_Q         'Q'
#  define KEY_R         'R'
#  define KEY_S         'S'
#  define KEY_T         'T'
#  define KEY_U         'U'
#  define KEY_V         'V'
#  define KEY_W         'W'
#  define KEY_X         'X'
#  define KEY_Y         'Y'
#  define KEY_Z         'Z'
#  define KEY_1         '1'
#  define KEY_2         '2'
#  define KEY_3         '3'
#  define KEY_4         '4'
#  define KEY_5         '5'
#  define KEY_6         '6'
#  define KEY_7         '7'
#  define KEY_8         '8'
#  define KEY_9         '9'
#  define KEY_0         '0'
   //';'
#define KEY_SEMICOLON	186
   //':'
#define KEY_COLON	    186
  //'='	//187
#define KEY_EQUAL        187
  //'+'	//187
#define KEY_PLUS	     187
   //','	//188
#define KEY_COMMA	      188
     //'<'		//188
#define KEY_LESS_THAN	188
     //'-'		//189
#define KEY_MINUS	     189
    //'-'       //189
#define KEY_DASH         189
  //'_'		//189
#define KEY_Underscore	189
   //'.'		//190
#define KEY_STOP	     190
   //'.'		//190
#define KEY_PERIOD	     190
   //'>'		//190
#define KEY_GREATER_THAN	190
    //'/'		//191
#define KEY_SLASH	   191
   //'?'		//191
#define KEY_QUESTION	191
 //'`'		//192
#define KEY_ACCENT	     192
 //'~'		//192
#define KEY_TILDE	    192
  //'['		//219
#define KEY_LEFT_BRACKET	219
  //'{'		//219
#define KEY_OPEN_BRACE	219
  //'\\'		//220
#define KEY_BACKSLASH	220
 //'|'		//220
#define KEY_PIPE	     220
//']'		//221
#define KEY_RIGHT_BRACKET	221
//	'}'		//221
#define KEY_CLOSE_BRACE     221
   //'\''		//222
#define KEY_QUOTE	222
//Double quote	'\"'		//222
#  define KEY_ESCAPE       27
#  define KEY_PGUP         33
#  define KEY_PAGE_UP      33
#  define KEY_PGDN         34
#  define KEY_PAGE_DOWN    34
#  define KEY_END          35
#  define KEY_HOME         36
#  define KEY_LEFT         37
#  define KEY_UP           38
#  define KEY_RIGHT        39
#  define KEY_DOWN         40
#  define KEY_GRAY_UP  38
#  define KEY_GRAY_LEFT   37
#  define KEY_GRAY_RIGHT  39
#  define KEY_GRAY_DOWN    40
//#  define KEY_GRAY_UP      0x48
#  define KEY_GRAY_PGUP     33
#  define KEY_GRAY_MINUS    109
//#  define KEY_GRAY_LEFT 0x4B
//#  define KEY_GRAY_RIGHT   0x4D
#  define KEY_GRAY_PLUS   107
#  define KEY_GRAY_END    0x4F
#  define KEY_PAD_PLUS   107
//#  define KEY_GRAY_DOWN 0x50
#  define KEY_GRAY_PGDN   34
#  define KEY_GRAY_INS    45
#  define KEY_GRAY_INSERT    45
#  define KEY_GREY_INSERT   45
#  define KEY_GRAY_DEL       46
#  define KEY_GRAY_DELETE    46
#  define KEY_GREY_DELETE    47
#  define KEY_INSERT       45
#  define KEY_DEL          46
#  define KEY_DELETE       KEY_DEL
#  define KEY_PAD_MULT 106
#  define KEY_PAD_DOT  110
#  define KEY_PAD_DELETE 110
#  define KEY_PAD_DIV 111
#  define KEY_PAD_0 96
#  define KEY_PAD_1 97
#  define KEY_PAD_2 98
#  define KEY_PAD_3 99
#  define KEY_PAD_4 100
#  define KEY_PAD_5 101
#  define KEY_PAD_6 102
#  define KEY_PAD_7 103
#  define KEY_PAD_8 104
#  define KEY_PAD_9 105
#  define KEY_PAD_ENTER KEY_ENTER
#  define KEY_PAD_MINUS 109
#define KEY_NUM_LOCK 144
#undef KEY_SCROLL_LOCK
#define KEY_SCROLL_LOCK 145
     /*   https://w3c.github.io/uievents/#fixed-virtual-key-codes
     Backspace	8
Tab	9
Enter	13
Shift	16
Control	17
Alt	18
CapsLock	20
Escape	27	Esc
Space	32
PageUp	33
PageDown	34
End	35
Home	36
ArrowLeft	37
ArrowUp	38
ArrowRight	39
ArrowDown	40
Delete	46	Del
Semicolon	";"	186
Colon	":"	186
Equals sign	"="	187
Plus	"+"	187
Comma	","	188
Less than sign	"<"	188
Minus	"-"	189
Underscore	"_"	189
Period	"."	190
Greater than sign	">"	190
Forward slash	"/"	191
Question mark	"?"	191
Backtick	"`"	192
Tilde	"~"	192
Opening squace bracket	"["	219
Opening curly brace	"{"	219
Backslash	"\"	220
Pipe	"|"	220
Closing square bracket	"]"	221
Closing curly brace	"}"	221
Single quote	"'"	222
Double quote	"""	222
     */
#  endif
// if any key...
#if 1 || !defined( KEY_1 )
#  if defined( __ANDROID__ )
#    include <android/keycodes.h>
#    define KEY_SHIFT        AKEYCODE_SHIFT_LEFT
#    define KEY_LEFT_SHIFT   AKEYCODE_SHIFT_LEFT
 // maybe?
#    define KEY_RIGHT_SHIFT  AKEYCODE_SHIFT_RIGHT
#    ifndef AKEYCODE_CTRL_LEFT
#      define AKEYCODE_CTRL_LEFT 113
#    endif
#    ifndef AKEYCODE_CTRL_RIGHT
#      define AKEYCODE_CTRL_RIGHT 114
#    endif
#    define KEY_CTRL          AKEYCODE_CTRL_LEFT
#    define KEY_CONTROL       AKEYCODE_CTRL_LEFT
#    define KEY_LEFT_CONTROL  AKEYCODE_CTRL_LEFT
#    define KEY_RIGHT_CONTROL AKEYCODE_CTRL_RIGHT
 // can't get usually under windows?(keyhook!)
#    define KEY_ALT           AKEYCODE_ALT_LEFT
#    define KEY_LEFT_ALT      AKEYCODE_ALT_LEFT
#    define KEY_RIGHT_ALT     AKEYCODE_ALT_RIGHT
#    ifndef AKEYCODE_CAPS_LOCK
#      define AKEYCODE_CAPS_LOCK 115
#    endif
#    define KEY_CAPS_LOCK     AKEYCODE_CAPS_LOCK
#    define KEY_NUM_LOCK      0
#    ifndef AKEYCODE_SCROLL_LOCK
#      define AKEYCODE_SCROLL_LOCK 116
#    endif
 // unsure about this
#    define KEY_SCROLL_LOCK   AKEYCODE_SCROLL_LOCK
#    ifndef AKEYCODE_ESCAPE
#      define AKEYCODE_ESCAPE 111
#    endif
#    define KEY_ESC           AKEYCODE_ESCAPE
#    define KEY_ESCAPE        AKEYCODE_ESCAPE
#    ifndef AKEYCODE_MOVE_HOME
#      define AKEYCODE_MOVE_HOME 122
#    endif
#    ifndef AKEYCODE_MOVE_END
#      define AKEYCODE_MOVE_END 123
#    endif
#    define KEY_HOME          AKEYCODE_MOVE_HOME
#    define KEY_PAD_HOME      AKEYCODE_MOVE_HOME
#    define KEY_PAD_7         0
#    define KEY_GREY_HOME     0
#    define KEY_UP            AKEYCODE_DPAD_UP
#    define KEY_PAD_8         0
#    define KEY_PAD_UP        0
#    define KEY_GREY_UP       0
#    define KEY_PGUP          0
#    define KEY_PAD_9         0
#    define KEY_PAD_PGUP      0
#    define KEY_GREY_PGUP     0
#    define KEY_LEFT          AKEYCODE_DPAD_LEFT
#    define KEY_PAD_4         0
#    define KEY_PAD_LEFT      0
#    define KEY_GREY_LEFT     0
#    define KEY_CENTER        AKEYCODE_DPAD_CENTER
#    define KEY_PAD_5         0
#    define KEY_PAD_CENTER    0
#    define KEY_GREY_CENTER   0
#    define KEY_RIGHT         AKEYCODE_DPAD_RIGHT
#    define KEY_PAD_6         0
#    define KEY_PAD_RIGHT     0
#    define KEY_GREY_RIGHT    0
#    define KEY_END           AKEYCODE_MOVE_END
#    define KEY_PAD_1         0
#    define KEY_PAD_END       0
#    define KEY_GREY_END      0
#    define KEY_DOWN          AKEYCODE_DPAD_DOWN
#    define KEY_PAD_2         0
#    define KEY_PAD_DOWN      0
#    define KEY_GREY_DOWN     0
#    define KEY_PGDN          0
#    define KEY_PAD_3         0
#    define KEY_PAD_PGDN      0
#    define KEY_GREY_PGDN     0
#    define KEY_INSERT        0
#    define KEY_PAD_0         0
#    define KEY_PAD_INSERT    0
#    define KEY_GREY_INSERT   0
#    define KEY_DELETE        0
#    define KEY_PAD_DOT       0
#    define KEY_PAD_DELETE    0
#    define KEY_GREY_DELETE   0
#    define KEY_PLUS          0
#    define KEY_PAD_PLUS      0
#    define KEY_GREY_PLUS     0
#    define KEY_MINUS         0
#    define KEY_PAD_MINUS     0
#    define KEY_GREY_MINUS    0
#    define KEY_MULT          0
#    define KEY_PAD_MULT      0
#    define KEY_GREY_MULT     0
#    define KEY_DIV           0
#    define KEY_PAD_DIV       0
#    define KEY_GREY_DIV      0
#    define KEY_ENTER         AKEYCODE_ENTER
#    define KEY_PAD_ENTER     AKEYCODE_ENTER
#    define KEY_NORMAL_ENTER  AKEYCODE_ENTER
 // windows keys keys
#    define KEY_WINDOW_1      0
 // windows keys keys
#    define KEY_WINDOW_2      0
#    define KEY_TAB           AKEYCODE_TAB
#    define KEY_SLASH         AKEYCODE_SLASH
#    define KEY_BACKSPACE     AKEYCODE_DEL
#    define KEY_SPACE         AKEYCODE_SPACE
#    define KEY_COMMA         AKEYCODE_COMMA
 // should be some sort of VK_ definitions....
#    define KEY_STOP          AKEYCODE_PERIOD
#    define KEY_PERIOD        AKEYCODE_PERIOD
#    define KEY_SEMICOLON     AKEYCODE_SEMICOLON
#    define KEY_QUOTE         AKEYCODE_APOSTROPHE
#    define KEY_LEFT_BRACKET  AKEYCODE_LEFT_BRACKET
#    define KEY_RIGHT_BRACKET AKEYCODE_RIGHT_BRACKET
#    define KEY_BACKSLASH     AKEYCODE_BACKSLASH
#    define KEY_DASH          AKEYCODE_MINUS
#    define KEY_EQUAL         AKEYCODE_EQUALS
#    define KEY_ACCENT        AKEYCODE_GRAVE
#    define KEY_1         AKEYCODE_1
#    define KEY_2         AKEYCODE_2
#    define KEY_3         AKEYCODE_3
#    define KEY_4         AKEYCODE_4
#    define KEY_5         AKEYCODE_5
#    define KEY_6         AKEYCODE_6
#    define KEY_7         AKEYCODE_7
#    define KEY_8         AKEYCODE_8
#    define KEY_9         AKEYCODE_9
#    define KEY_0         AKEYCODE_0
#    define KEY_F1        0
#    define KEY_F2        0
#    define KEY_F3        0
#    define KEY_F4        0
#    define KEY_F5        0
#    define KEY_F6        0
#    define KEY_F7        0
#    define KEY_F8        0
#    define KEY_F9        0
#    define KEY_F10       0
#    define KEY_F11       0
#    define KEY_F12       0
#    define KEY_A   AKEYCODE_A
#    define KEY_B   AKEYCODE_B
#    define KEY_C   AKEYCODE_C
#    define KEY_D   AKEYCODE_D
#    define KEY_E   AKEYCODE_E
#    define KEY_F   AKEYCODE_F
#    define KEY_G   AKEYCODE_G
#    define KEY_H   AKEYCODE_H
#    define KEY_I   AKEYCODE_I
#    define KEY_J   AKEYCODE_J
#    define KEY_K   AKEYCODE_K
#    define KEY_L   AKEYCODE_L
#    define KEY_M   AKEYCODE_M
#    define KEY_N   AKEYCODE_N
#    define KEY_O   AKEYCODE_O
#    define KEY_P   AKEYCODE_P
#    define KEY_Q   AKEYCODE_Q
#    define KEY_R   AKEYCODE_R
#    define KEY_S   AKEYCODE_S
#    define KEY_T   AKEYCODE_T
#    define KEY_U   AKEYCODE_U
#    define KEY_V   AKEYCODE_V
#    define KEY_W   AKEYCODE_W
#    define KEY_X   AKEYCODE_X
#    define KEY_Y   AKEYCODE_Y
#    define KEY_Z   AKEYCODE_Z
#  elif defined( __LINUX__ ) && !defined( __MAC__ ) && !defined( __ANDROID__ ) && !defined( USE_WIN32_KEY_DEFINES )
/* THis is a literal copy of bba013e1ca5e7150b42a1a1a1e852010d772edad / include/uapi/linux/input-event-codes.h
  from github.  Other than this leading comment it is the original copy; this is included as a fallback for linux
  systems (CentOS) which have a linux kernel older than 3.19; otherwise this would have been found in /usr/include/linux
  This file will not be updated further.
*/
/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
/*
 * Input event codes
 *
 *    *** IMPORTANT ***
 * This file is not only included from C-code but also from devicetree source
 * files. As such this file MUST only contain comments and defines.
 *
 * Copyright (c) 1999-2002 Vojtech Pavlik
 * Copyright (c) 2015 Hans de Goede <hdegoede@redhat.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by
 * the Free Software Foundation.
 */
#ifndef _UAPI_INPUT_EVENT_CODES_H
#define _UAPI_INPUT_EVENT_CODES_H
/*
 * Device properties and quirks
 */
#define INPUT_PROP_POINTER		0x00
#define INPUT_PROP_DIRECT		0x01
#define INPUT_PROP_BUTTONPAD		0x02
#define INPUT_PROP_SEMI_MT		0x03
#define INPUT_PROP_TOPBUTTONPAD		0x04
#define INPUT_PROP_POINTING_STICK	0x05
#define INPUT_PROP_ACCELEROMETER	0x06
#define INPUT_PROP_MAX			0x1f
#define INPUT_PROP_CNT			(INPUT_PROP_MAX + 1)
/*
 * Event types
 */
#define EV_SYN			0x00
#define EV_KEY			0x01
#define EV_REL			0x02
#define EV_ABS			0x03
#define EV_MSC			0x04
#define EV_SW			0x05
#define EV_LED			0x11
#define EV_SND			0x12
#define EV_REP			0x14
#define EV_FF			0x15
#define EV_PWR			0x16
#define EV_FF_STATUS		0x17
#define EV_MAX			0x1f
#define EV_CNT			(EV_MAX+1)
/*
 * Synchronization events.
 */
#define SYN_REPORT		0
#define SYN_CONFIG		1
/* Linux Event Code Synchronization Event */
#define SYN_MT_REPORT		2
#define SYN_DROPPED		3
#define SYN_MAX			0xf
#define SYN_CNT			(SYN_MAX+1)
/*
 * Keys and buttons
 *
 * Most of the keys/buttons are modeled after USB HUT 1.12
 * (see http://www.usb.org/developers/hidpage).
 * Abbreviations in the comments:
 * AC - Application Control
 * AL - Application Launch Button
 * SC - System Control
 */
#define KEY_RESERVED		0
#define KEY_ESC			1
#define KEY_1			2
#define KEY_2			3
#define KEY_3			4
#define KEY_4			5
#define KEY_5			6
#define KEY_6			7
#define KEY_7			8
#define KEY_8			9
#define KEY_9			10
#define KEY_0			11
#define KEY_MINUS		12
#define KEY_EQUAL		13
#define KEY_BACKSPACE		14
#define KEY_TAB			15
#define KEY_Q			16
#define KEY_W			17
#define KEY_E			18
#define KEY_R			19
#define KEY_T			20
#define KEY_Y			21
#define KEY_U			22
#define KEY_I			23
#define KEY_O			24
#define KEY_P			25
#define KEY_LEFTBRACE		26
#define KEY_RIGHTBRACE		27
#define KEY_ENTER		28
#define KEY_LEFTCTRL		29
#define KEY_A			30
#define KEY_S			31
#define KEY_D			32
#define KEY_F			33
#define KEY_G			34
#define KEY_H			35
#define KEY_J			36
#define KEY_K			37
#define KEY_L			38
#define KEY_SEMICOLON		39
#define KEY_APOSTROPHE		40
#define KEY_GRAVE		41
#define KEY_LEFTSHIFT		42
#define KEY_BACKSLASH		43
#define KEY_Z			44
#define KEY_X			45
#define KEY_C			46
#define KEY_V			47
#define KEY_B			48
#define KEY_N			49
#define KEY_M			50
#define KEY_COMMA		51
#define KEY_DOT			52
#define KEY_SLASH		53
#define KEY_RIGHTSHIFT		54
#define KEY_KPASTERISK		55
#define KEY_LEFTALT		56
#define KEY_SPACE		57
#define KEY_CAPSLOCK		58
#define KEY_F1			59
#define KEY_F2			60
#define KEY_F3			61
#define KEY_F4			62
#define KEY_F5			63
#define KEY_F6			64
#define KEY_F7			65
#define KEY_F8			66
#define KEY_F9			67
#define KEY_F10			68
#define KEY_NUMLOCK		69
#define KEY_SCROLLLOCK		70
#define KEY_KP7			71
#define KEY_KP8			72
#define KEY_KP9			73
#define KEY_KPMINUS		74
#define KEY_KP4			75
#define KEY_KP5			76
#define KEY_KP6			77
#define KEY_KPPLUS		78
#define KEY_KP1			79
#define KEY_KP2			80
#define KEY_KP3			81
#define KEY_KP0			82
#define KEY_KPDOT		83
#define KEY_ZENKAKUHANKAKU	85
#define KEY_102ND		86
#define KEY_F11			87
#define KEY_F12			88
#define KEY_RO			89
#define KEY_KATAKANA		90
#define KEY_HIRAGANA		91
#define KEY_HENKAN		92
#define KEY_KATAKANAHIRAGANA	93
#define KEY_MUHENKAN		94
#define KEY_KPJPCOMMA		95
#define KEY_KPENTER		96
#define KEY_RIGHTCTRL		97
#define KEY_KPSLASH		98
#define KEY_SYSRQ		99
#define KEY_RIGHTALT		100
#define KEY_LINEFEED		101
#define KEY_HOME		102
#define KEY_UP			103
#define KEY_PAGEUP		104
#define KEY_LEFT		105
#define KEY_RIGHT		106
#define KEY_END			107
#define KEY_DOWN		108
#define KEY_PAGEDOWN		109
#define KEY_INSERT		110
#define KEY_DELETE		111
#define KEY_MACRO		112
#define KEY_MUTE		113
#define KEY_VOLUMEDOWN		114
#define KEY_VOLUMEUP		115
#define KEY_POWER		116
#define KEY_KPEQUAL		117
#define KEY_KPPLUSMINUS		118
#define KEY_PAUSE		119
#define KEY_SCALE		120
#define KEY_KPCOMMA		121
#define KEY_HANGEUL		122
#define KEY_HANGUEL		KEY_HANGEUL
#define KEY_HANJA		123
#define KEY_YEN			124
#define KEY_LEFTMETA		125
#define KEY_RIGHTMETA		126
#define KEY_COMPOSE		127
#define KEY_STOP		128
#define KEY_AGAIN		129
#define KEY_PROPS		130
#define KEY_UNDO		131
#define KEY_FRONT		132
#define KEY_COPY		133
#define KEY_OPEN		134
#define KEY_PASTE		135
#define KEY_FIND		136
#define KEY_CUT			137
#define KEY_HELP		138
#define KEY_MENU		139
#define KEY_CALC		140
#define KEY_SETUP		141
#define KEY_SLEEP		142
#define KEY_WAKEUP		143
#define KEY_FILE		144
#define KEY_SENDFILE		145
#define KEY_DELETEFILE		146
#define KEY_XFER		147
#define KEY_PROG1		148
#define KEY_PROG2		149
#define KEY_WWW			150
#define KEY_MSDOS		151
#define KEY_COFFEE		152
#define KEY_SCREENLOCK		KEY_COFFEE
#define KEY_ROTATE_DISPLAY	153
#define KEY_DIRECTION		KEY_ROTATE_DISPLAY
#define KEY_CYCLEWINDOWS	154
#define KEY_MAIL		155
#define KEY_BOOKMARKS		156
#define KEY_COMPUTER		157
#define KEY_BACK		158
#define KEY_FORWARD		159
#define KEY_CLOSECD		160
#define KEY_EJECTCD		161
#define KEY_EJECTCLOSECD	162
#define KEY_NEXTSONG		163
#define KEY_PLAYPAUSE		164
#define KEY_PREVIOUSSONG	165
#define KEY_STOPCD		166
#define KEY_RECORD		167
#define KEY_REWIND		168
#define KEY_PHONE		169
#define KEY_ISO			170
#define KEY_CONFIG		171
#define KEY_HOMEPAGE		172
#define KEY_REFRESH		173
#define KEY_EXIT		174
#define KEY_MOVE		175
#define KEY_EDIT		176
#define KEY_SCROLLUP		177
#define KEY_SCROLLDOWN		178
#define KEY_KPLEFTPAREN		179
#define KEY_KPRIGHTPAREN	180
#define KEY_NEW			181
#define KEY_REDO		182
#define KEY_F13			183
#define KEY_F14			184
#define KEY_F15			185
#define KEY_F16			186
#define KEY_F17			187
#define KEY_F18			188
#define KEY_F19			189
#define KEY_F20			190
#define KEY_F21			191
#define KEY_F22			192
#define KEY_F23			193
#define KEY_F24			194
#define KEY_PLAYCD		200
#define KEY_PAUSECD		201
#define KEY_PROG3		202
#define KEY_PROG4		203
#define KEY_DASHBOARD		204
#define KEY_SUSPEND		205
#define KEY_CLOSE		206
#define KEY_PLAY		207
#define KEY_FASTFORWARD		208
#define KEY_BASSBOOST		209
#define KEY_PRINT		210
#define KEY_HP			211
#define KEY_CAMERA		212
#define KEY_SOUND		213
#define KEY_QUESTION		214
#define KEY_EMAIL		215
#define KEY_CHAT		216
#define KEY_SEARCH		217
#define KEY_CONNECT		218
#define KEY_FINANCE		219
#define KEY_SPORT		220
#define KEY_SHOP		221
#define KEY_ALTERASE		222
#define KEY_CANCEL		223
#define KEY_BRIGHTNESSDOWN	224
#define KEY_BRIGHTNESSUP	225
#define KEY_MEDIA		226
#define KEY_SWITCHVIDEOMODE	227
	/* Cycle between available video
					   outputs (Monitor/LCD/TV-out/etc) */
#define KEY_KBDILLUMTOGGLE	228
#define KEY_KBDILLUMDOWN	229
#define KEY_KBDILLUMUP		230
#define KEY_SEND		231
#define KEY_REPLY		232
#define KEY_FORWARDMAIL		233
#define KEY_SAVE		234
#define KEY_DOCUMENTS		235
#define KEY_BATTERY		236
#define KEY_BLUETOOTH		237
#define KEY_WLAN		238
#define KEY_UWB			239
#define KEY_UNKNOWN		240
#define KEY_VIDEO_NEXT		241
#define KEY_VIDEO_PREV		242
#define KEY_BRIGHTNESS_CYCLE	243
#define KEY_BRIGHTNESS_AUTO	244
	/* Set Auto Brightness: manual
					  brightness control is off,
					  rely on ambient */
#define KEY_BRIGHTNESS_ZERO	KEY_BRIGHTNESS_AUTO
#define KEY_DISPLAY_OFF		245
#define KEY_WWAN		246
#define KEY_WIMAX		KEY_WWAN
#define KEY_RFKILL		247
#define KEY_MICMUTE		248
/* Code 255 is reserved for special needs of AT keyboard driver */
#define BTN_MISC		0x100
#define BTN_0			0x100
#define BTN_1			0x101
#define BTN_2			0x102
#define BTN_3			0x103
#define BTN_4			0x104
#define BTN_5			0x105
#define BTN_6			0x106
#define BTN_7			0x107
#define BTN_8			0x108
#define BTN_9			0x109
#define BTN_MOUSE		0x110
#define BTN_LEFT		0x110
#define BTN_RIGHT		0x111
#define BTN_MIDDLE		0x112
#define BTN_SIDE		0x113
#define BTN_EXTRA		0x114
#define BTN_FORWARD		0x115
#define BTN_BACK		0x116
#define BTN_TASK		0x117
#define BTN_JOYSTICK		0x120
#define BTN_TRIGGER		0x120
#define BTN_THUMB		0x121
#define BTN_THUMB2		0x122
#define BTN_TOP			0x123
#define BTN_TOP2		0x124
#define BTN_PINKIE		0x125
#define BTN_BASE		0x126
#define BTN_BASE2		0x127
#define BTN_BASE3		0x128
#define BTN_BASE4		0x129
#define BTN_BASE5		0x12a
#define BTN_BASE6		0x12b
#define BTN_DEAD		0x12f
#define BTN_GAMEPAD		0x130
#define BTN_SOUTH		0x130
#define BTN_A			BTN_SOUTH
#define BTN_EAST		0x131
#define BTN_B			BTN_EAST
#define BTN_C			0x132
#define BTN_NORTH		0x133
#define BTN_X			BTN_NORTH
#define BTN_WEST		0x134
#define BTN_Y			BTN_WEST
#define BTN_Z			0x135
#define BTN_TL			0x136
#define BTN_TR			0x137
#define BTN_TL2			0x138
#define BTN_TR2			0x139
#define BTN_SELECT		0x13a
#define BTN_START		0x13b
#define BTN_MODE		0x13c
#define BTN_THUMBL		0x13d
#define BTN_THUMBR		0x13e
#define BTN_DIGI		0x140
#define BTN_TOOL_PEN		0x140
#define BTN_TOOL_RUBBER		0x141
#define BTN_TOOL_BRUSH		0x142
#define BTN_TOOL_PENCIL		0x143
#define BTN_TOOL_AIRBRUSH	0x144
#define BTN_TOOL_FINGER		0x145
#define BTN_TOOL_MOUSE		0x146
#define BTN_TOOL_LENS		0x147
#define BTN_TOOL_QUINTTAP	0x148
#define BTN_STYLUS3		0x149
#define BTN_TOUCH		0x14a
#define BTN_STYLUS		0x14b
#define BTN_STYLUS2		0x14c
#define BTN_TOOL_DOUBLETAP	0x14d
#define BTN_TOOL_TRIPLETAP	0x14e
#define BTN_TOOL_QUADTAP	0x14f
#define BTN_WHEEL		0x150
#define BTN_GEAR_DOWN		0x150
#define BTN_GEAR_UP		0x151
#define KEY_OK			0x160
#define KEY_SELECT		0x161
#define KEY_GOTO		0x162
#define KEY_CLEAR		0x163
#define KEY_POWER2		0x164
#define KEY_OPTION		0x165
#define KEY_INFO		0x166
#define KEY_TIME		0x167
#define KEY_VENDOR		0x168
#define KEY_ARCHIVE		0x169
#define KEY_PROGRAM		0x16a
#define KEY_CHANNEL		0x16b
#define KEY_FAVORITES		0x16c
#define KEY_EPG			0x16d
#define KEY_PVR			0x16e
#define KEY_MHP			0x16f
#define KEY_LANGUAGE		0x170
#define KEY_TITLE		0x171
#define KEY_SUBTITLE		0x172
#define KEY_ANGLE		0x173
#define KEY_FULL_SCREEN		0x174
#define KEY_ZOOM		KEY_FULL_SCREEN
#define KEY_MODE		0x175
#define KEY_KEYBOARD		0x176
#define KEY_ASPECT_RATIO	0x177
#define KEY_SCREEN		KEY_ASPECT_RATIO
#define KEY_PC			0x178
#define KEY_TV			0x179
#define KEY_TV2			0x17a
#define KEY_VCR			0x17b
#define KEY_VCR2		0x17c
#define KEY_SAT			0x17d
#define KEY_SAT2		0x17e
#define KEY_CD			0x17f
#define KEY_TAPE		0x180
#define KEY_RADIO		0x181
#define KEY_TUNER		0x182
#define KEY_PLAYER		0x183
#define KEY_TEXT		0x184
#define KEY_DVD			0x185
#define KEY_AUX			0x186
#define KEY_MP3			0x187
#define KEY_AUDIO		0x188
#define KEY_VIDEO		0x189
#define KEY_DIRECTORY		0x18a
#define KEY_LIST		0x18b
#define KEY_MEMO		0x18c
#define KEY_CALENDAR		0x18d
#define KEY_RED			0x18e
#define KEY_GREEN		0x18f
#define KEY_YELLOW		0x190
#define KEY_BLUE		0x191
#define KEY_CHANNELUP		0x192
#define KEY_CHANNELDOWN		0x193
#define KEY_FIRST		0x194
#define KEY_LAST		0x195
#define KEY_AB			0x196
#define KEY_NEXT		0x197
#define KEY_RESTART		0x198
#define KEY_SLOW		0x199
#define KEY_SHUFFLE		0x19a
#define KEY_BREAK		0x19b
#define KEY_PREVIOUS		0x19c
#define KEY_DIGITS		0x19d
#define KEY_TEEN		0x19e
#define KEY_TWEN		0x19f
#define KEY_VIDEOPHONE		0x1a0
#define KEY_GAMES		0x1a1
#define KEY_ZOOMIN		0x1a2
#define KEY_ZOOMOUT		0x1a3
#define KEY_ZOOMRESET		0x1a4
#define KEY_WORDPROCESSOR	0x1a5
#define KEY_EDITOR		0x1a6
#define KEY_SPREADSHEET		0x1a7
#define KEY_GRAPHICSEDITOR	0x1a8
#define KEY_PRESENTATION	0x1a9
#define KEY_DATABASE		0x1aa
#define KEY_NEWS		0x1ab
#define KEY_VOICEMAIL		0x1ac
#define KEY_ADDRESSBOOK		0x1ad
#define KEY_MESSENGER		0x1ae
#define KEY_DISPLAYTOGGLE	0x1af
#define KEY_BRIGHTNESS_TOGGLE	KEY_DISPLAYTOGGLE
#define KEY_SPELLCHECK		0x1b0
#define KEY_LOGOFF		0x1b1
#define KEY_DOLLAR		0x1b2
#define KEY_EURO		0x1b3
#define KEY_FRAMEBACK		0x1b4
#define KEY_FRAMEFORWARD	0x1b5
#define KEY_CONTEXT_MENU	0x1b6
#define KEY_MEDIA_REPEAT	0x1b7
#define KEY_10CHANNELSUP	0x1b8
#define KEY_10CHANNELSDOWN	0x1b9
#define KEY_IMAGES		0x1ba
#define KEY_NOTIFICATION_CENTER	0x1bc
#define KEY_PICKUP_PHONE	0x1bd
#define KEY_HANGUP_PHONE	0x1be
#define KEY_DEL_EOL		0x1c0
#define KEY_DEL_EOS		0x1c1
#define KEY_INS_LINE		0x1c2
#define KEY_DEL_LINE		0x1c3
#define KEY_FN			0x1d0
#define KEY_FN_ESC		0x1d1
#define KEY_FN_F1		0x1d2
#define KEY_FN_F2		0x1d3
#define KEY_FN_F3		0x1d4
#define KEY_FN_F4		0x1d5
#define KEY_FN_F5		0x1d6
#define KEY_FN_F6		0x1d7
#define KEY_FN_F7		0x1d8
#define KEY_FN_F8		0x1d9
#define KEY_FN_F9		0x1da
#define KEY_FN_F10		0x1db
#define KEY_FN_F11		0x1dc
#define KEY_FN_F12		0x1dd
#define KEY_FN_1		0x1de
#define KEY_FN_2		0x1df
#define KEY_FN_D		0x1e0
#define KEY_FN_E		0x1e1
#define KEY_FN_F		0x1e2
#define KEY_FN_S		0x1e3
#define KEY_FN_B		0x1e4
#define KEY_FN_RIGHT_SHIFT	0x1e5
#define KEY_BRL_DOT1		0x1f1
#define KEY_BRL_DOT2		0x1f2
#define KEY_BRL_DOT3		0x1f3
#define KEY_BRL_DOT4		0x1f4
#define KEY_BRL_DOT5		0x1f5
#define KEY_BRL_DOT6		0x1f6
#define KEY_BRL_DOT7		0x1f7
#define KEY_BRL_DOT8		0x1f8
#define KEY_BRL_DOT9		0x1f9
#define KEY_BRL_DOT10		0x1fa
#define KEY_NUMERIC_0		0x200
#define KEY_NUMERIC_1		0x201
#define KEY_NUMERIC_2		0x202
#define KEY_NUMERIC_3		0x203
#define KEY_NUMERIC_4		0x204
#define KEY_NUMERIC_5		0x205
#define KEY_NUMERIC_6		0x206
#define KEY_NUMERIC_7		0x207
#define KEY_NUMERIC_8		0x208
#define KEY_NUMERIC_9		0x209
#define KEY_NUMERIC_STAR	0x20a
#define KEY_NUMERIC_POUND	0x20b
#define KEY_NUMERIC_A		0x20c
#define KEY_NUMERIC_B		0x20d
#define KEY_NUMERIC_C		0x20e
#define KEY_NUMERIC_D		0x20f
#define KEY_CAMERA_FOCUS	0x210
#define KEY_WPS_BUTTON		0x211
#define KEY_TOUCHPAD_TOGGLE	0x212
#define KEY_TOUCHPAD_ON		0x213
#define KEY_TOUCHPAD_OFF	0x214
#define KEY_CAMERA_ZOOMIN	0x215
#define KEY_CAMERA_ZOOMOUT	0x216
#define KEY_CAMERA_UP		0x217
#define KEY_CAMERA_DOWN		0x218
#define KEY_CAMERA_LEFT		0x219
#define KEY_CAMERA_RIGHT	0x21a
#define KEY_ATTENDANT_ON	0x21b
#define KEY_ATTENDANT_OFF	0x21c
#define KEY_ATTENDANT_TOGGLE	0x21d
#define KEY_LIGHTS_TOGGLE	0x21e
#define BTN_DPAD_UP		0x220
#define BTN_DPAD_DOWN		0x221
#define BTN_DPAD_LEFT		0x222
#define BTN_DPAD_RIGHT		0x223
#define KEY_ALS_TOGGLE		0x230
#define KEY_ROTATE_LOCK_TOGGLE	0x231
#define KEY_BUTTONCONFIG		0x240
#define KEY_TASKMANAGER		0x241
#define KEY_JOURNAL		0x242
#define KEY_CONTROLPANEL		0x243
#define KEY_APPSELECT		0x244
#define KEY_SCREENSAVER		0x245
#define KEY_VOICECOMMAND		0x246
#define KEY_ASSISTANT		0x247
#define KEY_KBD_LAYOUT_NEXT	0x248
#define KEY_BRIGHTNESS_MIN		0x250
#define KEY_BRIGHTNESS_MAX		0x251
#define KEY_KBDINPUTASSIST_PREV		0x260
#define KEY_KBDINPUTASSIST_NEXT		0x261
#define KEY_KBDINPUTASSIST_PREVGROUP		0x262
#define KEY_KBDINPUTASSIST_NEXTGROUP		0x263
#define KEY_KBDINPUTASSIST_ACCEPT		0x264
#define KEY_KBDINPUTASSIST_CANCEL		0x265
/* Diagonal movement keys */
#define KEY_RIGHT_UP			0x266
#define KEY_RIGHT_DOWN			0x267
#define KEY_LEFT_UP			0x268
#define KEY_LEFT_DOWN			0x269
#define KEY_ROOT_MENU			0x26a
/* Show Top Menu of the Media (e.g. DVD) */
#define KEY_MEDIA_TOP_MENU		0x26b
#define KEY_NUMERIC_11			0x26c
#define KEY_NUMERIC_12			0x26d
/*
 * Toggle Audio Description: refers to an audio service that helps blind and
 * visually impaired consumers understand the action in a program. Note: in
 * some countries this is referred to as "Video Description".
 */
#define KEY_AUDIO_DESC			0x26e
#define KEY_3D_MODE			0x26f
#define KEY_NEXT_FAVORITE		0x270
#define KEY_STOP_RECORD			0x271
#define KEY_PAUSE_RECORD		0x272
#define KEY_VOD				0x273
#define KEY_UNMUTE			0x274
#define KEY_FASTREVERSE			0x275
#define KEY_SLOWREVERSE			0x276
/*
 * Control a data application associated with the currently viewed channel,
 * e.g. teletext or data broadcast application (MHEG, MHP, HbbTV, etc.)
 */
#define KEY_DATA			0x277
#define KEY_ONSCREEN_KEYBOARD		0x278
/* Electronic privacy screen control */
#define KEY_PRIVACY_SCREEN_TOGGLE	0x279
/* Select an area of screen to be copied */
#define KEY_SELECTIVE_SCREENSHOT	0x27a
/*
 * Some keyboards have keys which do not have a defined meaning, these keys
 * are intended to be programmed / bound to macros by the user. For most
 * keyboards with these macro-keys the key-sequence to inject, or action to
 * take, is all handled by software on the host side. So from the kernel's
 * point of view these are just normal keys.
 *
 * The KEY_MACRO# codes below are intended for such keys, which may be labeled
 * e.g. G1-G18, or S1 - S30. The KEY_MACRO# codes MUST NOT be used for keys
 * where the marking on the key does indicate a defined meaning / purpose.
 *
 * The KEY_MACRO# codes MUST also NOT be used as fallback for when no existing
 * KEY_FOO define matches the marking / purpose. In this case a new KEY_FOO
 * define MUST be added.
 */
#define KEY_MACRO1			0x290
#define KEY_MACRO2			0x291
#define KEY_MACRO3			0x292
#define KEY_MACRO4			0x293
#define KEY_MACRO5			0x294
#define KEY_MACRO6			0x295
#define KEY_MACRO7			0x296
#define KEY_MACRO8			0x297
#define KEY_MACRO9			0x298
#define KEY_MACRO10			0x299
#define KEY_MACRO11			0x29a
#define KEY_MACRO12			0x29b
#define KEY_MACRO13			0x29c
#define KEY_MACRO14			0x29d
#define KEY_MACRO15			0x29e
#define KEY_MACRO16			0x29f
#define KEY_MACRO17			0x2a0
#define KEY_MACRO18			0x2a1
#define KEY_MACRO19			0x2a2
#define KEY_MACRO20			0x2a3
#define KEY_MACRO21			0x2a4
#define KEY_MACRO22			0x2a5
#define KEY_MACRO23			0x2a6
#define KEY_MACRO24			0x2a7
#define KEY_MACRO25			0x2a8
#define KEY_MACRO26			0x2a9
#define KEY_MACRO27			0x2aa
#define KEY_MACRO28			0x2ab
#define KEY_MACRO29			0x2ac
#define KEY_MACRO30			0x2ad
/*
 * Some keyboards with the macro-keys described above have some extra keys
 * for controlling the host-side software responsible for the macro handling:
 * -A macro recording start/stop key. Note that not all keyboards which emit
 *  KEY_MACRO_RECORD_START will also emit KEY_MACRO_RECORD_STOP if
 *  KEY_MACRO_RECORD_STOP is not advertised, then KEY_MACRO_RECORD_START
 *  should be interpreted as a recording start/stop toggle;
 * -Keys for switching between different macro (pre)sets, either a key for
 *  cycling through the configured presets or keys to directly select a preset.
 */
#define KEY_MACRO_RECORD_START		0x2b0
#define KEY_MACRO_RECORD_STOP		0x2b1
#define KEY_MACRO_PRESET_CYCLE		0x2b2
#define KEY_MACRO_PRESET1		0x2b3
#define KEY_MACRO_PRESET2		0x2b4
#define KEY_MACRO_PRESET3		0x2b5
/*
 * Some keyboards have a buildin LCD panel where the contents are controlled
 * by the host. Often these have a number of keys directly below the LCD
 * intended for controlling a menu shown on the LCD. These keys often don't
 * have any labeling so we just name them KEY_KBD_LCD_MENU#
 */
#define KEY_KBD_LCD_MENU1		0x2b8
#define KEY_KBD_LCD_MENU2		0x2b9
#define KEY_KBD_LCD_MENU3		0x2ba
#define KEY_KBD_LCD_MENU4		0x2bb
#define KEY_KBD_LCD_MENU5		0x2bc
#define BTN_TRIGGER_HAPPY		0x2c0
#define BTN_TRIGGER_HAPPY1		0x2c0
#define BTN_TRIGGER_HAPPY2		0x2c1
#define BTN_TRIGGER_HAPPY3		0x2c2
#define BTN_TRIGGER_HAPPY4		0x2c3
#define BTN_TRIGGER_HAPPY5		0x2c4
#define BTN_TRIGGER_HAPPY6		0x2c5
#define BTN_TRIGGER_HAPPY7		0x2c6
#define BTN_TRIGGER_HAPPY8		0x2c7
#define BTN_TRIGGER_HAPPY9		0x2c8
#define BTN_TRIGGER_HAPPY10		0x2c9
#define BTN_TRIGGER_HAPPY11		0x2ca
#define BTN_TRIGGER_HAPPY12		0x2cb
#define BTN_TRIGGER_HAPPY13		0x2cc
#define BTN_TRIGGER_HAPPY14		0x2cd
#define BTN_TRIGGER_HAPPY15		0x2ce
#define BTN_TRIGGER_HAPPY16		0x2cf
#define BTN_TRIGGER_HAPPY17		0x2d0
#define BTN_TRIGGER_HAPPY18		0x2d1
#define BTN_TRIGGER_HAPPY19		0x2d2
#define BTN_TRIGGER_HAPPY20		0x2d3
#define BTN_TRIGGER_HAPPY21		0x2d4
#define BTN_TRIGGER_HAPPY22		0x2d5
#define BTN_TRIGGER_HAPPY23		0x2d6
#define BTN_TRIGGER_HAPPY24		0x2d7
#define BTN_TRIGGER_HAPPY25		0x2d8
#define BTN_TRIGGER_HAPPY26		0x2d9
#define BTN_TRIGGER_HAPPY27		0x2da
#define BTN_TRIGGER_HAPPY28		0x2db
#define BTN_TRIGGER_HAPPY29		0x2dc
#define BTN_TRIGGER_HAPPY30		0x2dd
#define BTN_TRIGGER_HAPPY31		0x2de
#define BTN_TRIGGER_HAPPY32		0x2df
#define BTN_TRIGGER_HAPPY33		0x2e0
#define BTN_TRIGGER_HAPPY34		0x2e1
#define BTN_TRIGGER_HAPPY35		0x2e2
#define BTN_TRIGGER_HAPPY36		0x2e3
#define BTN_TRIGGER_HAPPY37		0x2e4
#define BTN_TRIGGER_HAPPY38		0x2e5
#define BTN_TRIGGER_HAPPY39		0x2e6
#define BTN_TRIGGER_HAPPY40		0x2e7
/* We avoid low common keys in module aliases so they don't get huge. */
#define KEY_MIN_INTERESTING	KEY_MUTE
#define KEY_MAX			0x2ff
#define KEY_CNT			(KEY_MAX+1)
/*
 * Relative axes
 */
#define REL_X			0x00
#define REL_Y			0x01
#define REL_Z			0x02
#define REL_RX			0x03
#define REL_RY			0x04
#define REL_RZ			0x05
#define REL_HWHEEL		0x06
#define REL_DIAL		0x07
#define REL_WHEEL		0x08
#define REL_MISC		0x09
/*
 * 0x0a is reserved and should not be used in input drivers.
 * It was used by HID as REL_MISC+1 and userspace needs to detect if
 * the next REL_* event is correct or is just REL_MISC + n.
 * We define here REL_RESERVED so userspace can rely on it and detect
 * the situation described above.
 */
#define REL_RESERVED		0x0a
#define REL_WHEEL_HI_RES	0x0b
#define REL_HWHEEL_HI_RES	0x0c
#define REL_MAX			0x0f
#define REL_CNT			(REL_MAX+1)
/*
 * Absolute axes
 */
#define ABS_X			0x00
#define ABS_Y			0x01
#define ABS_Z			0x02
#define ABS_RX			0x03
#define ABS_RY			0x04
#define ABS_RZ			0x05
#define ABS_THROTTLE		0x06
#define ABS_RUDDER		0x07
#define ABS_WHEEL		0x08
#define ABS_GAS			0x09
#define ABS_BRAKE		0x0a
#define ABS_HAT0X		0x10
#define ABS_HAT0Y		0x11
#define ABS_HAT1X		0x12
#define ABS_HAT1Y		0x13
#define ABS_HAT2X		0x14
#define ABS_HAT2Y		0x15
#define ABS_HAT3X		0x16
#define ABS_HAT3Y		0x17
#define ABS_PRESSURE		0x18
#define ABS_DISTANCE		0x19
#define ABS_TILT_X		0x1a
#define ABS_TILT_Y		0x1b
#define ABS_TOOL_WIDTH		0x1c
#define ABS_VOLUME		0x20
#define ABS_MISC		0x28
/*
 * 0x2e is reserved and should not be used in input drivers.
 * It was used by HID as ABS_MISC+6 and userspace needs to detect if
 * the next ABS_* event is correct or is just ABS_MISC + n.
 * We define here ABS_RESERVED so userspace can rely on it and detect
 * the situation described above.
 */
#define ABS_RESERVED		0x2e
#define ABS_MT_SLOT		0x2f
#define ABS_MT_TOUCH_MAJOR	0x30
#define ABS_MT_TOUCH_MINOR	0x31
#define ABS_MT_WIDTH_MAJOR	0x32
#define ABS_MT_WIDTH_MINOR	0x33
#define ABS_MT_ORIENTATION	0x34
#define ABS_MT_POSITION_X	0x35
#define ABS_MT_POSITION_Y	0x36
#define ABS_MT_TOOL_TYPE	0x37
#define ABS_MT_BLOB_ID		0x38
#define ABS_MT_TRACKING_ID	0x39
#define ABS_MT_PRESSURE		0x3a
#define ABS_MT_DISTANCE		0x3b
#define ABS_MT_TOOL_X		0x3c
#define ABS_MT_TOOL_Y		0x3d
#define ABS_MAX			0x3f
#define ABS_CNT			(ABS_MAX+1)
/*
 * Switch events
 */
#define SW_LID			0x00
#define SW_TABLET_MODE		0x01
#define SW_HEADPHONE_INSERT	0x02
#define SW_RFKILL_ALL		0x03
  /* rfkill master switch, type "any"
					 set = radio enabled */
#define SW_RADIO		SW_RFKILL_ALL
#define SW_MICROPHONE_INSERT	0x04
#define SW_DOCK			0x05
#define SW_LINEOUT_INSERT	0x06
#define SW_JACK_PHYSICAL_INSERT 0x07
#define SW_VIDEOOUT_INSERT	0x08
#define SW_CAMERA_LENS_COVER	0x09
#define SW_KEYPAD_SLIDE		0x0a
#define SW_FRONT_PROXIMITY	0x0b
#define SW_ROTATE_LOCK		0x0c
#define SW_LINEIN_INSERT	0x0d
#define SW_MUTE_DEVICE		0x0e
#define SW_PEN_INSERTED		0x0f
#define SW_MACHINE_COVER	0x10
#define SW_MAX			0x10
#define SW_CNT			(SW_MAX+1)
/*
 * Misc events
 */
#define MSC_SERIAL		0x00
#define MSC_PULSELED		0x01
#define MSC_GESTURE		0x02
#define MSC_RAW			0x03
#define MSC_SCAN		0x04
#define MSC_TIMESTAMP		0x05
#define MSC_MAX			0x07
#define MSC_CNT			(MSC_MAX+1)
/*
 * LEDs
 */
#define LED_NUML		0x00
#define LED_CAPSL		0x01
#define LED_SCROLLL		0x02
#define LED_COMPOSE		0x03
#define LED_KANA		0x04
#define LED_SLEEP		0x05
#define LED_SUSPEND		0x06
#define LED_MUTE		0x07
#define LED_MISC		0x08
#define LED_MAIL		0x09
#define LED_CHARGING		0x0a
#define LED_MAX			0x0f
#define LED_CNT			(LED_MAX+1)
/*
 * Autorepeat values
 */
#define REP_DELAY		0x00
#define REP_PERIOD		0x01
#define REP_MAX			0x01
#define REP_CNT			(REP_MAX+1)
/*
 * Sounds
 */
#define SND_CLICK		0x00
#define SND_BELL		0x01
#define SND_TONE		0x02
#define SND_MAX			0x07
#define SND_CNT			(SND_MAX+1)
#endif
// These definitions resemble keyboard scancodes.
// for wayland, these are what comes into the key callback.
#undef BTN_START
#define KEY_ESCAPE KEY_ESC
#define KEY_PGDN KEY_PAGEDOWN
#define KEY_PAGE_DOWN  KEY_PAGEDOWN
#define KEY_PGUP KEY_PAGEUP
#define KEY_PAGE_UP  KEY_PAGEUP
#define KEY_DASH KEY_MINUS
#define KEY_QUOTE KEY_APOSTROPHE
#define KEY_PAD_PLUS KEY_KPPLUS
#define KEY_PAD_ENTER KEY_KPENTER
#define KEY_PAD_MINUS KEY_KPMINUS
#define KEY_PAD_DOT   KEY_KPDOT
#define KEY_PAD_DIV   KEY_KPSLASH
//#define KEY_DASH
#define KEY_LEFT_BRACKET KEY_LEFTBRACE
#define KEY_RIGHT_BRACKET KEY_RIGHTBRACE
#define KEY_PAD_MULT  KEY_KPASTERISK
#define KEY_PAD_9   KEY_KP9
#define KEY_PAD_8   KEY_KP8
#define KEY_PAD_7   KEY_KP7
#define KEY_PAD_6   KEY_KP6
#define KEY_PAD_5   KEY_KP5
#define KEY_PAD_4   KEY_KP4
#define KEY_PAD_3   KEY_KP3
#define KEY_PAD_2   KEY_KP2
#define KEY_PAD_1   KEY_KP1
#define KEY_PAD_0   KEY_KP0
#define KEY_CENTER  KEY_KPPLUSMINUS
#define KEY_LESS   KEY_COMMA
#define KEY_PAD_DELETE KEY_KPDOT
#define KEY_GREY_INSERT KEY_INSERT
#define KEY_GREY_DELETE KEY_DELETE
#define KEY_PERIOD KEY_DOT
#define KEY_CAPS_LOCK KEY_CAPSLOCK
#define KEY_LEFT_SHIFT KEY_LEFTSHIFT
#define KEY_RIGHT_SHIFT KEY_RIGHTSHIFT
#define KEY_ALT KEY_LEFTALT
#define KEY_LEFT_ALT KEY_LEFTALT
#define KEY_RIGHT_ALT KEY_RIGHTALT
#define KEY_CTRL KEY_LEFTCTRL
#define KEY_LEFT_CONTROL KEY_LEFTCTRL
#define KEY_RIGHT_CONTROL KEY_RIGHTCTRL
#define KEY_SCROLL_LOCK KEY_SCROLLLOCK
#define KEY_SHIFT KEY_LEFTSHIFT
#define KEY_DEL KEY_BACKSPACE
//#define
#define KEY_ACCENT KEY_GRAVE
	  //#define USE_SDL_KEYSYM
// ug - KEYSYMS are too wide...
// so - we fall back to x scancode tables - and translate sym to these
// since the scancodes which come from X are not the same as from console Raw
// but - perhaps we should re-translate these to REAL scancodes... but in either
// case - these fall to under 256 characters, and can therefore be used...
//#    define USE_X_RAW_SCANCODES
#    ifdef USE_X_RAW_SCANCODES
//#pragma message( "XRAW")
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   50
 // maybe?
#      define KEY_RIGHT_SHIFT  62
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  37
#      define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      64
#      define KEY_RIGHT_ALT     113
#      define KEY_CAPS_LOCK     66
#      define KEY_NUM_LOCK      77
 // unsure about this
#      define KEY_SCROLL_LOCK   78
#      define KEY_ESC           9
#      define KEY_ESCAPE        9
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      79
#      define KEY_PAD_7         79
#      define KEY_GREY_HOME     97
#      define KEY_UP            0xFB
#      define KEY_PAD_8         80
#      define KEY_PAD_UP        80
#      define KEY_GREY_UP       98
#      define KEY_PGUP          0xFA
#      define KEY_PAGE_UP       KEY_PGUP
#      define KEY_PAD_9         81
#      define KEY_PAD_PGUP      81
#      define KEY_GREY_PGUP     99
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         83
#      define KEY_PAD_LEFT      83
#      define KEY_GREY_LEFT     100
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         84
#      define KEY_PAD_CENTER    84
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         85
#      define KEY_PAD_RIGHT     85
#      define KEY_GREY_RIGHT    102
#      define KEY_END           0xF6
#      define KEY_PAD_1         87
#      define KEY_PAD_END       87
#      define KEY_GREY_END      103
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         88
#      define KEY_PAD_DOWN      88
#      define KEY_GREY_DOWN     104
#      define KEY_PGDN          0xF4
#      define KEY_PAGE_DOWN     KEY_PGDN
#      define KEY_PAD_3         89
#      define KEY_PAD_PGDN      89
#      define KEY_GREY_PGDN     105
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         90
#      define KEY_PAD_INSERT    90
#      define KEY_GREY_INSERT   106
#      define KEY_DELETE        0xF2
#      define KEY_DEL           KEY_DELETE
#      define KEY_PAD_DOT       91
#      define KEY_PAD_DELETE    91
#      define KEY_GREY_DELETE   107
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      86
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     82
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      63
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       112
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     108
#      define KEY_NORMAL_ENTER  36
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
//#pragma message("GOOD DEFINE")
#      define KEY_TAB           23
#      define KEY_SLASH         61
#      define KEY_BACKSPACE     22
#      define KEY_SPACE         65
#      define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#      define KEY_STOP          60
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     47
#      define KEY_QUOTE         48
#      define KEY_LEFT_BRACKET  34
#      define KEY_RIGHT_BRACKET 35
#      define KEY_BACKSLASH     51
#      define KEY_DASH          20
#      define KEY_EQUAL         21
#      define KEY_EQUALS       KEY_EQUAL
#      define KEY_ACCENT        49
#      define KEY_APOSTROPHE    KEY_QUOTE
#      define KEY_GRAVE        KEY_ACCENT
#      define KEY_SHIFT_LEFT   KEY_LEFT_SHIFT
#      define KEY_SHIFT_RIGHT  KEY_RIGHT_SHIFT
#      define KEY_1         10
#      define KEY_2         11
#      define KEY_3         12
#      define KEY_4         13
#      define KEY_5         14
#      define KEY_6         15
#      define KEY_7         16
#      define KEY_8         17
#      define KEY_9         18
#      define KEY_0         19
#      define KEY_F1        67
#      define KEY_F2        68
#      define KEY_F3        69
#      define KEY_F4        70
#      define KEY_F5        71
#      define KEY_F6        72
#      define KEY_F7        73
#      define KEY_F8        74
#      define KEY_F9        75
#      define KEY_F10       76
#      define KEY_F11       95
#      define KEY_F12       96
#      define KEY_A         38
#      define KEY_B         56
#      define KEY_C         54
#      define KEY_D         40
#      define KEY_E         26
#      define KEY_F         41
#      define KEY_G         42
#      define KEY_H         43
#      define KEY_I         31
#      define KEY_J         44
#      define KEY_K         45
#      define KEY_L         46
#      define KEY_M         58
#      define KEY_N         57
#      define KEY_O         32
#      define KEY_P         33
#      define KEY_Q         24
#      define KEY_R         27
#      define KEY_S         39
#      define KEY_T         28
#      define KEY_U         30
#      define KEY_V         55
#      define KEY_W         25
#      define KEY_X         53
#      define KEY_Y         29
#      define KEY_Z         52
#    elif defined( USE_SDL_KEYSYM )
#      include <SDL.h>
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   SDLK_LSHIFT
#      define KEY_RIGHT_SHIFT  SDLK_RSHIFT
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  SDLK_LCTRL
#      define KEY_RIGHT_CONTROL SDLK_RCTRL
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      SDLK_LALT
#      define KEY_RIGHT_ALT     SDLK_RALT
#      define KEY_CAPS_LOCK     SDLK_CAPSLOCK
#      define KEY_NUM_LOCK      SDLK_NUMLOCK
#      define KEY_SCROLL_LOCK   SDLK_SCROLLOCK
#      define KEY_ESC           SDLK_ESCAPE
#      define KEY_ESCAPE        SDLK_ESCAPE
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      SDLK_KP7
#      define KEY_PAD_7         SDLK_KP7
#      define KEY_GREY_HOME     SDLK_HOME
#      define KEY_UP            0xFB
#      define KEY_PAD_8         SDLK_KP8
#      define KEY_PAD_UP        SDLK_KP8
#      define KEY_GREY_UP       SDLK_UP
#      define KEY_PGUP          0xFA
#      define KEY_PAD_9         SDLK_KP9
#      define KEY_PAD_PGUP      SDLK_KP9
#      define KEY_GREY_PGUP     SDLK_PAGEUP
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         SDLK_KP4
#      define KEY_PAD_LEFT      SDLK_KP4
#      define KEY_GREY_LEFT     SDLK_LEFT
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         SDLK_KP5
#      define KEY_PAD_CENTER    SDLK_KP5
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         SDLK_KP6
#      define KEY_PAD_RIGHT     SDLK_KP6
#      define KEY_GREY_RIGHT    SDLK_RIGHT
#      define KEY_END           0xF6
#      define KEY_PAD_1         SDLK_KP1
#      define KEY_PAD_END       SDLK_KP1
#      define KEY_GREY_END      SDLK_END
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         SDLK_KP2
#      define KEY_PAD_DOWN      SDLK_KP2
#      define KEY_GREY_DOWN     SDLK_DOWN
#      define KEY_PGDN          0xF4
#      define KEY_PAD_3         SDLK_KP3
#      define KEY_PAD_PGDN      SDLK_KP3
#      define KEY_GREY_PGDN     SDLK_PAGEDN
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         SDLK_KP0
#      define KEY_PAD_INSERT    SDLK_KP0
#      define KEY_GREY_INSERT   SDLK_INSERT
#      define KEY_DELETE        0xF2
#      define KEY_PAD_DOT       SDLK_KP_PERIOD
#      define KEY_PAD_DELETE    SDLK_KP_PERIOD
#      define KEY_GREY_DELETE   SDLK_DELETE
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      SDLK_KP_PLUS
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     SDLK_KP_MINUS
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      SDLK_KP_MULTIPLY
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       SDLK_KP_DIVIDE
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     SDLK_KP_ENTER
#      define KEY_NORMAL_ENTER  SDLK_RETURN
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
#      define KEY_TAB           SDLK_TAB
#      define KEY_SLASH         SDLK_SLASH
#      define KEY_BACKSPACE     SDLK_BACKSPACE
#      define KEY_SPACE         SDLK_SPACE
#      define KEY_COMMA         SDLK_COMMA
 // should be some sort of VK_ definitions....
#      define KEY_STOP          SDLK_PERIOD
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     SDLK_SEMICOLON
#      define KEY_QUOTE         SDLK_QUOTE
#      define KEY_LEFT_BRACKET  SDLK_LEFTBRACKET
#      define KEY_RIGHT_BRACKET SDLK_RIGHTBRACKET
#      define KEY_BACKSLASH     SDLK_BACKSLASH
#      define KEY_DASH          SDLK_MINUS
#      define KEY_EQUAL         SDLK_EQUALS
 // grave
#      define KEY_ACCENT        SDLK_BACKQUOTE
#      define KEY_1         SDLK_1
#      define KEY_2         SDLK_2
#      define KEY_3         SDLK_3
#      define KEY_4         SDLK_4
#      define KEY_5         SDLK_5
#      define KEY_6         SDLK_6
#      define KEY_7         SDLK_7
#      define KEY_8         SDLK_8
#      define KEY_9         SDLK_9
#      define KEY_0         SDLK_0
#      define KEY_F1        SDLK_F1
#      define KEY_F2        SDLK_F2
#      define KEY_F3        SDLK_F3
#      define KEY_F4        SDLK_F4
#      define KEY_F5        SDLK_F5
#      define KEY_F6        SDLK_F6
#      define KEY_F7        SDLK_F7
#      define KEY_F8        SDLK_F8
#      define KEY_F9        SDLK_F9
#      define KEY_F10       SDLK_F10
#      define KEY_F11       SDLK_F11
#      define KEY_F12       SDLK_F12
#      define KEY_A         SDLK_A
#      define KEY_B         SDLK_B
#      define KEY_C         SDLK_C
#      define KEY_D         SDLK_D
#      define KEY_E         SDLK_E
#      define KEY_F         SDLK_F
#      define KEY_G         SDLK_G
#      define KEY_H         SDLK_H
#      define KEY_I         SDLK_I
#      define KEY_J         SDLK_J
#      define KEY_K         SDLK_K
#      define KEY_L         SDLK_L
#      define KEY_M         SDLK_M
#      define KEY_N         SDLK_N
#      define KEY_O         SDLK_O
#      define KEY_P         SDLK_P
#      define KEY_Q         SDLK_Q
#      define KEY_R         SDLK_R
#      define KEY_S         SDLK_S
#      define KEY_T         SDLK_T
#      define KEY_U         SDLK_U
#      define KEY_V         SDLK_V
#      define KEY_W         SDLK_W
#      define KEY_X         SDLK_X
#      define KEY_Y         SDLK_Y
#      define KEY_Z         SDLK_Z
#    elif defined( USE_RAW_SCANCODE )
#      error RAW_SCANCODES have not been defined yet.
#      define KEY_SHIFT        0xFF
#      define KEY_LEFT_SHIFT   50
 // maybe?
#      define KEY_RIGHT_SHIFT  62
#      define KEY_CTRL          0xFE
#      define KEY_CONTROL       0xFE
#      define KEY_LEFT_CONTROL  37
#      define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#      define KEY_ALT           0xFD
#      define KEY_LEFT_ALT      64
#      define KEY_RIGHT_ALT     113
#      define KEY_CAPS_LOCK     66
#      define KEY_NUM_LOCK      77
 // unsure about this
#      define KEY_SCROLL_LOCK   78
#      define KEY_ESC           9
#      define KEY_ESCAPE        9
#      define KEY_HOME          0xFC
#      define KEY_PAD_HOME      79
#      define KEY_PAD_7         79
#      define KEY_GREY_HOME     97
#      define KEY_UP            0xFB
#      define KEY_PAD_8         80
#      define KEY_PAD_UP        80
#      define KEY_GREY_UP       98
#      define KEY_PGUP          0xFA
#      define KEY_PAD_9         81
#      define KEY_PAD_PGUP      81
#      define KEY_GREY_PGUP     99
#      define KEY_LEFT          0xF9
#      define KEY_PAD_4         83
#      define KEY_PAD_LEFT      83
#      define KEY_GREY_LEFT     100
#      define KEY_CENTER        0xF8
#      define KEY_PAD_5         84
#      define KEY_PAD_CENTER    84
#      define KEY_GREY_CENTER   0
#      define KEY_RIGHT         0xF7
#      define KEY_PAD_6         85
#      define KEY_PAD_RIGHT     85
#      define KEY_GREY_RIGHT    102
#      define KEY_END           0xF6
#      define KEY_PAD_1         87
#      define KEY_PAD_END       87
#      define KEY_GREY_END      103
#      define KEY_DOWN          0xF5
#      define KEY_PAD_2         88
#      define KEY_PAD_DOWN      88
#      define KEY_GREY_DOWN     104
#      define KEY_PGDN          0xF4
#      define KEY_PAD_3         89
#      define KEY_PAD_PGDN      89
#      define KEY_GREY_PGDN     105
#      define KEY_INSERT        0xF3
#      define KEY_PAD_0         90
#      define KEY_PAD_INSERT    90
#      define KEY_GREY_INSERT   106
#      define KEY_DELETE        0xF2
#      define KEY_PAD_DOT       91
#      define KEY_PAD_DELETE    91
#      define KEY_GREY_DELETE   107
#      define KEY_PLUS          0xF1
#      define KEY_PAD_PLUS      86
#      define KEY_GREY_PLUS     0
#      define KEY_MINUS         0xF0
#      define KEY_PAD_MINUS     82
#      define KEY_GREY_MINUS    0
#      define KEY_MULT          0xEF
#      define KEY_PAD_MULT      63
#      define KEY_GREY_MULT     0
#      define KEY_DIV           0xEE
#      define KEY_PAD_DIV       112
#      define KEY_GREY_DIV      0
#      define KEY_ENTER         0xED
#      define KEY_PAD_ENTER     108
#      define KEY_NORMAL_ENTER  36
 // windows keys keys
#      define KEY_WINDOW_1      115
 // windows keys keys
#      define KEY_WINDOW_2      117
#      define KEY_TAB           23
#      define KEY_SLASH         61
#      define KEY_BACKSPACE     22
#      define KEY_SPACE         65
#      define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#      define KEY_STOP          60
#      define KEY_PERIOD        KEY_STOP
#      define KEY_SEMICOLON     47
#      define KEY_QUOTE         48
#      define KEY_LEFT_BRACKET  34
#      define KEY_RIGHT_BRACKET 35
#      define KEY_BACKSLASH     51
#      define KEY_DASH          20
#      define KEY_EQUAL         21
#      define KEY_ACCENT        49
#      define KEY_1         10
#      define KEY_2         11
#      define KEY_3         12
#      define KEY_4         13
#      define KEY_5         14
#      define KEY_6         15
#      define KEY_7         16
#      define KEY_8         17
#      define KEY_9         18
#      define KEY_0         19
#      define KEY_F1        67
#      define KEY_F2        68
#      define KEY_F3        69
#      define KEY_F4        70
#      define KEY_F5        71
#      define KEY_F6        72
#      define KEY_F7        73
#      define KEY_F8        74
#      define KEY_F9        75
#      define KEY_F10       76
#      define KEY_F11       95
#      define KEY_F12       96
#      define KEY_A         38
#      define KEY_B         56
#      define KEY_C         54
#      define KEY_D         40
#      define KEY_E         26
#      define KEY_F         41
#      define KEY_G         42
#      define KEY_H         43
#      define KEY_I         31
#      define KEY_J         44
#      define KEY_K         45
#      define KEY_L         46
#      define KEY_M         58
#      define KEY_N         57
#      define KEY_O         32
#      define KEY_P         33
#      define KEY_Q         24
#      define KEY_R         27
#      define KEY_S         39
#      define KEY_T         28
#      define KEY_U         30
#      define KEY_V         55
#      define KEY_W         25
#      define KEY_X         53
#      define KEY_Y         29
#      define KEY_Z         52
#    endif
#  endif
#endif
#if defined( DEFINE_HARDWARE_SCANCODES )
#  ifndef KBD_HPP
#    define KBD_HPP
#    define KBD_INT            9
#    define KBD_EXTENDED_CODE     0xE0
#    define LOW_ASCII(asc)     (asc&0x7F)
#    define NUM_KEYS        256
#    ifdef WIN32
//#    define KEY_ESC       27
//#    define KEY_LEFT      37
//#    define KEY_CENTER    KB_CENTER
//#    define KEY_RIGHT     39
//#    define KEY_DOWN      40
//#    define KEY_GRAY_UP   38
//#    define KEY_GRAY_LEFT 37
//#    define KEY_GRAY_RIGHT   39
//#    define KEY_GRAY_DOWN    40
//#    define KEY_LEFT_SHIFT   16
//#    define KEY_RIGHT_SHIFT  16
//#    define KEY_GRAY_PGUP 33
//#    define KEY_GRAY_PGDN 34
//#    define KEY_GRAY_INS  45
//#    define KEY_GRAY_DEL  46
//#    define KEY_P         80
//#    define KEY_M         77
#    else
#      define KEY_ESC       0x01
#      define KEY_1         0x02
#      define KEY_2         0x03
#      define KEY_3         0x04
#      define KEY_4         0x05
#      define KEY_5         0x06
#      define KEY_6         0x07
#      define KEY_7         0x08
#      define KEY_8         0x09
#      define KEY_9         0x0A
#      define KEY_0         0x0B
#      define KEY_MINUS     0x0C
#      define KEY_PLUS         0x0D
#      define  KEY_BKSP        0x0E
#pragma error BAD DEFINE
#      define KEY_TAB       0x0F
#      define KEY_Q         0x10
#      define KEY_W         0x11
#      define KEY_E         0x12
#      define KEY_R         0x13
#      define KEY_T         0x14
#      define KEY_Y         0x15
#      define KEY_U         0x16
#      define KEY_I         0x17
#      define  KEY_O        0x18
#      define KEY_P         0x19
#      define KEY_BRACK_OPEN   0x1A
#      define KEY_BRACK_CLOSE  0x1B
#      define KEY_ENTER     0x1C
#      define KEY_LEFT_CTRL 0x1D
#      define KEY_A         0x1E
#      define KEY_S         0x1F
#      define KEY_D         0x20
#      define KEY_F         0x21
#      define KEY_X         0x2D
#      define KEY_C         0x2E
#      define KEY_V         0x2F
#      define KEY_B         0x30
#      define KEY_N         0x31
#      define KEY_M         0x32
#      define KEY_GRAY_SLASH   0x35
#      define KEY_RIGHT_SHIFT  0x36
#      define KEY_GRAY_STAR 0x37
#      define KEY_LEFT_ALT     0x38
#      define KEY_SPACE     0x39
#      define KEY_CAPS         0x3A
#      define KEY_F1        0x3B
#      define KEY_F2        0x3C
#      define KEY_F3        0x3D
#      define KEY_F4        0x3E
#      define KEY_F5        0x3F
#      define KEY_F6        0x40
#      define KEY_F7        0x41
#      define KEY_F8        0x42
#      define KEY_F9        0x43
#      define KEY_F10       0x44
#      define KEY_UP        0x48
#      define KEY_LEFT      0x4B
#      define KEY_CENTER    0x4C
#      define KEY_RIGHT     0x4D
#      define KEY_DOWN      0x50
#      define KEY_DEL       0x53
#      define KEY_F11       0x57
#      define KEY_F12       0x58
#      define KEY_RIGHT_CTRL   BIT_7+0x1D
#      define KEY_RIGHT_ALT BIT_7+0x38
#      define KEY_GRAY_UP      BIT_7+0x48
#      define KEY_GRAY_PGUP BIT_7+0x49
#      define KEY_GRAY_MINUS   BIT_7+0x4A
#      define KEY_GRAY_LEFT BIT_7+0x4B
#      define KEY_GRAY_RIGHT   BIT_7+0x4D
#      define KEY_GRAY_PLUS BIT_7+0x4E
#      define KEY_GRAY_END     BIT_7+0x4F
#      define KEY_GRAY_DOWN BIT_7+0x50
#      define KEY_GRAY_PGDN BIT_7+0x51
#      define KEY_GRAY_INS     BIT_7+0x52
#      define KEY_GRAY_DEL     BIT_7+0x53
#    endif
#  endif
#endif
#endif
// $Log: keybrd.h,v $
// Revision 1.16  2004/08/11 11:41:06  d3x0r
// Begin seperation of key and render
//
// Revision 1.15  2004/06/01 21:53:43  d3x0r
// Fix PUBLIC dfeinitions from Windoze-centric to system nonspecified
//
// Revision 1.14  2004/04/27 04:58:16  d3x0r
// Forgot to macro a function..
//
// Revision 1.13  2004/04/27 03:06:16  d3x0r
// Define F1-F10
//
// Revision 1.12  2004/03/05 23:33:21  d3x0r
// Missing keydefs - may be wrong.
//
// Revision 1.11  2003/03/25 08:38:11  panther
// Add logging
//
/* Crafted by Jim Buckeyne (c)1999-2006++ Freedom Collective
   Image building tracking, and simple manipulations.        */
// if the library is to have it's own idea of what
// an image is - then it should have included
// the definition for 'SFTFont', and 'Image' before
// including this... otherwise, it is assumed to
// be a client, and therefore does not need the information
// if a custom structure is used - then it MUST define
// it's ACTUAL x,y,width,height as the first 4 int32_t bit values.
#ifndef IMAGE_H
// multiple inclusion protection symbol
#define IMAGE_H
#if defined( _MSC_VER ) && defined( SACK_BAG_EXPORTS ) && 0
#define HAS_ASSEMBLY
#endif
/* Define COLOR type. Basically the image library regards color
   as 32 bits of data. User applications end up needing to
   specify colors in the correct method for the platform they
   are working on. This provides aliases to rearrange colors.
   For instance the colors on windows and the colors for OpenGL
   are not exactly the same. If the OpenGL driver is specified
   as the output device, the entire code would need to be
   rebuilt for specifying colors correctly for opengl. While
   otherwise they are both 32 bits, and pieces work, they get
   very ugly colors output.
   See Also
   <link Colors>                                                */
#ifndef COLOR_STRUCTURE_DEFINED
/* An exclusion symbol for defining CDATA and color operations. */
#define COLOR_STRUCTURE_DEFINED
#ifdef __cplusplus
namespace sack {
	namespace image {
#endif
		// byte index values for colors on the video buffer...
		enum color_byte_index {
 I_BLUE  = 0,
 I_GREEN = 1,
 I_RED   = 2,
 I_ALPHA = 3
		};
#if defined( __ANDROID__ ) || defined( _OPENGL_DRIVER )
#  define USE_OPENGL_COMPAT_COLORS
#endif
#if ( !defined( IMAGE_LIBRARY_SOURCE_MAIN ) && ( !defined( FORCE_NO_INTERFACE ) || defined( ALLOW_IMAGE_INTERFACE ) ) )      && !defined( FORCE_COLOR_MACROS )
#define Color( r,g,b ) MakeColor(r,g,b)
#define AColor( r,g,b,a ) MakeAlphaColor(r,g,b,a)
#define SetAlpha( rgb, a ) SetAlphaValue( rgb, a )
#define SetGreen( rgb, g ) SetGreeValue(rgb,g )
#define AlphaVal(color) GetAlphaValue( color )
#define RedVal(color)   GetRedValue(color)
#define GreenVal(color) GetGreenValue(color)
#define BlueVal(color)  GetBlueValue(color)
#else
#if defined( _OPENGL_DRIVER ) || defined( USE_OPENGL_COMPAT_COLORS )
#  define Color( r,g,b ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|0xFF000000)
#  define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|((a)<<24))
#  define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
#  define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0xFF)<<8 ) )
#  define SetBlue( rgb, b )  ( ((rgb)&0xFF00FFFF) | ( ((b)&0xFF)<<16 ) )
#  define SetRed( rgb, r )   ( ((rgb)&0xFFFFFF00) | ( ((r)&0xFF)<<0 ) )
#  define GLColor( c )  (c)
#  define AlphaVal(color) ((color&0xFF000000) >> 24)
#  define RedVal(color)   ((color&0x000000FF) >> 0)
#  define GreenVal(color) ((color&0x0000FF00) >> 8)
#  define BlueVal(color)  ((color&0x00FF0000) >> 16)
#else
#  ifdef _WIN64
#    define AND_FF &0xFF
#  else
/* This is a macro to cure a 64bit warning in visual studio. */
#    define AND_FF
#  endif
/* A macro to create a solid color from R G B coordinates.
   Example
   <code lang="c++">
   CDATA color1 = Color( 255,0,0 ); // Red only, so this is bright red
   CDATA color2 = Color( 0,255,0); // green only, this is bright green
   CDATA color3 = Color( 0,0,255); // blue only, this is birght blue
   CDATA color4 = Color(93,93,32); // this is probably a goldish grey
   </code>                                                             */
#define Color( r,g,b ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|0xFF000000)
/* Build a color with alpha specified. */
#define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|(((a)AND_FF)<<24))
/* Sets the alpha part of a color. (0-255 value, 0 being
   transparent, and 255 solid(opaque))
   Example
   <code lang="c++">
   CDATA color = BASE_COLOR_RED;
   CDATA hazy_color = SetAlpha( color, 128 );
   </code>
 */
#define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
/* Sets the green channel of a color. Expects a value 0-255.  */
#define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0x0000FF)<<8 ) )
/* Sets the blue channel of a color. Expects a value 0-255.  */
#define SetBlue( rgb, b ) ( ((rgb)&0xFFFFFF00) | ( ((b)&0x0000FF)<<0 ) )
/* Sets the red channel of a color. Expects a value 0-255.  */
#define SetRed( rgb, r ) ( ((rgb)&0xFF00FFFF) | ( ((r)&0x0000FF)<<16 ) )
/* Return a CDATA that is meant for output to OpenGL. */
#define GLColor( c )  (((c)&0xFF00FF00)|(((c)&0xFF0000)>>16)|(((c)&0x0000FF)<<16))
/* Get the alpha value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define AlphaVal(color) (((color) >> 24) & 0xFF)
/* Get the red value of a color. This is a 0-255 unsigned byte. */
#define RedVal(color)   (((color) >> 16) & 0xFF)
/* Get the green value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define GreenVal(color) (((color) >> 8) & 0xFF)
/* Get the blue value of a color. This is a 0-255 unsigned byte. */
#define BlueVal(color)  (((color)) & 0xFF)
#endif
 // IMAGE_LIBRARY_SOURCE
#endif
		/* a definition for a single color channel - for function replacements for ___Val macros*/
		typedef unsigned char COLOR_CHANNEL;
        /* a 4 byte array of color (not really used, we mostly went with CDATA and PCDATA instead of COLOR and PCOLOR */
		typedef COLOR_CHANNEL COLOR[4];
		// color data raw...
		typedef uint32_t CDATA;
		/* pointer to an array of 32 bit colors */
		typedef uint32_t *PCDATA;
		/* A Pointer to <link COLOR>. Probably an array of color (a
		 block of pixels for instance)                            */
		typedef COLOR *PCOLOR;
//-----------------------------------------------
// common color definitions....
//-----------------------------------------------
// both yellows need to be fixed.
#define BASE_COLOR_BLACK         Color( 0,0,0 )
#define BASE_COLOR_BLUE          Color( 0, 0, 128 )
#define BASE_COLOR_DARKBLUE          Color( 0, 0, 42 )
/* An opaque Green.
   See Also
   <link Colors>    */
#define BASE_COLOR_GREEN         Color( 0, 128, 0 )
/* An opaque cyan - kind of a light sky like blue.
   See Also
   <link Colors>                                   */
#define BASE_COLOR_CYAN          Color( 0, 128, 128 )
/* An opaque red.
   See Also
   <link Colors>  */
#define BASE_COLOR_RED           Color( 192, 32, 32 )
/* An opaque BROWN. Brown is dark yellow... so this might be
   more like a gold sort of color instead.
   See Also
   <link Colors>                                             */
#define BASE_COLOR_BROWN         Color( 140, 140, 0 )
#define BASE_COLOR_LIGHTBROWN         Color( 221, 221, 85 )
#define BASE_COLOR_MAGENTA       Color( 160, 0, 160 )
#define BASE_COLOR_LIGHTGREY     Color( 192, 192, 192 )
/* An opaque darker grey (gray?).
   See Also
   <link Colors>                  */
#define BASE_COLOR_DARKGREY      Color( 128, 128, 128 )
/* An opaque a bight or light color blue.
   See Also
   <link Colors>                          */
#define BASE_COLOR_LIGHTBLUE     Color( 0, 0, 255 )
/* An opaque lighter, brighter green color.
   See Also
   <link Colors>                            */
#define BASE_COLOR_LIGHTGREEN    Color( 0, 255, 0 )
/* An opaque a lighter, more bight cyan color.
   See Also
   <link Colors>                               */
#define BASE_COLOR_LIGHTCYAN     Color( 0, 255, 255 )
/* An opaque bright red.
   See Also
   <link Colors>         */
#define BASE_COLOR_LIGHTRED      Color( 255, 0, 0 )
/* An opaque Lighter pink sort of red-blue color.
   See Also
   <link Colors>                                  */
#define BASE_COLOR_LIGHTMAGENTA  Color( 255, 0, 255 )
/* An opaque bright yellow.
   See Also
   <link Colors>            */
#define BASE_COLOR_YELLOW        Color( 255, 255, 0 )
/* An opaque White.
   See Also
   <link Colors>    */
#define BASE_COLOR_WHITE         Color( 255, 255, 255 )
#define BASE_COLOR_ORANGE        Color( 204,96,7 )
#define BASE_COLOR_NICE_ORANGE   Color( 0xE9, 0x7D, 0x26 )
#define BASE_COLOR_PURPLE        Color( 0x7A, 0x11, 0x7C )
#ifdef __cplusplus
 //	 namespace image {
	}
 //SACK_NAMESPACE_END
}
using namespace sack::image;
#endif
#endif
// $Log: colordef.h,v $
// Revision 1.4  2003/04/24 00:03:49  panther
// Added ColorAverage to image... Fixed a couple macros
//
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef __NO_INTERFACES__
#endif
# ifndef SECOND_IMAGE_LEVEL
#  define SECOND_IMAGE_LEVEL _2
/* This is a macro used for building name changes for
   interfaces.                                        */
#  define PASTE(sym,name) name
# else
#  define PASTE2(sym,name) sym##name
#  define PASTE(sym,name) PASTE2(sym,name)
# endif
/* Macro to do symbol concatenation. */
#define _PASTE2(sym,name) sym##name
/* A second level paste macro so macro substitution is done on
   \parameters.                                                */
#define _PASTE(sym,name) _PASTE2(sym,name)
/* Define the default call type of image routines. CPROC is
   __cdecl.                                                 */
#define IMAGE_API CPROC
#     ifdef IMAGE_LIBRARY_SOURCE
#        define IMAGE_PROC  EXPORT_METHOD
// this sometimes needs an extra 'extern'
//#           ifdef IMAGE_MAIN
//#        define IMAGE_PROC_D EXPORT_METHOD
//#           else
//#        define IMAGE_PROC_D extern EXPORT_METHOD
//#           endif
#     else
/* Define the linkage type of the routine... probably
   __declspec(dllimport) if not building the library. */
#        define IMAGE_PROC IMPORT_METHOD
// this sometimes needs an extra 'extern'
//#        define IMAGE_PROC_D  IMPORT_METHOD
#     endif
#if defined( _WIN32 ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER ) && !defined( _D3D10_DRIVER ) && !defined( _D3D11_DRIVER )
#define _INVERT_IMAGE
#endif
#ifdef __cplusplus
/* Define the namespace of image routines, when building under
   C++.                                                        */
#ifdef _D3D_DRIVER
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#define IMAGE_EXTRA_CLOSE
#elif defined( _D3D10_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d10 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d10 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#define IMAGE_EXTRA_CLOSE
#elif defined( _D3D11_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d11 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d11 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#define IMAGE_EXTRA_CLOSE
#else
#  define BASE_IMAGE_NAMESPACE namespace image {
#  define IMAGE_NAMESPACE namespace sack { namespace image {
#  define _IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}
#endif
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE extern "C" {
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE_END }
#else
#define BASE_IMAGE_NAMESPACE
#define IMAGE_NAMESPACE
#define _IMAGE_NAMESPACE
#define IMAGE_NAMESPACE_END
#define ASM_IMAGE_NAMESPACE
 /* Defined Image API.
   See Also
   <link sack::image::Image, Image>
   <link sack::image::SFTFont, SFTFont>
   <link Colors>
									*/
#define ASM_IMAGE_NAMESPACE_END
#endif
#ifdef USE_API_ALIAS_PREFIX
#  define IMGVER__(a,b) a##b
#  define IMGVER_(a,b) IMGVER__(a,b)
#  define IMGVER(n)   IMGVER_(USE_API_ALIAS_PREFIX,n)
#else
#  define IMGVER(n)   n
#endif
#ifdef __cplusplus
namespace sack {
#endif
/* Deals with images and image processing.
   Image is the primary type of this.
   SFTFont is a secondary type for putting text on images.
   render namespace is contained in image, because without
   image, there could be no render. see PRENDERER.         */
#ifdef __cplusplus
	namespace image {
#endif
/* A fixed point decimal number (for freetype font rendering) */
typedef int64_t fixed;
//#ifndef IMAGE_STRUCTURE_DEFINED
//#define IMAGE_STRUCTURE_DEFINED
// consider minimal size - +/- 32000 should be enough for display purposes.
// print... well that's another matter.
   typedef int32_t IMAGE_COORDINATE;
   /* Represents the width and height of an image (unsigned values) */
   typedef uint32_t  IMAGE_SIZE_COORDINATE;
   /* An array of 2 IMAGE_COORDINATES - [0] = x, [1] = y */
   typedef IMAGE_COORDINATE IMAGE_POINT[2];
   /* An unsigned value coordinate pair to track the size of
	  images.                                                */
   typedef IMAGE_SIZE_COORDINATE IMAGE_EXTENT[2];
   /* Pointer to an <link sack::image::IMAGE_POINT, IMAGE_POINT> */
   typedef IMAGE_COORDINATE *P_IMAGE_POINT;
   /* Pointer to a <link sack::image::IMAGE_EXTENT, IMAGE_EXTENT> */
   typedef IMAGE_SIZE_COORDINATE *P_IMAGE_EXTENT;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct boundry_rectangle_tag
{
   union {
	  IMAGE_POINT position;
	  struct {
		 IMAGE_COORDINATE x, y;
	  };
   };
   union {
	  IMAGE_EXTENT size;
	  struct {
		 IMAGE_SIZE_COORDINATE width, height;
	  };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#else
/* Defines the coordinates of a rectangle. */
/* Pointer to an image rectangle.  */
typedef struct boundry_rectangle_tag
{
   /* anonymous union containing position information. */
   union {
	  /* An anonymous structure containing x,y and width,height of a
		 rectangle.                                                  */
	  struct {
		 /* the left coordinate of a rectangle. */
		 /* the top coordinate of a rectangle */
		 IMAGE_COORDINATE x, y;
		 /* The Y span of the rectangle */
		 /* the X Span of the rectangle */
		 IMAGE_SIZE_COORDINATE width, height;
	  };
	  /* Anonymous structure containing position (x,y) and size
		 (width,height).                                        */
	  struct {
		 /* The location of a rectangle (upper left x, y) */
		 IMAGE_POINT position;
		 /* the size of a rectangle (width and height) */
		 IMAGE_EXTENT size;
	  };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#endif
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_H(ImagePoint) ((ImagePoint)[0])
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_V(ImagePoint) ((ImagePoint)[1])
// the image at exactly this position and size
// is the one being referenced, the actual size and position
// may vary depending on use (a sub-image outside the
// boundry of its parent).
#define ImageData union {	                             struct {		                                       IMAGE_COORDINATE x, y;		                      IMAGE_SIZE_COORDINATE width, height;	         };	                                              struct {		                                       IMAGE_POINT position;		                       IMAGE_EXTENT size;	                           };                                               }
/* One of the two primary types that the image library works
   with.
   Example
   <code lang="c++">
   void LoadImage( char *name )
   {
	   Image image = LoadImageFile( name );
	   if( image )
	   {
		  // the image file loaded successfully.
	   }
   }
   </code>                                                   */
typedef struct ImageFile_tag *Image;
typedef struct SlicedImageFile *SlicedImage;
#if defined( IMAGE_STRUCTURE_DEFINED )
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
IMAGE_PROC  PCDATA IMAGE_API ImageAddress( Image image, int32_t x, int32_t y );
#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#endif
#endif
#if defined( __cplusplus )
IMAGE_NAMESPACE_END
#endif
/* \Internal Image structure. Tracks an image, but can also have
   sub-images allocated on the image. Performing image
   operations to sub images are clipped to the region of the
   board, and go directly to the image memory the sub image is
   on. A image only has one data buffer.                         */
#ifndef IMAGE_STRUCTURE_DEFINED
#ifdef _D3D_DRIVER
#include <d3d9.h>
#endif
#ifdef _D3D10_DRIVER
#include <D3D10_1.h>
#include <D3D10.h>
#endif
#ifdef _D3D11_DRIVER
#include <D3D11.h>
#endif
#ifdef _VULKAN_DRIVER
#  ifdef _WIN32
#    define VK_USE_PLATFORM_WIN32_KHR
#  else
#    define VK_USE_PLATFORM_XCB_KHR
#  endif
#  include <vulkan/vulkan.h>
#endif
#if defined( _WIN32 ) && !defined( _INVERT_IMAGE ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER )
#define _INVERT_IMAGE
#endif
#define WILL_DEFINE_IMAGE_STRUCTURE
#define IMAGE_STRUCTURE_DEFINED
IMAGE_NAMESPACE
#ifdef __cplusplus
	namespace Interface
{
	struct image_interface_tag;
}
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
#ifndef PSPRITE_METHOD
#define PSPRITE_METHOD PSPRITE_METHOD
/* pointer to a structure defining a sprite draw method this should be defined in render namespace...*/
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	/* Flags which may be combined in <link sack::image::ImageFile_tag::flags, Image.flags> */
	enum ImageFlags {
 // this has been freed - but contains sub images
IF_FLAG_FREE   =0x00001,
 // moved beyond parent image's bound
IF_FLAG_HIDDEN =0x00002,
 // built with a *image from external sources
IF_FLAG_EXTERN_COLORS =0x00004,
 // pay attention to (clips) array.
IF_FLAG_HAS_CLIPS     =0x00008,
// with no _X_STRING flag - characters are shown as literal character glyph.
 // strings on this use 'c' processing
IF_FLAG_C_STRING       = 0x00010,
 // strings on this use menu processing ( &underline )
IF_FLAG_MENU_STRING    = 0x00020,
 // strings use control chars (newline, tab)
IF_FLAG_CONTROL_STRING = 0x00040,
 // this has been freed - but contains sub images
IF_FLAG_OWN_DATA       = 0x00080,
  // image is inverted (standard under windows, but this allows images to be configured dynamically - a hack to match SDL lameness )
IF_FLAG_INVERTED       = 0x00100,
// DisplayLib uses this flag - indicates panel root
 // please #define user flag to this
IF_FLAG_USER1          = 0x10000,
// DisplayLib uses this flag - indicates is part of a displayed panel
IF_FLAG_USER2          = 0x20000,
IF_FLAG_USER3          = 0x40000,
 // output should render to opengl target (with transform); also used with proxy
IF_FLAG_FINAL_RENDER   = 0x00200,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_UPDATED        = 0x00400,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_HAS_PUTSTRING  = 0x00800,
 // is an in-memory image; that is the surface can be written to directly with pixel ops (putstring)
IF_FLAG_IN_MEMORY      = 0x01000,
	};
//#define _DRAWPOINT_X 0
//#define _DRAWPOINT_Y 1
struct ImageFile_tag
{
#if defined( IMAGE_LIBRARY_SOURCE ) || defined( NEED_REAL_IMAGE_STRUCTURE )
	int real_x;
	int real_y;
   // desired height and width may not be actual cause of
	int real_width;
  // resizing of parent image....
	int real_height;
# ifdef HAVE_ANONYMOUS_STRUCTURES
	IMAGE_RECTANGLE;
# else
 // need this for sub images - otherwise is irrelavent
	int x;
	int y;
  /// Width of image.
	int width;
 /// Height of image.
	int height;
# endif
#else
	/* X coordinate of the image within another image. */
	int x;
	/* Y coordinate of an image within another image. */
	int y;
   // desired height and width may not be actual cause of
	int width;
  // resizing of parent image....
	int height;
 // need this for sub images - otherwise is irrelavent
	int actual_x;
	int actual_y;
  // Width of image.
	int actual_width;
 // Height of image.
	int actual_height;
#endif
 // width of real physical layer
	int pwidth;
	// The image data.
	PCOLOR image;
	/* a combination of <link ImageFlags, IF_FLAG_> (ImageFile Flag)
	   which apply to this image.                                    */
	int flags;
	/* This points to a peer image that existed before this one. If
	   NULL, there is no elder, otherwise, contains the next peer
	   image in the same parent image.                              */
	/* Points to the parent image of a sub-image. (The parent image
	   contains this image)                                         */
	/* Pointer to the youngest child sub-image. If there are no sub
	   images pChild will be NULL. Otherwise, pchild points at the
	   first of one or more sub images. Other sub images in this one
	   are found by following the pElder link of the pChild.         */
	/* This points at a more recently created sub-image. (another
	   sub image within the same parent, but younger)             */
	struct ImageFile_tag *pParent, *pChild, *pElder, *pYounger;
	   // effective x - clipped by reality real coordinate.
	           // (often eff_x = -real_x )
	int eff_x;
	/* this is used internally for knowing what the effective y of
	   the image is. If the sub-image spans a boundry of a parent
	   image, then the effective Y that will be worked with is only
	   a part of the subimage.                                      */
	int eff_y;
		// effective max - maximum coordinate...
	int eff_maxx;
		// effective maximum Y
	int eff_maxy;
		/* An extra rectangle that can be used to carry additional
		 information like update region.                         */
	IMAGE_RECTANGLE auxrect;
	// fonts need a way to output the font character subimages to the real image...
	// or for 3D; to reverse scale appropriately
	struct image_interface_tag  *reverse_interface;
 // what the interface thinks this is...
	POINTER reverse_interface_instance;
	void (*extra_close)( struct ImageFile_tag *);
//DOM-IGNORE-BEGIN
#if defined( __3D__ )
	PTRANSFORM transform;
#endif
#ifdef _OPENGL_DRIVER
	/* gl context? */
	LOGICAL depthTest;
	PLIST glSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int glActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef _D3D10_DRIVER
	PLIST Surfaces;
	ID3D10Texture2D *pActiveSurface;
#endif
#ifdef _D3D11_DRIVER
	PLIST Surfaces;
	ID3D11Texture2D *pActiveSurface;
#endif
#ifdef _D3D_DRIVER
	/* gl context? */
	PLIST Surfaces;
	IDirect3DBaseTexture9 *pActiveSurface;
#endif
#ifdef _VULKAN_DRIVER
	LOGICAL depthTest;
	PLIST vkSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int vkActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
	VkCommandBuffer* commandBuffers;
#endif
#ifdef __cplusplus
 // watcom limits protections in structs to protected and public
#ifndef __WATCOMC__
private:
#endif
#endif
//DOM-IGNORE-END
};
enum SlicedImageSection {
	SLICED_IMAGE_TOP_LEFT,
	SLICED_IMAGE_TOP,
	SLICED_IMAGE_TOP_RIGHT,
	SLICED_IMAGE_LEFT,
	SLICED_IMAGE_CENTER,
	SLICED_IMAGE_RIGHT,
	SLICED_IMAGE_BOTTOM_LEFT,
	SLICED_IMAGE_BOTTOM,
	SLICED_IMAGE_BOTTOM_RIGHT,
};
struct SlicedImageFile {
	struct ImageFile_tag *image;
	struct ImageFile_tag *slices[9];
	uint32_t left, right, top, bottom;
	uint32_t center_w, center_h;
	uint32_t right_w;
	uint32_t bottom_h;
	LOGICAL output_center;
	LOGICAL extended_slice;
};
/* The basic structure. This is referenced by applications as '<link sack::image::Image, Image>'
	This is the primary type that the image library works with.
	This is the internal definition.
	This is a actual data content, Image is (ImageFile *).                                        */
typedef struct ImageFile_tag ImageFile;
/* A simple wrapper to add dynamic changing position and
	orientation to an image. Sprites can be output at any angle. */
struct sprite_tag
{
	/* Current location of the sprite's origin. */
	/* Current location of the sprite's origin. */
  // current x and current y for placement on image.
	int32_t curx, cury;
  // int of bitmap hotspot... centers cur on hot
	int32_t hotx, hoty;
	Image image;
	// curx,y are kept for moving the sprite independantly
	fixed scalex, scaley;
	// radians from 0 -> 2*pi.  there is no negative...
 // radians for now... (used internally, set by blot rotated sprite)
	float angle;
	// should consider keeping the angle of rotation
	// and also should cosider keeping velocity/acceleration
	// but then limits would have to be kept also... so perhaps
	// the game module should keep such silly factors... but then couldn't
	// it also keep curx, cury ?  though hotx hoty is the actual
	// origin to rotate this image about, and to draw ON curx 0 cury 0
	// int orgx, orgy;  // rotated origin of bitmap.
	// after being drawn the min(x,y) and max(x,y) are set.
 // after draw, these are the extent of the sprite.
	int32_t minx, maxx;
 // after draw, these are the extent of the sprite.
	int32_t miny, maxy;
	PSPRITE_METHOD pSpriteMethod;
};
/* A Sprite type. Adds position and rotation and motion factors
	to an image. Hooks into the render system to get an update to
	draw on a temporary layer after the base rendering is done.   */
typedef struct sprite_tag SPRITE;
#ifdef _INVERT_IMAGE
// inversion does not account for eff_y - only eff_maxy
// eff maxy - eff_minY???
/*+((i)->eff_y)*/
#define INVERTY(i,y)     ( (((i)->eff_maxy) - (y)))
#else
/* This is a macro is used when image data is inverted on a
	platform. (Windows images, the first row of data is the
	bottom of the image, all Image operations are specified from
	the top-left as 0,0)                                         */
#define INVERTY(i,y)     ((y) - (i)->eff_y)
#endif
/*+((i)->eff_y)*/
#define INVERTY_INVERTED(i,y)     ( (((i)->eff_maxy) - (y)))
#define INVERTY_NON_INVERTED(i,y)     ((y) - (i)->eff_y)
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
//IMAGE_PROC( PCDATA, ImageAddress )( Image image, int32_t x, int32_t y );
//#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#else
#define IMG_ADDRESS(i,x,y)    ((CDATA*)	                             ((i)->image + (( (x) - (i)->eff_x )	 +(((i)->flags&IF_FLAG_INVERTED)?(INVERTY_INVERTED( (i), (y) ) * (i)->pwidth ):(INVERTY_NON_INVERTED( (i), (y) ) * (i)->pwidth ))	                             ))										   )
#endif
IMAGE_NAMESPACE_END
// end if_not_included
#endif
#if defined( __cplusplus )
IMAGE_NAMESPACE
#endif
/* pointer to a sprite type. */
typedef struct sprite_tag *PSPRITE;
//#endif
// at some point, it may be VERY useful
// to have this structure also have a public member.
//
#ifndef NO_FONT
typedef struct simple_font_tag {
 // all characters same height
   uint16_t height;
 // number of characters in the set
   uint16_t characters;
 // open ended array size characters...
   uint8_t char_width[1];
} FontData;
/* Contains information about a font for drawing and rendering
   from a font file.                                           */
typedef struct font_tag *SFTFont;
#endif
/* A definition of a block structure to transport font and image
   data across message queues.                                   */
/* Type of buffer used to transfer data across message queues. */
typedef struct data_transfer_state_tag {
   /* size of this block of data. */
   uint32_t size;
   /* offset of the data in the total message. Have to break up
	  large buffers into smaller chunks for transfer.           */
   uint32_t offset;
   /* buffer containing the data to transfer. */
   CDATA buffer;
} *DataState;
//-----------------------------------------------------
enum string_behavior {
   // every character assumed to have a glyph-including '\0'
   STRING_PRINT_RAW
 // control characters perform 'typical' actions - newline, tab, backspace...
   ,STRING_PRINT_CONTROL
  // c style escape characters are handled \n \b \x## - literal text
   ,STRING_PRINT_C
   ,STRING_PRINT_MENU
 /* &amp; performs an underline, also does C style handling. \\&amp;
						 == &amp;                                                         */
};
/* Definitions of symbols to pass to <link SetBlotMethod> to
   specify optimization method.                              */
enum blot_methods {
	/* A Symbol to pass to <link SetBlotMethod> to specify using C
	  coded primitives. (for shading and alpha blending).         */
	BLOT_C
   , BLOT_ASM
/* A Symbol to pass to <link SetBlotMethod> to specify using
	  primitives with assembly optimization (for shading and alpha
	  blending).                                                   */
						,
				  /* A Symbol to pass to <link SetBlotMethod> to specify using
	  primitives with MMX optimization (for shading and alpha
	  blending).                                                */
	BLOT_MMX
};
// specify the method that pixels are copied from one image to another
enum BlotOperation {
   /* copy the pixels from one image to another with no color transform*/
 BLOT_COPY = 0,
   // copy the pixels from one image to another with no color transform, scaling by a single color
 BLOT_SHADED = 1,
   // copy the pixels from one image to another with no color transform, scaling independant R, G and B color channels to a combination of an R Color, B Color, G Color
 BLOT_MULTISHADE = 2,
   /* copy the pixels from one image to another with simple color inversion transform*/
 BLOT_INVERTED = 3,
 /* orientation blots for fonts to 3D and external displays */
 // no orientation difference - 0 value.
 BLOT_ORIENT_NORMAL = 0x00,
   // flip image on blot.
 BLOT_ORIENT_INVERT = 0x04,
// when outputing image, put image vertical inverted (rotated 90 degrees)
 BLOT_ORIENT_VERTICAL = 0x08,
 // when outputing image, put image vertical inverted (rotated 90 degrees)
 BLOT_ORIENT_VERTICAL_INVERT = 0x0C,
 BLOT_ORIENTATTION = 0x0C,
};
/* Transparency parameter definition
   0 : no transparency - completely opaque
   1 (TRUE): 0 colors (absolute transparency) only
   2-255 : 0 color transparent, plus transparency factor applied
   to all 2 - mostly almost completely transparent 255 not
   transparent (opaque)
   257-511 : alpha transparency in pixel plus transparency value
   \- 256 0 pixels will be transparent 257 - slightly more
   opaquen than the original 511 - image totally opaque - alpha
   will be totally overriden no addition 511 nearly completely
   transparent 512-767 ; the low byte of this is subtracted from
   the alpha of the image ; this allows images to be more
   transparent than they were originally 512 - no modification
   alpha imge normal 600 - mid range... more transparent 767 -
   totally transparent any value of transparent greater than the
   max will be clipped to max this will make very high values
   opaque totally...                                             */
enum AlphaModifier {
	/* Direct alpha copy - (Alpha of different layers is added). whatever the alpha is is what the output will be.  Adding a value of 0-255 here will increase the base opacity by that much */
	ALPHA_TRANSPARENT = 0x100
	// Inverse alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will decrease the base opacity by that much
	, ALPHA_TRANSPARENT_INVERT = 0x200
	/* Direct alpha copy - (Alpha of different layers is multiplied).  Adding a value of 0-255 here will
	   increase
	   the base opacity by that much */
	, ALPHA_TRANSPARENT_MUL = 0x400
	// more than this clips to total transparency
	// for line, plot more than 255 will
	// be total opaque... this max only
	// applies to blotted images
	, ALPHA_TRANSPARENT_MAX = 0x2FF
};
/* library global changes. string behavior cannot be tracked per
   image. string behavior should, for all strings, be the same
   usage for an application... so behavior is associated with
   the particular stream and/or image family. does not modify
   character handling behavior - only strings.
   See Also
   <link sack::image::string_behavior, String Behaviors>         */
   IMAGE_PROC  void IMAGE_API  IMGVER(SetStringBehavior)( Image pImage, uint32_t behavior );
   /* Specify the optimized code to draw with. There are 3 levels,
	  C - routines coded in C, ASM - assembly optimization (32bit
	  NASM), MMX assembly but taking advantage of MMX features.    */
   IMAGE_PROC  void IMAGE_API  IMGVER(SetBlotMethod)    ( uint32_t method );
   /* This routine can be used to generically scale to any point
	  between two colors.
	  Parameters
	  Color 1 :   CDATA color to scale from
	  Color 2 :   CDATA color to scale to
	  distance :  How from from 0 to max distance to scale.
	  max :       How wide the scalar is.
	  Remarks
	  Max is the scale that distance can go from. Distance 0 is the
	  first color, Distance == max is the second color. The
	  distance from 0 to max proportionately scaled the color....
	  Example
	  <code lang="c++">
	  CDATA green = BASE_COLOR_GREEN;
	  CDATA blue = BASE_COLOR_BLUE;
	  CDATA red = BASE_COLOR_RED;
	  </code>
	  Compute a color that is halfway from blue to green. (if the
	  total distance is 100, then 50 is half way).
	  <code lang="c++">
	  CDATA blue_green = ColorAverage( blue, green, 50, 100 );
	  </code>
	  Compute a color that's mostly red.
	  <code lang="c++">
	  CDATA red_blue_green = ColorAverage( blue_green, red, 240, 255 );
	  </code>
	  Iterate through a whole scaled range...
	  <code lang="c++">
	  int n;
	  for( n = 0; n \< 100; n++ )
	  {
		  CDATA scaled = ColorAverage( BASE_COLOR_WHITE, BASE_COLOR_BLACK, n, 100 );
		  // as n increases, the color slowly goes from WHITE to BLACK.
	  }
	  </code>                                                                        */
   IMAGE_PROC  CDATA IMGVER(ColorAverage)( CDATA c1, CDATA c2, int d, int max );
   /* Creates an image from user defined parts. The buffer used is
	  from the user. This was used by the video library, but
	  RemakeImage accomplishes this also.
	  Parameters
	  pc :      the color buffer to use for the image.
	  width :   how wide the color buffer is
	  height :  How tall the color buffer is                       */
   IMAGE_PROC  Image IMAGE_API IMGVER(BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* <combine sack::image::MakeImageFile>
	  Adds <link sack::DBG_PASS, DBG_PASS> parameter. */
   /* Creates an Image with a specified width and height. The
	  image's color is undefined to start.
	  Parameters
	  Width :     how wide to make the image. Cannot be negative.
	  Height :    how tall to make the image. Cannot be negative.
	  DBG_PASS :  _nt_
	  Example
	  See <link sack::image::Image, Image>                        */
   IMAGE_PROC  Image IMAGE_API IMGVER(MakeImageFileEx  )(uint32_t Width, uint32_t Height DBG_PASS);
   /* Creates a sub image region on an image. Sub-images may be
	  used like any other image. There are two uses for this sort
	  of thing. OH, the sub image shares the exact data of the
	  parent image, and is not a copy.
	  Parameters
	  pImage :  image to make the sub image in
	  x :       signed location of the top side of the sub\-image
	  y :       signed location of the left side of the sub\-image
	  width :   how wide to make the sub\-image
	  height :  how tall to make the sub\-image
	  Returns
	  NULL if the input image is NULL.
	  Otherwise returns an Image.
	  Example
	  Use 1: An image might contain a grid of symbols or
	  characters, each exactly the same size. These may be token
	  pieces used in a game or a special graphic font.
	  <code lang="c++">
	  Image pieces_image = LoadImageFile( "Game Pieces.image" );
	  PLIST pieces = NULL;
	  int x, y;
	  \#define PIECE_WIDTH 32
	  \#define PIECE_HEIGHT 32
	  for( x = 0; x \< 10; x++ )
		 for( y = 0; y \< 2; y++ )
		 {
			 AddLink( &amp;pieces, MakeSubImage( pieces_image
										   , x * PIECE_WIDTH, y * PIECE_HEIGHT
										   , PIECE_WIDTH, PIECE_HEIGHT );
		 }
	  // at this point there we have a list with all the tokens,
	  // which were 32x32 pixels each.
	  // Any of these piece images may be output using a scaled or direct blot.
	  </code>
	  Use 2: Partitioning views on an image for things like
	  controls and other clipped regions.
	  <code lang="c++">
	  Image image = MakeImageFile( 1024, 768 );
	  Image clock = MakeSubImage( image, 32, 32, 150, 16 );
	  DrawString( clock, 0, 0, BASE_COLOR_WHITE, BASE_COLOR_BLACK, "Current Time..." );
	  </code>                                                                           */
   IMAGE_PROC  Image IMAGE_API IMGVER(MakeSubImageEx   )( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
   /* Adds an image as a sub-image of another image. The image
	  being added as a sub image must not already have a parent.
	  Sub-images are like views into the parent, and share the same
	  pixel buffer that the parent has.
	  Parameters
	  pFoster :  This is the parent image to received the new
				 subimage
	  pOrphan :  this is the subimage to be added                   */
   IMAGE_PROC  void IMAGE_API IMGVER(AdoptSubImage    )( Image pFoster, Image pOrphan );
   /* Removes a sub-image (child image) from a parent image. The
	  sub image my then be moved to another image with
	  AdoptSubImage.
	  Parameters
	  pImage :  the sub\-image to orphan.                        */
   IMAGE_PROC  void IMAGE_API IMGVER(OrphanSubImage   )( Image pImage );
   /* Create or recreate an image using the specified color buffer,
	  and size. All sub-images have their color data reference
	  updated.
	  Example
	  <code>
	  Image image = NULL;
	  POINTER data = NewArray( CDATA, 100* 100 );
	  image = RemakeImage( image, data, 100, 100 );
	  </code>
	  Remarks
	  If the source image is NULL, a new image will be built using
	  the color buffer and size specified.
	  Image.flags has IF_FLAG_EXTERN_COLORS set if made this way,
	  since the color buffer is an external resource. This causes
	  UnmakeImage() to not attempt to free the color buffer.
	  If the original image does exist, its color buffer is swapped
	  for the one specified, and coordinates are updated. The video
	  system uses this to create an image that has the color data
	  surface the surface of the display.
	  See Also
	  <link sack::image::BuildImageFile, BuildImageFile>
	  GetDisplayImage
	  Parameters
	  data :    Pointer to a buffer of 32 bit color data. ARGB and
				ABGR available via compile option.
	  width :   the width of the data in pixels.
	  height :  the height of the data in pixels.
	  Returns
	  \Returns the original image if not NULL, otherwise results
	  with an image who's color plane is defined by a user defined
	  buffer of width by height size. The user must have allocated
	  this buffer appropriately, and is responsible for its
	  destruction.                                                  */
   IMAGE_PROC  Image IMAGE_API IMGVER(RemakeImageEx    )( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* Load an image file. Today we support PNG, JPG, GIF, BMP.
	  Tomorrow consider tapping into that FreeImage project on
	  sourceforge, that combines all readers into one.
	  Parameters
	  name :      Filename to read from. Opens in 'Current Directory'
				  if not an absolute path.
	  DBG_PASS :  _nt_
	  Example
	  See <link sack::image::Image, Image>                            */
	IMAGE_PROC  Image IMAGE_API IMGVER(LoadImageFileEx  )( CTEXTSTR name DBG_PASS );
	/* <combinewith sack::image::LoadImageFileEx@CTEXTSTR name>
	   Extended load image file. This allows specifying a file group
	   to load from. (Groups were added for platforms without
	   support of current working directory).
	   Parameters
	   group :  Group to load the file from
	   _nt_ :   _nt_                                                 */
	IMAGE_PROC Image  IMAGE_API IMGVER(LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
   /* Decodes a block of memory into an image. This is used
	  internally so, LoadImageFile() opens the file and reads it
	  into a buffer, which it then passes to DecodeMemoryToImage().
	  Images stored in custom user structures may be passed for
	  decoding also.
	  Parameters
	  buf :   Pointer to bytes of data to decode
	  size :  the size of the buffer to decode
	  Returns
	  NULL is returned if the data does not decode as an image.
	  an Image is returned otherwise.
	  Example
	  This pretends that you have a FILE* open to some image
	  already, and that the image is tiny (less than 4k bytes).
	  <code lang="c#">
	  char buffer[4096];
	  int length;
	  length = fread( buffer, 1, 4096, some_file );
	  Image image = DecodeMemoryToImage( buffer, length );
	  if( image )
	  {
		 // buffer decoded okay.
	  }
	  </code>                                                       */
			IMAGE_PROC  Image IMAGE_API IMGVER(DecodeMemoryToImage )( uint8_t* buf, size_t size );
#ifdef __cplusplus
		namespace loader{
#endif
	IMAGE_PROC  LOGICAL IMAGE_API IMGVER(PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC  LOGICAL IMAGE_API IMGVER(JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
#ifdef __cplusplus
		}
#endif
	  /* direct hack for processing clipboard data... probably does some massaging of the databefore calling DecodeMemoryToImage */
   IMAGE_PROC  Image IMAGE_API IMGVER(ImageRawBMPFile )(uint8_t* ptr, uint32_t filesize);
	/* Releases an image, has extra debug parameters.
	   Parameters
	   Image :     the Image to release.
	   DBG_PASS :  Adds <link sack::DBG_PASS, DBG_PASS> parameter for
				   the release memory tracking.                       */
	IMAGE_PROC  void IMAGE_API IMGVER(UnmakeImageFileEx )( Image pif DBG_PASS );
   /* Sets the active image rectangle to the bounding rectangle
	  specified. This can be used to limit artificially drawing
	  onto an image. (It is easier to track to create a subimage in
	  the location to draw instead of masking with a bound rect,
	  which has problems restoring back to initial conditions)
	  Parameters
	  pImage :  Image to set the drawing clipping rectangle.
	  bound :   a pointer to an IMAGE_RECTANGLE to set the image
				boundaries to.                                      */
   IMAGE_PROC  void  IMAGE_API IMGVER(SetImageBound    )( Image pImage, P_IMAGE_RECTANGLE bound );
// reset clip rectangle to the full image (subimage part )
// Some operations (move, resize) will also reset the bound rect,
// this must be re-set afterwards.
// ALSO - one SHOULD be nice and reset the rectangle when done,
// otherwise other people may not have checked this.
/* Change the size of an image, reallocating the color buffer as
   necessary.
   <b>Parameters</b>
   <b>Remarks</b>
   If the image is a sub image (located within a parent), the
   subimage view on the parent image is updated to the new width
   and height. The color buffer remains the parent's buffer.
   If the image is a parent, a new buffer is allocated. If the
   previous buffer was specified by the user in RemakeImage,
   that buffer is not freed, but a new buffer is still created.
   <b>Bugs</b>
   If the image is a parent image, the child images are not
   updated to the newly allocated buffer. Resize works really
   well for subimages though.                                    */
   IMAGE_PROC  void IMAGE_API IMGVER(ResizeImageEx     )( Image pImage, int32_t width, int32_t height DBG_PASS);
   /* Moves an image within a parent image. Top level images and
	  images which have a user color buffer do not move.
	  Parameters
	  pImage :  The image to move.
	  x :       the new X coordinate of the image.
	  y :       the new Y coordinate of the image.               */
   IMAGE_PROC  void IMAGE_API IMGVER(MoveImage         )( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
   IMAGE_PROC  void IMAGE_API IMGVER(BlatColor         )( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* Blat is the sound a trumpet makes when it spews forth
	  noise... so Blat color is just fill a rectangle with a color,
	  quickly. Apply alpha transparency of the color specified.
	  Parameters
	  pifDest :  The destination image to fill the rectangle on
	  x :        left coordinate of the rectangle
	  y :        right coordinate of the rectangle
	  w :        width of the rectangle
	  h :        height of the rectangle
	  color :    color to fill the rectangle with. The alpha of this
				 color will be applied.                              */
   IMAGE_PROC  void IMAGE_API IMGVER(BlatColorAlpha    )( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* \ \
	  Parameters
	  pDest :         destination image (the one to copy to)
	  pIF :           source image
	  x :             destination top coordinate
	  y :             destination left coordinate
	  nTransparent :  <link sack::image::AlphaModifier, Alpha Operation>
	  method :        <link sack::image::blot_methods, Blot Method>
	  _nt_ :          _nt_                                               */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotImageEx       )( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
   /* Copies an image from one image onto another. The copy is done
	  directly and no scaling is applied. If a width or height
	  larget than the image to copy is specified, only the amount
	  of the image that is valid is copied.
	  Parameters
	  pDest :         Destination image
	  pIF :           Image file to copy
	  x :             X position to put copy at
	  y :             Y position to put copy at
	  xs :            X position to copy from.
	  ys :            Y position to copy from.
	  wd :            how much of the image horizontally to copy
	  ht :            how much of the image vertically to copy
	  nTransparent :  <link sack::image::AlphaModifier, Alpha Transparency method>
	  method :        <link sack::image::blot_methods, BlotMethods>
	  <b>Method == BLOT_SHADED extra parameters</b>
	  red :    Color to use the red channel to output the scale from
			   black to color
	  green :  Color to use the red channel to output the scale from
			   black to color
	  blue :   Color to use the red channel to output the scale from
			   black to color
	  <b>Method == BLOT_SHADED extra parameters</b>
	  shade :  _nt_
	  See Also                                                                     */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotImageSizedEx  )( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
   /* Copies some or all of an image to a destination image of
	  specified width and height. This does linear interpolation
	  scaling.
	  There are simple forms of this function as macros, since
	  commonly you want to output the entire image, a macro which
	  automatically sets (0,0),(width,height) as the source
	  \parameters to output the whole image exists.
	  Parameters
	  \ \
	  pifDest :       Destination image
	  pifSrc :        image to copy from
	  xd :            destination x coordinate
	  yd :            destination y coordinate
	  wd :            destination width (source image width will be
					  scaled to this)
	  hd :            destination height (source image height will
					  be scaled to this)
	  xs :            source x coordinate (where to copy from)
	  ys :            source y coordinate (where to copy from)
	  ws :            source width (how much of the image to copy)
	  hs :            source height (how much of the image to copy)
	  nTransparent :  Alpha method...
	  method :        specifies how the source color data is
					  transformed if at all. See BlotMethods
	  ... :           possible extra parameters depending on method
	  <b>Method == BLOT_MULTISHADE extra parameters</b>
	  red :    Color to use the red channel to output the scale from
			   black to color
	  green :  Color to use the red channel to output the scale from
			   black to color
	  blue :   Color to use the red channel to output the scale from
			   black to color
	  <b>Method == BLOT_SHADED extra parameters</b>
	  shade :  _nt_
	  See Also
	  <link sack::image::AlphaModifier, Alpha Methods>
	  <link sack::image::blot_methods, Blot Methods>
	  <link sack::image::BlotScaledImage, BlotScaledImage>
	  <link sack::image::BlotScaledImageShaded, BlotScaledImageShaded>
	  <link sack::image::BlotScaledImageShadedAlpha, BlotScaledImageShadedAlpha>
																				 */
   IMAGE_PROC  void IMAGE_API IMGVER(BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
								   , int32_t xd, int32_t yd
								   , uint32_t wd, uint32_t hd
								   , int32_t xs, int32_t ys
								   , uint32_t ws, uint32_t hs
								   , uint32_t nTransparent
								   , uint32_t method, ... );
/* Your basic PLOT functions (Image.C, plotasm.asm)
   A function pointer to the function which sets a pixel in an
   image at a specified x, y coordinate.
   Parameters
   Image :  The image to get the pixel from
   X :      x coordinate to get pixel color
   Y :      y coordinate to get pixel color
   Color :  color to put at the coordinate. image will be set
			exactly to this color, and whatever the alpha of the
			color is.                                            */
   IMAGE_PROC  void plot       ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which sets a pixel in an
	  image at a specified x, y coordinate.
	  Parameters
	  Image :  The image to get the pixel from
	  X :      x coordinate to get pixel color
	  Y :      y coordinate to get pixel color
	  Color :  color to put at the coordinate. Alpha blending will be
			   done.                                                  */
   IMAGE_PROC  void plotalpha  ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which gets a pixel from an
	  image at a specified x, y coordinate.
	  Parameters
	  Image :  The image to get the pixel from
	  X :      x coordinate to get pixel color
	  Y :      y coordinate to get pixel color
	  Returns
	  CDATA color in the Image at the specified coordinate.         */
   IMAGE_PROC  CDATA getpixel  ( Image pi, int32_t x, int32_t y );
//-------------------------------
// Line functions  (lineasm.asm) // should include a line.c ... for now core was assembly...
//-------------------------------
  // d is color data...
   IMAGE_PROC  void do_line      ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
  // d is color data...
   IMAGE_PROC  void do_lineAlpha ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
   /* This is a function pointer that references a function to do
	  optimized horizontal lines. The function pointer is updated
	  when SetBlotMethod() is called.
	  Parameters
	  Image :   the image to draw to
	  Y :       the y coordinate of the line (how far down from top to
				draw it)
	  x_from :  X coordinate to draw from
	  x_to :    X coordinate to draw to
	  color :   the color of the line. This color will be set to the
				surface, the alpha result will be the alpha of this
				color.                                                 */
   IMAGE_PROC  void do_hline      ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
	  optimized vertical lines. The function pointer is updated
	  when SetBlotMethod() is called.
	  Parameters
	  Image :   the image to draw to
	  X :       the x coordinate of the line (how far over to draw
				it)
	  y_from :  Y coordinate to draw from
	  y_to :    Y coordinate to draw to
	  color :   the color of the line. This color will be set to the
				surface, the alpha result will be the alpha of this
				color.                                               */
   IMAGE_PROC  void do_vline      ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
   /* This is a function pointer that references a function to do
	  optimized horizontal lines with alpha blending. The function
	  pointer is updated when SetBlotMethod() is called.
	  Parameters
	  Image :   the image to draw to
	  Y :       the Y coordinate of the line (how far down from top
				of image to draw it)
	  x_from :  X coordinate to draw from
	  x_to :    X coordinate to draw to
	  color :   the color of the line (alpha component of the color
				will be applied)                                    */
   IMAGE_PROC  void do_hlineAlpha ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
	  optimized vertical lines with alpha blending. The function
	  pointer is updated when SetBlotMethod() is called.
	  Parameters
	  Image :   the image to draw to
	  X :       the x coordinate of the line (how far over to draw
				it)
	  y_from :  Y coordinate to draw from
	  y_to :    Y coordinate to draw to
	  color :   the color of the line (alpha component of the color
				will be applied)                                    */
   IMAGE_PROC  void do_vlineAlpha ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
	/* routine which iterates through the points along a lone from
	   x,y to xto,yto, calling a user function at each point.
	   Parameters
	   Image :  the image to pretend to draw on
	   x :      draw from this x coordinate
	   y :      draw from this y coordinate
	   xto :    draw to this x coordinate
	   yto :    draw to this y coordinate
	   d :      userdata (color data)
	   func :   user callback function to a function of type...<p />void
				func( Image pif, int32_t x, int32_t y, int d ) ;
	   Remarks
	   The Image passed does not HAVE to be an Image, it can be any
	   user POINTER.
	   The data passed is limited to 32 bits, and will not hold a
	   pointer if built for 64 bit platform.
	   Example
	   <code lang="c++">
	   Image image;
	   void MyPlotter( Image image, int32_t x, int32_t y, CDATA color )
	   {
		   // do something with the image at x,y
	   }
	   void UseMyPlotter( Image image )
	   {
		   do_lineExV( image, 10, 10, 80, 80, BASE_COLOR_BLACK, MyPlotter );
	   }
	   </code>                                                               */
	IMAGE_PROC  void do_lineExV    ( Image pImage, int32_t x, int32_t y
									, int32_t xto, int32_t yto, uintptr_t color
									, void (*func)( Image pif, int32_t x, int32_t y, uintptr_t d ) );
   /* \Returns the correct SFTFont pointer to the default font. In all
	  font functions, NULL may be used as the font, and this is the
	  font that will be used.
	  Parameters
	  None.
	  Example
	  <code lang="c++">
	  SFTFont font = GetDefaultFont();
	  </code>                                                       */
   IMAGE_PROC  SFTFont IMAGE_API IMGVER(GetDefaultFont )( void );
   /* \Returns the height of a font for purposes of spacing between
	  lines. Characters may render outside of this height.
	  Parameters
	  SFTFont :  SFTFont to get the height of. if NULL returns an internal
			  font's height.
	  Returns
	  the height of the font.                                        */
   IMAGE_PROC  uint32_t  IMAGE_API IMGVER(GetFontHeight  )( SFTFont );
   /* \Returns the approximate rectangle that would be used for a
	  string. It only counts using the line measurement. Newlines
	  in strings count to wrap text to subsequent lines and start
	  recounting the width, returning the maximum length of string
	  horizontally.
	  Parameters
	  pString :  The string to measure
	  len :      the length of characters to count in string
	  width :    a pointer to a uint32_t to receive the width of the
				 string
	  height :   a pointer to a uint32_t to receive the height of the
				 string
	  UseFont :  A SFTFont to use.
	  Returns
	  \Returns the width parameter. If NULL are passed for width
	  and height, this is OK. One of the simple macros just passes
	  the string and gets the return - this is for how wide the
	  string would be.                                             */
   IMAGE_PROC  uint32_t  IMAGE_API IMGVER(GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
   /* Fill the width and height with the actual size of the string
	  as it is drawn. (may be above or below the original
	  rectangle)
	  Parameters
	  pString :     the string to measure
	  nLen :        the number of characters in the string
	  width :       a pointer to a 32 bit value to get resulting
					width
	  height :      a pointer to a 32 bit value to get resulting
					height
	  charheight :  the actual height of the characters (as reports
					by line)
	  UseFont :     a SFTFont to use. If NULL use a default internal
					font.                                           */
   IMAGE_PROC  uint32_t IMAGE_API IMGVER(GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
// background of color 0,0,0 is transparent - alpha component does not
// matter....
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterFont              )( Image pImage
												  , int32_t x, int32_t y, int32_t height
												  , CDATA color, CDATA background,
												   TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn from the point up, with the characters
	  aligned with the top to the left; it goes up from the point.
	  the point becomes the bottom left of the rectangle output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  c :           the character to output
	  font :        the font to use. NULL use an internal default
					font.                                          */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterVerticalFont      )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn from the point to the left, with the
	  characters aligned with the top to the left; it goes up from
	  the point. the point becomes the bottom left of the rectangle
	  \output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  pc :          pointer to constant text
	  nLen :        length of text to output
	  font :        the font to use. NULL use an internal default
					font.                                           */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterInvertFont        )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a character in the specified font, from the specified
	  point, text is drawn from the point up, with the characters
	  aligned with the top to the left; it goes up from the point. the
	  point becomes the bottom left of the rectangle output.
	  Parameters
																	   */
   IMAGE_PROC  void IMAGE_API IMGVER(PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn right side up and godes from left to
	  right. The point becomes the top left of the rectangle
	  \output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  pc :          pointer to constant text
	  nLen :        length of text to output
	  font :        the font to use. NULL use an internal default
					font.                                         */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringFontEx              )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* justification 0 is left, 1 is right, 2 is center */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringFontExx              )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font, int justication, uint32_t _width );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn from the point down, with the characters
	  aligned with the top to the right; it goes down from the
	  point. the point becomes the top right of the rectangle
	  \output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  pc :          pointer to constant text
	  nLen :        length of text to output
	  font :        the font to use. NULL use an internal default
					font.                                           */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringVerticalFontEx      )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn upside down, and goes to the left from
	  the point. the point becomes the bottom right of the
	  rectangle output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  pc :          pointer to constant text
	  nLen :        length of text to output
	  font :        the font to use. NULL use an internal default
					font.                                         */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringInvertFontEx        )( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
	  point, text is drawn from the point up, with the characters
	  aligned with the top to the left; it goes up from the point. the
	  point becomes the bottom left of the rectangle output.
	  Parameters
	  pImage :      image to draw string into
	  x :           x position of the string
	  y :           y position of the string
	  color :       color of the data drawn in the font
	  background :  color of the data not drawn in the font
	  pc :          pointer to constant text
	  nLen :        length of text to output
	  font :        the font to use. NULL use an internal default
					font.                                              */
   IMAGE_PROC  void IMAGE_API IMGVER(PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   //uint32_t (*PutMenuStringFontEx)            ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   //uint32_t (*PutCStringFontEx)               ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   IMAGE_PROC  uint32_t IMAGE_API IMGVER(GetMaxStringLengthFont  )( uint32_t width, SFTFont UseFont );
   /* Used as a proper accessor method to get an image's width and
	  height. Decided to allow the image structure to be mostly
	  public, so the first 4 members are the images x,y, width and
	  height, and are immediately accessable by the Image pointer.
	  Parameters
	  pImage :  image to get the size of
	  width :   pointer to a 32 bit unsigned value to result with the
				width, if NULL ignored.
	  height :  pointer to a 32 bit unsigned value to result with the
				height, if NULL ignored.                              */
   IMAGE_PROC  void IMAGE_API IMGVER(GetImageSize            )( Image pImage, uint32_t *width, uint32_t *height );
   /* \Returns the pointer to the color buffer currently used
	  \internal to the image.
	  Parameters
	  pImage :  Image to get the surface of.
	  Example
	  <code lang="c#">
	  Image image = MakeImageFile( 100, 100 );
	  PCDATA pointer_color_data = GetImageSurface( image );
	  </code>
	  Note
	  This might be used to do an optimized output routine. Drawing
	  to the image with plot and line are not necessarily the best
	  for things like circles. Provides ability for user to output
	  directly to the color buffer.                                 */
   IMAGE_PROC  PCDATA IMAGE_API IMGVER(GetImageSurface        )( Image pImage );
   // would seem silly to load fonts - but for server implementations
   // the handle received is not the same as the font sent.
   IMAGE_PROC  SFTFont IMAGE_API IMGVER(LoadFont                )( SFTFont font );
   /* Destroys a font, releasing all resources associated with
	  character data and font rendering.                       */
   IMAGE_PROC  void IMAGE_API IMGVER(UnloadFont              )( SFTFont font );
	/* This is a function used to synchronize image operations when
	   the image interface is across a message server.              */
	IMAGE_PROC  void IMAGE_API IMGVER(SyncImage                  )( void );
	// intersect rectangle, results with the overlapping portion of R1 and R2
   // into R ...
   IMAGE_PROC  int IMAGE_API IMGVER(IntersectRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* Merges two image rectangles. The resulting rectangle is a
	  rectangle that includes both rectangles.
	  Parameters
	  r :   Pointer to an IMAGE_RECTANGLE for the result.
	  r1 :  PIMAGE_RECTANGLE one rectangle.
	  r2 :  PIMAGE_RECTANGLE the other rectangle.               */
   IMAGE_PROC  int IMAGE_API IMGVER(MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* User applications may use an aux rect attatched to an image. The
	  'Display' render library used this itself however, making
	  this mostly an internal feature.
	  Parameters
	  pImage :  image to get the aux rect of.
	  pRect :   pointer to an IMAGE_RECTANGLE to get the aux
				rectangle data in.                                     */
   IMAGE_PROC  void IMAGE_API IMGVER(GetImageAuxRect    )( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* User applications may use an aux rect attatched to an image.
	  The 'Display' render library used this itself however, making
	  this mostly an internal feature.
	  Parameters
	  pImage :  image to set the aux rect of.
	  pRect :   pointer to an IMAGE_RECTANGLE to set the aux
				rectangle to.                                       */
   IMAGE_PROC  void IMAGE_API IMGVER(SetImageAuxRect    )( Image pImage, P_IMAGE_RECTANGLE pRect );
	/* \ \
	   Parameters
	   Filename :  \file name of image to load. Converts image into
				   sprite automatically, resulting with a sprite.
	   DBG_PASS :  See <link sack::DBG_PASS, DBG_PASS>              */
		IMAGE_PROC  PSPRITE IMAGE_API IMGVER(MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
	  /* create a sprite from an Image */
	IMAGE_PROC  PSPRITE IMAGE_API IMGVER(MakeSpriteImageEx )( Image image DBG_PASS );
	/* Release a Sprite. */
	IMAGE_PROC  void IMAGE_API IMGVER(UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
	// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
	IMAGE_PROC  void IMAGE_API IMGVER(rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height );
   /* output a rotated sprite to destination image, using and angle specified.  The angle is represented as 0x1 0000 0000 is 360 degrees */
	IMAGE_PROC  void IMAGE_API IMGVER(rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
   /* output a sprite at its current location */
	IMAGE_PROC  void IMAGE_API IMGVER(BlotSprite )( Image pdest, PSPRITE ps );
/* Sets the point on a sprite which is the 'hotspot' the hotspot
   is the point that is drawn at the specified coordinate when
   outputting a sprite.
   Parameters
   sprite :  The PSPRITE to set the hotspot of.
   x :       x coordinate in the sprite's image that becomes the
			 hotspot.
   y :       y coordinate in the sprite's image that becomes the
			 hotspot.                                            */
IMAGE_PROC  PSPRITE IMAGE_API IMGVER(SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* This function sets the current location of a sprite. When
   asked to render, the sprite will draw itself here.
   Parameters
   sprite :  the sprite to move
   x :       the new x coordinate of the parent image to draw at
   y :       the new y coordinate of the parent image to draw at */
IMAGE_PROC  PSPRITE IMAGE_API IMGVER(SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
/* Use a font file to get a font that can be used for outputting
   characters and strings.
   Parameters
   file\ :    Filename of a font to render.
   nWidth :   desired width in pixels to render the font.
   nHeight :  desired height in pixels to render the font.
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.  */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(InternalRenderFontFile )( CTEXTSTR file
																		, int32_t nWidth
																		, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																		, uint32_t flags
																		);
/* Rerender the current font with a new size. */
IMAGE_PROC void IMAGE_API IMGVER(RerenderFont)( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
	/* Dumps the whole cache to log file, shows family, style, path and filename.
	Is the same sort of dump that OpenFontFile uses.
	 */
IMAGE_PROC void IMAGE_API IMGVER(DumpFontCache)( void );
#ifndef INTERNAL_DUMP_FONT_FILE
/* takes a font and dumps a header-file formatted file; then the font can be
 statically built into code. */
IMAGE_PROC void IMAGE_API IMGVER(DumpFontFile)( CTEXTSTR name, SFTFont font_to_dump );
#endif
/* Creates a font based on indexes from the internal font cache.
   This is used by the FontPicker dialog to choose a font. The
   data the dialog used to render the font is available to the
   application, and may be passed back for rendering a font
   without knowing specifically what the values mean.
   Parameters
   nFamily :  The number of the family in the cache.
   nStyle :   The number of the style in the cache.
   nFile :    The number of the file in the cache.
   nWidth :   the width to use for rendering characters (in
			  pixels)
   nHeight :  the height to use for rendering characters (in
			  pixels)
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.
   Returns
   A SFTFont which can be used to output. If the file exists. NULL
   on failure.
   Example
   Used internally for FontPicker dialog, see <link sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t, InternalRenderFontFile> */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(InternalRenderFont )( uint32_t nFamily
																  , uint32_t nStyle
																  , uint32_t nFile
																  , int32_t nWidth
																  , int32_t nHeight
																  , PFRACTION width_scale
																  , PFRACTION height_scale
																  , uint32_t flags
																  );
/* Releases all resources for a SFTFont.  */
IMAGE_PROC  void IMAGE_API IMGVER(DestroyFont)( SFTFont *font );
/* Get the global font data structure. This is an internal
   structure, and it's definition may not be exported. Currently
   the definition is in documentation.
   See Also
   <link sack::image::FONT_GLOBAL, SFTFont Global>                  */
IMAGE_PROC  struct font_global_tag * IMAGE_API IMGVER(GetGlobalFonts)( void );
// types of data which may result...
typedef struct font_data_tag *PFONTDATA;
/* Information to render a font from a file to memory. */
typedef struct render_font_data_tag *PRENDER_FONTDATA;
/* Recreates a SFTFont based on saved FontData. The resulting font
   may be scaled from its original size.
   Parameters
   pfd :           pointer to font data.
   width_scale :   FRACTION to scale the original font height
				   \description by. if NULL uses the original
				   font's size.
   height_scale :  FRACTION to scale the original font height
				   \description by.  if NULL uses the original
				   font's size.
   Example
   <code lang="c++">
   POINTER some_loaded_data; // pretend it is initialized to something valid
   SFTFont font = RenderScaledFontData( some_loaded_data, NULL, NULL );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font );
   </code>
   Or, maybe your original designed screen was 1024x768, and
   it's now showing on 1600x1200, for the text to remain the
   same...
   <code lang="c++">
   FRACTION width_scale;
   FRACTION height_scale;
   uint32_t w, h;
   GetDisplaySize( &amp;w, &amp;h );
   SetFraction( width_scale, w, 1024 );
   SetFraction( height_scale, h, 768 );
   SFTFont font2 = RenderScaledFontData( some_loaded_data, &amp;width_scale, &amp;height_scale );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font2 );
   </code>                                                                                     */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
#define RenderFontData(pfd) RenderScaledFontData( pfd,NULL,NULL )
#define ogl_RenderFontData(pfd) ogl_RenderScaledFontData( pfd,NULL,NULL )
/* <combinewith sack::image::RenderScaledFontEx@CTEXTSTR@uint32_t@uint32_t@PFRACTION@PFRACTION@uint32_t@size_t *@POINTER *, sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                                                                                                                        */
IMAGE_PROC SFTFont IMAGE_API IMGVER(RenderScaledFontEx)( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* Renders a font with a FRACTION scalar for the X and Y sizes.
   Parameters
   name :          Name of the font (file).
   width :         Original width (in pels) to make the font.
   height :        Original height (in pels) to make the font.
   width_scale :   scalar to apply to the width
   height_scale :  scalar to apply to the height
   flags :         Flags specifying how many bits to render the
				   font with (and other info?) See enum
				   FontFlags.                                   */
IMAGE_PROC SFTFont IMAGE_API IMGVER(RenderScaledFont)( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
#define RenderScaledFont(n,w,h,ws,hs) RenderScaledFontEx(n,w,h,ws,hs,NULL,NULL)
/* Renders a font file and returns a SFTFont. The font can then be
   used in string output functions to images.
   Parameters
   file\ :           \File name of a font to render. Any font
					 that freetype supports.
   width :           width of characters to render in.
   height :          height of characters to render.
   flags :           if( ( flags &amp; 3 ) == 3 )<p /> font\-\>flags
					 = FONT_FLAG_8BIT;<p /> else if( ( flags &amp;
					 3 ) == 2 )<p /> font\-\>flags =
					 FONT_FLAG_2BIT;<p /> else<p /> font\-\>flags
					 = FONT_FLAG_MONO;<p />
   pnFontDataSize :  optional pointer to a 32 bit value to
					 receive the size of rendered data.
   pFontData :       The render data. This data can be used to
					 recreate this font.                             */
IMAGE_PROC  SFTFont IMAGE_API IMGVER(RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
#define RenderFontFile(file,w,h,flags) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,NULL,NULL)
#define RenderFontFileEx(file,w,h,flags,a,b) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,a,b )
		/* This can be used to get the internal description of a font,
		   which the user may then save, and use later to recreate the
		   font the same way.
		   Parameters
		   font :         SFTFont to get the render description from.
		   fontdata :     a pointer to a pointer which will be filled
						  with a pointer buffer that has the font data.
		   fontdatalen :  a pointer to 32 bit value to receive the length
						  of data.                                        */
		IMAGE_PROC  int IMAGE_API IMGVER(GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
// exported for the PSI font chooser to set the data for the font
// to be retreived later when only the font handle remains.
IMAGE_PROC  void IMAGE_API IMGVER(SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
#ifndef PSPRITE_METHOD
/* <combine sack::image::PSPRITE_METHOD>
   \ \                                   */
#define PSPRITE_METHOD PSPRITE_METHOD
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	// provided for display rendering portion to define this method for sprites to use.
   // deliberately out of namespace... please do not move this up.
IMAGE_PROC  void IMAGE_API IMGVER(SetSavePortion )( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
/* \Returns the red channel of the color
   Parameters
   color :  Color to get the red channel of.
   Returns
   The COLOR_CHANNEL (byte) of the red channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetRedValue)( CDATA color ) ;
/* \Returns the green channel of the color
   Parameters
   color :  Color to get the green channel of.
   Returns
   The COLOR_CHANNEL (byte) of the green channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetGreenValue)( CDATA color );
/* \Returns the blue channel of the color
   Parameters
   color :  Color to get the blue channel of.
   Returns
   The COLOR_CHANNEL (byte) of the blue channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetBlueValue)( CDATA color );
/* \Returns the alpha channel of the color
   Parameters
   color :  Color to get the alpha channel of.
   Returns
   The COLOR_CHANNEL (byte) of the alpha channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API IMGVER(GetAlphaValue)( CDATA color );
/* Sets the red channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new red channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetRedValue)( CDATA color, COLOR_CHANNEL r ) ;
/* Sets the green channel in a color value.
   Parameters
   color :  Original color to modify
   g :      new green channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetGreenValue)( CDATA color, COLOR_CHANNEL green );
/* Sets the blue channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new blue channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetBlueValue)( CDATA color, COLOR_CHANNEL b );
/* Sets the alpha channel in a color value.
   Parameters
   color :  Original color to modify
   a :      new alpha channel value         */
IMAGE_PROC CDATA IMAGE_API IMGVER(SetAlphaValue)( CDATA color, COLOR_CHANNEL a );
/* Makes a CDATA color from the RGB components. Sets the alpha
   as 100% opaque.
   Parameters
   r :      red channel of new color
   green :  green channel of new color
   b :      blue channel of new color                          */
IMAGE_PROC CDATA IMAGE_API IMGVER(MakeColor)( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
/* Create a CDATA color from components.
   Parameters
   r :      Red channel value
   green :  green channel value
   b :      blue channel value
   a :      alpha channel value
   Returns
   A CDATA representing the color specified. */
IMAGE_PROC CDATA IMAGE_API IMGVER(MakeAlphaColor)( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
/* With 3d renderer, images have a transformation matrix. This
   function allows you to get the transformation matrix.
   Parameters
   pImage :  image to get the transformation matrix of.        */
IMAGE_PROC  PTRANSFORM IMAGE_API IMGVER(GetImageTransformation)( Image pImage );
enum image_translation_relation
{
   IMAGE_TRANSFORM_RELATIVE_CENTER = 0,
   IMAGE_TRANSFORM_RELATIVE_LEFT,
   IMAGE_TRANSFORM_RELATIVE_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_TOP,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM,
   IMAGE_TRANSFORM_RELATIVE_TOP_LEFT,
   IMAGE_TRANSFORM_RELATIVE_TOP_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_LEFT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_RIGHT,
 // only mode that uses the 'aux' parameter of SetImageTransformRelation
   IMAGE_TRANSFORM_RELATIVE_OTHER
};
/*
 This sets flags on the image, so when it's called for rendering to the screen
 this is how
	*/
IMAGE_PROC  void IMAGE_API IMGVER(SetImageTransformRelation)( Image pImage, enum image_translation_relation relation, PRCOORD aux );
/*
 This just draws the image into the current 3d context.
 This is a point-sprite engine too....
 It does not setup anything about rendering this, just generates the texture at the right coords.
 Parameters
 render_pixel_scaled : when drawing, reverse compute from the angle of the view, and the depth of the thing to scale orthagonal, but at depth.  (help 3d vision)
 */
IMAGE_PROC  void IMAGE_API IMGVER(Render3dImage)( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC  void IMAGE_API IMGVER(Render3dText)( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
/*
  Utilized by fonts with images with reverse_interface set to transfer child images;
  may be generally useful; but had to be exposed through interface
  Might be a shallow move....
 */
IMAGE_PROC  void IMAGE_API IMGVER(TransferSubImages)( Image pImageTo, Image pImageFrom );
IMAGE_PROC  LOGICAL IMAGE_API IMGVER(IsImageTargetFinal)( Image image );
/* These flags are used in SetImageRotation and RotateImageAbout
   functions - these are part of the 3D driver interface
   extension. They allow for controlling how the rotation is
   performed.                                                    */
enum image_rotation_flags {
 // relative to center of image (center if not left, right, top or bottom )
	IMAGE_ROTATE_FLAG_CENTER = 0,
 // relative to top edge (center if not left or right)
   IMAGE_ROTATE_FLAG_TOP,
 // relative to left edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_LEFT,
 // relative to right edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_RIGHT,
 // relative to bottom edge (center if not left or right )
   IMAGE_ROTATE_FLAG_BOTTOM,
 // use the offset relative to the image orientation
	IMAGE_ROTATE_FLAG_ADD_CUSTOM_OFFSET
};
/* Sets the rotation matrix of an image to an arbitrary
   yaw/pitch/roll coordinate.
   Parameters
   pImage :     Image to rotate
   edge_flag :  what edge the rotation is relative to
   offset_x :   offset from the edge to get the center
   offset_y :   offset from the edge to get the center
   rx :         rotation about x axis (horizontal)
   ry :         rotation about y axis (vertical)
   rz :         rotation about z axis (into screen)     */
IMAGE_PROC void IMAGE_API IMGVER(SetImageRotation)( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
/* Allows arbitrary rotation of an image in 3d render mode.
   Parameters
   pImage :     image to rotate
   edge_flag :  see enum image_rotation_flags
   offset_x :   offset from top left of image to center the
				rotation
   offset_y :   offset from top left of image to center the
				rotation
   vAxis :      axis to rotate around, can be any arbitrary
				direction
   angle :      angle of rotation around the axis.
   Remarks
   \See Also <link sack::image::image_rotation_flags, image_rotation_flags Enumeration> */
IMAGE_PROC void IMAGE_API IMGVER(RotateImageAbout)( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC void IMAGE_API IMGVER(MarkImageDirty)( Image pImage );
/* Defines the function interface for an image module. */
_INTERFACE_NAMESPACE
/* Defines a pointer member of the interface structure. */
#define IMAGE_PROC_PTR(type,name) type (CPROC*_##name)
/* Macro to build function pointer entries in the image
   interface.                                           */
//#define DIMAGE_PROC_PTR(type,name) type (CPROC**_##name)
/* This defines the interface call table. each function
   available in the API is reflected in this interface. It
   provdes a function table so applications don't have to be
   directly linked to the image API. This allows replacing the
   image API.                                                  */
typedef struct image_interface_tag
{
/* <combine sack::image::SetStringBehavior@Image@uint32_t>
   Internal
   Interface index 4                                  */
 IMAGE_PROC_PTR( void, SetStringBehavior) ( Image pImage, uint32_t behavior );
/* <combine sack::image::SetBlotMethod@uint32_t>
   \ \
   Internal
   Interface index 5                        */
 IMAGE_PROC_PTR( void, SetBlotMethod)     ( uint32_t method );
/*
   Internal
   Interface index 6*/
   IMAGE_PROC_PTR( Image,BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t Height>
   Internal
   Interface index 7*/
  IMAGE_PROC_PTR( Image,MakeImageFileEx)  (uint32_t Width, uint32_t Height DBG_PASS);
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t height>
   Internal
   Interface index 8                                                                    */
   IMAGE_PROC_PTR( Image,MakeSubImageEx)   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t height>
   \ \
   <b>Internal</b>
   Interface index 9                                                */
   IMAGE_PROC_PTR( Image,RemakeImageEx)    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   Internal
   Interface index 10                                                   */
  IMAGE_PROC_PTR( Image,LoadImageFileEx)  ( CTEXTSTR name DBG_PASS );
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Internal
   Interface index 11                                                 */
  IMAGE_PROC_PTR( void,UnmakeImageFileEx) ( Image pif DBG_PASS );
//-----------------------------------------------------
/* <combine sack::image::ResizeImageEx@Image@int32_t@int32_t height>
   Internal
   Interface index 14                                                          */
  IMAGE_PROC_PTR( void,ResizeImageEx)     ( Image pImage, int32_t width, int32_t height DBG_PASS);
/* <combine sack::image::MoveImage@Image@int32_t@int32_t>
   Internal
   Interface index 15                                               */
   IMAGE_PROC_PTR( void,MoveImage)         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 16                                                             */
   IMAGE_PROC_PTR( void,BlatColor)     ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlatColorAlpha@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 17                                                                  */
   IMAGE_PROC_PTR( void,BlatColorAlpha)( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlotImageEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 18*/
   IMAGE_PROC_PTR( void,BlotImageEx)     ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
 /* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 19*/
   IMAGE_PROC_PTR( void,BlotImageSizedEx)( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
  Internal
   Interface index  20                                                                                                        */
   IMAGE_PROC_PTR( void,BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
								   , int32_t xd, int32_t yd
								   , uint32_t wd, uint32_t hd
								   , int32_t xs, int32_t ys
								   , uint32_t ws, uint32_t hs
								   , uint32_t nTransparent
								   , uint32_t method, ... );
/*Internal
   Interface index 21*/
   IMAGE_PROC_PTR( void,plot)      ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 22*/
   IMAGE_PROC_PTR( void,plotalpha) ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 23*/
   IMAGE_PROC_PTR( CDATA,getpixel) ( Image pi, int32_t x, int32_t y );
/*Internal
   Interface index 24*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_line)     ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
/*Internal
   Interface index 25*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_lineAlpha)( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
/*Internal
   Interface index 26*/
   IMAGE_PROC_PTR( void,do_hline)     ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 27*/
   IMAGE_PROC_PTR( void,do_vline)     ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/*Internal
   Interface index 28*/
   IMAGE_PROC_PTR( void,do_hlineAlpha)( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 29*/
   IMAGE_PROC_PTR( void,do_vlineAlpha)( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/* <combine sack::image::GetDefaultFont>
   Internal
   Interface index 30                    */
   IMAGE_PROC_PTR( SFTFont,GetDefaultFont) ( void );
/* <combine sack::image::GetFontHeight@SFTFont>
   Internal
   Interface index 31                                        */
   IMAGE_PROC_PTR( uint32_t ,GetFontHeight)  ( SFTFont );
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   Internal
   Interface index 32                                                          */
   IMAGE_PROC_PTR( uint32_t ,GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@uint32_t@SFTFont>
   Internal
   Interface index 33                                                           */
   IMAGE_PROC_PTR( void,PutCharacterFont)              ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 34                                                                                        */
   IMAGE_PROC_PTR( void,PutCharacterVerticalFont)      ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 35                                                                                      */
   IMAGE_PROC_PTR( void,PutCharacterInvertFont)        ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 36                                                                                              */
   IMAGE_PROC_PTR( void,PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 37                                                                                   */
   IMAGE_PROC_PTR( void,PutStringFontEx)              ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 38                                                                                           */
   IMAGE_PROC_PTR( void,PutStringVerticalFontEx)      ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 39                                                                                         */
   IMAGE_PROC_PTR( void,PutStringInvertFontEx)        ( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 40                                                                                                 */
   IMAGE_PROC_PTR( void,PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, int32_t height, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   Internal
   Interface index 41                                     */
   IMAGE_PROC_PTR( uint32_t, GetMaxStringLengthFont )( uint32_t width, SFTFont UseFont );
/* <combine sack::image::GetImageSize@Image@uint32_t *@uint32_t *>
   Internal
   Interface index 42                                                    */
   IMAGE_PROC_PTR( void, GetImageSize)                ( Image pImage, uint32_t *width, uint32_t *height );
/* <combine sack::image::LoadFont@SFTFont>
   Internal
   Interface index 43                                   */
   IMAGE_PROC_PTR( SFTFont, LoadFont )                   ( SFTFont font );
		 /* <combine sack::image::UnloadFont@SFTFont>
			\ \                                    */
		 IMAGE_PROC_PTR( void, UnloadFont )                 ( SFTFont font );
/* Internal
   Interface index 44
   This is used by internal methods to transfer image and font
   data to the render agent.                                   */
   IMAGE_PROC_PTR( DataState, BeginTransferData )    ( uint32_t total_size, uint32_t segsize, CDATA data );
/* Internal
   Interface index 45
   Used internally to transfer data to render agent. */
   IMAGE_PROC_PTR( void, ContinueTransferData )      ( DataState state, uint32_t segsize, CDATA data );
/* Internal
   Interface index 46
   Command issues at end of data transfer to decode the data
   into an image.                                            */
   IMAGE_PROC_PTR( Image, DecodeTransferredImage )    ( DataState state );
/* After a data transfer decode the information as a font.
   Internal
   Interface index 47                                      */
   IMAGE_PROC_PTR( SFTFont, AcceptTransferredFont )     ( DataState state );
/*Internal
   Interface index 48*/
   IMAGE_PROC_PTR( CDATA, ColorAverage )( CDATA c1, CDATA c2
											  , int d, int max );
/* <combine sack::image::SyncImage>
   Internal
   Interface index 49               */
   IMAGE_PROC_PTR( void, SyncImage )                 ( void );
		 /* <combine sack::image::GetImageSurface@Image>
			\ \                                          */
		 IMAGE_PROC_PTR( PCDATA, GetImageSurface )       ( Image pImage );
		 /* <combine sack::image::IntersectRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
			\ \                                                                                             */
		 IMAGE_PROC_PTR( int, IntersectRectangle )      ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::MergeRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
	  \ \                                                                                         */
   IMAGE_PROC_PTR( int, MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::GetImageAuxRect@Image@P_IMAGE_RECTANGLE>
	  \ \                                                            */
   IMAGE_PROC_PTR( void, GetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::SetImageAuxRect@Image@P_IMAGE_RECTANGLE>
	  \ \                                                            */
   IMAGE_PROC_PTR( void, SetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::OrphanSubImage@Image>
	  \ \                                         */
   IMAGE_PROC_PTR( void, OrphanSubImage )  ( Image pImage );
   /* <combine sack::image::AdoptSubImage@Image@Image>
	  \ \                                              */
   IMAGE_PROC_PTR( void, AdoptSubImage )   ( Image pFoster, Image pOrphan );
	/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
	   \ \                                                         */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
	/* <combine sack::image::MakeSpriteImageEx@Image image>
	   \ \                                                  */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageEx )( Image image DBG_PASS );
	/* <combine sack::image::rotate_scaled_sprite@Image@PSPRITE@fixed@fixed@fixed>
	   \ \                                                                         */
	IMAGE_PROC_PTR( void   , rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height);
	/* <combine sack::image::rotate_sprite@Image@PSPRITE@fixed>
	   \ \                                                      */
	IMAGE_PROC_PTR( void   , rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
 /* <combine sack::image::BlotSprite@Image@PSPRITE>
	 Internal
   Interface index 61                                              */
		IMAGE_PROC_PTR( void   , BlotSprite )( Image pdest, PSPRITE ps );
	/* <combine sack::image::DecodeMemoryToImage@uint8_t*@uint32_t>
	   \ \                                                */
	IMAGE_PROC_PTR( Image, DecodeMemoryToImage )( uint8_t* buf, size_t size );
   /* <combine sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t>
	  \returns a SFTFont                                                      */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFontFile )( CTEXTSTR file
																 , int32_t nWidth
																 , int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																 , uint32_t flags
																 );
   /* <combine sack::image::InternalRenderFont@uint32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t>
	  requires knowing the font cache....                                 */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFont )( uint32_t nFamily
															, uint32_t nStyle
															, uint32_t nFile
															, int32_t nWidth
															, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
															, uint32_t flags
															);
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
IMAGE_PROC_PTR( SFTFont, RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
IMAGE_PROC_PTR( SFTFont, RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *size, POINTER *pFontData );
/* <combine sack::image::DestroyFont@SFTFont *>
   \ \                                       */
IMAGE_PROC_PTR( void, DestroyFont)( SFTFont *font );
/* <combine sack::image::GetGlobalFonts>
   global_font_data in interface is really a global font data. Don't
   have to call GetGlobalFont to get this.                           */
struct font_global_tag *_global_font_data;
/* <combine sack::image::GetFontRenderData@SFTFont@POINTER *@uint32_t *>
   \ \                                                           */
IMAGE_PROC_PTR( int, GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
/* <combine sack::image::SetFontRendererData@SFTFont@POINTER@uint32_t>
   \ \                                                         */
IMAGE_PROC_PTR( void, SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
/* <combine sack::image::SetSpriteHotspot@PSPRITE@int32_t@int32_t>
   \ \                                                       */
IMAGE_PROC_PTR( PSPRITE, SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* <combine sack::image::SetSpritePosition@PSPRITE@int32_t@int32_t>
   \ \                                                        */
IMAGE_PROC_PTR( PSPRITE, SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
	/* <combine sack::image::UnmakeImageFileEx@Image pif>
	   \ \                                                */
	IMAGE_PROC_PTR( void, UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
/* <combine sack::image::GetGlobalFonts>
   \ \                                   */
IMAGE_PROC_PTR( struct font_global_tag *, GetGlobalFonts)( void );
/* <combinewith sack::image::GetStringRenderSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@uint32_t *@SFTFont, sack::image::GetStringRenderSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                                                                                                                     */
IMAGE_PROC_PTR( uint32_t, GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
IMAGE_PROC_PTR( Image, LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
IMAGE_PROC_PTR( SFTFont, RenderScaledFont )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
IMAGE_PROC_PTR( SFTFont, RenderScaledFontEx )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetRedValue )( CDATA color ) ;
IMAGE_PROC_PTR( COLOR_CHANNEL, GetGreenValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetBlueValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetAlphaValue )( CDATA color );
IMAGE_PROC_PTR( CDATA, SetRedValue )( CDATA color, COLOR_CHANNEL r ) ;
IMAGE_PROC_PTR( CDATA, SetGreenValue )( CDATA color, COLOR_CHANNEL green );
IMAGE_PROC_PTR( CDATA, SetBlueValue )( CDATA color, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, SetAlphaValue )( CDATA color, COLOR_CHANNEL a );
IMAGE_PROC_PTR( CDATA, MakeColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, MakeAlphaColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
IMAGE_PROC_PTR( PTRANSFORM, GetImageTransformation )( Image pImage );
IMAGE_PROC_PTR( void, SetImageRotation )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
IMAGE_PROC_PTR( void, RotateImageAbout )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC_PTR( void, MarkImageDirty )( Image pImage );
IMAGE_PROC_PTR( void, DumpFontCache )( void );
IMAGE_PROC_PTR( void, RerenderFont )( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadTexture )( Image child_image, int option );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadShadedTexture )( Image child_image, int option, CDATA color );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadMultiShadedTexture )( Image child_image, int option, CDATA red, CDATA green, CDATA blue );
IMAGE_PROC_PTR( void, SetImageTransformRelation )( Image pImage, enum image_translation_relation relation, PRCOORD aux );
IMAGE_PROC_PTR( void, Render3dImage )( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC_PTR( void, DumpFontFile )( CTEXTSTR name, SFTFont font_to_dump );
IMAGE_PROC_PTR( void, Render3dText )( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
// transfer all sub images to new image using appropriate methods
// extension for internal fonts to be utilized by external plugins...
IMAGE_PROC_PTR( void, TransferSubImages )( Image pImageTo, Image pImageFrom );
// when using reverse interfaces, need a way to get the real image
// from the fake image (proxy image)
IMAGE_PROC_PTR( Image, GetNativeImage )( Image pImageTo );
// low level support for proxy; this exposes some image_common.c routines
IMAGE_PROC_PTR( Image, GetTintedImage )( Image child_image, CDATA color );
IMAGE_PROC_PTR( Image, GetShadedImage )( Image child_image, CDATA red, CDATA green, CDATA blue );
// test for IF_FLAG_FINAL_RENDER (non physical surface/prevent local copy-restore)
IMAGE_PROC_PTR( LOGICAL, IsImageTargetFinal )( Image image );
// use image data to create a clone of the image for the new application instance...
// this is used when a common image resource is used for all application instances
// it should be triggered during onconnect.
// it is a new image instance that should be used for future app references...
IMAGE_PROC_PTR( Image, ReuseImage )( Image image );
IMAGE_PROC_PTR( void, PutStringFontExx )( Image pImage
											 , int32_t x, int32_t y, int32_t height
											 , CDATA color, CDATA background
											 , CTEXTSTR pc, size_t nLen, SFTFont font, int justification, uint32_t _width );
// sometimes it's not possible to use blatcolor to clear an imate...
// sometimes its parent is not redrawn?
IMAGE_PROC_PTR( void, ResetImageBuffers )( Image image, LOGICAL image_only );
	IMAGE_PROC_PTR(  LOGICAL, PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC_PTR(  LOGICAL, JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
	IMAGE_PROC_PTR(  void, SetFontBias )( SFTFont font, int32_t x, int32_t y );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImage )( Image source, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom, LOGICAL output_center );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImageComplex )( Image source
										, uint32_t top_left_x, uint32_t top_left_y, uint32_t top_left_width, uint32_t top_left_height
										, uint32_t top_x, uint32_t top_y, uint32_t top_width, uint32_t top_height
										, uint32_t top_right_x, uint32_t top_right_y, uint32_t top_right_width, uint32_t top_right_height
										, uint32_t left_x, uint32_t left_y, uint32_t left_width, uint32_t left_height
										, uint32_t center_x, uint32_t center_y, uint32_t center_width, uint32_t center_height
										, uint32_t right_x, uint32_t right_y, uint32_t right_width, uint32_t right_height
										, uint32_t bottom_left_x, uint32_t bottom_left_y, uint32_t bottom_left_width, uint32_t bottom_left_height
										, uint32_t bottom_x, uint32_t bottom_y, uint32_t bottom_width, uint32_t bottom_height
										, uint32_t bottom_right_x, uint32_t bottom_right_y, uint32_t bottom_right_width, uint32_t bottom_right_height
										, LOGICAL output_center );
	IMAGE_PROC_PTR( void, UnmakeSlicedImage )( SlicedImage image );
	IMAGE_PROC_PTR( void, BlotSlicedImageEx )( Image dest, SlicedImage source, int32_t x, int32_t y, uint32_t width, uint32_t height, int alpha, enum BlotOperation op, ... );
	IMAGE_PROC_PTR( void, SetSavePortion )( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
} IMAGE_INTERFACE, *PIMAGE_INTERFACE;
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using.                                    */
#define PROC_ALIAS(name) ((USE_IMAGE_INTERFACE)->_##name)
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using. For function pointers.             */
#define PPROC_ALIAS(name) (*(USE_IMAGE_INTERFACE)->_##name)
#ifdef DEFINE_DEFAULT_IMAGE_INTERFACE
//static PIMAGE_INTERFACE always_defined_interface_that_makes_this_efficient;
#  define USE_IMAGE_INTERFACE GetImageInterface()
#endif
#if defined( FORCE_NO_INTERFACE ) && !defined( ALLOW_IMAGE_INTERFACES )
#  undef USE_IMAGE_INTERFACE
#else
#  define GetImageInterface() (PIMAGE_INTERFACE)GetInterface( "image" )
/* <combine sack::image::DropImageInterface@PIMAGE_INTERFACE>
   \ \                                                        */
#  define DropImageInterface(x) DropInterface( "image", NULL )
#endif
#ifdef USE_IMAGE_INTERFACE
#define GetRedValue                          PROC_ALIAS(GetRedValue )
#define GetBlueValue                          PROC_ALIAS(GetBlueValue )
#define GetGreenValue                          PROC_ALIAS(GetGreenValue )
#define GetAlphaValue                          PROC_ALIAS(GetAlphaValue )
#define SetRedValue                          PROC_ALIAS(SetRedValue )
#define SetBlueValue                          PROC_ALIAS(SetBlueValue )
#define SetGreenValue                          PROC_ALIAS(SetGreenValue )
#define SetAlphaValue                          PROC_ALIAS(SetAlphaValue )
#define MakeColor                          PROC_ALIAS(MakeColor )
#define MakeAlphaColor                          PROC_ALIAS(MakeAlphaColor )
#define MarkImageDirty                    PROC_ALIAS(MarkImageDirty)
#define GetStringRenderSizeFontEx          PROC_ALIAS(GetStringRenderSizeFontEx )
#define LoadImageFileFromGroupEx          PROC_ALIAS(LoadImageFileFromGroupEx )
#define SetStringBehavior                  PROC_ALIAS(SetStringBehavior )
                      //PROC_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   PROC_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    PROC_ALIAS(MakeImageFileEx )
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t>
   \ \                                                   */
#define MakeImageFile(w,h)                 PROC_ALIAS(MakeImageFileEx)( w,h DBG_SRC )
#define MakeSubImageEx                     PROC_ALIAS(MakeSubImageEx )
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t>
   \ \                                                                  */
#define MakeSubImage( image, x, y, w, h )  PROC_ALIAS(MakeSubImageEx)( image, x, y, w, h DBG_SRC )
#define RemakeImageEx                      PROC_ALIAS(RemakeImageEx )
#define ResizeImageEx                      PROC_ALIAS(ResizeImageEx )
#define MoveImage                          PROC_ALIAS(MoveImage )
#define LoadImageFileEx                    PROC_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                PROC_ALIAS(DecodeMemoryToImage )
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Destroys an image. Does not automatically destroy child
   images created on the image.
   Parameters
   Image :  an image to destroy
   Example
   <code lang="c++">
   Image image = MakeImageFile( 100, 100 );
   UnmakeImageFile( image );
   </code>                                                 */
#define UnmakeImageFile(pif)               PROC_ALIAS(UnmakeImageFileEx )( pif DBG_SRC )
#define UnmakeImageFileEx                  PROC_ALIAS(UnmakeImageFileEx )
#define BlatColor                          PROC_ALIAS(BlatColor )
#define BlatColorAlpha                     PROC_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   PROC_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        PROC_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             PROC_ALIAS(BlotScaledImageSizedEx )
#define plot                               PPROC_ALIAS(plot )
#define plotalpha                          PPROC_ALIAS(plotalpha )
#define getpixel                           PPROC_ALIAS(getpixel )
#define do_line                            PPROC_ALIAS(do_line )
#define do_lineAlpha                       PPROC_ALIAS(do_lineAlpha )
#define do_hline                           PPROC_ALIAS(do_hline )
#define do_vline                           PPROC_ALIAS(do_vline )
#define do_hlineAlpha                      PPROC_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      PPROC_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     PROC_ALIAS(GetDefaultFont )
#define GetFontHeight                      PROC_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                PROC_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   PROC_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           PROC_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             PROC_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     PROC_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontExx                   PROC_ALIAS(PutStringFontExx)
#define PutStringFontEx                    PROC_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            PROC_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              PROC_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      PROC_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             PROC_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       PROC_ALIAS(GetImageSize )
#define LoadFont                           PROC_ALIAS(LoadFont )
#define UnloadFont                         PROC_ALIAS(UnloadFont )
#define ColorAverage                       PPROC_ALIAS(ColorAverage)
#define TransferSubImages                  PROC_ALIAS(TransferSubImages)
#define SyncImage                          PROC_ALIAS(SyncImage )
#define IntersectRectangle                 PROC_ALIAS(IntersectRectangle)
#define MergeRectangle                     PROC_ALIAS(MergeRectangle)
#define GetImageSurface                    PROC_ALIAS(GetImageSurface)
#define SetImageAuxRect                    PROC_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    PROC_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     PROC_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     PROC_ALIAS(GetGlobalFonts)
#define GetTintedImage                     PROC_ALIAS(GetTintedImage)
#define GetShadedImage                     PROC_ALIAS(GetShadedImage)
#define AdoptSubImage                      PROC_ALIAS(AdoptSubImage)
#define MakeSpriteImageFileEx   PROC_ALIAS(MakeSpriteImageFileEx)
#define MakeSpriteImageEx       PROC_ALIAS(MakeSpriteImageEx)
#define UnmakeSprite            PROC_ALIAS(UnmakeSprite )
#define rotate_scaled_sprite    PROC_ALIAS(rotate_scaled_sprite)
#define rotate_sprite           PROC_ALIAS(rotate_sprite)
#define BlotSprite              PROC_ALIAS(BlotSprite)
#define SetSpritePosition  PROC_ALIAS(  SetSpritePosition )
#define SetSpriteHotspot  PROC_ALIAS(  SetSpriteHotspot )
#define InternalRenderFont          PROC_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      PROC_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              PROC_ALIAS(RenderScaledFontData)
//#define RenderScaledFont              PROC_ALIAS(RenderScaledFont)
#define RenderScaledFontEx              PROC_ALIAS(RenderScaledFontEx)
#define DumpFontCache              PROC_ALIAS(DumpFontCache)
#define RerenderFont              PROC_ALIAS(RerenderFont)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadTexture              PROC_ALIAS(ReloadTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadShadedTexture              PROC_ALIAS(ReloadShadedTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadMultiShadedTexture              PROC_ALIAS(ReloadMultiShadedTexture)
#define DestroyFont              PROC_ALIAS(DestroyFont)
#define GetFontRenderData              PROC_ALIAS(GetFontRenderData)
#define SetFontRendererData              PROC_ALIAS(SetFontRendererData)
#define RenderFontFileScaledEx              PROC_ALIAS(RenderFontFileScaledEx)
#define GetImageTransformation              PROC_ALIAS(GetImageTransformation)
#define SetImageTransformRelation      PROC_ALIAS( SetImageTransformRelation )
#define Render3dImage                  PROC_ALIAS( Render3dImage )
#define Render3dText                   PROC_ALIAS( Render3dText )
#define DumpFontFile                   PROC_ALIAS( DumpFontFile )
#define IsImageTargetFinal                   PROC_ALIAS( IsImageTargetFinal )
#define ReuseImage                      if((USE_IMAGE_INTERFACE)->_ReuseImage) PROC_ALIAS( ReuseImage )
#define ResetImageBuffers                      if((USE_IMAGE_INTERFACE)->_ResetImageBuffers) PROC_ALIAS( ResetImageBuffers )
#define PngImageFile                    PROC_ALIAS( PngImageFile )
#define JpgImageFile                    PROC_ALIAS( JpgImageFile )
#define SetFontBias                     PROC_ALIAS( SetFontBias )
#define MakeSlicedImage                 PROC_ALIAS( MakeSlicedImage )
#define MakeSlicedImageComplex          PROC_ALIAS( MakeSlicedImageComplex )
#define UnmakeSlicedImage                 PROC_ALIAS( UnmakeSlicedImage )
#define BlotSlicedImageEx               PROC_ALIAS( BlotSlicedImageEx )
#define SetSavePortion                          PROC_ALIAS(SetSavePortion )
//#define global_font_data         (*PROC_ALIAS(global_font_data))
#endif
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   \ \                                                    */
#define GetMaxStringLength(w) GetMaxStringLengthFont(w, NULL )
#ifdef DEFINE_IMAGE_PROTOCOL
//#include <msgprotocol.h>
// need to define BASE_IMAGE_MESSAGE_ID before hand to determine what the base message is.
//#define MSG_ID(method)  ( ( offsetof( struct image_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_IMAGE_MESSAGE_ID + MSG_EventUser )
#define MSG_SetStringBehavior                  MSG_ID( SetStringBehavior )
#define MSG_SetBlotMethod                      MSG_ID( SetBlotMethod )
#define MSG_BuildImageFileEx                   MSG_ID( BuildImageFileEx )
#define MSG_MakeImageFileEx                    MSG_ID( MakeImageFileEx )
#define MSG_MakeSubImageEx                     MSG_ID( MakeSubImageEx )
#define MSG_RemakeImageEx                      MSG_ID( RemakeImageEx )
#define MSG_UnmakeImageFileEx                  MSG_ID( UnmakeImageFileEx )
#define MSG_ResizeImageEx                      MSG_ID( ResizeImageEx )
#define DecodeMemoryToImage                    MSG_ID( DecodeMemoryToImage )
#define MSG_MoveImage                          MSG_ID( MoveImage )
#define MSG_BlatColor                          MSG_ID( BlatColor )
#define MSG_BlatColorAlpha                     MSG_ID( BlatColorAlpha )
#define MSG_BlotImageSizedEx                   MSG_ID( BlotImageSizedEx )
#define MSG_BlotImageEx                        MSG_ID( BlotImageEx )
#define MSG_BlotScaledImageSizedEx             MSG_ID( BlotScaledImageSizedEx )
#define MSG_plot                               MSG_ID( plot )
#define MSG_plotalpha                          MSG_ID( plotalpha )
#define MSG_getpixel                           MSG_ID( getpixel )
#define MSG_do_line                            MSG_ID( do_line )
#define MSG_do_lineAlpha                       MSG_ID( do_lineAlpha )
#define MSG_do_hline                           MSG_ID( do_hline )
#define MSG_do_vline                           MSG_ID( do_vline )
#define MSG_do_hlineAlpha                      MSG_ID( do_hlineAlpha )
#define MSG_do_vlineAlpha                      MSG_ID( do_vlineAlpha )
#define MSG_GetDefaultFont                     MSG_ID( GetDefaultFont )
#define MSG_GetFontHeight                      MSG_ID( GetFontHeight )
#define MSG_GetStringSizeFontEx                MSG_ID( GetStringSizeFontEx )
#define MSG_PutCharacterFont                   MSG_ID( PutCharacterFont )
#define MSG_PutCharacterVerticalFont           MSG_ID( PutCharacterVerticalFont )
#define MSG_PutCharacterInvertFont             MSG_ID( PutCharacterInvertFont )
#define MSG_PutCharacterVerticalInvertFont     MSG_ID( PutCharacterVerticalInvertFont )
#define MSG_PutStringFontEx                    MSG_ID( PutStringFontEx )
#define MSG_PutStringVerticalFontEx            MSG_ID( PutStringVerticalFontEx )
#define MSG_PutStringInvertFontEx              MSG_ID( PutStringInvertFontEx )
#define MSG_PutStringInvertVerticalFontEx      MSG_ID( PutStringInvertVerticalFontEx )
#define MSG_GetMaxStringLengthFont             MSG_ID( GetMaxStringLengthFont )
#define MSG_GetImageSize                       MSG_ID( GetImageSize )
#define MSG_ColorAverage                       MSG_IC( ColorAverage )
// these messages follow all others... and are present to handle
// LoadImageFile
// #define MSG_LoadImageFile (no message)
// #define MSG_LoadFont      (no message)
#define MSG_UnloadFont                         MSG_ID( UnloadFont )
#define MSG_BeginTransferData                  MSG_ID( BeginTransferData )
#define MSG_ContinueTransferData               MSG_ID( ContinueTransferData )
#define MSG_DecodeTransferredImage             MSG_ID( DecodeTransferredImage )
#define MSG_AcceptTransferredFont              MSG_ID( AcceptTransferredFont )
#define MSG_SyncImage                          MSG_ID( SyncImage )
#define MSG_IntersectRectangle                 MSG_ID( IntersectRectangle )
#define MSG_MergeRectangle                     MSG_ID( MergeRectangle)
#define MSG_GetImageSurface                    MSG_ID( GetImageSurface )
#define MSG_SetImageAuxRect                    MSG_ID(SetImageAuxRect)
#define MSG_GetImageAuxRect                    MSG_ID(GetImageAuxRect)
#define MSG_OrphanSubImage                     MSG_ID(OrphanSubImage)
#define MSG_GetGlobalFonts                     MSG_ID(GetGlobalFonts)
#define MSG_AdoptSubImage                      MSG_ID(AdoptSubImage)
#define MSG_MakeSpriteImageFileEx   MSG_ID(MakeSpriteImageFileEx)
#define MSG_MakeSpriteImageEx       MSG_ID(MakeSpriteImageEx)
#define MSG_UnmakeSprite            MSG_ID(UnmakeSprite )
#define MSG_rotate_scaled_sprite    MSG_ID(rotate_scaled_sprite)
#define MSG_rotate_sprite           MSG_ID(rotate_sprite)
#define MSG_BlotSprite              MSG_ID(BlotSprite)
#define MSG_SetSpritePosition  MSG_ID(  SetSpritePosition )
#define MSG_SetSpriteHotspot  MSG_ID(  SetSpriteHotspot )
#define MSG_InternalRenderFont          MSG_ID(InternalRenderFont)
#define MSG_InternalRenderFontFile      MSG_ID(InternalRenderFontFile)
#define MSG_RenderScaledFontData              MSG_ID(RenderScaledFontData)
#define MSG_RenderScaledFont              MSG_ID(RenderScaledFont)
#define MSG_RenderFontData              MSG_ID(RenderFontData)
#define MSG_DestroyFont              MSG_ID(DestroyFont)
#define MSG_GetFontRenderData              MSG_ID(GetFontRenderData)
#define MSG_SetFontRendererData              MSG_ID(SetFontRendererData)
#endif
#ifdef USE_IMAGE_LEVEL
#define PASTELEVEL(level,name) level##name
#define LEVEL_ALIAS(name)      PASTELEVEL(USE_IMAGE_LEVEL,name)
#  ifdef STUPID_NO_DATA_EXPORTS
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,_PASTE(_,name)))
#  else
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,name))
#  endif
#define SetStringBehavior                  LEVEL_ALIAS(SetStringBehavior )
                      //LEVEL_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   LEVEL_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    LEVEL_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     LEVEL_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      LEVEL_ALIAS(RemakeImageEx )
#define ResizeImageEx                      LEVEL_ALIAS(ResizeImageEx )
#define MoveImage                          LEVEL_ALIAS(MoveImage )
#define LoadImageFileEx                    LEVEL_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                LEVEL_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  LEVEL_ALIAS(UnmakeImageFileEx )
#define BlatColor                          LEVEL_ALIAS(BlatColor )
#define BlatColorAlpha                     LEVEL_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   LEVEL_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        LEVEL_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             LEVEL_ALIAS(BlotScaledImageSizedEx )
#define plot                               LEVEL_ALIAS(plot )
#define plotalpha                          LEVEL_ALIAS(plotalpha )
#error 566
#define getpixel                           LEVEL_ALIAS(getpixel )
#define do_line                            LEVEL_ALIAS(do_line )
#define do_lineAlpha                       LEVEL_ALIAS(do_lineAlpha )
#define do_hline                           LEVEL_ALIAS(do_hline )
#define do_vline                           LEVEL_ALIAS(do_vline )
#define do_hlineAlpha                      LEVEL_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      LEVEL_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     LEVEL_ALIAS(GetDefaultFont )
#define GetFontHeight                      LEVEL_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                LEVEL_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   LEVEL_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           LEVEL_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             LEVEL_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     LEVEL_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontEx                    LEVEL_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            LEVEL_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              LEVEL_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      LEVEL_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             LEVEL_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       LEVEL_ALIAS(GetImageSize )
#define LoadFont                           LEVEL_ALIAS(LoadFont )
#define UnloadFont                         LEVEL_ALIAS(UnloadFont )
#define ColorAverage                       LEVEL_ALIAS(ColorAverage)
#define SyncImage                          LEVEL_ALIAS(SyncImage )
#define IntersectRectangle                 LEVEL_ALIAS( IntersectRectangle )
#define MergeRectangle                     LEVEL_ALIAS(MergeRectangle)
#define GetImageSurface                    LEVEL_ALIAS(GetImageSurface)
#define SetImageAuxRect                    LEVEL_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    LEVEL_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     LEVEL_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     LEVEL_ALIAS(GetGlobalFonts)
#define AdoptSubImage                      LEVEL_ALIAS(AdoptSubImage)
#define InternalRenderFont          LEVEL_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      LEVEL_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              LEVEL_ALIAS(RenderScaledFontData)
#define RenderFontData              LEVEL_ALIAS(RenderFontData)
#define RenderFontFileScaledEx              LEVEL_ALIAS(RenderFontFileScaledEx)
#endif
_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
// these macros provide common extensions for
// commonly used shorthands of the above routines.
// no worry - one way or another, the extra data is
// created, and the base function called, it's a sad
// truth of life, that one codebase is easier to maintain
// than a duplicate copy for each minor case.
// although - special forwards - such as DBG_SRC will just dissappear
// in certain compilation modes (NON_DEBUG)
/* <combine sack::image::BuildImageFileEx@PCOLOR@uint32_t@uint32_t>
   \ \                                                           */
#define BuildImageFile(p,w,h) BuildImageFileEx( p,w,h DBG_SRC )
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t>
   \ \                                                              */
#define RemakeImage(p,pc,w,h) RemakeImageEx(p,pc,w,h DBG_SRC)
/* <combine sack::image::ResizeImageEx@Image@uint32_t@uint32_t>
   \ \                                                              */
#define ResizeImage( p,w,h) ResizeImageEx( p,w,h DBG_SRC )
/* <combine sack::image::MakeSpriteImageEx@Image image>
   \ \                                                  */
#define MakeSpriteImage(image) MakeSpriteImageEx(image DBG_SRC)
/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
   \ \                                                         */
#define MakeSpriteImageFile(file) MakeSpriteImageFileEx( image DBG_SRC )
/* This function flips an image top to bottom. This if for
   building windows compatible images. Internally images are
   kept in platform-native direction. If an image is created
   from another source, this might be a method to flip the image
   top-to-bottom if required.
   Parameters
   pImage :                           Image to flip.
   <link sack::DBG_PASS, DBG_PASS> :  _nt_
   Note
   There has been a warning around flip image for a while, it
   does its job right now (reversing jpeg images on windows),
   but not necessarily suited for the masses.                    */
IMAGE_PROC  void IMAGE_API IMGVER(FlipImageEx )( Image pif DBG_PASS );
/* <combine sack::image::FlipImageEx@Image pif>
   \ \                                          */
#define FlipImage(pif) FlipImageEx( pif DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFile(file) LoadImageFileEx( file DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFileFromGroup(group,file) LoadImageFileFromGroupEx( group, file DBG_SRC )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImageTo(img,color) BlatColor(img,0,0,(img)->width,(img)->height, color )
#define ogl_ClearImageTo(img,color) ogl_BlatColor(img,0,0,(img)->width,(img)->height, color )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImage(img) BlatColor(img,0,0,(img)->width,(img)->height, 0 )
#define ogl_ClearImage(img) ogl_BlatColor(img,0,0,(img)->width,(img)->height, 0 )
/* Copy one image to another. Copies the source from 0,0 to the
   destination 0,0 of the minimum width and height of the
   smaller of the source or destination.
   Parameters
   pifDest :  Image to copy to
   pifSrc :   Image to copy from
   X :        left coordinate to copy image to
   Y :        upper coordinate to copy image to
   Example
   This creates an image to write to, creates an image to copy
   (a 64 by 64 square that is filled with 50% green color). And
   copies the image to the output buffer.
   <code>
   Image output = MakeImageFile( 1024, 768 );
   Image source = MakeImageFile( 64, 64 );
   // 50% transparent
   ClearImageTo( source, SetAlpha( BASE_COLOR_GREEN, 128 ) );
   ClearImage( output );
   BlotImage( output, source, 100, 100 );
   BlotImageAlpha( output, source, 200, 200 );
   </code>                                                      */
#define BlotImage( pd, ps, x, y ) BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
#define ogl_BlotImage( pd, ps, x, y ) ogl_BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
/* Output a sliced image to an image surface
  sliced images scale center portions, but copy output corner images
  */
#define BlotSlicedImage( pd, ps, x, y, w, h ) BlotSlicedImageEx( pd, ps, x, y, w, h, ALPHA_TRANSPARENT, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to <link sack::image::AlphaModifier, Alpha>
				  \: Specify how to write the alpha                            */
#define BlotImageAlpha( pd, ps, x, y, a ) BlotImageEx( pd, ps, x, y, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSized( pd, ps, x, y, w, h ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
#define ogl_BlotImageSized( pd, ps, x, y, w, h ) ogl_BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
#define ogl_BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) ogl_BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
#define ogl_BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination. Shade the image on copy with a color.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   Color :        color to multiply the source color by to shade
				  on copy.                                       */
#define BlotImageShaded( pd, ps, xd, yd, c ) BlotImageEx( pd, ps, xd, yd, TRUE, BLOT_SHADED, c )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
#define ogl_BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShaded( pd, ps, xd, yd, r, g, b ) BlotImageEx( pd, ps, xd, yd, ALPHA_TRANSPARENT, BLOT_MULTISHADE, r, g, b )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
#define ogl_BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) ogl_BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSized( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedMultiShaded( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs,r,g,b ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_MULTISHADE,r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedTo( pd, ps, xd, yd, wd, hd) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToAlpha( pd, ps, xd, yd, wd, hd, a) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShaded( pd, ps, xd, yd, wd, hd,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShadedAlpha( pd, ps, xd, yd, wd, hd,a,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShaded( pd, ps, xd, yd, wd, hd,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShadedAlpha( pd, ps, xd, yd, wd, hd,a,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageAlpha( pd, ps, t ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShadedAlpha( pd, ps, t, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShadedAlpha( pd, ps, t, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImage( pd, ps ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShaded( pd, ps, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShaded( pd, ps, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageTo( pd, ps )  BlotScaledImageToEx( pd, ps, FALSE, BLOT_COPY )
/* now why would we need an inverse line? I don't get it....
   anyhow this would draw from the end to the start... basically
   this accounts for rounding errors on the orward way.          */
#define do_inv_line(pb,x,y,xto,yto,d) do_line( pb,y,x,yto,xto,d)
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                               */
#define PutCharacter(i,x,y,h,fore,back,c)               PutCharacterFont(i,x,y,h,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Passes default font if not specified.                                                     */
#define PutCharacterVertical(i,x,y,h,fore,back,c)       PutCharacterVerticalFont(i,x,y,h,fore,back,c,NULL )
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                     */
#define PutCharacterInvert(i,x,y,h,fore,back,c)         PutCharacterInvertFont(i,x,y,h,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVertical(i,x,y,h,fore,back,c) PutCharacterInvertVerticalFont(i,x,y,h,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVerticalFont(i,x,y,h,fore,back,c,f) PutCharacterVerticalInvertFont(i,x,y,h,fore,back,c,f )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutString(pi,x,y,h,fore,back,pc) PutStringFontEx( pi, x, y, h,fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringEx(pi,x,y,h,color,back,pc,len) PutStringFontEx( pi, x, y, h,color,back,pc,len,NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringFont(pi,x,y,h,fore,back,pc,font) PutStringFontEx(pi,x,y,h,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVertical(pi,x,y,h,fore,back,pc) PutStringVerticalFontEx( pi, x, y, h,fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalEx(pi,x,y,h,color,back,pc,len) PutStringVerticalFontEx( pi, x, y, h,color,back,pc,len,NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalFont(pi,x,y,h,fore,back,pc,font) PutStringVerticalFontEx(pi,x,y,h,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvert( pi, x, y,h, fore, back, pc ) PutStringInvertFontEx( pi, x, y,h, fore, back, pc,StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvertEx( pi, x, y,h, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y,h, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   The non Ex Version doesn't pass the string length.                                         */
#define PutStringInvertFont( pi, x, y, h,fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, h,fore, back, pc, StrLen(pc), font )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVertical( pi, x, y,h, fore, back, pc ) PutStringInvertVerticalFontEx( pi, x, y,h, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalEx( pi, x, y, h,fore, back, pc, nLen ) PutStringInvertVerticalFontEx( pi, x, y, h,fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalFont( pi, x, y, h,fore, back, pc, font ) PutStringInvertVerticalFontEx( pi, x, y, h,fore, back, pc, StrLen(pc), font )
//IMG_PROC uint32_t PutMenuStringFontEx        ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutMenuStringFont(img,x,y,fore,back,string,font) PutMenuStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutMenuString(img,x,y,fore,back,str)           PutMenuStringFont(img,x,y,fore,back,str,NULL)
//
//IMG_PROC uint32_t PutCStringFontEx           ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutCStringFont(img,x,y,fore,back,string,font) PutCStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutCString( img,x,y,fore,back,string) PutCStringFont(img,x,y,fore,back,string,NULL )
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeEx(s,len,pw,ph) GetStringSizeFontEx( (s),len,pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                         */
#define GetStringSize(s,pw,ph)       GetStringSizeFontEx( (s),StrLen(s),pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeFont(s,pw,ph,f) GetStringSizeFontEx( (s),StrLen(s),pw,ph,f )
#ifdef __cplusplus
#ifdef IMAGE_EXTRA_CLOSE
	}
#endif
 // IMAGE_NAMESPACE_END
} }
#ifdef _D3D_DRIVER
using namespace sack::image::d3d;
#elif defined( _D3D10_DRIVER )
using namespace sack::image::d3d10;
#elif defined( _D3D11_DRIVER )
using namespace sack::image::d3d11;
#else
using namespace sack::image;
#endif
#endif
#endif
/*   */
#ifndef __NO_INTERFACES__
   // for interface, can omit if no interfaces
#endif
#ifndef __NO_MSGSVR__
  // for interface across the message service
/* Common SYSVIPC Message Queue protocol for hosting shared
   services over a few global pipes.                        */
#ifndef MESSAGE_SERVICE_PROTOCOL
#define MESSAGE_SERVICE_PROTOCOL
#ifdef __cplusplus
using namespace sack;
#endif
#ifdef __cplusplus
#define _MSG_NAMESPACE  namespace msg {
#define _PROTOCOL_NAMESPACE namespace protocol {
#define MSGPROTOCOL_NAMESPACE namespace sack { _MSG_NAMESPACE _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END }} }
#else
#define _MSG_NAMESPACE
#define _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END
#endif
#ifdef __cplusplus
namespace sack {
#endif
	/* This namespace contains an implmentation of inter process
	   communications using a set of message queues which result
	   from 'msgget' 'msgsnd' and 'msgrcv'. This are services
	   available under a linux kernel. Reimplemented a version to
	   service for windows. This is really a client/service
	   registration and message routing system, it is not the
	   message queue itself. See <link sack::containers::message, message>
	   for the queue implementation (again, under linux, does not
	   use this custom queue).
	   See Also
	   RegisterService
	   LoadService                                                         */
#ifdef __cplusplus
	namespace msg {
#endif
/* Defines structures and methods for receiving and sending
	   messages. Also defines some utility macros for referencing
		message ID from a user interface structure.                */
#ifdef __cplusplus
		namespace protocol {
#endif
#define MSGQ_ID_BASE "Srvr"
// this is a fun thing, in order to use it,
// undefine MyInterface, and define your own to your
// library's interface structure name (the tag of the structure)
#define MSG_ID(method)  BASE_MESSAGE_ID,( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) +  MSG_EventUser )
#define MSG_OFFSET(method)  ( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) + MSG_EventUser )
#define INTERFACE_METHOD(type,name) type (CPROC*_##name)
// this is the techincal type of SYSV IPC MSGQueues
#define MSGIDTYPE long
#ifdef __64__
#  ifdef __LINUX__
#    define _MsgID_f  _64fs
#  else
#    define _MsgID_f  _32fs
#  endif
#else
#  define _MsgID_f  _32fs
#endif
// this will determine the length of parameter list
// based on the first and last parameters.
#define ParamLength( first, last ) ( ((uintptr_t)((&(last))+1)) - ((uintptr_t)(&(first))) )
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef PREFIX_PACKED struct buffer_len_tag {
	CPOINTER buffer;
	size_t len;
} PACKED BUFFER_LENGTH_PAIR;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// Dispach Pending - particularly display mouse event messages
//                   needed to be accumulated before being dispatched
//                   this event is generated when no more messages
//                   have been received.
#define MSG_EventDispatchPending   0
#define MSG_DispatchPending   MSG_EventDispatchPending
// these are event message definitions.
// server events come through their function table, clients
// register an event handler... these are low numbered since
// they are guaranteed from the client/server respectively.
// Mate ended - for the client, this means that the server
//              has become defunct.  For the server, this
//              means that a client is no longer present.
//              also issued when a client volentarily leaves
//              which in effect is the same as being discovered gone.
//    param[0] = Process ID of client disconnecting
//  result_length = INVALID_INDEX - NO RESULT DATA, PLEASE!
#define MSG_MateEnded         MSG_ServiceUnload
#define MSG_ServiceUnload     0
//#define MSG_ServiceClose    MSG_ServiceUnload
//#define MSG_ServiceUnload        MSG_MateEnded
// finally - needed to define a way for the service
// to actually know when a client connects... so that
// it may validate commands as being froma good source.
// also, a multiple service server may want this to know which
// service is being loaded.
//     params + 0 = text string of the service to load
//  on return result[1] is the number of messages this routine
//  expects.
//     result[0] is the number of events this service may generate
#define MSG_MateStarted      1
#define MSG_ServiceLoad      MSG_MateStarted
// Service is about to be unloaded - here's a final chance to
// cleanup before being yanked from existance.
// Last reference to the service is now gone, going to do the unload.
#define MSG_UndefinedMessage2      2
// no defined mesasage fo this
#define MSG_UndefinedMessage3       3
// Other messages may be filled in here...
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventUser       MSG_UserServiceMessages
#define MSG_UserServiceMessages 16
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventInternal       MSG_InternalServiceMessages
#define MSG_InternalServiceMessages 4
enum server_event_messages {
	// these messages are sent to client's event channel
	// within the space of core service requests (0-256?)
	// it's on top of client event user - cause the library
	// may also receive client_disconnect/connect messages
   //
	MSG_SERVICE_DATA = MSG_EventInternal
 // end of list - zero or more MSG_SERVICE_DATA mesasges will preceed this.
      , MSG_SERVICE_NOMORE
	, MSG_SERVICE_MAX_ID
};
enum server_failure_messages {
	CLIENT_UNKNOWN
									  , MESSAGE_UNKNOWN
 // sending server(sourced) messages to server
									  , MESSAGE_INVALID
 // could not find a service for the message.
									  , SERVICE_UNKNOWN
									  , UNABLE_TO_LOAD
};
enum service_messages {
 // no message ID 0 ever.
	INVALID_MESSAGE  = 0
 // server responce to clients - failure
							 , SERVER_FAILURE   = 0x80000000
							 // failure may result for the above reasons.
 // server responce to clients - success
							 , SERVER_SUCCESS   = 0x40000000
 // server needs more time to complete...
							 , SERVER_NEED_TIME = 0x20000000
 // server had no method to process the message
							 , SERVER_UNHANDLED = 0x10000000
 // client requests a service (load by name)
							 , CLIENT_LOAD_SERVICE = 1
 // client no longer needs a service (unload msgbase)
							 , CLIENT_UNLOAD_SERVICE
       // new client wants to connect
							 , CLIENT_CONNECT
    // client disconnects (no responce)
							 , CLIENT_DISCONNECT
             // server/client message to other requesting status
							 , RU_ALIVE
             // server/client message to other responding status
							 , IM_ALIVE
 // client register service (name, serivces, callback table.)
							 , CLIENT_REGISTER_SERVICE
 // client requests a list of services (optional param partial filter?)
                      , CLIENT_LIST_SERVICES
   // Service needs more time, and passes back a millisecond delay-reset
                      , IM_TARDY
};
#define LOWEST_BASE_MESSAGE 0x100
/* Service route object that manages connection between service and client.
*/
typedef struct ServiceRoute_tag SERVICE_ROUTE;
/* pointer to a service route, which is a pair of endpoints.
*/
typedef struct ServiceRoute_tag *PSERVICE_ROUTE;
/*  This is a unique service address
*/
typedef struct ServiceEndPoint_tag SERVICE_ENDPOINT, *PSERVICE_ENDPOINT;
// this is part of the message structure
//
// this structure is avaialble at ((PSERVICE_ROUTE)(((uint32_t*)params)-1)[-1])
// (to explain that, the first uint32_t back is the MsgID... to get JUST the route tag
//  have to go back one Dword then back a service_route struct...
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
PREFIX_PACKED struct ServiceEndPoint_tag
{
   // remote process ID
	MSGIDTYPE process_id;
   // service (either served or connected as client) remote id
	MSGIDTYPE service_id;
}PACKED;
PREFIX_PACKED struct ServiceRoute_tag
{
   SERVICE_ENDPOINT dest;
	//MSGIDTYPE process_id;   // remote process ID
   //MSGIDTYPE service_id;   // service (either served or connected as client) remote id
   SERVICE_ENDPOINT source;
   //uint32_t source_process_id; // need this defined here anyway; so this can be used in receivers
	//uint32_t source_service_id;  // the service this is connected to, or is a connection for local ID
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#define GetServiceRoute(data)   ((PSERVICE_ROUTE)(((uint32_t*)data)-1)-1)
// server functions will return TRUE if no failure
// server functions will return FALSE on failure
// FAILURE or SUCCESS will be returned to the client,
//   along with any result data set.
// native mode (unspecified... one would assume
// stack passing, but the world is bizarre and these are
// probably passed by registers.
typedef int (CPROC *server_message_handler)( PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
														 , uint32_t *params, size_t param_length
														 , uint32_t *result, size_t *result_length );
typedef int (CPROC *server_message_handler_ex)( uintptr_t psv
															 , PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
															 , uint32_t *params, size_t param_length
															 , uint32_t *result, size_t *result_length );
// params[-1] == Source Process ID
// params[-2] == Source Route ID
typedef int (CPROC *server_function)( PSERVICE_ROUTE route, uint32_t *params, size_t param_length
										 , uint32_t *result, size_t *result_length );
typedef struct server_function_entry_tag{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR name;
#endif
	server_function function;
} SERVER_FUNCTION;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#define ServerFunctionEntry(name) { #name, name }
#else
#define ServerFunctionEntry(name) { name }
#endif
typedef SERVER_FUNCTION *server_function_table;
// MsgID will be < MSG_EventUser if it's a system message...
// MsgID will be service msgBase + Remote ID...
//    so the remote needs to specify a unique base... so ...
//    entries must still be used...
typedef int (CPROC*EventHandlerFunction)( MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionEx)( PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionExx)( uintptr_t psv, PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID
														 , uint32_t*params, size_t paramlen);
// result of EventHandlerFunction shall be one fo the following values...
//   EVENT_HANDLED
// 0 - no futher action required
//   EVENT_WAIT_DISPATCH
// 1 - when no further events are available, please send event_dispatched.
//     this Event was handled by an internal queuing for later processing.
enum EventResult {
	EVENT_HANDLED = 0,
	EVENT_WAIT_DISPATCH = 1
};
//------------------- Begin Server Message Structs ----------------
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef struct MsgSvr_RegisterRequest_msg MsgSvr_RegisterRequest;
PREFIX_PACKED struct MsgSvr_RegisterRequest_msg
{
	MSGIDTYPE RouteID;
  // service_id...
   MSGIDTYPE ClientID;
}PACKED;
typedef struct MsgSrv_ReplyServiceLoad_msg MsgSrv_ReplyServiceLoad;
PREFIX_PACKED struct MsgSrv_ReplyServiceLoad_msg
{
	MSGIDTYPE ServiceID;
 // if this is a local service, it's dispatched this way?
	THREAD_ID thread;
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#ifdef __cplusplus
 //MSGPROTOCOL_NAMESPACE_END
} } }
using namespace sack::msg::protocol;
#endif
#endif
#endif
#ifndef SECOND_RENDER_LEVEL
#define SECOND_RENDER_LEVEL
#define PASTE(sym,name) name
#else
#define PASTE2(sym,name) sym##name
#define PASTE(sym,name) PASTE2(sym,name)
#endif
#ifdef USE_API_ALIAS_PREFIX
#  define RVER(n)   IMGVER_(USE_API_ALIAS_PREFIX,n)
#else
#  define RVER(n)   n
#endif
#        ifdef RENDER_LIBRARY_SOURCE
#           define RENDER_PROC(type,name) EXPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,RVER(name))
#        else
#           define RENDER_PROC(type,name) IMPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,RVER(name))
#        endif
#ifdef __cplusplus
namespace sack {
   #endif
/* <copy render.h>
   \ \             */
#ifdef __cplusplus
namespace image {
   #endif
/* PRENDERER is the primary object this namespace deals with.
   See Also
   <link render.h>                                            */
#ifdef __cplusplus
namespace render {
   #endif
/* Application layer abstract structure to handle displays. This
 is the type returned by OpenDisplay.                          */
typedef struct HVIDEO_tag *PRENDERER;
typedef struct key_function  KEY_FUNCTION;
typedef struct key_function *PKEY_FUNCTION;
// Event Message ID's CANNOT be 0
// Message Event ID (base+0) is when the
// server teriminates, and ALL client resources
// are lost.
// Message Event ID (base+1) is when the
// final message has been received, and any
// pending events collected should be dispatched.
#ifndef __NO_MSGSVR__
enum {
   /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_CloseMethod = MSG_EventUser,
  /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_MouseMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_LoseFocusMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_KeyMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_GeneralMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawFractureMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_ThreadEventPost
};
#endif
#ifdef __WATCOMC__
#if ( __WATCOMC__ < 1291 )
#define NO_TOUCH
#endif
#endif
#ifndef WIN32
#define NO_TOUCH
#define NO_PEN
#endif
#if defined( __LINUX__ )
#define NO_TOUCH
#endif
#if defined( __ANDROID__ )
// definately IS touch
#undef NO_TOUCH
#define MINGW_SUX
#endif
// static void OnBeginShutdown( "Unique Name" )( void ) { /* run shutdown code */ }
#define OnBeginShutdown(name)	 DefineRegistryMethod("SACK",BeginShutdown,"System","Begin Shutdown",name "_begin_shutdown",void,(void),__LINE__)
/* function signature for the close callback  which can be specified to handle events to close the display.  see SetCloseHandler. */
typedef void (CPROC*CloseCallback)( uintptr_t psvUser );
/* function signature to define hide/restore callback, it just gets the user data of the callback... */
typedef void (CPROC*HideAndRestoreCallback)( uintptr_t psvUser );
/* function signature for the redraw callback  which can be specified to handle events to redraw the display.  see SetRedrawHandler. */
typedef int (CPROC*RedrawCallback)( uintptr_t psvUser, PRENDERER self );
/* function signature for the mouse callback  which can be specified to handle events from mouse motion on the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.*/
typedef uintptr_t  (CPROC*MouseCallback)( uintptr_t psvUser, int32_t x, int32_t y, uint32_t b );
typedef struct input_point
{
   //
	RCOORD x, y;
	struct {
  // set on first down, clear on subsequent events
		BIT_FIELD new_event : 1;
 // set on first up, clear on first down,
		BIT_FIELD end_event : 1;
	} flags;
} *PINPUT_POINT;
enum pen_event_flags {
      // Default
	PEN_EVENT_FLAG_NONE = 0x00000000
   // The barrel button is pressed
	,PEN_EVENT_FLAG_BARREL = 0x00000001
 // The pen is inverted
	,PEN_EVENT_FLAG_INVERTED = 0x00000002
   // The eraser button is pressed
	,PEN_EVENT_FLAG_ERASER = 0x00000004
      // is a new event
	,PEN_EVENT_FLAG_NEW    = 0x00000010
      // is an end event
	,PEN_EVENT_FLAG_END    = 0x00000020
};
enum pen_event_mask {
       // Default - none of the optional fields are valid
	PEN_EVENT_MASK_NONE = 0x00000000
  // The pressure field is valid
	,PEN_EVENT_MASK_PRESSURE = 0x00000001
  // The rotation field is valid
	,PEN_EVENT_MASK_ROTATION = 0x00000002
    // The tiltX field is valid
	,PEN_EVENT_MASK_TILT_X = 0x00000004
    // The tiltY field is valid
	,PEN_EVENT_MASK_TILT_Y = 0x00000008
};
typedef struct pen_event {
	enum pen_event_flags penFlags;
	enum pen_event_mask penMask;
	uint32_t pressure;
	uint32_t rotation;
	int32_t x;
	int32_t y;
	int32_t tiltX;
	int32_t tiltY;
	int nOverflow;
	struct pen_event *pOverflow;
} *PPEN_EVENT;
#ifndef NO_TOUCH
#if defined( MINGW_SUX )
/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
  // the dwTime field contains a system generated value
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM  0x0001
  // the dwExtraInfo field is valid
#define TOUCHINPUTMASKF_EXTRAINFO       0x0002
  // the cxContact and cyContact fields are valid
#define TOUCHINPUTMASKF_CONTACTAREA     0x0004
#ifndef __ANDROID__
typedef HANDLE HTOUCHINPUT;
#endif
#define WM_TOUCH 0x0240
#define TWF_FINETOUCH 0x00000001
#define TWF_WANTPALM 0x00000002
#endif
 // added to flags as touches are used.  Controls may use some of the touches but not all.
#define TOUCHEVENTF_USED 0x8000
/* function signature for the touch callback  which can be specified to handle events from touching the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.  Return 1 if some of the touches are used.
  This will trigger a check to see if there are unused touches to continue sending... oh but on renderer there's only one callback, more
  important as a note of the control touch event handerer.
  */
typedef int  (CPROC*TouchCallback)( uintptr_t psvUser, PINPUT_POINT pTouches, int nTouches );
typedef int ( CPROC *PenCallback )( uintptr_t psvUser, PPEN_EVENT penEvent );
#endif
/* function signature for the close callback  which can be specified to handle events to redraw the display.  see SetLoseFocusHandler. */
typedef void (CPROC*LoseFocusCallback)(
uintptr_t dwUser, PRENDERER pGain );
// without a keyproc, you will still get key notification in the mousecallback
// if KeyProc returns 0 or is NULL, then bound keys are checked... otherwise
// priority is given to controls with focus that handle keys.
typedef int (CPROC*KeyProc)( uintptr_t dwUser, uint32_t keycode );
// without any other proc, you will get a general callback message.
typedef void (CPROC*RenderReadCallback)(uintptr_t psvUser, PRENDERER pRenderer, TEXTSTR buffer, INDEX len );
// called before redraw callback to update the background on the scene...
typedef void (CPROC*_3DUpdateCallback)( uintptr_t psvUser );
// callback type for clipborad event reception.
typedef void (CPROC*ClipboardCallback)(uintptr_t psvUser);
//----------------------------------------------------------
//   Mouse Button definitions
//----------------------------------------------------------
// the prefix of these may either be interpreted as MAKE - as in
// a make/break state of a switch.  Or may be interpreted as
// MouseKey.... such as KB_ once upon a time stood for KeyBoard,
// and not Keebler as some may have suspected.
enum ButtonFlags {
#ifndef MK_LBUTTON
 // left mouse button  MouseKey_ ?
	MK_LBUTTON  = 0x01,
#endif
#ifndef MK_MBUTTON
  // right mouse button MouseKey_ ?
	MK_RBUTTON  = 0x02,
#endif
#ifndef MK_SHIFT
   // the shift key on the keyboard
  MK_SHIFT     = 0x04,
#endif
#ifndef MK_CONTROL
  // the control key on the keyboard
  MK_CONTROL   = 0x08,
#endif
#ifndef MK_RBUTTON
  // middle mouse button MouseKey_ ?
	MK_MBUTTON  = 0x10,
#endif
#ifndef MK_XBUTTON1
  // middle mouse button MouseKey_ ?
	MK_XBUTTON1 = 0x20,
#endif
#ifndef MK_XBUTTON2
  // middle mouse button MouseKey_ ?
	MK_XBUTTON2 = 0x40,
#endif
#ifndef MK_ALT
   // the alt key on the keyboard (not normally defined in Windows)
  MK_ALT       = 0x80,
#endif
  // scroll wheel click down  (not normally defined in Windows)
  MK_SCROLL_DOWN  = 0x100,
  // scroll wheel click up    (not normally defined in Windows)
  MK_SCROLL_UP    = 0x200,
  // scroll wheel click left  (not normally defined in Windows)
  MK_SCROLL_LEFT  = 0x400,
  // scroll wheel click right (not normally defined in Windows)
  MK_SCROLL_RIGHT = 0x800,
#ifndef MK_NO_BUTTON
// used to indicate that there is
// no known button information available.  The mouse
// event which triggered this was beyond the realm of
// this mouse handler, but it is entitled to know that
// it now knows nothing.
  MK_NO_BUTTON = 0xFFFFFFFF,
#endif
// this bit will NEVER NEVER NEVER be set
// for ANY reason whatsoever. ( okay except when it's in MK_NO_BUTTON )
  MK_INVALIDBUTTON = 0x80000000,
// One or more other buttons were pressed.  These
// buttons are available by querying the keyboard state.
 // any other button (keyboard)
  MK_OBUTTON       = 0x1000,
 // any other button (keyboard) went up
  MK_OBUTTON_UP    = 0x2000
};
// mask to test to see if some button (physical mouse, not logical)
// is currently pressed...
#define MK_SOMEBUTTON       (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON|MK_XBUTTON1|MK_XBUTTON2)
// test to see if any button is clicked */
#define MAKE_SOMEBUTTONS(b)     ((b)&(MK_SOMEBUTTON))
// test to see if a specific button is clicked
#define BUTTON_STILL_DOWN(b,button)     ((b)&(button))
// test a button variable to see if no buttons are currently pressed
// NOBUTTON, NOBUTTONS may be confusing, consider renaming these....
#define MAKE_NOBUTTONS(b)     ( !((b) & MK_SOMEBUTTON ) )
// break of some button
#define BREAK_NEWBUTTON(b,_b) ((((b)^(_b))&(_b))&MK_SOMEBUTTON)
// break a specific button (the last up of the button)
#define BREAK_A_BUTTON(b,_b,button) ((((b)^(_b))&(_b))&(button))
// make of some button (the first down of a button)
#define MAKE_NEWBUTTON(b,_b) ((((b)^(_b))&(b))&MK_SOMEBUTTON)
// make a specific button (the first down of the button)
#define MAKE_A_BUTTON(b,_b,button) ((((b)^(_b))&(b))&(button))
// test current b vs prior _b to see if the  last button pressed is
// now not pressed...
#define BREAK_LASTBUTTON(b,_b)  ( BREAK_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(b) )
// test current b vs prior _b to see if there is now some button pressed
// when previously there were no buttons pressed...
#define MAKE_FIRSTBUTTON(b,_b) ( MAKE_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(_b) )
// these button states may reflect the current
// control, alt, shift key states.  There may be further
// definitions (meta?) And as of the writing of this comment
// these states may not be counted on, if you care about these
// please do validate that the code gives them to you all the way
// from the initial mouse message through all layers to the final
// application handler.
enum sizeDisplayValues {
	wrsdv_one  = 0,
	wrsdv_top = 1,
	wrsdv_bottom = 2,
	wrsdv_left = 4,
	wrsdv_right = 8,
};
//----------------------------------------------------------
enum DisplayAttributes {
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_ALPHA    = 0x10000,
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_HOLEY    = 0x20000,
  /* when used by the Display Lib manager, this describes how to manage the subsurface
    focus on this window excludes any of it's parent/sibling panels
    from being able to focus. */
  PANEL_ATTRIBUTE_EXCLUSIVE = 0x40000,
  /* when used by the Display Lib manager, this describes how to manage the subsurface
    child attribute affects the child is contained within this parent */
  PANEL_ATTRIBUTE_INTERNAL  = 0x88000,
    // open the window as layered - allowing full transparency.
  DISPLAY_ATTRIBUTE_LAYERED = 0x0100,
    // window will not be in alt-tab list
  DISPLAY_ATTRIBUTE_CHILD = 0x0200,
    // set to WS_EX_TRANSPARENT - all mouse is passed, regardless of alpha/shape
  DISPLAY_ATTRIBUTE_NO_MOUSE = 0x0400,
    // when created, the display does not attempt to set itself into focus, otherwise we try to focus self.
  DISPLAY_ATTRIBUTE_NO_AUTO_FOCUS = 0x0800,
  // when created, set topmost as soon as possible
  DISPLAY_ATTRIBUTE_TOPMOST = 0x1000,
};
 // does not HAVE to be called but may
    RENDER_PROC( int , InitDisplay) (void);
	 // this generates a mouse event though the mouse system directly
    // there is no queuing, and the mouse is completed before returning.
    RENDER_PROC( void, GenerateMouseRaw)( int32_t x, int32_t y, uint32_t b );
	 /* Create mouse events to self?
	    Parameters
	    x :  x of the mouse
	    y :  y of the mouse
	    b :  buttons of the mouse    */
	 RENDER_PROC( void, GenerateMouseDeltaRaw )( int32_t x, int32_t y, uint32_t b );
    /* Sets the title of the application window. Once upon a time,
       applications only were able to make a SINGLE window. Internally,
       all windows are mounted against a hidden application window,
       and this appilcation window gets the title.
       Parameters
       title :  Title for the application                               */
    RENDER_PROC( void , SetApplicationTitle) (const TEXTCHAR *title );
    /* Sets the title of the window (shows up in windows when
       alt-tabbing). Also shows up on the task tray icon (if there
       is one)
       Parameters
       render :  display to set the title of
       title :   new text for the title.                           */
    RENDER_PROC( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
    /* Sets the icon to show for the application's window.
       Parameters
       Icon :  this really has to be an HICON I think... it's for
               setting the icon on Windows' windows.              */
    RENDER_PROC( void , SetApplicationIcon)  (Image Icon);
    /* Gets the size of the default desktop screen.
       Parameters
       width :   pointer to a 32 value for the display's width.
       height :  pointer to a 32 value for the display's height.
       Example
       <code lang="c++">
       uint32_t w, h;
       GetDisplaySize( &amp;w, &amp;h );
       </code>
       See Also
       <link sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *, GetDisplaySizeEx> */
    RENDER_PROC( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
	 /* \	     Parameters
	    nDisplay :  display to get the coordinates of. 0 is the
	                default display from GetDesktopWindow(). 1\-n are
	                displays for multiple display systems, 1,2,3,4
	                etc..
	    x :         left screen coordinate of this display
	    y :         top screen coordinate of this display
	    width :     how wide this display is
	    height :    how tall this display is
	    Example
	    <code lang="c#">
	    int32_t x, y;
	    uint32_t w, h;
	    GetDisplaySizeEx( 1, &amp;x, &amp;y, &amp;w, &amp;h );
	    </code>                                                       */
	 RENDER_PROC (void, GetDisplaySizeEx) ( int nDisplay
													  , int32_t *x, int32_t *y
													  , uint32_t *width, uint32_t *height);
    /* Sets the first displayed physical window to a certain size. This
       should actually adjust the screen size. Like GetDisplaySize
       \returns the size of the actual display, this should set the
       size of the actual display.
       Parameters
       width :   new width of the screen
       height :  new height of the screen.                              */
    RENDER_PROC( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
#ifdef WIN32
    /* Enable logging when updates happen to the real display.
       Parameters
       bEnable :  TRUE to enable, FALSE to disable.            */
    RENDER_PROC (void, EnableLoggingOutput)( LOGICAL bEnable );
	 /* A method to promote any arbitrary HWND to a PRENDERER. This
	    can be used to put SACK display surfaces in .NET
	    applications.
	    Parameters
	    hWnd :  HWND to make into a renderer.
	    Returns
	    PRENDERER new renderer that uses HWND to update to.         */
	 RENDER_PROC (PRENDERER, MakeDisplayFrom) (HWND hWnd);
#endif
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display                                         */
    RENDER_PROC( PRENDERER, OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.                                               */
    RENDER_PROC( PRENDERER, OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.
       below :       display to put this one under. (for building
                     behind a cover window)                                                       */
    RENDER_PROC( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	 /* Sets the alpha level of the overall display window.
	    Parameters
	    hVideo :  display to set the overall fade level on
	    level :   the level of fade from 0 (transparent) to 255
	              (opaque)
	    Example
	    <code lang="c++">
	    PRENDERER render = OpenDisplay( 0 );
	    int i;
	    UpdateDisplay( render );
	    </code>
	    <code>
	    // the window will slowly fade out
	    for( i = 255; i \> 0; i-- )
	    </code>
	    <code lang="c++">
	        SetDisplayFade( render, i );
	    CloseDisplay( render );  // Hiding the display works too, if it is to be reused.
	    </code>                                                                          */
	 RENDER_PROC( void, SetDisplayFade )( PRENDERER hVideo, int level );
    /* closes a display, releasing all resources assigned to it.
       Parameters
       hDisplay :  Render display to close.                      */
    RENDER_PROC( void         , CloseDisplay) ( PRENDERER );
    /* Updates just a portion of a display window. Minimizing the
       size required for screen output greatly increases efficiency.
       Also on vista+, this will update just a portion of a
       transparent display.
       Parameters
       hVideo :  the display to update
       x :       the left coordinate of the region to update
       y :       the top coordinate of the region to update
       width :   the width of the region to update
       height :  the height of the region to update
       DBG_PASS information is used to track who is doing updates
       when update logging is enabled.                               */
    RENDER_PROC( void , UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
   \ \                                                                                      */
#define UpdateDisplayPortion(r,x,y,w,h) UpdateDisplayPortionEx(r,x,y,w,h DBG_SRC )
	 /* Updates the entire surface of a display.
	    Parameters
	    display :  display to update
	    DBG_PASS information is passed for logging writing to
	    physical display.
	                                                          */
	 RENDER_PROC( void , UpdateDisplayEx)        ( PRENDERER DBG_PASS );
#define UpdateDisplay(r) UpdateDisplayEx(r DBG_SRC)
/* Gets the current location and size of a display.
       Parameters
       hVideo :  display to get the position of
       x :       pointer to a signed 32 bit value to get the left
                 edge of the display.
       y :       pointer to a signed 32 bit value to get the top edge
                 of the display.
       width :   pointer to a unsigned 32 bit value to get the width.
       height :  pointer to a unsigned 32 bit value to get the
                 height.                                              */
    RENDER_PROC( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* Moves a display to an absolute position.
       Parameters
       render :  the display to move
       x :       new X coordinate for the left of the display
       y :       new Y coordinate for the top of the display  */
    RENDER_PROC( void , MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* Moves a display relative to its current position.
       Parameters
       render :  the display to move
       delx :    a signed amount to add to its X coordiante
       dely :    a signed amount ot add to its Y coordinate. ( bigger
                 values go down the screen )                          */
    RENDER_PROC( void , MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* Sets the display's current size. If it is different than
       before, will invoke render's redraw callback.
       Parameters
       display :  the display to set the size of
       w :        new width of the display
       h :        new height of the display                     */
    RENDER_PROC( void , SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* Sets the display's current size relative to what it currently
       is. If it is different than before, will invoke render's
       redraw callback.
       Parameters
       display :  the display to set the size of
       w :        signed value to add to current width
       h :        signed value to add to current height              */
    RENDER_PROC( void , SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
   /* Change the position and size of a display.
      Parameters
      hVideo :  display to move and size
      x :       new left coordinate of the display
      y :       new top coordinate of the display
      w :       new width of the display
      h :       new height of the display          */
   RENDER_PROC( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* Moves and changes the display size relative to its current
      size. All parameters are relative to current.
      Parameters
      hVideo :  display to move and change the size of
      delx :    amount to modify the left coordinate by
      dely :    amount to modify the top coordinate by
      delw :    amount to change the width by
      delh :    amount to change the height by                   */
   RENDER_PROC( void, MoveSizeDisplayRel )( PRENDERER hVideo
                                        , int32_t delx, int32_t dely
                                        , int32_t delw, int32_t delh );
		/* Put the display above another display. This makes sure that
		   the displays are stacked at least in this order.
		   Parameters
		   this_display :  the display to put above another
		   that_display :  the display that will be on the bottom.     */
		RENDER_PROC( void , PutDisplayAbove)      ( PRENDERER this_display, PRENDERER that_display );
      /* put this in container
	   Parameters
	   hVideo :      Display to put into another display surface
	   hContainer :  The new parent window of the hVideo.
	   Example
	   <code lang="c#">
	   Render render = OpenDisplay( 0 );
	   Render parent = OpenDisplay( 0 );
	   PutDisplayIn( render, parent );
	   </code>                                                   */
	 RENDER_PROC (void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
    /* Gets the Image from the Render.
       Parameters
       renderer :  the display window to get the surface of.
       Returns
       Image that is the surface of the window to draw to.   */
    RENDER_PROC( Image , GetDisplayImage)     ( PRENDERER );
    /* Sets the close handler callback. Called when a window is
       closed externally.
       Parameters
       hVideo :     display to set the close handler for
       callback :   close method to call when the display is called
       user_data :  user data passed to close method when invoked.  */
    RENDER_PROC( void , SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* Specifies the mouse event handler for a display.
       Parameters
       hVideo :     display to set the mouse handler for
       callback :   the routine to call when a mouse event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* Specifies the hide event handler for a display.
       Parameters
       hVideo :     display to set the hide handler for
       callback :   the routine to call when a hide event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* Specifies the restore event handler for a display.
       Parameters
       hVideo :     display to set the restore handler for
       callback :   the routine to call when a restore event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
#ifndef NO_TOUCH
    /* Specifies the touch event handler for a display.
       Parameters
       hVideo :     display to set the touch handler for
       callback :   the routine to call when a touch event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
	   RENDER_PROC( void , SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
#ifndef NO_PEN
     /* Specifies the pen event handler for a display.
        Parameters
        hVideo :     display to set the touch handler for
        callback :   the routine to call when a touch event happens.
        user_data :  this value is passed to the callback routine when
                     it is called.                                     */
     RENDER_PROC( void, SetPenHandler )( PRENDERER, PenCallback, uintptr_t );
#endif
     /* Sets the function to call when a redraw event is required.
	    Parameters
	    hVideo :     display to set the handler for
	    callback :   function to call when a redraw is required (or
	                 requested).
	    user_data :  this value is passed to the redraw callback.
	    Example
	    See <link render.h>
	    See Also
	    <link sack::image::render::Redraw@PRENDERER, Redraw>        */
	 RENDER_PROC( void , SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
	 // call this to call the callback registered. as appropriate.  Said callback
    // should never be directly called by application.
    RENDER_PROC( void, Redraw )( PRENDERER hVideo );
    /* Sets the keyboard handler callback for a display
       Parameters
       hVideo :     display to receive key events for.
       callback :   callback invoked when a key event happens.
       user_data :  user data passed to the callback when invoked.
       Remarks
       the keyboard handler may make use of the scan code itself for
       PKEYDEFINE structures. There are also a variety of methods
       for checking the 32 bit key value. The value passed to the
       keyboard handler contains most all of the information about
       the state of the keyboard and specific key.                   */
    RENDER_PROC( void , SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* Sets a callback handler called when focus is gained or lost
       by the display.
       Parameters
       hVideo :     display to set the event on
       callback :   the user callback to call when focus is lost or
                    gained.
       user_data :  user data passed to the callback when invoked.
       Note
       When the LoseFocusCallback is called, the renderer is the one
       that is getting the focus. This may be you, may be NULL
       (everyone losing focus) or may be another PRENDERER in your
       application.                                                  */
    RENDER_PROC( void , SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* Undefined */
    RENDER_PROC( void, SetRenderReadCallback )( PRENDERER pRenderer, RenderReadCallback callback, uintptr_t psv );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( void , SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#endif
    /* Receives the current global mouse state, and position in
       screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse X position.
       y :  pointer to a signed 32 bit value for the mouse Y position.
       b :  current state of mouse buttons. See <link sack::image::render::ButtonFlags, ButtonFlags>. */
    RENDER_PROC( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
    /* Gets the current mouse position in screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse position
       y :  pointer to a signed 32 bit value for the mouse position
       Example
       <code lang="c++">
       int32_t x, y;
       GetMousePosition( &amp;x, &amp;y );
       </code>                                                      */
    RENDER_PROC( void , GetMousePosition)     ( int32_t *x, int32_t *y );
    /* Sets the mouse pointer at the specified display coordinates.
       Parameters
       hDisplay :  display to use to where to position the mouse. Will
                   fault if NULL is passed.
       x :         x relative to the display to set the mouse
       y :         y relative to the display to set the mouse          */
    RENDER_PROC( void , SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* Test a display to see if it is focused.
       Parameters
       hVideo :  display to check to see if it has focus. (keyboard
                 \input)
       Returns
       TRUE if focused, else FALSE.                                 */
    RENDER_PROC( LOGICAL , HasFocus)          ( PRENDERER );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( int, SendActiveMessage)     ( PRENDERER dest, PACTIVEMESSAGE msg );
    RENDER_PROC( PACTIVEMESSAGE , CreateActiveMessage) ( int ID, int size, ... );
#endif
    /* Translates a key's scancode into text. Handles things like
       capslock, shift...
       Parameters
       key :  KEY_ to translate
       Returns
       char that the key represents. (should implement a method to
       get back the UNICODE character).                            */
    RENDER_PROC( const TEXTCHAR *, GetKeyText)             ( int key );
    /* Simple check to see if a key is in a pressed state.
       Parameters
       display :  display to check the key state in
       key :      KEY_ symbol to check.                    */
    RENDER_PROC( uint32_t, IsKeyDown )              ( PRENDERER display, int key );
    /* \        Parameters
       display :  display to test the key status in
       key :      KEY_ symbol to check if the key is pressed
       Returns
       TRUE if the key is down, else FALSE.                  */
    RENDER_PROC( uint32_t, KeyDown )                ( PRENDERER display, int key );
    /* Sometimes displays can be closed by external forces (the
       close button on most windows). This tests to see if a display
       is still valid, or if it has been closed externally.
       Returns
       TRUE if display is still okay. FALSE if the display is no
       longer able to be used.
       Parameters
       display :  the display to check the validity of.              */
    RENDER_PROC( LOGICAL, DisplayIsValid )     ( PRENDERER display );
    /* Assigns all mouse input to a window. This allows the window
       to process messages which are outside of itself normally.
       Parameters
       display :  which window wants to own the mouse
       own :      1 to own, 0 to release ownership.                */
    RENDER_PROC( void, OwnMouseEx )            ( PRENDERER display, uint32_t bOwn DBG_PASS );
    /* Proprietary routine for reading touch screen serial devices
       directly and performing self calibration. Should rely on
       system driver and it's calibration instead.                 */
    RENDER_PROC( int, BeginCalibration )       ( uint32_t points );
    /* Used when display is accessed via a remote message pipe, this
       allows all render operations to be flushed and processed.
       Parameters
       display :  display to flush                                   */
    RENDER_PROC( void, SyncRender )            ( PRENDERER display );
/* Makes a display topmost. There isn't a way to un-topmost a
   window.
   Parameters
   hVideo :  display to make topmost
   Note
   Windows maintains at least two distinct stacks of windows. Normal
   windows in the normal window stack, and a set of windows that
   are above all other windows (except other windows that are
   also topmost).                                                    */
RENDER_PROC( void, MakeTopmost )( PRENDERER hVideo );
/* This makes the display topmost, but more so, any window that
   gets put over it it will attempt put itself over it.
   Parameters
   hVideo :  display to make top top most.                      */
RENDER_PROC (void, MakeAbsoluteTopmost) (PRENDERER hVideo);
/* Tests a display to see if it is set as topmost.
   Parameters
   hVideo :  display to inquire if it's topmost.
   Returns
   TRUE if display is topmost, else FALSE.         */
RENDER_PROC( int, IsTopmost )( PRENDERER hVideo );
/* Hides a display. That is, the content no longer shows on the
   users display.
   Parameters
   hVideo :  the handle of the Render to hide.
   See Also
   <link sack::image::render::RestoreDisplay@PRENDERER, RestoreDisplay> */
RENDER_PROC( void, HideDisplay )( PRENDERER hVideo );
/* Puts a display back on the screen. This is used in
   conjunction with HideDisplay().
   Parameters
   hVideo :  display to restore                       */
RENDER_PROC( void, RestoreDisplay )( PRENDERER hVideo );
	RENDER_PROC( void, RestoreDisplayEx )( PRENDERER hVideo DBG_PASS );
#define RestoreDisplay(n) RestoreDisplayEx( n DBG_SRC )
/* A check to see if HideDisplay has been applied to the
   display.
   Returns
   TRUE if the display is hidden, otherwise FALSE.
   Parameters
   video :  the display to check if hidden               */
RENDER_PROC( LOGICAL, IsDisplayHidden )( PRENDERER video );
// set focus to display, no events are generated if display already
// has the focus.
RENDER_PROC( void, ForceDisplayFocus )( PRENDERER display );
// display set as topmost within it's group (normal/bottommost/topmost)
RENDER_PROC( void, ForceDisplayFront )( PRENDERER display );
// display is force back one layer... or forced to bottom?
// alt-n pushed the display to the back... alt-tab is different...
RENDER_PROC( void, ForceDisplayBack )( PRENDERER display );
/* Not implemented on windows native, is for getting back
   display information over message service abstraction.
   if a readcallback is enabled, then this will be no-wait, and
   one will expect to receive the read data in the callback.
   Otherwise this will return any data which is present already,
   also non wait. Returns length read, INVALID_INDEX if no data
   read.
   If there IS a read callback, return will be 1 if there was no
   previous read queued, and 0 if there was already a read
   pending there may be one and only one read queued (for now)
   In either case if the read could not be queued, it will be
   0..
   If READLINE is true - then the result of the read will be a
   completed line. if there is no line present, and no callback
   defined, this will return INVALID_INDEX characters... 0
   characters is a n only (in line mode) 0 will be returned for
   no characters in non line mode...
   it will not have the end of line terminator (as generated by
   a non-bound enter key) I keep thinking there must be some
   kinda block mode read one can do, but no, uhh no, there's no
   way to get the user to put in X characters exactly....?
   Parameters
   pRenderer :  display to read from
   buffer :     buffer to read into
   maxlen :     maximum length of buffer to read
   bReadLine :  ???                                              */
RENDER_PROC( uint32_t, ReadDisplayEx )( PRENDERER pRenderer, TEXTSTR buffer, uint32_t maxlen, LOGICAL bReadLine );
/* Unused. Incomplete. */
#define ReadDisplay(r,b,len)      ReadDisplayEx(r,b,len,FALSE)
/* Unused. Incomplete. */
#define ReadDisplayLine(r,b,len)  ReadDisplayEx(r,b,len,TRUE)
/* Issues an update to a layered (transparent) window. This does
   the update directly, and does not have to be done within the
   redraw event.
   Parameters
   hVideo :    display to update a part of
   bContent :  TRUE is only the passed rectangle should update
   x :         left coordinate of the region to update to
               physical display
   y :         top coordinate of the region to update to physical
               display
   w :         width of the region to update to physical display
   h :         height of the region to update to physical display */
RENDER_PROC( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
#ifndef KEY_STRUCTURE_DEFINED
typedef LOGICAL (CPROC*KeyTriggerHandler)(uintptr_t,uint32_t keycode);
typedef struct KeyDefine *PKEYDEFINE;
#endif
/* Can create an external key binder to store key event
   bindings. One of these is available per display.
   Example
   <code lang="c++">
   void Alt_A_Pressed(uintptr_t user_data,uint32_t keycode)
   {
       // do something when alt-a is pressed.
   }
   {
      PKEYDEFINE my_key_events = CreateKeyBinder();
      BindKeyToEventEx( my_key_events, KEY_A, KEY_MOD_ALT, Alt_A_Pressed, 0 );
   }
   // then later, in a KeyProc handler...
   HandleKeyEvents( my_key_events, keycode );
   </code>                                                                     */
RENDER_PROC( PKEYDEFINE, CreateKeyBinder )( void );
/* Destroyes a PKEYDEFINE previously created with
   CreateKeyBinder.
   Parameters
   pKeyDef :  key binder to destroy.              */
RENDER_PROC( void, DestroyKeyBinder )( PKEYDEFINE pKeyDef );
/* Evaluates a key against the key defines to trigger possible
   events.
   Parameters
   KeyDefs :  PKEYDEFINE keystate which has keys bound to it.
   keycode :  the keycode passed to a KeyProc handler.         */
RENDER_PROC( int, HandleKeyEvents )( PKEYDEFINE KeyDefs, uint32_t keycode );
/* Assigns a callback routine to a key event.
   Parameters
   KeyDefs :   pointer to key table to set event in
   scancode :  scancode of the key \- this is a KEY_ code from
               keybrd.h
   modifier :  specific modifiers pressed for this event (control,
               alt, shift)
   trigger :   the trigger function to invoke when the key is
               pressed
   psv :       a uintptr_t user data passed to the trigger function
               when invoked.                                       */
RENDER_PROC( int, BindEventToKeyEx )( PKEYDEFINE KeyDefs, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Binds a key to a display.
   Parameters
   pRenderer :  display to set the event in (each display has a
                PKEYDEFINE internally. If this is NULL, then the
                event is bound to global events, an applies for
                any display window that gets a key input.
   scancode :   key scancode (a KEY_ identifier from keybrd.h)
   modifier :   key state modifier to apply to match the trigger
                on (control, alt, shift)
   trigger :    callback to invoke when the key combination is
                pressed
   psv :        user data to pass to the trigger when invoked.   */
RENDER_PROC( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Remove a previous binding to a key.
   Parameters
   pRenderer :  renderer to remove the key bind from
   scancode :   key scancode to stop checking
   modifier :   key modifier to stop checking        */
RENDER_PROC( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
/* A way to test to see if the current input device is a touch
   display. This can affect how mouse clicks are handles for
   things like buttons.
   Parameters
   None.
   Returns
   0.                                                          */
RENDER_PROC( int, IsTouchDisplay )( void );
// static void OnInputTouch( "Touch Handler" )(
#define OnSurfaceInput(name)	 DefineRegistryMethod("sack/render",SurfaceInput,"surface input","SurfaceInput",name,void,( int nInputs, PINPUT_POINT pInputs ),__LINE__)
#ifndef PSPRITE_METHOD
/* Unused. Incomplete. */
#define PSPRITE_METHOD PSPRITE_METHOD
RENDER_NAMESPACE_END
IMAGE_NAMESPACE
   /* define sprite draw method structure */
	typedef struct sprite_method_tag *PSPRITE_METHOD;
IMAGE_NAMESPACE_END
RENDER_NAMESPACE
#endif
/* Adds a sprite rendering method to the display. Just before
   updating to the display, the display is saved, and sprite
   update callbacks are issued. then the resulting display is
   \output. Sprite data only exists on the output image just
   before it is put on the physical display.
   Parameters
   render :    the display to attach a sprite render method to
   callback :  callback to draw sprites
   psv :       user data passed to callback when it is called
   Returns
   Pointer to a SpriteMethod that can be used in SavePortion...
   uhmm
   Note
   Has fallen into disrepair, and may need work before sprites
   work this way.                                               */
RENDER_PROC( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
/* signature for callback method to pass to
   WinShell_AcceptDroppedFiles.             */
typedef LOGICAL (CPROC*dropped_file_acceptor)(uintptr_t psv, CTEXTSTR filename, int32_t x, int32_t y );
/* Adds a callback to call when a file is dropped. Each callback
   can return 0 that it did not accept the file, or 1 that it
   did. once the file is accepted by a handler, it is not passed
   to any other handlers.
   Parameters
   renderer :  display to handle dropped files for
   f :         callback to acceptor
   psvUser :   user data passed to acceptor when it is invoked   */
RENDER_PROC( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
/* Enables a timer on the mouse to hide the cursor after a
   second that the mouse is not being moved.
   Parameters
   hVideo :   display to hide the mouse automatically for
   bEnable :  enable automatic hiding. After a few seconds, the
              mouse goes away until it moves(not click).        */
RENDER_PROC (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
/* Sets whether the display wants to get any mouse events at
   all.
   Parameters
   hVideo :    display to set the property for
   bNoMouse :  if 1, disables any mouse events. if 0, enables mouse
               events to the display.                               */
RENDER_PROC( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
#ifdef WIN32
	/* \returns the native handle used to output to. this can be an
	   SDL_Screen or HWND depending on platform.
	   Parameters
	   video :  display to get the native handle for
	   Returns
	   the system handle of the display object being used to output. */
	RENDER_PROC( HWND, GetNativeHandle )( PRENDERER video );
#endif
/* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
   \ \                                                          */
#define OwnMouse(d,o) OwnMouseEx( d, o DBG_SRC )
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplay(a)            OpenDisplaySizedAt(a,-1,-1,-1,-1)
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplaySized(a,w,h)   OpenDisplaySizedAt(a,w,h,-1,-1)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAbove(p,a)            OpenDisplayAboveSizedAt(p,-1,-1,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAboveSized(p,a,w,h)   OpenDisplayAboveSizedAt(p,w,h,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
   \ \                                                                                                   */
#define OpenDisplayUnderSizedAt(p,a,w,h,x,y) OpenDisplayAboveUnderSizedAt(a,w,h,x,y,NULL,p)
/* Lock the renderer for this thread to use. */
RENDER_PROC( void, LockRenderer )( PRENDERER render );
/* Unlock the renderer for other threads to use. */
RENDER_PROC( void, UnlockRenderer )( PRENDERER render );
/* Function to check if the draw mode of the renderer requires
   an ALL update (opengl/direct3d) every frame the whole display
   must be drawn.                                                */
RENDER_PROC( LOGICAL, RequiresDrawAll )( void );
RENDER_PROC( void, MarkDisplayUpdated )( PRENDERER );
#ifndef __NO_INTERFACES__
/* Interface defines the functions that are exported from the
   render library. This interface may be retrieved with
   LoadInterface( "\<appropriate name" ).                     */
_INTERFACE_NAMESPACE
/* Macro to define exports for render.h */
#define RENDER_PROC_PTR(type,name) type  (CPROC*_##name)
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag RENDER_INTERFACE;
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag *PRENDER_INTERFACE;
/* This is a function table interface to the video library. Allows
   application to not be linked to the video portion directly,
   allowing dynamic replacement.                                   */
struct render_interface_tag
{
      /* <combine sack::image::render::InitDisplay>
         \ \                                        */
       RENDER_PROC_PTR( int , InitDisplay) (void);
       /* <combine sack::image::render::SetApplicationTitle@TEXTCHAR *>
          \ \                                                           */
			 RENDER_PROC_PTR( void , SetApplicationTitle) (const TEXTCHAR *title );
          /* <combine sack::image::render::SetApplicationIcon@Image>
                                                    \ \                                                     */
       RENDER_PROC_PTR( void , SetApplicationIcon)  (Image Icon);
    /* <combine sack::image::render::GetDisplaySize@uint32_t *@uint32_t *>
       \ \                                                       */
    RENDER_PROC_PTR( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::SetDisplaySize@uint32_t@uint32_t>
       \ \                                                   */
    RENDER_PROC_PTR( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
    /* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
       \ \                                                                     */
    RENDER_PROC_PTR( PRENDERER , OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
       \ \                                                                                    */
    RENDER_PROC_PTR( PRENDERER , OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* <combine sack::image::render::CloseDisplay@PRENDERER>
       \ \                                                   */
    RENDER_PROC_PTR( void        , CloseDisplay) ( PRENDERER );
    /* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
       \ \                                                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
    /* <combine sack::image::render::UpdateDisplayEx@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayEx)        ( PRENDERER DBG_PASS);
    /* <combine sack::image::render::GetDisplayPosition@PRENDERER@int32_t *@int32_t *@uint32_t *@uint32_t *>
       \ \                                                                                   */
    RENDER_PROC_PTR( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::MoveDisplay@PRENDERER@int32_t@int32_t>
       \ \                                                            */
    RENDER_PROC_PTR( void, MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::MoveDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* <combine sack::image::render::SizeDisplay@PRENDERER@uint32_t@uint32_t>
       \ \                                                          */
    RENDER_PROC_PTR( void, SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* <combine sack::image::render::SizeDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
    /* <combine sack::image::render::MoveSizeDisplayRel@PRENDERER@int32_t@int32_t@int32_t@int32_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, MoveSizeDisplayRel )  ( PRENDERER hVideo
                                                 , int32_t delx, int32_t dely
                                                 , int32_t delw, int32_t delh );
    RENDER_PROC_PTR( void, PutDisplayAbove)      ( PRENDERER, PRENDERER );
 /* <combine sack::image::render::PutDisplayAbove@PRENDERER@PRENDERER>
                                                              \ \                                                                */
    /* <combine sack::image::render::GetDisplayImage@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( Image, GetDisplayImage)     ( PRENDERER );
    /* <combine sack::image::render::SetCloseHandler@PRENDERER@CloseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* <combine sack::image::render::SetMouseHandler@PRENDERER@MouseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* <combine sack::image::render::SetRedrawHandler@PRENDERER@RedrawCallback@uintptr_t>
       \ \                                                                               */
    RENDER_PROC_PTR( void, SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
    /* <combine sack::image::render::SetKeyboardHandler@PRENDERER@KeyProc@uintptr_t>
       \ \                                                                          */
    RENDER_PROC_PTR( void, SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* <combine sack::image::render::SetLoseFocusHandler@PRENDERER@LoseFocusCallback@uintptr_t>
       \ \                                                                                     */
    RENDER_PROC_PTR( void, SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* <combine sack::image::render::SetDefaultHandler@PRENDERER@GeneralCallback@uintptr_t>
       \ \                                                                                 */
#if ACTIVE_MESSAGE_IMPLEMENTED
			 RENDER_PROC_PTR( void, SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#else
       POINTER junk1;
#endif
    /* <combine sack::image::render::GetMousePosition@int32_t *@int32_t *>
		 \ \                                                           */
    RENDER_PROC_PTR( void, GetMousePosition)     ( int32_t *x, int32_t *y );
    /* <combine sack::image::render::SetMousePosition@PRENDERER@int32_t@int32_t>
       \ \                                                                 */
    RENDER_PROC_PTR( void, SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::HasFocus@PRENDERER>
       \ \                                               */
    RENDER_PROC_PTR( LOGICAL, HasFocus)          ( PRENDERER );
    /* <combine sack::image::render::GetKeyText@int>
       \ \                                           */
    RENDER_PROC_PTR( const TEXTCHAR *, GetKeyText)           ( int key );
    /* <combine sack::image::render::IsKeyDown@PRENDERER@int>
       \ \                                                    */
    RENDER_PROC_PTR( uint32_t, IsKeyDown )        ( PRENDERER display, int key );
    /* <combine sack::image::render::KeyDown@PRENDERER@int>
       \ \                                                  */
    RENDER_PROC_PTR( uint32_t, KeyDown )         ( PRENDERER display, int key );
    /* <combine sack::image::render::DisplayIsValid@PRENDERER>
       \ \                                                     */
    RENDER_PROC_PTR( LOGICAL, DisplayIsValid )  ( PRENDERER display );
    /* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
       \ \                                                          */
    RENDER_PROC_PTR( void, OwnMouseEx )            ( PRENDERER display, uint32_t Own DBG_PASS);
    /* <combine sack::image::render::BeginCalibration@uint32_t>
       \ \                                                 */
    RENDER_PROC_PTR( int, BeginCalibration )       ( uint32_t points );
    /* <combine sack::image::render::SyncRender@PRENDERER>
       \ \                                                 */
    RENDER_PROC_PTR( void, SyncRender )            ( PRENDERER pDisplay );
    /* DEPRICATED; left in structure for compatibility.  Removed define and export definition. */
	 /* <combine sack::image::render::MoveSizeDisplay@PRENDERER@int32_t@int32_t@int32_t@int32_t>
	    \ \                                                                          */
	 RENDER_PROC_PTR( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* <combine sack::image::render::MakeTopmost@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, MakeTopmost )    ( PRENDERER hVideo );
   /* <combine sack::image::render::HideDisplay@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, HideDisplay )      ( PRENDERER hVideo );
   /* <combine sack::image::render::RestoreDisplay@PRENDERER>
      \ \                                                     */
   RENDER_PROC_PTR( void, RestoreDisplay )   ( PRENDERER hVideo );
	/* <combine sack::image::render::ForceDisplayFocus@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFocus )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayFront@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFront )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayBack@PRENDERER>
	   \ \                                                       */
	RENDER_PROC_PTR( void, ForceDisplayBack )( PRENDERER display );
	/* <combine sack::image::render::BindEventToKey@PRENDERER@uint32_t@uint32_t@KeyTriggerHandler@uintptr_t>
	   \ \                                                                                        */
	RENDER_PROC_PTR( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
	/* <combine sack::image::render::UnbindKey@PRENDERER@uint32_t@uint32_t>
	   \ \                                                        */
	RENDER_PROC_PTR( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
	/* <combine sack::image::render::IsTopmost@PRENDERER>
	   \ \                                                */
	RENDER_PROC_PTR( int, IsTopmost )( PRENDERER hVideo );
	/* Used as a point to sync between applications and the message
	   display server; Makes sure that all draw commands which do
	   not have a response are done.
	   Waits until all commands are processed; which is wait until
	   this command is processed.                                   */
	RENDER_PROC_PTR( void, OkaySyncRender )            ( void );
   /* <combine sack::image::render::IsTouchDisplay>
      \ \                                           */
   RENDER_PROC_PTR( int, IsTouchDisplay )( void );
	/* <combine sack::image::render::GetMouseState@int32_t *@int32_t *@uint32_t *>
	   \ \                                                              */
	RENDER_PROC_PTR( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
	/* <combine sack::image::render::EnableSpriteMethod@PRENDERER@void__cdecl*RenderSpritesPTRSZVAL psv\, PRENDERER renderer\, int32_t x\, int32_t y\, uint32_t w\, uint32_t h@uintptr_t>
	   \ \                                                                                                                                                               */
	RENDER_PROC_PTR ( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
	/* <combine sack::image::render::WinShell_AcceptDroppedFiles@PRENDERER@dropped_file_acceptor@uintptr_t>
	   \ \                                                                                                 */
	RENDER_PROC_PTR( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
	/* <combine sack::image::render::PutDisplayIn@PRENDERER@PRENDERER>
	   \ \                                                             */
	RENDER_PROC_PTR(void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
#ifdef WIN32
	/* <combine sack::image::render::MakeDisplayFrom@HWND>
	   \ \                                                 */
			RENDER_PROC_PTR (PRENDERER, MakeDisplayFrom) (HWND hWnd) ;
#else
      POINTER junk4;
#endif
	/* <combine sack::image::render::SetRendererTitle@PRENDERER@TEXTCHAR *>
	   \ \                                                                  */
	RENDER_PROC_PTR( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
	/* <combine sack::image::render::DisableMouseOnIdle@PRENDERER@LOGICAL>
	   \ \                                                                 */
	RENDER_PROC_PTR (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
	/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
	   \ \                                                                                                   */
	RENDER_PROC_PTR( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	/* <combine sack::image::render::SetDisplayNoMouse@PRENDERER@int>
	   \ \                                                            */
	RENDER_PROC_PTR( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
	/* <combine sack::image::render::Redraw@PRENDERER>
	   \ \                                             */
	RENDER_PROC_PTR( void, Redraw )( PRENDERER hVideo );
	/* <combine sack::image::render::MakeAbsoluteTopmost@PRENDERER>
	   \ \                                                          */
	RENDER_PROC_PTR(void, MakeAbsoluteTopmost) (PRENDERER hVideo);
	/* <combine sack::image::render::SetDisplayFade@PRENDERER@int>
	   \ \                                                         */
	RENDER_PROC_PTR( void, SetDisplayFade )( PRENDERER hVideo, int level );
	/* <combine sack::image::render::IsDisplayHidden@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( LOGICAL, IsDisplayHidden )( PRENDERER video );
#ifdef WIN32
	/* <combine sack::image::render::GetNativeHandle@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( HWND, GetNativeHandle )( PRENDERER video );
#endif
		 /* <combine sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *>
		    \ \                                                                           */
		 RENDER_PROC_PTR (void, GetDisplaySizeEx) ( int nDisplay
														  , int32_t *x, int32_t *y
														  , uint32_t *width, uint32_t *height);
	/* Locks a video display. Applications shouldn't be locking
	   this, but if for some reason they require it; use this
	   function.                                                */
	RENDER_PROC_PTR( void, LockRenderer )( PRENDERER render );
	/* Release renderer lock critical section. Applications
	   shouldn't be locking this surface.                   */
	RENDER_PROC_PTR( void, UnlockRenderer )( PRENDERER render );
	/* Provides a way for applications to cause the window to flush
	   to the display (if it's a transparent window)                */
	RENDER_PROC_PTR( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
	/* Check to see if the render mode is always redraw; changes how
	   smudge works in PSI. If always redrawn, then the redraw isn't
	   done during the smudge, and instead is delayed until a draw
	   is triggered at which time all controls are drawn.
	   Returns
	   TRUE if full screen needs to be drawn during a draw,
	   otherwise partial updates may be done.                        */
	RENDER_PROC_PTR( LOGICAL, RequiresDrawAll )( void );
#ifndef NO_TOUCH
		/* <combine sack::image::render::SetTouchHandler@PRENDERER@fte inc asdfl;kj
		 fteTouchCallback@uintptr_t>
       \ \                                                                             */
			RENDER_PROC_PTR( void, SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
#ifndef NO_TOUCH
		/* <combine sack::image::render::SetPenHandler@PRENDERER@fte inc asdfl;kj
		 fteTouchCallback@uintptr_t>
       \ \                                                                             */
			RENDER_PROC_PTR( void, SetPenHandler)      ( PRENDERER, PenCallback, uintptr_t );
#endif
    RENDER_PROC_PTR( void, MarkDisplayUpdated )( PRENDERER );
    /* <combine sack::image::render::SetHideHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* <combine sack::image::render::SetRestoreHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
		 RENDER_PROC_PTR( void, RestoreDisplayEx )   ( PRENDERER hVideo DBG_PASS );
		 /* added for android extensions; call to enable showing the keyboard in the correct thread
        ; may have applications for windows tablets
		  */
       RENDER_PROC_PTR( void, SACK_Vidlib_ShowInputDevice )( void );
		 /* added for android extensions; call to enable hiding the keyboard in the correct thread
		  ; may have applications for windows tablets */
       RENDER_PROC_PTR( void, SACK_Vidlib_HideInputDevice )( void );
	/* Check to see if the render mode is allows updates from any thread.
	   If supported can simplify updates (requiring less scheduling queues).
	   If it is not supported (such as an X display where only a single thread
	   can write to the server, otherwise the socket state gets confused) then
	   Redraw() should be used to dispatch appriorately.  PSI Implements this
	   internally, so smudge() on a control will behave appriopriately.
	   If RequiresDrawAll() this is irrelavent.
	   Returns
	   TRUE if any thread is allowed to generate UpdateDisplayPortion().
	   otherwise must call Redraw() on the surface to get a event in the
	   correct thread.*/
			 RENDER_PROC_PTR( LOGICAL, AllowsAnyThreadToUpdate )( void );
		/* This method takes the renderer and either A) resizes it to the display
		 and issues a redraw; or it sets the screen to the size of the renderer
		 and scales the image direct to the display.  Pass NULL or another window
		 to clear the current fullscreen app.
		 Second paramter is the display to show full on; 0 is 'default'...
		 1, 2, 3, etc... will be absolute number... if not supported will be same a 0 */
		RENDER_PROC_PTR( void, SetDisplayFullScreen )( PRENDERER renderer, int nDisplay );
		/* like full screen, some applications may want to
       enable owning the screen... (media player) */
      RENDER_PROC_PTR( void, SuspendSystemSleep )( int bool_suspend_enable );
	RENDER_PROC_PTR( LOGICAL, RenderIsInstanced )( void );
	RENDER_PROC_PTR( LOGICAL, VidlibRenderAllowsCopy )( void );
	RENDER_PROC_PTR( void, SetDisplayCursor )( CTEXTSTR nCursor );
	RENDER_PROC_PTR( LOGICAL, IsDisplayRedrawForced )( PRENDERER renderer );
 // only valid during a headless display event....
	RENDER_PROC_PTR( void, ReplyCloseDisplay )( void );
		/* Clipboard Callback */
	RENDER_PROC_PTR( void, SetClipboardEventCallback )(PRENDERER pRenderer, ClipboardCallback callback, uintptr_t psv);
	// where ever the current mouse is, lock the mouse to the window, and allow the mouse to move it.
	//
	RENDER_PROC_PTR( void, BeginMoveDisplay )(PRENDERER pRenderer );
	// where ever the current mouse is, lock the mouse to the window, and allow the mouse to move it.
	//
	RENDER_PROC_PTR( void, BeginSizeDisplay )(PRENDERER pRenderer, enum sizeDisplayValues sizeFrom );
   RENDER_PROC_PTR( void, WillUpdatePortions)( PRENDERER pRenderer, LOGICAL disableAutoDraw );
};
#ifdef DEFINE_DEFAULT_RENDER_INTERFACE
#define USE_RENDER_INTERFACE GetDisplayInterface()
#endif
#ifdef FORCE_NO_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#ifdef FORCE_NO_RENDER_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#if !defined(FORCE_NO_RENDER_INTERFACE)
/* RENDER_PROC( PRENDER_INTERFACE, GetDisplayInterface )( void
 );
   Gets the interface the proper way - by name.
   Returns
   Pointer to the render interface.                            */
#  define GetDisplayInterface() (PRENDER_INTERFACE)GetInterface( "render" )
/* RENDER_PROC( void, DropDisplayInterface )( PRENDER_INTERFACE interface );
   release the interface (could be cleanup, most are donothing....
   parameters
   interface   - Pointer to the render interface.                            */
#  define DropDisplayInterface(x) DropInterface( "render", x )
#endif
#ifdef USE_RENDER_INTERFACE
typedef int check_this_variable;
// these methods are provided for backwards compatibility
// these should not be used - but rather use the interface defined below
// (the ones not prefixed by ActImage_ - except for ActImage_Init, which
// may(should) be called before any other function.
#define REND_PROC_ALIAS(name) ((USE_RENDER_INTERFACE)->_##name)
#define REND_PROC_ALIAS_VOID(name) if(USE_RENDER_INTERFACE)(USE_RENDER_INTERFACE)->_##name
#define SetApplicationTitle       REND_PROC_ALIAS(SetApplicationTitle)
#define SetRendererTitle       REND_PROC_ALIAS(SetRendererTitle)
#define SetApplicationIcon        REND_PROC_ALIAS(SetApplicationIcon)
#define GetDisplaySize            REND_PROC_ALIAS(GetDisplaySize)
#define GetDisplaySizeEx            REND_PROC_ALIAS(GetDisplaySizeEx)
#define MarkDisplayUpdated            REND_PROC_ALIAS(MarkDisplayUpdated)
#define SetDisplaySize            REND_PROC_ALIAS(SetDisplaySize)
#define GetDisplayPosition        REND_PROC_ALIAS(GetDisplayPosition)
#define IssueUpdateLayeredEx      REND_PROC_ALIAS(IssueUpdateLayeredEx)
#define MakeDisplayFrom        REND_PROC_ALIAS(MakeDisplayFrom)
#define OpenDisplaySizedAt        REND_PROC_ALIAS(OpenDisplaySizedAt)
#define OpenDisplayAboveSizedAt   REND_PROC_ALIAS(OpenDisplayAboveSizedAt)
#define OpenDisplayAboveUnderSizedAt   REND_PROC_ALIAS(OpenDisplayAboveUnderSizedAt)
#define CloseDisplay              REND_PROC_ALIAS(CloseDisplay)
#define UpdateDisplayPortionEx    REND_PROC_ALIAS(UpdateDisplayPortionEx)
#define UpdateDisplayEx             REND_PROC_ALIAS(UpdateDisplayEx)
#define SetMousePosition          REND_PROC_ALIAS(SetMousePosition)
#define GetMousePosition          REND_PROC_ALIAS(GetMousePosition)
#define GetMouseState          REND_PROC_ALIAS(GetMouseState)
#define EnableSpriteMethod          REND_PROC_ALIAS(EnableSpriteMethod)
#define WinShell_AcceptDroppedFiles REND_PROC_ALIAS(WinShell_AcceptDroppedFiles)
#define MoveDisplay               REND_PROC_ALIAS(MoveDisplay)
#define MoveDisplayRel            REND_PROC_ALIAS(MoveDisplayRel)
#define SizeDisplay               REND_PROC_ALIAS(SizeDisplay)
#define Redraw               REND_PROC_ALIAS(Redraw)
#define RequiresDrawAll()        (USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RequiresDrawAll()):0
#define SizeDisplayRel            REND_PROC_ALIAS(SizeDisplayRel)
#define MoveSizeDisplay        REND_PROC_ALIAS(MoveSizeDisplay)
#define MoveSizeDisplayRel        REND_PROC_ALIAS(MoveSizeDisplayRel)
#define PutDisplayAbove           REND_PROC_ALIAS(PutDisplayAbove)
#define PutDisplayIn           REND_PROC_ALIAS(PutDisplayIn)
#define GetDisplayImage           REND_PROC_ALIAS(GetDisplayImage)
#define LockRenderer              REND_PROC_ALIAS(LockRenderer)
#define UnlockRenderer              REND_PROC_ALIAS(UnlockRenderer)
#define SetCloseHandler           REND_PROC_ALIAS(SetCloseHandler)
#define SetMouseHandler           REND_PROC_ALIAS(SetMouseHandler)
#define SetHideHandler           REND_PROC_ALIAS(SetHideHandler)
#define SetRestoreHandler           REND_PROC_ALIAS(SetRestoreHandler)
#define AllowsAnyThreadToUpdate()          ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate)?(USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate():1:1)
#define VidlibRenderAllowsCopy()        ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy)?(USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy():1:1)
#ifndef __LINUX__
#define SetTouchHandler           REND_PROC_ALIAS(SetTouchHandler)
#define SetPenHandler           REND_PROC_ALIAS(SetPenHandler)
#endif
#define SetRedrawHandler          REND_PROC_ALIAS(SetRedrawHandler)
#define SetKeyboardHandler        REND_PROC_ALIAS(SetKeyboardHandler)
#define SetLoseFocusHandler       REND_PROC_ALIAS(SetLoseFocusHandler)
#define SetDefaultHandler         REND_PROC_ALIAS(SetDefaultHandler)
#define GetKeyText                REND_PROC_ALIAS(GetKeyText)
#define HasFocus                  REND_PROC_ALIAS(HasFocus)
#define SACK_Vidlib_ShowInputDevice REND_PROC_ALIAS( SACK_Vidlib_ShowInputDevice )
#define SACK_Vidlib_HideInputDevice REND_PROC_ALIAS( SACK_Vidlib_HideInputDevice )
#define CreateMessage             REND_PROC_ALIAS(CreateMessage)
#define SendActiveMessage         REND_PROC_ALIAS(SendActiveMessage)
#define IsKeyDown                 REND_PROC_ALIAS(IsKeyDown)
#define KeyDown                   REND_PROC_ALIAS(KeyDown)
#define DisplayIsValid            REND_PROC_ALIAS(DisplayIsValid)
#define OwnMouseEx                REND_PROC_ALIAS(OwnMouseEx)
#define BeginCalibration          REND_PROC_ALIAS(BeginCalibration)
#define SyncRender                REND_PROC_ALIAS(SyncRender)
#define OkaySyncRender                REND_PROC_ALIAS(OkaySyncRender)
#define HideDisplay               REND_PROC_ALIAS(HideDisplay)
#define IsDisplayHidden               REND_PROC_ALIAS(IsDisplayHidden)
/* <combine sack::image::render::GetNativeHandle@PRENDERER>
   \ \                                                      */
#define GetNativeHandle             REND_PROC_ALIAS(GetNativeHandle)
//#define RestoreDisplay             REND_PROC_ALIAS(RestoreDisplay)
#define RestoreDisplayEx             REND_PROC_ALIAS(RestoreDisplayEx)
#define MakeTopmost               REND_PROC_ALIAS_VOID(MakeTopmost)
#define MakeAbsoluteTopmost               REND_PROC_ALIAS_VOID(MakeAbsoluteTopmost)
#define IsTopmost               REND_PROC_ALIAS(IsTopmost)
#define SetDisplayFade               REND_PROC_ALIAS(SetDisplayFade)
#define ForceDisplayFocus         REND_PROC_ALIAS(ForceDisplayFocus)
#define ForceDisplayFront       REND_PROC_ALIAS(ForceDisplayFront)
#define ForceDisplayBack          REND_PROC_ALIAS(ForceDisplayBack)
#define BindEventToKey          REND_PROC_ALIAS(BindEventToKey)
#define UnbindKey               REND_PROC_ALIAS(UnbindKey)
#define IsTouchDisplay          REND_PROC_ALIAS(IsTouchDisplay)
#define DisableMouseOnIdle      REND_PROC_ALIAS(DisableMouseOnIdle )
#define SetDisplayNoMouse      REND_PROC_ALIAS(SetDisplayNoMouse )
#define SetTouchHandler        REND_PROC_ALIAS(SetTouchHandler)
#define SetPenHandler        REND_PROC_ALIAS(SetPenHandler)
#define ReplyCloseDisplay      if(USE_RENDER_INTERFACE) if((USE_RENDER_INTERFACE)->_ReplyCloseDisplay) (USE_RENDER_INTERFACE)->_ReplyCloseDisplay
#define SetClipboardEventCallback   REND_PROC_ALIAS( SetClipboardEventCallback )
#define SetDisplayFullScreen    REND_PROC_ALIAS_VOID( SetDisplayFullScreen )
#define SuspendSystemSleep      REND_PROC_ALIAS_VOID( SuspendSystemSleep )
#define RenderIsInstanced()       ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RenderIsInstanced)?(USE_RENDER_INTERFACE)->_RenderIsInstanced():0:0)
#define SetDisplayCursor(n)           {if((USE_RENDER_INTERFACE)&&(USE_RENDER_INTERFACE)->_SetDisplayCursor)REND_PROC_ALIAS(SetDisplayCursor)(n);}
#define IsDisplayRedrawForced(r)    ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_IsDisplayRedrawForced)?(USE_RENDER_INTERFACE)->_IsDisplayRedrawForced(r):0:0)
#define BeginMoveDisplay(r)   ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_BeginMoveDisplay)?((USE_RENDER_INTERFACE)->_BeginMoveDisplay(r),1):0:0)
#define BeginSizeDisplay(r,m)   ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_BeginSizeDisplay)?((USE_RENDER_INTERFACE)->_BeginSizeDisplay(r,m),1):0:0)
#define WillUpdatePortions(r,v) ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_WillUpdatePortions)?((USE_RENDER_INTERFACE)->_WillUpdatePortions(r,v),1):0:0)
#endif
	_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11::Interface;
#else
	using namespace sack::image::render::Interface;
#endif
#endif
#endif
#ifndef __NO_MSGSVR__
#ifdef DEFINE_RENDER_PROTOCOL
  // offsetof
// need to define BASE_RENDER_MESSAGE_ID before including this.
//#define MSG_ID(method)  ( ( offsetof( struct render_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_RENDER_MESSAGE_ID + MSG_EventUser )
#define MSG_DisplayClientClose        MSG_ID(DisplayClientClose)
#define MSG_SetApplicationTitle       MSG_ID(SetApplicationTitle)
#define MSG_SetRendererTitle       MSG_ID(SetRendererTitle)
#define MSG_SetApplicationIcon        MSG_ID(SetApplicationTitle)
#define MSG_GetDisplaySize            MSG_ID(GetDisplaySize)
#define MSG_SetDisplaySize            MSG_ID(SetDisplaySize)
#define MSG_GetDisplayPosition        MSG_ID(GetDisplayPosition)
#define MSG_OpenDisplaySizedAt        MSG_ID(OpenDisplaySizedAt)
#define MSG_OpenDisplayAboveSizedAt   MSG_ID(OpenDisplayAboveSizedAt)
#define MSG_CloseDisplay              MSG_ID(CloseDisplay)
#define MSG_UpdateDisplayPortionEx    MSG_ID(UpdateDisplayPortionEx)
#define MSG_UpdateDisplay             MSG_ID(UpdateDisplayEx)
#define MSG_SetMousePosition          MSG_ID(SetMousePosition)
#define MSG_GetMousePosition          MSG_ID(GetMousePosition)
#define MSG_GetMouseState             MSG_ID(GetMouseState )
#define MSG_Redraw               MSG_ID(Redraw)
#define MSG_EnableSpriteMethod             MSG_ID(EnableSpriteMethod )
#define MSG_WinShell_AcceptDroppedFiles    MSG_ID(WinShell_AcceptDroppedFiles )
#define MSG_MoveDisplay               MSG_ID(MoveDisplay)
#define MSG_MoveDisplayRel            MSG_ID(MoveDisplayRel)
#define MSG_SizeDisplay               MSG_ID(SizeDisplay)
#define MSG_SizeDisplayRel            MSG_ID(SizeDisplayRel)
#define MSG_MoveSizeDisplay           MSG_ID(MoveSizeDisplay)
#define MSG_MoveSizeDisplayRel        MSG_ID(MoveSizeDisplayRel)
#define MSG_PutDisplayAbove           MSG_ID(PutDisplayAbove)
#define MSG_GetDisplayImage           MSG_ID(GetDisplayImage)
#define MSG_SetCloseHandler           MSG_ID(SetCloseHandler)
#define MSG_SetMouseHandler           MSG_ID(SetMouseHandler)
#define MSG_SetRedrawHandler          MSG_ID(SetRedrawHandler)
#define MSG_SetKeyboardHandler        MSG_ID(SetKeyboardHandler)
#define MSG_SetLoseFocusHandler       MSG_ID(SetLoseFocusHandler)
#define MSG_SetDefaultHandler         MSG_ID(SetDefaultHandler)
// -- all other handlers - client side only
#define MSG_HasFocus                  MSG_ID(HasFocus)
#define MSG_SendActiveMessage         MSG_ID(SendActiveMessage)
#define MSG_GetKeyText                MSG_ID(GetKeyText)
#define MSG_IsKeyDown                 MSG_ID(IsKeyDown)
#define MSG_KeyDown                   MSG_ID(KeyDown)
#define MSG_DisplayIsValid            MSG_ID(DisplayIsValid)
#define MSG_OwnMouseEx                 MSG_ID(OwnMouseEx)
#define MSG_BeginCalibration           MSG_ID(BeginCalibration)
#define MSG_SyncRender                 MSG_ID(SyncRender)
#define MSG_OkaySyncRender                 MSG_ID(OkaySyncRender)
#define MSG_HideDisplay               MSG_ID(HideDisplay)
#define MSG_IsDisplayHidden               MSG_ID(IsDisplayHidden)
#define MSG_RestoreDisplay             MSG_ID(RestoreDisplay)
#define MSG_MakeTopmost               MSG_ID(MakeTopmost)
#define MSG_BindEventToKey          MSG_ID(BindEventToKey)
#define MSG_UnbindKey               MSG_ID(UnbindKey)
#define MSG_IsTouchDisplay          MSG_ID(IsTouchDisplay )
#define MSG_GetNativeHandle             MSG_ID(GetNativeHandle)
#endif
#endif
// static void OnDisplayChangedSize( "" )( PRENDERER, int nDisplay, uint32_t x, uint32_t y, uint32_t width, uint32_t height )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplaySizeChange(name)	 DefineRegistryMethod("sack/render",OnDisplaySizeChange,"display",name,"on_display_size_change",void,( uintptr_t psv_redraw, int nDisplay, int32_t x, int32_t y, uint32_t width, uint32_t height ),__LINE__)
// static void OnDisplayPause( "" )( void )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplayPause(name)	 DefineRegistryMethod("sack/render/android",OnDisplayPause,"display",name,"on_display_pause",void,(void),__LINE__)
// static void OnDisplayResume( "" )( void )
	// OnDisplayResume is called on systems that allow the application to suspend its display.
	// Wake from sleep mode may also trigger such an event, allows application to restore saved state
   // a media player, for instance, may continue playing ( it might be good to wait just a little longer than 'now')
#define OnDisplayResume(name)	 DefineRegistryMethod("sack/render/android",OnDisplayResume,"display",name,"on_display_resume",void,(void),__LINE__)
	struct display_app;
	struct display_app_local;
	// static void OnDisplayConnect( "" )( struct display_app*app, struct display_app_local ***pppLocal )
	//  app is a unique handle to the display instance.  Can be used as a key to locate resources for the display
	//  pppLocal is ... ugly.
	//  ThreadLocal struct instance_local *_thread_local;
	//  static void OnDisplayConnect( "" )( struct display_app*app, struct display_app_local ***pppLocal )
	//  {
	//	    _thread_local = New( struct instance_local );
	//      MemSet( option_thread, 0, sizeof( option_thread ) );
	//      (*local) = (struct display_app_local**)&option_thread;
	//       //... init local here
	//  }
	//
#define OnDisplayConnect(name)	 DefineRegistryMethod("/sack/render/remote display",OnDisplayConnect,"connect",name,"new_display_connect",void,(struct display_app*app, struct display_app_local ***),__LINE__)
	// unimplemented.
#define OnDisplayConnected(name)	 DefineRegistryMethod("/sack/render/remote display",OnDisplayConnect,"connect",name,"new_display_connected",void,(struct display_app*app),__LINE__)
#ifdef __cplusplus
#ifdef RENDER_EXTRA_CLOSE
}
#endif
 //RENDER_NAMESPACE_END
} } }
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11;
#else
	using namespace sack::image::render;
#endif
#endif
#endif
// : $
// $Log: render.h,v $
// Revision 1.48  2005/05/25 16:50:09  d3x0r
// Synch with working repository.
//
// Revision 1.10  2003/03/25 08:38:11  panther
// Add logging
//
#endif
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
#ifdef __cplusplus
	}
}
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
struct malloc_chunk_tag
{
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
	PREFIX_PACKED struct {
   // if 0 - block is free
		uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
		uint16_t dwPad;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t to_chunk_start;
	} PACKED info;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
};
struct heap_chunk_tag
{
 // *next, **me; &next is also &this block.
	DeclareLink( struct heap_chunk_tag );
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
   // needed for release to find free linked list head
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag *pRoot;
	PREFIX_PACKED struct {
            // if 0 - block is free
		uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
		uint16_t dwPad;
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t alignment;
      // to_chunk_start is computed from byData offset by alignment minus a uin16_t.
 // this is additional to subtract to get back to start (aligned allocate)
		uint16_t to_chunk_start;
	} PACKED info;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
};
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	}
}
#endif
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::containers;
		using namespace sack::memory;
		using namespace sack::logging;
#endif
//#define LOG_CREATE_EVENT_OBJECT
//#define LOG_THREAD
//#define LOG_SLEEPS
// - define this to log when timers were delayed in scheduling...
//198#define LOG_LATENCY_LIGHT
//#define LOG_LATENCY
//#define LOG_INSERTS
//#define LOG_DISPATCH
//#define DEBUG_PIPE_USAGE
const char *default_thread_name = "ThreadSignal";
typedef struct thread_event THREAD_EVENT;
typedef struct thread_event *PTHREAD_EVENT;
struct thread_event
{
	TEXTSTR name;
#ifdef _WIN32
	HANDLE hEvent;
#endif
};
#define MAXTHREAD_EVENTSPERSET 64
DeclareSet( THREAD_EVENT );
struct timer_tag
{
// putting next as first thing in structure
   // allows me to reference also prior
	struct timer_tag *next;
	union {
		struct timer_tag **me;
		struct timer_tag *prior;
	};
	struct {
		BIT_FIELD bRescheduled : 1;
		BIT_FIELD bRemoved : 1;
	} flags;
	uint32_t frequency;
	int32_t delta;
	uint32_t ID;
	void (CPROC*callback)(uintptr_t user);
	uintptr_t userdata;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR pFile;
	int nLine;
#endif
};
typedef struct timer_tag TIMER, *PTIMER;
#define MAXTIMERSPERSET 32
DeclareSet( TIMER );
struct threads_tag
{
	// these first two items MUST
	// be declared publically, and MUST be visible
	// to the thread created.
	uintptr_t param;
	uintptr_t (CPROC*proc)( struct threads_tag * );
	uintptr_t (CPROC*simple_proc)( POINTER );
 // might be not a real thread.
	CTEXTSTR thread_event_name;
	volatile THREAD_ID thread_ident;
	PTHREAD_EVENT thread_event;
#ifdef _WIN32
	//HANDLE hEvent;
	volatile HANDLE hThread;
#else
#ifdef USE_PIPE_SEMS
 // file handles that are the pipe's ends. 0=read 1=write
	int pipe_ends[2];
#endif
	//int semaphore; // use this as a status of pipes if USE_PIPE_SEMS is used...; otherwise it's a ipcsem
  // uses mutex now instead of semaphore to sleep
	pthread_mutex_t mutex;
	pthread_t hThread;
#endif
	struct {
		//BIT_FIELD bLock : 1;
		//BIT_FIELD bSleeping : 1;
		//BIT_FIELD bWakeWhileRunning : 1;
		BIT_FIELD bRemovedWhileRunning;
		BIT_FIELD bLocal;
		volatile BIT_FIELD bReady;
		volatile BIT_FIELD bStarted;
	} flags;
	//struct threads_tag *next, **me;
	CTEXTSTR pFile;
	uint32_t nLine;
};
typedef struct threads_tag THREAD;
#define MAXTHREADSPERSET 64
DeclareSet( THREAD );
struct timer_local_data {
	uint32_t timerID;
	LOGICAL wrappedTimerID;
	PTIMERSET timer_pool;
	PTHREAD_EVENTSET thread_event_pool;
	PTIMER timers;
 // this timer is scheduled to be added...
	PTIMER add_timer;
	PTIMER current_timer;
	struct {
		BIT_FIELD away_in_timer : 1;
		BIT_FIELD insert_while_away : 1;
		BIT_FIELD bExited : 1;
#ifdef ENABLE_CRITICALSEC_LOGGING
		BIT_FIELD bLogCriticalSections : 1;
#endif
		BIT_FIELD bLogSleeps : 1;
		BIT_FIELD bLogTimerDispatch : 1;
		BIT_FIELD bLogThreadCreate : 1;
		BIT_FIELD bHaltTimers : 1;
	} flags;
 // this timer is scheduled to be removed...
	volatile uint32_t del_timer;
 // should somehow end up equating to sleep overhead...
	uint32_t tick_bias;
 // last known time that a timer could have fired...
	uint64_t last_tick;
 // the current moment up to which we fire all timers.
	uint64_t this_tick;
	PTHREAD pTimerThread;
	PTHREADSET threadset;
	PTHREAD threads;
	volatile uint32_t lock_timers;
	CRITICALSECTION cs_timer_change;
	//uint32_t pending_timer_change;
	uint32_t remove_timer;
	volatile uint32_t CurrentTimerID;
	int32_t last_sleep;
	PLIST onThreadCreate;
	PLIST onThreadExit;
#define globalTimerData (*global_timer_structure)
	volatile uint64_t lock_thread_create;
	// should be a short list... 10 maybe 15...
	PLIST thread_events;
	CRITICALSECTION csGrab;
#if !HAS_TLS
#  if defined( WIN32 )
	DWORD my_thread_info_tls;
#  elif defined( __LINUX__ )
	pthread_key_t my_thread_info_tls;
#  endif
#endif
}
#ifdef __STATIC_GLOBALS__
  global_timer_structure__
#endif
;
struct timer_local_data *global_timer_structure
#ifdef __STATIC_GLOBALS__
    = &global_timer_structure__;
#endif
// = { 1000 };
;
#if HAS_TLS
struct my_thread_info {
	PTHREAD pThread;
	THREAD_ID nThread;
};
DeclareThreadLocal  struct my_thread_info _MyThreadInfo;
#  define MyThreadInfo (_MyThreadInfo)
#else
#  define MyThreadInfo (*_MyThreadInfo)
#endif
#ifdef _WIN32
#else
//https://godbolt.org/z/Kx8cP68E8
//#include <sys/ipc.h>
	 // hmm wonder why this has to be defined....
	 // semtimedop is a wonderful wonderful thing...
	 // but yet /usr/include/sys/sem.h only defines it if
// __USE_GNU is defined....
#ifndef __USE_GNU
#define __USE_GNU
#endif
#ifdef __ANDROID__
#include <linux/sem.h>
#else
#include <sys/sem.h>
#endif
#endif
void  RemoveTimerEx( uint32_t ID DBG_PASS );
#if !HAS_TLS
static struct my_thread_info* GetThreadTLS( void )
{
	struct my_thread_info* _MyThreadInfo;
#  ifndef __STATIC_GLOBALS__
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
#  endif
#  if defined( WIN32 )
	if( !( _MyThreadInfo = (struct my_thread_info*)TlsGetValue( global_timer_structure->my_thread_info_tls ) ) )
	{
		int old = ClearAllocateLogging( FALSE );
		TlsSetValue( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		ResetAllocateLogging( old );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#  elif defined( __LINUX__ )
	if( !( _MyThreadInfo = (struct my_thread_info*)pthread_getspecific( global_timer_structure->my_thread_info_tls ) ) )
	{
		pthread_setspecific( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#  endif
	return &MyThreadInfo;
}
#endif
// this priorirty is also relative to a secondary init for procreg/names.c
// if you change this, need to change when that is scheduled also
PRIORITY_PRELOAD( LowLevelInit, TIMER_MODULE_PRELOAD_PRIORITY )
{
	// there is a small chance the local is already initialized.
#  ifndef __STATIC_GLOBALS__
	if( !global_timer_structure ) {
 // init thread local variable with thread id and self thread.
		MyThreadInfo.pThread = MakeThread();
		MyThreadInfo.nThread = MyThreadInfo.pThread->thread_ident;
		SimpleRegisterAndCreateGlobal( global_timer_structure );
		OnThreadCreate( (void(*)(void))MakeThread );
 // init thread local variable with thread id and self thread.
		MakeThread();
	}
#  endif
	if( !globalTimerData.timerID )
	{
 // init thread local variable with thread id and self thread.
		MakeThread();
#if !HAS_TLS
#if defined( WIN32 )
		globalTimerData.my_thread_info_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &globalTimerData.my_thread_info_tls, NULL );
#endif
#endif
		InitializeCriticalSec( &globalTimerData.csGrab );
		// this may have initialized early?
		globalTimerData.timerID = 1000;
		//lprintf( "thread global will be %p %p", global_timer_structure, &global_timer_structure );
	}
}
PRELOAD( ConfigureTimers )
{
#ifndef __NO_OPTIONS__
#  ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = SACK_GetProfileInt( GetProgramName(), "SACK/Memory Library/Log critical sections", 0 );
#  endif
	globalTimerData.flags.bLogThreadCreate = SACK_GetProfileInt( GetProgramName(), "SACK/Timers/Log Thread Create", 0 );
	globalTimerData.flags.bLogSleeps = SACK_GetProfileInt( GetProgramName(), "SACK/Timers/Log Sleeps", 0 );
	globalTimerData.flags.bLogTimerDispatch = SACK_GetProfileInt( GetProgramName(), "SACK/Timers/Log Timer Dispatch", 0 );
#endif
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
#ifdef __LINUX__
uint32_t  GetTickCount( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
#ifndef timeGetTime
uint32_t  timeGetTime( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
#endif
void  Sleep( uint32_t ms )
{
	(usleep((ms)*1000));
}
#endif
uintptr_t closesem( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
#ifdef USE_PIPE_SEMS
	//lprintf( "CLOSE PIPES %s %" _64fx " %d %d", thread->thread_event_name, thread->thread_ident, thread->pipe_ends[0], thread->pipe_ends[1] );
	close( thread->pipe_ends[0] );
	close( thread->pipe_ends[1] );
	thread->pipe_ends[0] = -1;
	thread->pipe_ends[1] = -1;
	//thread->semaphore = -1;
#else
	pthread_mutex_destroy( &thread->mutex );
#endif
	return 0;
}
static uintptr_t threadrunning( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( thread->hThread && thread->flags.bStarted )
		return 1;
	return 0;
}
// sharemem exit priority +1 (exit after everything else, except emmory; globals at memory+1)
PRIORITY_ATEXIT( CloseAllWakeups, ATEXIT_PRIORITY_THREAD_SEMS )
{
	uint32_t start = GetTickCount() + 50;
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	while( ( start > GetTickCount() ) && ForAllInSet( THREAD, globalTimerData.threadset, threadrunning, 0 ) )
		Relinquish();
	//lprintf( "Destroy thread semaphores..." );
	ForAllInSet( THREAD, globalTimerData.threadset, closesem, (uintptr_t)0 );
	DeleteSet( (GENERICSET**)&globalTimerData.threadset );
	globalTimerData.pTimerThread = NULL;
	//globalTimerData.threads = NULL;
	globalTimerData.timers = NULL;
}
#endif
// sharemem exit priority +1 (exit after everything else, except emmory)
PRIORITY_ATEXIT( StopTimers, ATEXIT_PRIORITY_TIMERS )
{
	int tries = 0;
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	if( global_timer_structure ) {
		globalTimerData.flags.bExited = 1;
		if( globalTimerData.pTimerThread )
			WakeThread( globalTimerData.pTimerThread );
		while( globalTimerData.pTimerThread )
		{
			tries++;
			if( tries > 10 )
				return;
			WakeThread( globalTimerData.pTimerThread );
			Relinquish();
		}
	}
}
//--------------------------------------------------------------------------
static void InitWakeup( PTHREAD thread, CTEXTSTR event_name )
{
#ifdef _DEBUG
	int prior;
	prior = ClearAllocateLogging( FALSE );
#endif
	if( !event_name )
		thread->thread_event_name = event_name = default_thread_name;
	else
		thread->thread_event_name = (TEXTSTR)StrDup( event_name );
#ifdef _WIN32
	if( !thread->thread_event )
	{
		PTHREAD_EVENT thread_event;
		TEXTCHAR name[64];
		tnprintf( name, 64, "%s:%08lX:%08lX", event_name, (uint32_t)(thread->thread_ident >> 32)
		        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF) );
		name[sizeof(name)/sizeof(name[0])-1] = 0;
#ifdef LOG_CREATE_EVENT_OBJECT
		lprintf( "Thread Event created is: %s everyone should use this...", name );
#endif
 // New( THREAD_EVENT );
		thread_event         = GetFromSet( THREAD_EVENT, &globalTimerData.thread_event_pool );
		thread_event->name   = StrDup( name );
		thread_event->hEvent = CreateEvent( NULL, TRUE, FALSE, name );
		AddLink( &globalTimerData.thread_events, thread_event );
		thread->thread_event = thread_event;
	}
#else
#ifdef USE_PIPE_SEMS
	// store status of pipe() in semaphore... it's not really a semaphore..
#  ifdef DEBUG_PIPE_USAGE
	lprintf( "Init wakeup %p %s", thread, event_name );
	lprintf( "OPENING A PIPE END SEMAPHORE:%d", thread->semaphore );
#  endif
	if( pipe( thread->pipe_ends ) == -1 )
	{
		lprintf( "Failed to get pipe! %d:%s", errno, strerror( errno ) );
	}
	else
	{
		char buf;
		int success = 0;
		do
		{
			int stat;
			int n;
			fd_set set;
			struct timeval timeout;
			FD_ZERO(&set);
			FD_SET( thread->pipe_ends[0], &set);
			timeout.tv_sec = 0;
			timeout.tv_usec = 100;
#  ifdef DEBUG_PIPE_USAGE
			lprintf(" Begin select-flush on thread %p", thread );
#  endif
			stat = select(thread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
			if(stat == -1)
			{
				lprintf( "select error %d %d", errno, thread->pipe_ends[0]);
			}
			else if(stat == 0)
			{
				success = 1;
#  ifdef DEBUG_PIPE_USAGE
				lprintf("timeout");
#  endif
			}
			else
			{
#  ifdef DEBUG_PIPE_USAGE
				lprintf(" immediate return?" );
#  endif
				stat = read( thread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
				lprintf( "Stat is now %d", stat );
#  endif
			}
		}
		while( !success );
	}
#else
	pthread_mutex_init( &thread->mutex, NULL );
	pthread_mutex_lock( &thread->mutex );
	//thread->semaphore = -1;
#endif
#endif
#ifdef _DEBUG
	ResetAllocateLogging( prior );
#endif
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread_name( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( StrCaseCmp( thread->thread_event_name, (CTEXTSTR)psv ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindWakeup( CTEXTSTR name )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		uint64_t oldval;
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) {
			//globalTimerData.lock_thread_create = oldval;
			Relinquish();
		}
	}
	else
	{
#ifndef __STATIC_GLOBALS__
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
#endif
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name, (uintptr_t)name );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = GetThisThreadID();
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
struct name_and_id_params
{
	CTEXTSTR name;
	THREAD_ID thread;
};
uintptr_t CPROC check_thread_name_and_id( POINTER p, uintptr_t psv )
{
	struct name_and_id_params *params = (struct name_and_id_params*)psv;
	PTHREAD thread = (PTHREAD)p;
	if( thread->thread_ident == params->thread
		&& StrCaseCmp( thread->thread_event_name, params->name ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThreadWakeup( CTEXTSTR name, THREAD_ID thread )
{
	PTHREAD check;
	struct name_and_id_params params;
	params.name = name;
	params.thread = thread;
	if( global_timer_structure )
	{
		uint64_t oldval;
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) {
			//globalTimerData.lock_thread_create = oldval;
			Relinquish();
		}
	}
	else
	{
#ifndef __STATIC_GLOBALS__
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
#endif
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name_and_id, (uintptr_t)&params );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	THREAD_ID ID = *((THREAD_ID*)psv);
	//lprintf( "Check thread %016llx %016llx %s", thread->thread_ident, ID, thread->thread_event_name );
	if( ( thread->thread_ident == ID )
		&& ( StrCmp( thread->thread_event_name, default_thread_name ) == 0 ) )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThread( THREAD_ID thread )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		uint64_t oldval;
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) {
			//globalTimerData.lock_thread_create = oldval;
			Relinquish();
		}
	}
	else
	{
#ifndef __STATIC_GLOBALS__
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
#endif
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread, (uintptr_t)&thread );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, NULL );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
void  WakeThreadEx( PTHREAD thread DBG_PASS )
{
 // can't wake nothing
	if( !thread )
	{
		//_lprintf(DBG_RELAY)( "Failed to find thread to wake..." );
		return;
	}
#ifdef _WIN32
	//	lprintf( "setting event." );
	{
		PTHREAD_EVENT thread_event;
		INDEX idx;
		TEXTCHAR name[64];
		if( !(thread_event = thread->thread_event ) )
		{
			tnprintf( name, sizeof(name), "%s:%08lX:%08lX"
			        , thread->thread_event_name, (uint32_t)(thread->thread_ident >> 32)
			        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF));
			name[sizeof(name)/sizeof(name[0])-1] = 0;
			LIST_FORALL( globalTimerData.thread_events, idx, PTHREAD_EVENT, thread_event )
			{
				if( StrCmp( thread_event->name, name ) == 0 )
					break;
			}
#ifdef LOG_CREATE_EVENT_OBJECT
			lprintf( "Event opened is: %s", name );
#endif
		}
#ifdef LOG_CREATE_EVENT_OBJECT
		else
		{
			lprintf( "Event opened is thread." );
		}
#endif
		if( !thread_event )
		{
 // New( THREAD_EVENT );
			thread_event         = GetFromSet( THREAD_EVENT, &globalTimerData.thread_event_pool );
			thread_event->name   = StrDup( name );
 /*EVENT_MODIFY_STATE */
			thread_event->hEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, name );
			AddLink( &globalTimerData.thread_events, thread_event );
			thread->thread_event = thread_event;
		}
		if( thread_event->hEvent )
		{
			//lprintf( "event opened successfully... %d", WaitForSingleObject( hEvent, 0 ) );
#ifndef NO_LOGGING
			if( globalTimerData.flags.bLogSleeps )
				_xlprintf(1 DBG_RELAY )( "About to wake on %d Thread event created...%016llx"
				                       , thread->thread_event->hEvent
				                       , thread->thread_ident );
#endif
			if( !SetEvent( thread_event->hEvent ) )
				lprintf( "Set event FAILED..%d", GetLastError() );
 // may or may not execute other thread before this...
			Relinquish();
		}
		else
		{
			lprintf( "Failed to open that event! %d", GetLastError() );
			// thread to wake is not ready to be
			// woken, does not exist, or some other
			// BAD problem.
		}
	}
#else
#  ifdef USE_PIPE_SEMS
	if( thread->semaphore != -1 )
	{
#    ifdef DEBUG_PIPE_USAGE
		_lprintf(DBG_RELAY)( "(wakethread)wil write pipe... %p", thread );
#    endif
		if( write( thread->pipe_ends[1], "G", 1 ) != 1 ) {
			int e = errno;
			lprintf( "Pipe Error? %d", e );
		}
		//lprintf( "did write pipe..." );
		Relinquish();
	}
#  else
	  pthread_mutex_unlock( &thread->mutex );
#  endif
#endif
}
void  WakeNamedThreadSleeperEx( CTEXTSTR name, THREAD_ID thread DBG_PASS )
{
	PTHREAD sleeper = FindThreadWakeup( name, thread );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
void  WakeNamedSleeperEx( CTEXTSTR name DBG_PASS )
{
	PTHREAD sleeper = FindWakeup( name );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
//--------------------------------------------------------------------------
void  WakeThreadIDEx( THREAD_ID thread DBG_PASS )
{
	PTHREAD pThread = FindThread( thread );
	WakeThreadEx( pThread DBG_RELAY );
}
//--------------------------------------------------------------------------
#undef WakeThreadID
void  WakeThreadID( THREAD_ID thread )
{
	WakeThreadIDEx( thread DBG_SRC );
}
//--------------------------------------------------------------------------
#ifdef _NO_SEMTIMEDOP_
#ifndef _WIN32
static void CPROC TimerWake( uintptr_t psv )
{
	WakeThreadEx( (PTHREAD)psv DBG_SRC );
}
#endif
#endif
//--------------------------------------------------------------------------
static void  InternalWakeableNamedSleepEx( CTEXTSTR name, uint32_t n, LOGICAL threaded DBG_PASS )
{
	PTHREAD pThread;
	if( name && threaded )
		pThread = FindThreadWakeup( name, GetThisThreadID() );
	else if( name )
		pThread = FindWakeup( name );
	else
	{
#if !HAS_TLS
		struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
		pThread = MyThreadInfo.pThread;
		if( !pThread )
		{
			MakeThread();
			pThread = MyThreadInfo.pThread;
		}
	}
	if( pThread )
	{
#ifdef _WIN32
#  ifndef NO_LOGGING
		if( globalTimerData.flags.bLogSleeps )
			_xlprintf(1 DBG_RELAY )( "About to sleep on %d Thread event created...%s:%016llx"
			                         , pThread->thread_event->hEvent
			                         , pThread->thread_event_name
			                         , pThread->thread_ident );
#  endif
		if( WaitForSingleObject( pThread->thread_event->hEvent
		                       , n==SLEEP_FOREVER?INFINITE:(n) ) != WAIT_TIMEOUT )
		{
#  ifdef LOG_LATENCY
			_lprintf(DBG_RELAY)( "Woke up- reset event" );
#  endif
			ResetEvent( pThread->thread_event->hEvent );
			//if( n == SLEEP_FOREVER )
			//   DebugBreak();
		}
#  ifdef LOG_LATENCY
		else
			_lprintf(DBG_RELAY)( "Timed out from %d", n );
#  endif
#else
		{
#  ifndef USE_PIPE_SEMS
#    ifdef _NO_SEMTIMEDOP_
			int nTimer = 0;
			if( n != SLEEP_FOREVER )
			{
				//lprintf( "Wakeable sleep in %ld (oneshot, no frequency)", n );
				nTimer = AddTimerExx( n, 0, TimerWake, (uintptr_t)pThread DBG_RELAY );
			}
#    endif
			if( !pThread->thread_event_name )
			{
				//lprintf( "Invalid semaphore...fixing?" );
				InitWakeup( pThread, name );
			}
#  endif
			//if( pThread->semaphore != -1 )
			{
				while(1)
				{
					int stat;
					//lprintf( "Lock on semop on semdo... %08x %016" _64fx "x", pThread->semaphore, pThread->thread_ident );
					//lprintf( "Before semval = %d %08lx", semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					if( n != SLEEP_FOREVER )
					{
#ifdef USE_PIPE_SEMS
						char buf;
						{
							fd_set set;
							struct timeval timeout;
							FD_ZERO(&set);
							FD_SET( pThread->pipe_ends[0], &set);
							timeout.tv_sec = n / 1000;
							timeout.tv_usec = ( n % 1000 ) * 1000;
#  ifdef DEBUG_PIPE_USAGE
							lprintf(" Begin select-read on thread %p %d ", pThread, n );
							//_lprintf(DBG_RELAY)( "Select  %p %d  %d  %d", pThread, pThread->pipe_ends[0], pThread->pipe_ends[1],n );
#  endif
							stat = select(pThread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
							if(stat == -1)
							{
								lprintf("select error %d %d", errno, pThread->pipe_ends[0]);
							}
							else if(stat == 0)
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf("timeout");
#  endif
							}
							else
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf(" immediate return?" );
#  endif
								stat = read( pThread->pipe_ends[0], &buf, 1 );
								// 1 = success
								// -1 will be an error (errno handled later)
								// 0 would be end of file...
#  ifdef DEBUG_PIPE_USAGE
								lprintf( "Stat is now %d", stat );
#endif
							}
						}
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
						struct timespec timeout;
						clock_gettime(CLOCK_REALTIME, &timeout);
						timeout.tv_nsec += ( n % 1000 ) * 1000000L;
						timeout.tv_sec += n / 1000;
						timeout.tv_sec += timeout.tv_nsec / 1000000000L;
						timeout.tv_nsec %= 1000000000L;
						//lprintf( "Timed wait:%d %d", timeout.tv_nsec, timeout.tv_sec );
						stat = pthread_mutex_timedlock( &pThread->mutex, &timeout );
						//lprintf( "Stat for timed lock:%d", stat );
						//stat = semtimedop( pThread->semaphore, semdo, 1, &timeout );
#endif
					}
					else
					{
#ifdef USE_PIPE_SEMS
						char buf;
#  ifdef DEBUG_PIPE_USAGE
						_lprintf(DBG_RELAY)(" Begin read on thread %p", pThread );
#  endif
						stat = read( pThread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
						stat = pthread_mutex_lock( &pThread->mutex );
						//stat = semop( pThread->semaphore, semdo, 1 );
#endif
					}
					//lprintf( "After semval = %d %08lx", semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					//lprintf( "Lock passed." );
					if( stat < 0 )
					{
						if( errno == EINTR )
						{
							//lprintf( "EINTR" );
							break;
							//continue;
						}
						if( errno == EAGAIN )
						{
							//lprintf( "EAGAIN?" );
							// timeout elapsed on semtimedop - or IPC_NOWAIT was specified
							// but since it's not, it must be the timeout condition.
							break;
						}
						if( errno == EIDRM )
						{
							lprintf( "pthread_mutex has been removed on us!?" );
							//pThread->semaphore = -1;
							break;
						}
						if( errno == EINVAL )
						{
							lprintf( "pthread_mutex is no longer valid on this thread object..." );
							// this probably means that it has gone away..
							//pThread->semaphore = -1;
							break;
						}
						lprintf( "stat from sempop on thread semaphore %p = %d (%d)"
						       , pThread
						       , stat
						       , stat<0?errno:0 );
						break;
					}
					else
					{
						// reset semaphore to nothing.... might
						// have been woken up MANY times.
							//lprintf( "Resetting our lock count from %d to 0...."
						//		 , semctl( pThread->semaphore, 0, GETVAL ));
#ifdef USE_PIPE_SEMS
						// flush? empty the pipe?
#else
						//semctl( pThread->semaphore, 0, SETVAL, 0 );
#endif
						break;
					}
				}
			}
			//else
			//{
			//	lprintf( "Still an invalid semaphore? Dang." );
			//	fprintf( stderr, "Out of semaphores." );
			//	BAG_Exit(0);
			//}
		}
#endif
		//pThread->flags.bSleeping = 0;
	}
	else
	{
		lprintf( "You, as a thread, do not exist, sorry." );
	}
}
#ifdef USE_PIPE_SEMS
int GetThreadSleeper( PTHREAD thread )
{
	return thread->pipe_ends[0];
}
#endif
void  WakeableNamedThreadSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, TRUE DBG_RELAY );
}
void  WakeableNamedSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, FALSE DBG_RELAY );
}
void  WakeableSleepEx( uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_RELAY );
}
#undef WakeableSleep
void  WakeableSleep( uint32_t n )
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC)
{
	WakeableSleepEx(n DBG_SRC);
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
static void TimerWakeableSleep( uint32_t n )
{
	if( globalTimerData.pTimerThread )
	{
#ifdef USE_PIPE_SEMS
		InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_SRC );
#else
		PTHREAD me = MakeThread();
		if( n != SLEEP_FOREVER )
		{
			struct timespec timeout;
			int stat;
			clock_gettime(CLOCK_REALTIME, &timeout);
			timeout.tv_nsec += ( n % 1000 ) * 1000000L;
			timeout.tv_sec += n / 1000;
			  timeout.tv_sec += timeout.tv_nsec / 1000000000L;
			  timeout.tv_nsec %= 1000000000L;
			pthread_mutex_timedlock( &globalTimerData.pTimerThread->mutex, &timeout );
		}
 // wait forever for the lock.
      else
 // otherwise was a normal timeout, not a wakeup, timeout does not unlock.
			pthread_mutex_lock( &globalTimerData.pTimerThread->mutex );
#endif
	}
}
#endif
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread );
// results if the timer
int  IsThisThreadEx( PTHREAD pThreadTest DBG_PASS )
{
	PTHREAD pThread;
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
//   lprintf( "Found thread; %p is it %p?", pThread, pThreadTest );
	if( pThread == pThreadTest )
		return TRUE;
	//lprintf( "Found thread; %p is not  %p?", pThread, pThreadTest );
	return FALSE;
}
static int NotTimerThread( void )
{
	PTHREAD pThread;
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	pThread = MyThreadInfo.pThread;
	if( pThread && ( pThread->proc == ThreadProc ) )
		return FALSE;
	return TRUE;
}
//--------------------------------------------------------------------------
static void  UnmakeThread( void )
{
	PTHREAD pThread;
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	uint64_t oldval;
 //-V595
	while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, MyThreadInfo.nThread ) ) {
		//globalTimerData.lock_thread_create = oldval;
		Relinquish();
	}
	if( globalTimerData.flags.bExited ) {
		globalTimerData.lock_thread_create = 0;
		return;
	}
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
	if( pThread )
	{
		// unlink from globalTimerData.threads list.
		//if( ( (*pThread->me)=pThread->next ) )
		//	pThread->next->me = pThread->me;
		{
			int tmp = ClearAllocateLogging( FALSE );
#ifdef _WIN32
			//lprintf( "Unmaking thread event! on thread %016" _64fx"x", pThread->thread_ident );
			CloseHandle( pThread->thread_event->hEvent );
			CloseHandle( pThread->hThread );
			{
#  if !HAS_TLS
				struct my_thread_info* _MyThreadInfo = GetThreadTLS();
 //-V595
				TlsSetValue( global_timer_structure->my_thread_info_tls, NULL );
				Deallocate( struct my_thread_info*, _MyThreadInfo );
#  else
				//Deallocate( struct my_thread_info*, _MyThreadInfo );
#  endif
			}
#else
			closesem( (POINTER)pThread, 0 );
#endif
			if( pThread->thread_event_name != default_thread_name )
				Deallocate( CTEXTSTR, pThread->thread_event_name );
#ifdef _WIN32
			Deallocate( TEXTSTR, pThread->thread_event->name );
			if( global_timer_structure )
				DeleteLink( &globalTimerData.thread_events, pThread->thread_event );
			DeleteFromSet( THREAD_EVENT, globalTimerData.thread_event_pool, pThread->thread_event );
#endif
			if( global_timer_structure )
 /*Release( pThread )*/
				DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
			ResetAllocateLogging( tmp );
		}
	}
	globalTimerData.lock_thread_create = 0;
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *ThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC ThreadWrapper( PTHREAD pThread )
#endif
{
	uintptr_t result = 0;
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
#ifdef _WIN32
	while( !pThread->hThread )
		Relinquish();
#endif
	pThread->flags.bStarted = 1;
	//DeAttachThreadToLibraries( TRUE );
	while( !pThread->flags.bReady )
		Relinquish();
#ifdef HAS_TLS
#  ifdef LOG_THREAD
	lprintf( "thread will be %p %p", MyThreadInfo.pThread, &MyThreadInfo );
	lprintf( "thread will be %p %p", pThread, &MyThreadInfo.pThread );
#  endif
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread =
#endif
		pThread->thread_ident = _GetMyThreadID();
	//DebugBreak();
	InitWakeup( pThread, NULL );
	{
		INDEX idx;
		void ( *f )( void );
		LIST_FORALL( globalTimerData.onThreadCreate, idx,  void( * )( void ), f ){
			f();
		}
	}
#ifdef LOG_THREAD
	Log1( "Set thread ident: %016" _64fx, pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->proc( pThread );
	if( globalTimerData.flags.bExited )
		return result;
	//lprintf( "%s(%d):Thread is exiting... ", pThread->pFile, pThread->nLine );
	//DeAttachThreadToLibraries( FALSE );
	UnmakeThread();
#ifdef __LINUX__
	pThread->hThread = 0;
#else
	pThread->hThread = NULL;
#endif
	{
		INDEX idx;
		void ( *f )( void );
		LIST_FORALL( globalTimerData.onThreadExit, idx, void( * )( void ), f ) {
			f();
		}
	}
	//lprintf( "%s(%d):Thread is exiting... ", pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *SimpleThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC SimpleThreadWrapper( PTHREAD pThread )
#endif
{
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	uintptr_t result = 0;
#ifdef _WIN32
	while( !pThread->hThread )
	{
		Log( "wait for main thread to process..." );
		Relinquish();
	}
#endif
	pThread->flags.bStarted = 1;
	while( !pThread->flags.bReady )
		Relinquish();
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread = pThread->thread_ident = GetMyThreadID();
	InitWakeup( pThread, NULL );
#ifdef LOG_THREAD
	Log1( "Set thread ident: %016" _64fx, pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->simple_proc( (POINTER)GetThreadParam( pThread ) );
	//lprintf( "%s(%d):Thread is exiting... ", pThread->pFile, pThread->nLine );
	UnmakeThread();
	//lprintf( "%s(%d):Thread is exiting... ", pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
PTHREAD  MakeThread( void )
{
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	if( MyThreadInfo.pThread )
		return MyThreadInfo.pThread;
	MyThreadInfo.nThread = _GetMyThreadID();
	{
		PTHREAD pThread;
		THREAD_ID thread_ident = _GetMyThreadID();
		// this must be a search(?)
		if( !(pThread = FindThread( thread_ident ) ) )
		{
			THREAD_ID oldval;
			//LOGICAL dontUnlock = FALSE;
 /*&& ( oldval != thread_ident )*/
			while( ( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) )
			{
				//globalTimerData.lock_thread_create = oldval;
				Relinquish();
			}
			//dontUnlock = TRUE;
 /*Allocate( sizeof( THREAD ) )*/
			pThread = GetFromSet( THREAD, &globalTimerData.threadset );;
			//lprintf( "Get Thread %p", pThread );
			MemSet( pThread, 0, sizeof( THREAD ) );
			pThread->flags.bLocal = TRUE;
			pThread->proc = NULL;
			pThread->param = 0;
			pThread->thread_ident = thread_ident;
			pThread->flags.bReady = 1;
			//if( ( pThread->next = globalTimerData.threads ) )
			//	globalTimerData.threads->me = &pThread->next;
			//pThread->me = &globalTimerData.threads;
			//globalTimerData.threads = pThread;
			InitWakeup( pThread, NULL );
			// something else is in the process of trying to lock this...
			//while( thread_ident != globalTimerData.lock_thread_create )
			//	Relinquish();
			globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
			Log3( "Created thread address: %p %" PRIxFAST64 " at %p"
			    , pThread->proc, pThread->thread_ident, pThread );
#endif
		}
		MyThreadInfo.pThread = pThread;
		return pThread;
	}
}
THREAD_ID GetThreadID( PTHREAD thread )
{
	if( thread )
		return thread->thread_ident;
	return 0;
}
THREAD_ID GetThisThreadID( void )
{
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#else
	if( !MyThreadInfo.nThread )
		MakeThread();
	return MyThreadInfo.nThread;
#endif
}
uintptr_t GetThreadParam( PTHREAD thread )
{
	if( thread )
		return thread->param;
	return 0;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToEx( uintptr_t (CPROC*proc)(PTHREAD), uintptr_t param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	uint64_t oldval;
	while( ( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) ) {
		//globalTimerData.lock_thread_create = oldval;
		Relinquish();
	}
	do
	{
		pThread = GetFromSet( THREAD, &globalTimerData.threadset );
		if( !pThread )
			xlprintf(LOG_ALWAYS)( "Thread to pThread allocation failed!" );
	} while( !pThread );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
	if( globalTimerData.flags.bLogThreadCreate )
		_lprintf(DBG_RELAY)( "Create New thread %p", pThread );
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->proc = proc;
	pThread->param = param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( "Begin Create Thread" );
#endif
#ifdef _WIN32
#  if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))ThreadWrapper, 8192, pThread );
#  else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(ThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#  endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread..." );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))ThreadWrapper, pThread );
#endif
	if( success )
	{
#ifndef _WIN32
		pthread_detach( pThread->hThread );
		// I don't get the return code from threads...
		// thread wrapper self destructs its handles...
		// should add an event callback on thread end.
#endif
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
#ifdef _WIN32
		{
			uint32_t now = GetTickCount();
			while( !pThread->thread_event && ( now + 250 ) > GetTickCount()  ) {
				Relinquish();
			}
		}
#endif
#ifdef LOG_THREAD
		Log3( "Created thread address: %p %016" _64fx" at %p"
		    , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		uint64_t oldval;
		// unlink from globalTimerData.threads list.
		while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) {
			//globalTimerData.lock_thread_create = oldval;
			Relinquish();
		}
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToSimpleEx( uintptr_t (CPROC*proc)(POINTER), POINTER param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	uint64_t oldval;
	while( ( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) ) {
		//globalTimerData.lock_thread_create = oldval;
		Relinquish();
	}
	pThread = GetFromSet( THREAD, &globalTimerData.threadset );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
#ifdef LOG_THREAD
	Log( "Creating a new thread... " );
	lprintf( "New thread %p", pThread );
#endif
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->simple_proc = proc;
	pThread->param = (uintptr_t)param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( "Begin Create Thread" );
#endif
#ifdef _WIN32
#if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))SimpleThreadWrapper, 8192, pThread );
#else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(SimpleThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread" );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))SimpleThreadWrapper, pThread );
#endif
	if( success )
	{
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
		while( !pThread->thread_ident )
			Relinquish();
#ifdef LOG_THREAD
		lprintf( "Created thread address: %p %016" _64fx" at %p"
		       , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		uint64_t oldval;
		// unlink from globalTimerData.threads list.
		while( oldval = LockedExchange64( &globalTimerData.lock_thread_create, 1 ) ) {
			//globalTimerData.lock_thread_create = oldval;
			Relinquish();
		}
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
void  EndThread( PTHREAD thread )
{
	if( thread )
	{
#ifdef __LINUX__
#  ifndef __ANDROID__
		pthread_cancel( thread->hThread );
#  endif
#else
		TerminateThread( thread->hThread, 0xD1E );
#ifdef LOG_THREAD
		lprintf( "Killing thread..." );
#endif
		CloseHandle( thread->thread_event->hEvent );
#endif
	}
}
#if _WIN32
HANDLE GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return INVALID_HANDLE_VALUE;
}
#endif
#ifdef __LINUX__
pthread_t GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return (pthread_t)NULL;
}
#endif
//--------------------------------------------------------------------------
static void DoInsertTimer( PTIMER timer )
{
	PTIMER check;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	EnterCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
//GetTickCount();
	uint64_t newtick = timeGetTime64();
//	lprintf("Add to timer %d delta %d %lld", timer->ID, timer->delta, newtick - globalTimerData.last_tick);
	timer->delta += newtick - globalTimerData.last_tick;
	if( !(check = globalTimerData.timers) )
	{
#ifdef LOG_INSERTS
		Log( "First(only known) timer!" );
#endif
		// subtract already existing time... (ONLY if first timer)
		//timer->delta -= ( globalTimerData.this_tick - globalTimerData.last_tick );
		(*(timer->me = &globalTimerData.timers))=timer;
#ifdef LOG_INSERTS
		Log( "Done with addition" );
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		return;
	}
	while( check )
	{
		// was previously <= which would schedule equal timers at the
		// head of the queue constantly.
#ifdef LOG_INSERTS
		lprintf( "Timer to store %d freq: %d delta: %d check delta: %d", timer->ID, timer->frequency, timer->delta, check->delta );
#endif
		if( timer->delta < check->delta )
		{
			check->delta -= timer->delta;
#ifdef LOG_INSERTS
			Log3( "Storing before timer: %d delta %d next %d", check->ID, timer->delta, check->delta );
#endif
			timer->next = check;
			(*(timer->me = check->me))=timer;
			check->me = &timer->next;
			if( timer->next == timer || check->next == check ) DebugBreak();
			break;
		}
		else
		{
			timer->delta -= check->delta;
		}
		if( !check->next )
		{
#ifdef LOG_INSERTS
			Log1( "Storing after last timer. Delta %d", timer->delta );
#endif
			(*(timer->me = &check->next))=timer;
			break;
		}
		check = check->next;
	}
#ifdef LOG_INSERTS
	Log( "Done with addition" );
#endif
	if( !check )
		Log( "Fatal! Didn't add the timer!" );
#ifdef ENABLE_CRITICALSEC_LOGGING
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
}
//--------------------------------------------------------------------------
static uintptr_t CPROC find_timer( POINTER p, uintptr_t psvID )
{
	uint32_t timerID = (uint32_t)psvID;
	PTIMER timer = (PTIMER)p;
	//lprintf( "Find to remove test %d==%d", timer->ID, timerID );
	if( timer->ID == timerID )
		return (uintptr_t)p;
	return 0;
}
static void  DoRemoveTimer( uint32_t timerID DBG_PASS )
{
	EnterCriticalSec( &globalTimerData.csGrab );
	{
		PTIMER timer = globalTimerData.timers;
		uintptr_t psvTimerResult = ForAllInSet( TIMER, &globalTimerData.timer_pool, find_timer, (uintptr_t)timerID );
		if( psvTimerResult )
			timer = (PTIMER)psvTimerResult;
		else
		{
			while( timer )
			{
				if( timer->ID == timerID )
					break;
				timer = timer->next;
			}
		}
		if( timer )
		{
			PTIMER tmp;
			if( ( tmp = ( (*timer->me) = timer->next ) ) )
			{
				// if I had a next - his refernece of thing that points at him is mine.
				tmp->delta += timer->delta;
				tmp->me = timer->me;
			}
			DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
		}
		else
			_lprintf(DBG_RELAY)( "Failed to find timer to grab" );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
static void InsertTimer( PTIMER timer DBG_PASS )
{
	if( NotTimerThread() )
	{
		if( globalTimerData.flags.away_in_timer )
 // if it's away - should be safe to add a new timer
		{
			globalTimerData.flags.insert_while_away = 1;
			// set that we're adding a timer while away
			if( globalTimerData.flags.away_in_timer )
			{
				// if the thread is still away - we can add the timer...
#ifdef LOG_SLEEPS
				lprintf( "Timer is away, just add this new timer back in.." );
#endif
				DoInsertTimer( timer );
				globalTimerData.flags.insert_while_away = 0;
				return;
			}
			// otherwise he came back before we set our addin
			// therefore it should be safe to schedule.
			globalTimerData.flags.insert_while_away = 0;
		}
#ifdef LOG_INSERTS
		Log( "Inserting timer...to wait for change allow" );
#endif
		// lockout multiple additions...
		EnterCriticalSec( &globalTimerData.cs_timer_change );
#ifdef LOG_INSERTS
		Log( "Inserting timer...to wait for free add" );
#endif
		// don't add a timer while there's one being added...
		while( globalTimerData.add_timer )
		{
			WakeThread(globalTimerData.pTimerThread);
			//Relinquish();
		}
#ifdef LOG_INSERTS
		Log( "Inserting timer...setup dataa" );
#endif
		globalTimerData.add_timer = timer;
		LeaveCriticalSec( &globalTimerData.cs_timer_change );
		// it might be sleeping....
#ifdef LOG_INSERTS
		Log( "Inserting timer...wake and done" );
#endif
#ifdef LOG_SLEEPS
		lprintf( "Wake timer thread." );
#endif
		// wake this thread because it's current scheduled delta (ex 1000ms)
		// may put it's sleep beyond the frequency of this timer (ex 10ms)
		WakeThreadEx(globalTimerData.pTimerThread DBG_RELAY);
	}
	else
	{
		EnterCriticalSec( &globalTimerData.csGrab );
		// have to assume that we're away in callback
		// in order to get here... there's no other way
		// for this routine to be called and BE the timer thread.
		// therefore - safe to add it.
		DoInsertTimer( timer );
#ifdef LOG_SLEEPS
		lprintf( "Insert timer not dispatched." );
#endif
		if( globalTimerData.timers == timer )
		{
#ifdef LOG_SLEEPS
			lprintf( "Wake timer thread." );
#endif
			WakeThread(globalTimerData.pTimerThread);
		}
		LeaveCriticalSec( &globalTimerData.csGrab );
	}
}
//--------------------------------------------------------------------------
static PTIMER GrabTimer( PTIMER timer, LOGICAL toProcess )
{
	// if a timer has been grabbed, it won't be grabbed...
	// but if a timer is being grabbed, it might get grabbed twice.
	if( timer && timer->me )
	{
		// the thing that points at me points at my next....
#ifdef LOG_INSERTS
		Log1( "Grab Timer: %d", timer->ID );
#endif
		if( ( (*timer->me) = timer->next ) )
		{
			// if I had a next - his refernece of thing that points at him is mine.
			timer->next->me = timer->me;
			if( !toProcess )
				timer->next->delta += timer->delta;
		}
		timer->next = NULL;
		timer->me = NULL;
		return timer;
	}
	return NULL;
}
//--------------------------------------------------------------------------
static int CPROC ProcessTimers( uintptr_t psvForce )
{
	if( global_timer_structure )
	{
	PTIMER timer;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
#endif
	uint32_t newtick;
	if( globalTimerData.flags.bExited )
		return -1;
	if( !psvForce && !IsThisThread( globalTimerData.pTimerThread ) )
	{
		//Log( "Unknown thread attempting to process timers..." );
		return -1;
	}
	if (globalTimerData.current_timer) {
		lprintf(" !!!!!!!!!!!!!!!!!!!! Recursing timer is a bad idea...");
		return 1;
	}
#ifndef _WIN32
	//nice( -3 ); // allow ourselves a bit more priority...
#endif
	{
		// there are timers - and there's one which wants to be added...
		// if there's no timers - just sleep here...
		while( ( !globalTimerData.add_timer && !globalTimerData.timers ) || globalTimerData.flags.bHaltTimers )
		{
			if( !psvForce )
				return 1;
#ifdef LOG_SLEEPS
			lprintf( "Timer thread sleeping forever..." );
#endif
#ifdef __LINUX__
			if( globalTimerData.pTimerThread )
				TimerWakeableSleep( SLEEP_FOREVER );
#else
			WakeableSleep( SLEEP_FOREVER );
#endif
			// had no timers - but NOW either we woke up by default...
			// OR - we go kicked awake - so mark the beginning of known time.
#ifdef LOG_LATENCY
			Log( "Re-synch first tick..." );
#endif
//GetTickCount();
			globalTimerData.last_tick = timeGetTime64();
		}
		// add and delete new/old timers here...
		// should be the next event after sleeping (low var-sleep top const-sleep)
		if( globalTimerData.add_timer )
		{
#ifdef LOG_INSERTS
			Log( "Adding timer really..." );
#endif
			DoInsertTimer( globalTimerData.add_timer );
			globalTimerData.add_timer = NULL;
		}
		if( globalTimerData.del_timer )
		{
#ifdef LOG_INSERTS
			Log( "Scheduled remove timer..." );
#endif
			DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
			globalTimerData.del_timer = 0;
		}
		// get the time now....
//GetTickCount();
		newtick = globalTimerData.this_tick = timeGetTime64();
#ifdef LOG_LATENCY
		lprintf( "total - %d Tick: %llu Last: %llu  delta: %llu", globalTimerData.timers?globalTimerData.timers->ID:-1, globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick );
#endif
		//if( globalTimerData.timers )
		//	 delay_skew = globalTimerData.this_tick-globalTimerData.last_tick - globalTimerData.timers->delta;
		// delay_skew = 0; // already chaotic...
		//if( timers )
		//	Log1( "timer delta: %ud", timers->delta );
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		while( ( EnterCriticalSec( &globalTimerData.csGrab ), timer = globalTimerData.timers ) &&
				( (int32_t)( newtick - globalTimerData.last_tick ) >= timer->delta ) )
		{
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
#ifdef LOG_LATENCY
#ifdef _DEBUG
			_xlprintf( 1, timer->pFile, timer->nLine )( "Tick: %u Last: %u  delta: %u Timerdelta: %u"
																	, globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#else
			lprintf( "Tick: %u Last: %u  delta: %u Timerdelta: %u"
			       , globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#endif
#endif
			// also enters csGrab... should be ok.
			// grabbing the timer this way does not change the next's delta
			GrabTimer( timer, TRUE );
#ifdef ENABLE_CRITICALSEC_LOGGING
			SetCriticalLogging( 0 );
			globalTimerData.flags.bLogCriticalSections = 0;
#endif
			LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
			globalTimerData.last_tick += timer->delta;
			if( timer->callback )
			{
#ifdef _WIN32
#if PARANOID
				if( IsBadCodePtr( (FARPROC)timer->callback ) )
				{
					Log1( "Timer %d proc has been unloaded! kiling timer", timer->ID );
					timer->frequency = 0;
				}
				else
#endif
#endif
				{
					//#ifdef LOG_DISPATCH
					static int level;
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level++;
#ifdef _DEBUG
						lprintf( "%d Dispatching timer %" _32fs " freq %" _32fs " %s(%d)", level, timer->ID, timer->frequency
						       , timer->pFile, timer->nLine );
#else
						lprintf( "%d Dispatching timer %" _32fs " freq %" _32fs, level, timer->ID, timer->frequency );
#endif
					}
					//#endif
					globalTimerData.current_timer = timer;
					timer->flags.bRescheduled = 0;
					globalTimerData.flags.away_in_timer = 1;
					globalTimerData.CurrentTimerID = timer->ID;
					timer->callback( timer->userdata );
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level--;
						lprintf( "timer done. (%d)", level );
					}
					globalTimerData.flags.away_in_timer = 0;
					while( globalTimerData.flags.insert_while_away )
					{
						// request for insert while away... allow it to
						// get scheduled...
						Relinquish();
					}
					globalTimerData.current_timer = NULL;
				}
				// allow timers to be added while away in this
				// timer's callback... so wait for it to finish.
				// but do - clear away status so that ANOTHER
				// timer will be held waiting...
			}
			// reset timer to frequency here
			// if a VERY long time has elapsed, next timer occurs its
			//  frequency after now.  Otherwise we may NEVER get out
			//  of processing this timer.
			// this point should be optioned whether the timer is
			// a guaranteed tick, or whether it's sloppy.
			if( !timer->flags.bRemoved && ( timer->frequency || timer->flags.bRescheduled ) )
			{
				if( timer->flags.bRescheduled )
				{
					timer->flags.bRescheduled = 0;
					// delta will have been set for next run...
					// therefore do not schedule it ourselves.
				}
				else
				{
					if( ( newtick - globalTimerData.last_tick ) > timer->frequency )
					{
#ifdef LOG_LATENCY_LIGHT
						lprintf( "Timer used more time than its frequency.  Scheduling at 1 ms." );
#endif
						timer->delta = ( newtick - globalTimerData.last_tick ) + 1;
					}
					else
					{
#ifdef LOG_LATENCY_LIGHT
						// timer alwyas goes +1 frequency from its base tick.
						lprintf( "Scheduling timer at 1 frequency." );
#endif
						timer->delta = timer->frequency;
					}
				}
				DoInsertTimer( timer );
			}
			else
			{
#ifdef LOG_INSERTS
				lprintf( "Removing one shot timer. %d", timer->ID );
#endif
				// was a one shot timer.
				DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
				timer = NULL;
			}
		}
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		if( timer )
		{
#ifdef LOG_LATENCY
			lprintf( "Pending timer in: %d Sleeping %d (%d) [%d]"
			       , timer->delta
			       , timer->delta - (newtick-globalTimerData.last_tick)
			       , timer->delta - (globalTimerData.this_tick-globalTimerData.last_tick)
			       , newtick - globalTimerData.this_tick
			       );
#endif
			globalTimerData.last_sleep = ( timer->delta - ( globalTimerData.this_tick - globalTimerData.last_tick ) );
			if( globalTimerData.last_sleep < 0 )
			{
				lprintf( "next pending sleep is %d", globalTimerData.last_sleep );
				globalTimerData.last_sleep = 1;
			}
#ifdef LOG_LATENCY
			Log1( "Sleeping %d", globalTimerData.last_sleep );
#endif
			if( !psvForce )
				return 1;
			if( globalTimerData.last_sleep )
			{
#ifdef __LINUX__
				TimerWakeableSleep( globalTimerData.last_sleep );
#else
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
				WakeableSleepEx( globalTimerData.last_sleep, timer->pFile, timer->nLine );
#else
				WakeableSleepEx( globalTimerData.last_sleep );
#endif
#endif
			}
			if( !global_timer_structure || globalTimerData.flags.bExited )
				return -1;
		}
		// else no timers - go back up to the top - where we sleep.
	}
	//Log( "Timer thread is exiting..." );
	return 1;
	}
	return -1;
}
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread )
{
	InitializeCriticalSec( &globalTimerData.cs_timer_change );
	globalTimerData.pTimerThread = pThread;
#ifndef __NO_IDLE__
	AddIdleProc( ProcessTimers, (uintptr_t)0 );
#endif
#ifndef _WIN32
 // allow ourselves a bit more priority...
	nice( -3 );
#endif
	//Log( "Permanently lock timers - indicates that thread is running..." );
	globalTimerData.lock_timers = 1;
	//Log( "Get first tick" );
//GetTickCount();
	globalTimerData.last_tick = timeGetTime64();
	while( ProcessTimers( 1 ) > 0 );
	//Log( "Timer thread is exiting..." );
	globalTimerData.pTimerThread = NULL;
	return 0;
}
//--------------------------------------------------------------------------
#if 0
// this would really be a good thing to impelment someday.
static void *WatchdogProc( void *unused )
{
	// this checks the running status of the main thread(s)
// if there is a paused thread, then a new thread is created.
// yeah see dekware( syscore/nexus.c WakeAThread() )
	return 0;
}
#endif
//--------------------------------------------------------------------------
uint32_t  AddTimerExx( uint32_t start, uint32_t frequency, TimerCallbackProc callback, uintptr_t user DBG_PASS )
{
	PTIMER timer = GetFromSet( TIMER, &globalTimerData.timer_pool );
	//timer = AllocateEx( sizeof( TIMER ) DBG_RELAY );
	MemSet( timer, 0, sizeof( TIMER ) );
	if( start && !frequency )
	{
		//"Creating one shot timer %d long", start );
	}
	//_lprintf( DBG_RELAY )( "----- First create timer %d %d %d", start, frequency, globalTimerData.timerID );
 // first time for timer to fire... may be 0
	timer->delta     = (int32_t)start;
	timer->frequency = frequency;
	timer->callback  = callback;
	uint32_t thisTimer;
	do {
		thisTimer = globalTimerData.timerID++;
		if( globalTimerData.timerID > 0x7FFFFFFF ) {
			globalTimerData.timerID = 1000;
			globalTimerData.wrappedTimerID = TRUE;
		}
		if( globalTimerData.wrappedTimerID ) {
			PTIMER chk = globalTimerData.timers;
			while( chk ) {
				if( chk->ID == thisTimer ) {
					thisTimer = 0;
					break;
				}
				chk = chk->next;
			}
		}
	} while( thisTimer == 0 );
	timer->ID        = thisTimer;
	timer->userdata  = user;
#ifdef _DEBUG
	timer->pFile = pFile;
	timer->nLine = nLine;
#endif
	if( !globalTimerData.pTimerThread )
	{
		//Log( "Starting \"a\" timer thread!!!!" );
		if( !( ThreadTo( ThreadProc, 0 ) ) )
		{
			//Log1( "Failed to start timer ThreadProc... %d", GetLastError() );
			return 0;
		}
		while( !globalTimerData.lock_timers )
			Relinquish();
		//Log1( "Thread started successfully? %d", GetLastError() );
		// make sure that the thread is running, and had setup its
		// locks, and tick reference
	}
	//_xlprintf(1 DBG_RELAY)( "Inserting newly created timer." );
	InsertTimer( timer DBG_RELAY );
	// don't need to sighup here, cause we MUST have permission
	// from the idle thread to add the timer, which means we issue it
	// a sighup to make it wake up and allow us to post.
#ifdef LOG_INSERTS
	_lprintf( DBG_RELAY )( "Resulting timer ID: %d", timer->ID );
#endif
	return timer->ID;
}
#undef AddTimerEx
uint32_t  AddTimerEx( uint32_t start, uint32_t frequency, void (CPROC*callback)(uintptr_t user), uintptr_t user )
{
	return AddTimerExx( start, frequency, callback, user DBG_SRC );
}
//--------------------------------------------------------------------------
void  RemoveTimerEx( uint32_t ID DBG_PASS )
{
	// Lockout multiple changes at a time...
 // IS timer thread..
	if( !NotTimerThread() ){
 // and not in THIS timer...
		if( ID != globalTimerData.CurrentTimerID )
		{
			// is timer thread itself... safe to remove the timer....
			DoRemoveTimer( ID DBG_SRC );
			return;
		}
 // current timer is trying to remove itself while it is running; the timer will be removed after the callback.
		else {
			globalTimerData.current_timer->flags.bRemoved = 1;
			return;
		}
	}
	EnterCriticalSec( &globalTimerData.cs_timer_change );
	// only allow one delete at a time...
	while( globalTimerData.del_timer )
	{
#ifdef LOG_INSERTS
		lprintf( "pending timer delete, wait." );
#endif
 // IS timer thread...
		if( !NotTimerThread() )
		{
#ifdef LOG_INSERTS
			lprintf( "is not the timer." );
#endif
			if( globalTimerData.del_timer != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "schedule timer is not the current timer..." );
#endif
				DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
				globalTimerData.del_timer = 0;
			}
			if( ID != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "removing timer is not the current timer" );
#endif
				DoRemoveTimer( ID DBG_SRC );
				return;
			}
		}
		else
			Relinquish();
	}
	// now how to set del_timer to a valid timer?!
#ifdef LOG_INSERTS
	_lprintf(DBG_RELAY)( "Set del_timer to schedule delete." );
#endif
	globalTimerData.del_timer = ID;
	LeaveCriticalSec( &globalTimerData.cs_timer_change );
	if( NotTimerThread() )
	{
#ifdef LOG_INSERTS
		lprintf( "wake thread, scheduled delete" );
#endif
		//Log( "waking timer thread to indicate deletion..." );
		WakeThread( globalTimerData.pTimerThread );
	}
}
#undef RemoveTimer
void  RemoveTimer( uint32_t ID )
{
	RemoveTimerEx( ID DBG_SRC );
}
//--------------------------------------------------------------------------
static void InternalRescheduleTimerEx( PTIMER timer, uint32_t delay )
{
	//lprintf( "Reschedule timer %p %p %d", timer, timer->userdata, delay);
	if( timer )
	{
		// grabbing the timer this way should put its delta into the next.
		PTIMER bGrabbed = GrabTimer( timer, FALSE );
		if (globalTimerData.flags.away_in_timer && globalTimerData.CurrentTimerID == timer->ID) {
#ifdef DEBUG_TIMER_RESCHEDULE
			lprintf("Timer is dispatched/close to being dispatched. %d", timer->ID);
#endif
 // tracks reschedule during callback
			timer->flags.bRescheduled = 1;
		}
  // should never pass a negative value here, but delta can be negative.
		timer->delta = (int32_t)delay;
//		lprintf( "Set timer delta %d %d", timer->delta, timer->ID );
#ifdef LOG_SLEEPS
		lprintf( "Reschedule at %d  %p", timer->delta, bGrabbed );
#endif
		if( bGrabbed )
		{
			//lprintf( "Rescheduling timer..." );
			DoInsertTimer( timer );
			if( timer == globalTimerData.timers )
			{
#ifdef LOG_SLEEPS
				lprintf( "We cheated to insert - so create a wake." );
#endif
				WakeThread( globalTimerData.pTimerThread );
			}
		}
	}
}
//--------------------------------------------------------------------------
// should lock this...
void  RescheduleTimerEx( uint32_t ID, uint32_t delay )
{
	PTIMER timer;
	EnterCriticalSec( &globalTimerData.csGrab );
	if( !ID )
	{
		timer =globalTimerData.current_timer;
#ifdef DEBUG_TIMER_RESCHEDULE
		lprintf("timer 0 specified - use current timer (if there is one?) %d", timer ? timer->ID : -1);
#endif
	}
	else
	{
		timer = globalTimerData.timers;
		while( timer && timer->ID != ID )
			timer = timer->next;
		if( !timer )
		{
			// this timer is not part of the list if it's
			// dispatched and we get here (timer itself rescheduling itself)
			if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
				timer = globalTimerData.current_timer;
#ifdef DEBUG_TIMER_RESCHEDULE
			lprintf("timer is processing? %d %d", ID, timer ? timer->ID : -1);
#endif
		}
#ifdef DEBUG_TIMER_RESCHEDULE
		else {
			lprintf("timer found to reschedule %d", timer ? timer->ID : -1);
		}
#endif
	}
	InternalRescheduleTimerEx( timer, delay );
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
void  RescheduleTimer( uint32_t ID )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( !timer )
	{
		if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
			timer = globalTimerData.current_timer;
	}
	if( timer )
	{
		InternalRescheduleTimerEx( timer, timer->frequency?timer->frequency:timer->delta );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
#if !defined( __NO_GUI__ )
#  ifndef __NO_INTERFACE_SUPPORT__
#    ifndef TARGETNAME
#      define TARGETNAME ""
#    endif
static void OnDisplayPause( "@Internal Timers" TARGETNAME )( void )
{
	globalTimerData.flags.bHaltTimers = 1;
}
//--------------------------------------------------------------------------
static void OnDisplayResume( "@Internal Timers" TARGETNAME)( void )
{
	globalTimerData.flags.bHaltTimers = 0;
	if( globalTimerData.pTimerThread )
		WakeThread( globalTimerData.pTimerThread );
}
#  endif
#endif
//--------------------------------------------------------------------------
void  ChangeTimerEx( uint32_t ID, uint32_t initial, uint32_t frequency )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( timer )
	{
		timer->frequency = frequency;
		InternalRescheduleTimerEx( timer, initial );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
LOGICAL  EnterCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	int d;
	THREAD_ID prior = 0;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#ifdef _DEBUG
	if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		_lprintf( DBG_RELAY )( "Enter critical section %p (owner) %" _64fx, pcs, pcs->dwThreadID );
#endif
#endif
	do
	{
		d=EnterCriticalSecNoWaitEx( pcs, &prior DBG_RELAY );
 // unable to update criticalsec - this is a quick-poll check.
		if( d < 0 )
			Relinquish();
		else if( d == 0 )
		{
			// was unable to aquire lock; and a quick check says there is a
			// thread owning it; so go to sleep for a bit.
			if( pcs->dwThreadID )
 // shouldn't need more than 1 cycle; but infinite can fail on short locks.
				WakeableNamedThreadSleepEx( "sack.critsec", 25 DBG_RELAY );
		}
	}
	while( (d <= 0) );
	return TRUE;
}
//-------------------------------------------------------------------------
LOGICAL  LeaveCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	THREAD_ID dwCurProc;
#ifdef _DEBUG
	uint64_t curtick;
#endif
	while( 1 ) {
#ifdef _DEBUG
		curtick = timeGetTime64();
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_xlprintf( LOG_NOISE DBG_RELAY )( "Begin leave critical section %p %" _64fx, pcs, pcs->dwThreadWaiting );
#endif
		while( LockedExchange( &pcs->dwUpdating, 1 )
#ifdef _DEBUG
			//GetTickCount() )
			&& ( ( curtick + 2000 ) > timeGetTime64() )
#endif
			) {
#ifdef ENABLE_CRITICALSEC_LOGGING
			if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
				_lprintf( DBG_RELAY )( "On leave - section is updating, wait..." );
#endif
			Relinquish();
		}
		dwCurProc = GetThisThreadID();
#ifdef _DEBUG
		//GetTickCount() )
		if( ( curtick + 2000 ) <= timeGetTime64() ) {
#ifdef DEBUG_CRITICAL_SECTIONS
			lprintf( "FROM: %s(%d)  %s(%d) %s(%d)"
					  , pcs->pFile[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-1))%MAX_SECTION_LOG_QUEUE]
					  , pcs->nLine[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-1))%MAX_SECTION_LOG_QUEUE]
					  , pcs->pFile[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-2))%MAX_SECTION_LOG_QUEUE]
					  , pcs->nLine[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-2))%MAX_SECTION_LOG_QUEUE]
					  , pcs->pFile[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-3))%MAX_SECTION_LOG_QUEUE]
					 , pcs->nLine[(pcs->nPrior+(MAX_SECTION_LOG_QUEUE-3))%MAX_SECTION_LOG_QUEUE]
					 );
#endif
			_lprintf(DBG_RELAY)( "Timeout during critical section wait for lock.  No lock should take more than 1 task cycle" );
			//DebugBreak();
			//continue;
		}
#endif
		break;
	}
	if( !pcs->dwLocks )
	{
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_lprintf( DBG_RELAY )( "Leaving a blank critical section" );
#endif
		DebugBreak();
		pcs->dwUpdating = 0;
		return FALSE;
	}
	if( pcs->dwThreadID == dwCurProc )
	{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 0;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
		pcs->dwLocks--;
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			lprintf( "Remaining locks... %08" _32fx, pcs->dwLocks );
#endif
		if( !pcs->dwLocks )
		{
			THREAD_ID dwWaiting = pcs->dwThreadWaiting;
			pcs->dwThreadID = 0;
			pcs->dwUpdating = 0;
			// wake the prior (if there is one sleeping)
			if( dwWaiting )
			{
#ifdef ENABLE_CRITICALSEC_LOGGING
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					_lprintf( DBG_RELAY )( "%8" _64fx " Waking a thread which is waiting...", dwWaiting );
#endif
				// don't clear waiting... so the proper thread can
				// allow itself to claim section...
				WakeNamedThreadSleeperEx( "sack.critsec", dwWaiting DBG_RELAY );
				//WakeThreadIDEx( wake DBG_RELAY);
			}
			return TRUE;
		}
	}
	else {
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		{
			_lprintf( DBG_RELAY )("Sorry - you can't leave a section owned by %016" _64fx " locks:%08" _32fx
#  ifdef DEBUG_CRITICAL_SECTIONS
				"%s(%d)..."
#  endif
				, pcs->dwThreadID
				, pcs->dwLocks
#  ifdef DEBUG_CRITICAL_SECTIONS
				, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : "Unknown", pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]
#  endif
				);
		}
#endif
		DebugBreak();
	}
	pcs->dwUpdating = 0;
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
void DeleteCriticalSec( PCRITICALSECTION pcs )
{
	// ya I don't have anything to do here...
	return;
}
#ifdef _WIN32
HANDLE  GetWakeEvent( void )
{
#if !HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#endif
	if( !MyThreadInfo.pThread ) MakeThread();
	return MyThreadInfo.pThread->thread_event->hEvent;
}
#endif
void OnThreadCreate( void (*f)(void) ) {
#ifndef __STATIC_GLOBALS__
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
#endif
	AddLink( &globalTimerData.onThreadCreate, f );
}
void OnThreadExit( void ( *f )( void ) ) {
#ifndef __STATIC_GLOBALS__
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
#endif
	AddLink( &globalTimerData.onThreadExit, f );
}
#undef GetThreadTLS
#undef MyThreadInfo
#ifdef __cplusplus
//	namespace timers {
}
//namespace sack {
}
#endif
//--------------------------------------------------------------------------
#undef globalTimerData
// $Log: timers.c,v $
// Revision 1.140  2005/06/22 23:13:51  jim
// Differentiate the normal logging of 'entered, left section' but leave in notable exception case logging when enabling critical section debugging.
//
// Revision 1.108  2005/01/23 11:28:24  panther
// Thread ID modification broke timer...
//
// 400 lines of logging removed... version 1.109?
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::memory;
#endif
      typedef struct idle_proc_tag IDLEPROC;
      typedef struct idle_proc_tag *PIDLEPROC;
struct idle_proc_tag
{
	struct {
		BIT_FIELD bDispatched : 1;
		BIT_FIELD bRemove : 1;
	} flags;
	// return -1 if not the correct thread
	// to handle this callback
	// return 0 if no messages were processed
	// return 1 if messages were processed
	int (CPROC*function)(uintptr_t);
	uintptr_t data;
	THREAD_ID thread;
	//PDATAQUEUE threads;
 // same function references go here - for multiple thread entries...
	PIDLEPROC similar;
	DeclareLink( struct idle_proc_tag );
};
struct idle_global_tag {
	CRITICALSECTION idle_cs;
	LOGICAL cs_inited;
	PIDLEPROC registered_idle_procs;
};
#ifndef __STATIC_GLOBALS__
// registered_idle_procs;
static struct idle_global_tag *idle_global;
PRIORITY_PRELOAD( InitGlobalIdle, OSALOT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( idle_global );
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = 1;
	}
}
#else
// registered_idle_procs;
static struct idle_global_tag _idle_global;
// registered_idle_procs;
static struct idle_global_tag *idle_global = &_idle_global;
#endif
#ifdef procs
#  undef procs
#endif
#define procs ((*idle_global).registered_idle_procs)
IDLE_PROC( void, AddIdleProc )( int (CPROC*Proc)( uintptr_t psv ), uintptr_t psvUser )
{
	PIDLEPROC proc = NULL;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( proc = procs; proc; proc = proc->next )
	{
		if( Proc == proc->function )
		{
			PIDLEPROC newproc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
			MemSet( newproc, 0, sizeof( IDLEPROC ) );
			newproc->function = Proc;
			newproc->data = psvUser;
			LinkLast( proc->similar, PIDLEPROC, newproc );
			break;
		}
	}
	// if the function is not already registered as an idle proc, register it.
	if( !proc )
	{
		proc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
		MemSet( proc, 0, sizeof( IDLEPROC ) );
		proc->function = Proc;
		proc->data = psvUser;
		LinkThing( procs, proc );
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
}
IDLE_PROC( int, RemoveIdleProc )( int (CPROC*Proc)(uintptr_t psv ) )
{
	PIDLEPROC check_proc;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( check_proc = procs; check_proc; check_proc = check_proc->next )
	{
		if( Proc == check_proc->function )
		{
			if( !check_proc->flags.bDispatched )
			{
				UnlinkThing( check_proc );
				if( check_proc->similar )
					LinkThing( check_proc->similar, procs );
				Release( check_proc );
			}
			else
			{
				check_proc->flags.bRemove = 1;
			}
			break;
		}
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
	return 0;
}
IDLE_PROC( int, IdleEx )( DBG_VOIDPASS )
{
	THREAD_ID me = GetThisThreadID();
	int success = 0;
	PIDLEPROC proc;
#ifndef __STATIC_GLOBALS__
	if( idle_global )
#endif
	for( proc = procs; proc;  )
	{
		PIDLEPROC check;
		int result;
		for( check = proc; check; check = check->similar )
		{
			check->flags.bDispatched = 1;
			//lprintf( "attempt proc %p in %Lx  procthread=%Lx", check, GetThreadID( MakeThread() ), check->thread );
			//if( !check->thread || ( check->thread == me ) )
			// sometimes... a function belongs to multiple threads...
			if( ( result = check->function( check->data ) ) != -1 )
			{
				check->thread = me;
				// the thread indicated it wants to sleep
				success = result;
			}
			check->flags.bDispatched = 0;
			if( check->flags.bRemove )
			{
				UnlinkThing( check );
				if( check->similar && check == proc )
					LinkThing( check->similar, procs );
				Release( proc );
				proc = procs;
				break;
			}
			else
			{
				//if( check->thread == me )
				{
					proc = proc->next;
					break;
				}
			}
		}
		if( check == NULL )
			proc = proc->next;
	}
	//_lprintf( DBG_AVAILABLE, "Is Going idle." DBG_RELAY );
	Relinquish();
	//_lprintf( DBG_AVAILABLE, "Is back from idle." DBG_RELAY );
	return success;
}
#undef Idle
IDLE_PROC( int, Idle )( void )
{
   return IdleEx( DBG_VOIDSRC );
}
IDLE_PROC( int, IdleForEx )( uint32_t dwMilliseconds DBG_PASS )
{
	//uint32_t dwStart = timeGetTime();
	//while( ( dwStart + dwMilliseconds ) > timeGetTime() )
	{
		if( !IdleEx( DBG_VOIDRELAY ) )
		{
			// sleeping... cause ew didn't do any idle procs...
			WakeableSleep( dwMilliseconds );
		}
	}
	return 0;
}
#undef IdleFor
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds )
{
   return IdleForEx( dwMilliseconds DBG_SRC );
}
#undef procs
#ifdef __cplusplus
 //namespace sack {
}
 //	namespace idle {
}
#endif
#include <time.h>
#ifdef __LINUX__
#endif
//-----------------------------------------------------------------------
FILESYS_NAMESPACE
// have to include this in-namespace
#ifdef _WIN32
#define LONG_PATHCHAR L'\\'
#define SYS_PATHCHAR "\\"
#else
#define LONG_PATHCHAR '/'
#define SYS_PATHCHAR "/"
#endif
#define PATHCHAR "/"
struct file_system_mounted_interface
{
	struct file_system_mounted_interface* nextLayer;
	struct file_system_mounted_interface** meLayer;
	//struct file_system_mounted_interface* sideLayer; // mount-as...
	struct file_system_mounted_interface* parent;
	//DeclareLink( struct file_system_mounted_interface );
	const char *name;
	int priority;
	uintptr_t psvInstance;
	struct file_system_interface *fsi;
	LOGICAL writeable;
};
#if !defined( WINFILE_COMMON_SOURCE ) && defined( __STATIC_GLOBALS__ )
extern
#endif
 struct winfile_local_tag {
	CRITICALSECTION cs_files;
	PLIST files;
	PLIST directories;
	PLIST groups;
	PLIST handles;
	PLIST file_system_interface;
	struct file_system_interface *default_file_system_interface;
	struct file_system_mounted_interface *_mounted_file_systems;
	struct file_system_mounted_interface *last_find_mount;
	struct file_system_mounted_interface *_default_mount;
	LOGICAL have_default;
	struct {
		BIT_FIELD bLogOpenClose : 1;
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDeallocateClosedFiles : 1;
		BIT_FIELD have_default_groups : 1;
		BIT_FIELD finished_default_groups : 1;
	} flags;
 // windows user local data
	TEXTSTR local_data_file_root;
 // windows /programdata/freedom collective/ProgramName/ root
	TEXTSTR data_file_root;
	TEXTSTR producer;
	TEXTSTR application;
 // install_dir/share/SACK
	TEXTSTR share_data_root;
 }
#ifdef __STATIC_GLOBALS__
winfile_local__;
#endif
;
#if HAS_TLS
struct filesys_thread_mount_info {
	struct file_system_mounted_interface* default_mount;
	struct file_system_mounted_interface** _mounted_file_systems;
#define mounted_file_systems _mounted_file_systems[0]
	struct file_system_mounted_interface* thread_local_mounted_file_systems;
	char* cwd;
};
#if !defined( WINFILE_COMMON_SOURCE )
extern
#endif
	DeclareThreadVar  struct filesys_thread_mount_info _fileSysThreadInfo;
#  define FileSysThreadInfo (_fileSysThreadInfo)
#else
#error "Please get a better platform target...."
//#  define fileSysThreadInfo (*_fileSysThreadInfo)
#endif
#ifndef WINFILE_COMMON_SOURCE
extern
#endif
	struct winfile_local_tag *winfile_local
#if defined( __STATIC_GLOBALS__ ) && defined( WINFILE_COMMON_SOURCE )
		   = &winfile_local__
#endif
	;
//#define l (*winfile_local)
#ifdef __EMSCRIPTEN__
static char *currentPath
       = "/home/web_user"
#endif
	;
#ifndef __NO_SACK_FILESYS__
//extern TEXTSTR ExpandPath( CTEXTSTR path );
#endif
int PathCmpEx( CTEXTSTR s1, CTEXTSTR s2, int maxlen ) {
	TEXTCHAR l1;
	TEXTCHAR l2;
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ; maxlen && s1[0] && s2[0]
		&& ( ( ( s1[0] == '/' || s1[1] == '\\' )
			&& ( s2[0] == '/' || s2[0] == '\\' ) )
			|| ( ( l1 = ( s1[0] >= 'a' && s1[0] <= 'z' ) ? s1[0] - ( 'a' - 'A' ) : s1[0] )
				== ( l2 = ( s2[0] >= 'a' && s2[0] <= 'z' ) ? s2[0] - ( 'a' - 'A' ) : s2[0] ) ) );
		s1++, s2++, maxlen-- ) {
		//lprintf( "Continue... compared %c(%d) vs %c(%d)", s1[0]<32?'?':s1[0], s1[0], s2[0]<32?'?':s2[0], s2[0] );
	}
	if( !maxlen )
		return 0;
	return l1 - l2;
}
int PathCmp( CTEXTSTR s1, CTEXTSTR s2 ) {
	return PathCmpEx( s1, s2, 65535 );
}
CTEXTSTR  pathrchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
const wchar_t* pathrchrW( const wchar_t* path ) {
	const wchar_t* end1, *end2;
	 end1 = StrRChrW( path, '\\' );
	 end2 = StrRChrW( path, '/' );
	 if( end1 > end2 )
		 return end1;
	 return end2;
 }
#ifdef __cplusplus
TEXTSTR  pathrchr ( TEXTSTR path )
{
	TEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
wchar_t* pathrchrW( wchar_t* path ) {
	wchar_t* end1, * end2;
	end1 = StrRChrW( path, '\\' );
	end2 = StrRChrW( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
#endif
//-----------------------------------------------------------------------
 CTEXTSTR  pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//-----------------------------------------------------------------------
TEXTSTR GetCurrentPath( TEXTSTR path, int len )
{
	// allow thread to initialize itself with a real currentpath...
	if( FileSysThreadInfo.cwd ) {
		strncpy( path, FileSysThreadInfo.cwd, len );
		return path;
	}
	if( !path )
		return 0;
#ifdef __EMSCRIPTEN__
   strncpy( path, currentPath, len );
#else
#  ifndef UNDER_CE
#    ifdef _WIN32
	GetCurrentDirectory( len, path );
#    else
#	    ifdef UNICODE
	{
		char _path[256];
		//TEXTCHAR *tmppath;
		//getcwd( _path, 256 );
		//tmppath = DupCStr( _path );
		//StrCpyEx( path, tmppath, len );
		path[0] = '.';
		path[1] = 0;
	}
#	    else
	getcwd( path, len );
#      endif
#    endif
#  endif
#endif
	return path;
}
#ifndef _WIN32
static void convert( uint64_t* outtime, time_t *time )
{
#warning convert time function is incomplete.
	*outtime = *time;
}
#endif
//-----------------------------------------------------------------------
uint64_t GetTimeAsFileTime ( void )
{
#if defined( __LINUX__ )
	struct timeval tmp;
	//struct timezone tz;
	FILETIME result;
//&tz );
	gettimeofday( &tmp, NULL );
	result = ( tmp.tv_usec * 10LL ) + ( tmp.tv_sec * 1000LL * 1000LL * 10LL );
	return result;
#else
	SYSTEMTIME st;
	FILETIME result;
	GetLocalTime( &st );
	SystemTimeToFileTime( &st, &result );
	return *(uint64_t*)&result;
#endif
}
 // last modification time.
 uint64_t  GetFileWriteTime( CTEXTSTR name )
{
#ifndef __NO_SACK_FILESYS__
	TEXTSTR tmppath = ExpandPath( name );
#else
#  define tmppath name
#endif
#ifdef _WIN32
	HANDLE hFile = CreateFile( tmppath
 // device access?
								  , 0
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
#ifndef __NO_SACK_FILESYS__
	Deallocate( TEXTSTR, tmppath );
#endif
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime;
		//uint64_t realtime;
		GetFileTime( hFile, NULL, NULL, &filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return *(uint64_t*)&filetime;
	}
	return 0;
#else
		struct stat statbuf;
		uint64_t realtime;
#ifdef UNICODE
	{
		char *tmpname = CStrDup( tmppath );
		stat( tmpname, &statbuf );
		Release( tmpname );
	}
#else
	stat( tmppath, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
 // last modification time.
 LOGICAL  SetFileWriteTime( CTEXTSTR name, uint64_t filetime )
{
#ifdef _WIN32
	HANDLE hFile = CreateFile( name
 // device access?
								  , GENERIC_WRITE
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		//uint64_t realtime;
		SetFileTime( hFile, NULL, NULL, (CONST FILETIME*)&filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
	   //realtime *= 100; // nano seconds?
	  return TRUE;
	}
	return FALSE;
#else
	struct stat statbuf;
	uint64_t realtime;
#ifdef UNICODE
	 {
		 int status;
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
		 Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
#ifdef WIN32
uint64_t ConvertFileTimeToInt( const FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.u.LowPart = filetime->dwLowDateTime;
	tmp.u.HighPart = filetime->dwHighDateTime;
	return tmp.QuadPart;
}
void ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.QuadPart = int_filetime;
	filetime->dwLowDateTime  = tmp.u.LowPart;
	filetime->dwHighDateTime = tmp.u.HighPart;
}
#endif
LOGICAL  SetFileTimes( CTEXTSTR name
  // last modification time.
							, uint64_t time_create
 // last modification time.
							, uint64_t time_modify
  // last modification time.
							, uint64_t time_access
							)
{
#ifdef _WIN32
	LOGICAL result = TRUE;
	HANDLE hFile = CreateFile( name
 //GENERIC_WRITE|FILE_WRITE_ATTRIBUTES //GENERIC_ALL // device access?
									 , GENERIC_ALL
									 , FILE_SHARE_READ|FILE_SHARE_WRITE
									 , NULL
									 , OPEN_EXISTING
									 , FILE_FLAG_BACKUP_SEMANTICS
									 , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime_create;
		FILETIME filetime_modify;
		FILETIME filetime_access;
		ULARGE_INTEGER tmp;
		//uint64_t realtime;
		tmp.QuadPart = time_create;
		filetime_create.dwLowDateTime = tmp.u.LowPart;
		filetime_create.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_access;
		filetime_access.dwLowDateTime = tmp.u.LowPart;
		filetime_access.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_modify;
		filetime_modify.dwLowDateTime = tmp.u.LowPart;
		filetime_modify.dwHighDateTime = tmp.u.HighPart;
#if 0
		{
			TEXTCHAR buf[3][64];
			SYSTEMTIME st;
			FileTimeToSystemTime( &time_create, &st );
			snprintf( buf[0], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_access, &st );
			snprintf( buf[1], 64,"%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_modify, &st );
			snprintf( buf[2], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			lprintf( "File times on [%s] are to be : %s %s %s", name, buf[0], buf[1], buf[2] );
		}
#endif
		if( !SetFileTime( hFile, (CONST FILETIME*)&filetime_create, (CONST FILETIME*)&filetime_access, (CONST FILETIME*)&filetime_modify ) )
		{
			result = FALSE;
			lprintf( "Failed to set times:(%s)%d", name, GetLastError() );
		}
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return result;
	}
	else
	{
		lprintf( "Failed to open to set time on %s:%d", name, GetLastError() );
	}
	return FALSE;
#else
	struct stat statbuf;
	 uint64_t realtime;
#ifdef UNICODE
	 {
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
	   Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
LOGICAL  IsPath ( CTEXTSTR path )
{
	if( !path )
		return 0;
#ifdef _WIN32
	{
		DWORD dwResult;
		dwResult = GetFileAttributes( path );
		if( dwResult == 0xFFFFFFFF )
			return 0;
		if( dwResult & FILE_ATTRIBUTE_DIRECTORY )
			return 1;
		return 0;
	}
#else
	 {
		 struct stat statbuf;
#ifdef UNICODE
		 {
			 int status;
			 char *tmppath = CStrDup( path );
			 status = stat( tmppath, &statbuf );
			 Release( tmppath );
			 if( status < 0 )
				 return 0;
		 }
#else
		 if( stat( path, &statbuf ) < 0 )
			 return 0;
#endif
		 return S_ISDIR( statbuf.st_mode );
	 }
#endif
}
//-----------------------------------------------------------------------
int  MakePath ( CTEXTSTR path )
{
	int status;
	if( !path )
		return 0;
#ifdef _WIN32
	wchar_t* wpath = CharWConvert( path );
	{ wchar_t* tmp; if( LONG_PATHCHAR ) for( tmp = wpath; tmp[0]; tmp++ ) if( tmp[0] == '/' ) tmp[0] = LONG_PATHCHAR; }
	status = CreateDirectoryW( wpath, NULL );
	if( !status )
	{
		uint32_t err = GetLastError();
		if( err == ERROR_ALREADY_EXISTS ){
			Release( wpath );
			return TRUE;
		}
		TEXTSTR tmppath = StrDup( path );
		TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
		if( last )
		{
			last[0] = 0;
			if( MakePath( tmppath ) )
				status = CreateDirectoryW( wpath, NULL );
		}
		Release( tmppath );
	}
	Release( wpath );
	return status;
#else
#  ifdef UNICODE
	{
		int status;
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = mkdir( tmppath, -1 );
		Release( tmppath );
		return !status;
	}
#  else
 // make directory with full umask permissions
	if( ( status = mkdir( path, -1 ) ) < 0 )
	{
		if( errno == EEXIST ) status = 0;
		else {
			TEXTSTR tmppath = StrDup( path );
			TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
			if( last )
			{
				last[0] = 0;
				if( tmppath[0] && MakePath( tmppath ) ) {
					status = mkdir( path, -1 );
					if( status < 0 )
						if( EEXIST == errno )
							status = 0;
				}
			}
			Release( tmppath );
		}
	}
	if( status < 0 )
		if( EEXIST == errno )
			status = 0;
	return !status;
#  endif
#endif
}
//-----------------------------------------------------------------------
int  SetCurrentPath ( CTEXTSTR path )
{
	TEXTSTR tmp = ExpandPath( path );
	if( IsPath( tmp ) ) {
		Release( FileSysThreadInfo.cwd );
		FileSysThreadInfo.cwd = StrDup( tmp );
		return 1;
	}
	int status = 1;
	TEXTSTR tmp_path;
	if( !path )
		return 0;
#ifndef __NO_SACK_FILESYS__
	tmp_path = ExpandPath( path );
#else
#  define tmp_path path
#endif
#ifndef UNDER_CE
#  ifdef _WIN32
	status = SetCurrentDirectory( tmp_path );
#  else
#	ifdef UNICODE
	{
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = chdir( tmppath );
		Release( tmppath );
	}
#	else
	 status = !chdir( tmp_path );
#	endif
#  endif
#ifndef __NO_SACK_FILESYS__
	Release( tmp_path );
#endif
	if( status )
	{
#ifndef __NO_SACK_FILESYS__
		TEXTCHAR tmp[256];
		path = GetCurrentPath( tmp, sizeof( tmp ) );
		SetDefaultFilePath( path );
#endif
	}
	else
	{
		TEXTCHAR tmp[256];
		lprintf( "Failed to change to [%s](%d) from %s", path, GetLastError(), GetCurrentPath( tmp, sizeof( tmp ) ) );
	}
#endif
	return status;
}
LOGICAL IsAbsolutePath( CTEXTSTR path )
{
	if(path)
	{
#ifdef WIN32
		if( ( path[0] && path[1] && path[2] ) &&
			  ( ( ( ( path[0] >= 'a' && path[0] <= 'z' )
				  || ( path[0] >= 'A' && path[0] <= 'Z' ) )
				  && ( path[1] == ':' )
				  && ( path[2] == '/' || path[2] == '\\' ) )
				|| ( path[0] == '/' && path[1] == '/' )
				|| ( path[0] == '\\' && path[1] == '\\' )
			  || ( path[0] == '/' || path[0] == '\\' ) )
		  )
			return TRUE;
#else
		if( path[0] == '/' || path[0] == '\\' )
			return TRUE;
#endif
	}
	return FALSE;
}
FILESYS_NAMESPACE_END
//-----------------------------------------------------------------------
// #define _FILE_OFFSET_BTIS	64
//[02:03 : 43] <significant> #define _LARGEFILE64_SOURCE
#define UNDEF_FILESYS_DEFS
#define FILESYSTEM_LIBRARY_SOURCE
#define NO_UNICODE_C
#define WINFILE_COMMON_SOURCE
#define FIX_RELEASE_COM_COLLISION
#ifndef _DEBUG
#  define __FILESYS_NO_FILE_LOGGING__
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#  include <winternl.h>
#  ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#  endif
#  ifdef UNDER_CE
#    define finddata_t WIN32_FIND_DATA
#    define findfirst FindFirstFile
#    define findnext  FindNextFile
#    define findclose FindClose
#  else
#    ifdef UNICODE
#      define finddata_t _wfinddata_t
#      define findfirst _wfindfirst
#      define findnext  _wfindnext
#      define findclose _findclose
#    else
#      define finddata_t _finddata_t
#      define findfirst _findfirst
#      define findnext  _findnext
#      define findclose _findclose
#    endif
#  endif
#else
 // opendir etc..
#  include <dirent.h>
#  ifndef MAX_PATH_NAME
#    define MAX_PATH_NAME PATH_MAX
#  endif
#endif
//#undef DeleteList
#ifdef WIN32
#endif
#ifndef UNDER_CE
  // O_BINARY
//#include <io.h>
#endif
FILESYS_NAMESPACE
enum textModes {
	TM_BINARY = 0,
	TM_UNKNOWN,
	TM_UTF8,
	TM_UTF16BE,
	TM_UTF16LE,
	TM_UTF32BE,
	TM_UTF32LE,
	TM_UTF7,
	TM_UTF1,
	TM_UTF_EBCDIC,
	TM_UTF_SCSU,
	TM_UTF_BOCU,
	TM_UTF_GB_18030
};
struct file {
	TEXTSTR name;
	TEXTSTR fullname;
	wchar_t* wfullname;
 // HANDLE 's
	PLIST  handles;
 // FILE *'s
	PLIST  files;
	INDEX  group;
	enum   textModes textmode;
  // text file modes; skip existing BOM for seek purposes.
	size_t file_start_offset;
	struct file_system_mounted_interface* mount;
 // allow covering for file systems that don't actually delete files that are still open
	int    deleted;
 // has been deleted, but deletion failed (probably because it's open)
	int    delete_on_close;
};
struct directory {
	TEXTSTR name;
	TEXTSTR fullname;
	wchar_t* wfullname;
	struct file_system_mounted_interface* mount;
 // allow covering for file systems that don't actually delete files that are still open
	int    deleted;
};
struct file_interface_tracker
{
	CTEXTSTR name;
	struct file_system_interface* fsi;
};
struct Group {
	TEXTSTR name;
	TEXTSTR base_path;
 // base is already expanded from this.
	TEXTSTR default_path;
};
extern struct file_system_interface native_fsi;
#ifdef _WIN32
#  ifndef SHGFP_TYPE_CURRENT
#    define SHGFP_TYPE_CURRENT 0
        // All Users\Application Data
#    define CSIDL_COMMON_APPDATA            0x0023
        // <user name>\Local Settings\Applicaiton Data (non roaming)
#    define CSIDL_LOCAL_APPDATA             0x001c
EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE SHGetFolderPathA( HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath );
#  endif
#endif
static void* CPROC sack_filesys_open( uintptr_t psv, const char* filename, const char* opts );
static int CPROC sack_filesys_close( void* file ) { return fclose( (FILE*)file ); }
static size_t CPROC sack_filesys_read( void* file, void* buf, size_t len ) { return fread( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_write( void* file, const void* buf, size_t len ) { return fwrite( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_seek( void* file, size_t pos, int whence ) { return fseek( (FILE*)file, (long)pos, whence ), ftell( (FILE*)file ); }
static int CPROC sack_filesys_unlink( uintptr_t psv, const char* filename );
static void UpdateLocalDataPath( void )
{
	if( ( *winfile_local ).data_file_root )ReleaseEx( ( *winfile_local ).data_file_root DBG_SRC );
	if( ( *winfile_local ).local_data_file_root )ReleaseEx( ( *winfile_local ).local_data_file_root DBG_SRC );
#ifdef _WIN32
	wchar_t path[MAX_PATH];
	TEXTCHAR* u8path;
	TEXTCHAR* realpath;
	size_t len;
	SHGetFolderPathW( NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_CURRENT, path );
	u8path = WcharConvert( path );
	realpath = NewArray( TEXTCHAR, len = StrLen( u8path )
		+ StrLen( ( *winfile_local ).producer ? ( *winfile_local ).producer : "" )
 // worse case +3
		+ StrLen( ( *winfile_local ).application ? ( *winfile_local ).application : "" ) + 3 );
	tnprintf( realpath, len, "%s%s%s%s%s", u8path
		, ( *winfile_local ).producer ? "\\" : "", ( *winfile_local ).producer ? ( *winfile_local ).producer : ""
		, ( *winfile_local ).application ? "\\" : "", ( *winfile_local ).application ? ( *winfile_local ).application : ""
	);
	( *winfile_local ).data_file_root = realpath;
	MakePath( ( *winfile_local ).data_file_root );
	ReleaseEx( u8path DBG_SRC );
	SHGetFolderPathW( NULL, CSIDL_LOCAL_APPDATA, NULL, SHGFP_TYPE_CURRENT, path );
	u8path = WcharConvert( path );
	realpath = NewArray( TEXTCHAR, len = StrLen( u8path )
		+ StrLen( ( *winfile_local ).producer ? ( *winfile_local ).producer : "" )
 // worse case +3
		+ StrLen( ( *winfile_local ).application ? ( *winfile_local ).application : "" ) + 3 );
	tnprintf( realpath, len, "%s%s%s%s%s", u8path
		, ( *winfile_local ).producer ? "\\" : "", ( *winfile_local ).producer ? ( *winfile_local ).producer : ""
		, ( *winfile_local ).application ? "\\" : "", ( *winfile_local ).application ? ( *winfile_local ).application : ""
	);
	( *winfile_local ).local_data_file_root = realpath;
	MakePath( ( *winfile_local ).local_data_file_root );
	ReleaseEx( u8path DBG_SRC );
#else
	TEXTCHAR path[MAXPATH];
	tnprintf( path, sizeof(path), "~/%s%s%s%s"
		, ( *winfile_local ).producer ? "." : "", ( *winfile_local ).producer ? ( *winfile_local ).producer : ""
		, ( *winfile_local ).application ? SYSPATHCHAR : "", ( *winfile_local ).application ? ( *winfile_local ).application : ""
	);
	( *winfile_local ).local_data_file_root = StrDup( path );;
#if !defined( __STATIC__ ) && !defined( __STATIC_GLOBALS__ )
	if( strcmp( GetInstallPath(), "/usr" ) == 0 )
		tnprintf( path, sizeof(path), "/var/%s%s%s%s"
			, ( *winfile_local ).producer ? "" : "", ( *winfile_local ).producer ? ( *winfile_local ).producer : ""
			, ( *winfile_local ).application ? SYSPATHCHAR : "", ( *winfile_local ).application ? ( *winfile_local ).application : ""
		);
	else
		tnprintf( path, sizeof(path),  "%s/var/%s%s%s%s"
			, GetInstallPath()
			, ( *winfile_local ).producer ? "" : "", ( *winfile_local ).producer ? ( *winfile_local ).producer : ""
			, ( *winfile_local ).application ? SYSPATHCHAR : "", ( *winfile_local ).application ? ( *winfile_local ).application : ""
		);
	( *winfile_local ).data_file_root = StrDup( path );
#else
	// this is a case of a portable project with __STATIC__ and __STATIC_GLOBALS__
	( *winfile_local ).data_file_root = (TEXTSTR)Hold( winfile_local[0].local_data_file_root );
#endif
	//lprintf( "initialized:%s %s", ( *winfile_local ).data_file_root, ( *winfile_local ).local_data_file_root );
#endif
#if !defined( __STATIC__ ) && !defined( __STATIC_GLOBALS__ )
	if( !( *winfile_local ).share_data_root ) {
		PVARTEXT pvt = VarTextCreate(); vtprintf( pvt, "%s/share/SACK", GetInstallPath() );
		TEXTSTR path = ExpandPath( GetText(VarTextPeek( pvt )));
		VarTextDestroy( &pvt );
		( *winfile_local ).share_data_root = path;
	}
#else
	if( !( *winfile_local ).share_data_root )
		( *winfile_local ).share_data_root = StrDup( "." );
#endif
}
void sack_set_common_data_producer( CTEXTSTR name )
{
	( *winfile_local ).producer = StrDup( name );
	UpdateLocalDataPath();
}
void sack_set_common_data_application( CTEXTSTR name )
{
	( *winfile_local ).application = StrDup( name );
	UpdateLocalDataPath();
}
static void threadInit( void ) {
 // edge case the main thread might init twice.
	if( !FileSysThreadInfo.cwd ) {
		FileSysThreadInfo.cwd = ExpandPath( "." );
	}
	if( !FileSysThreadInfo._mounted_file_systems ) {
		FileSysThreadInfo.default_mount = ( *winfile_local )._default_mount;
		FileSysThreadInfo._mounted_file_systems = &( *winfile_local )._mounted_file_systems;
		//FileSysThreadInfo.mounted_file_systems = ( *winfile_local )._mounted_file_systems;
	}
}
static void threadExit( void ) {
	if( FileSysThreadInfo.cwd ) {
		Deallocate( char*, FileSysThreadInfo.cwd );
	}
}
static void LocalInit( void )
{
#ifndef __STATIC_GLOBALS__
	if( !winfile_local )
		SimpleRegisterAndCreateGlobal( winfile_local );
#endif
	if( !( *winfile_local ).flags.bInitialized ) {
		if( !sack_get_filesystem_interface( "native" ) )
			sack_register_filesystem_interface( "native", &native_fsi );
		if( !( *winfile_local )._default_mount )
			( *winfile_local )._default_mount = sack_mount_filesystem( "native", &native_fsi, 1000, (uintptr_t)NULL, TRUE );
 // this only works for threads WE create... maybe that's fixable someday
		OnThreadCreate( threadInit );
		OnThreadExit( threadExit );
		InitializeCriticalSec( &( *winfile_local ).cs_files );
		( *winfile_local ).flags.bInitialized = 1;
  // this might or might not get dispatched already on this thread.
		threadInit();
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		( *winfile_local ).flags.bLogOpenClose = 0;
#endif
		if( !( *winfile_local ).producer )
			sack_set_common_data_producer( "Freedom Collective" );
		if( !( *winfile_local ).application )
			sack_set_common_data_application( GetProgramName() );
		UpdateLocalDataPath();
		{
			TEXTSTR check;
			char tmpPath[256];
			snprintf( tmpPath, 256, "%s/%s", getenv( "HOME" ), ".Freedom Collective" );
			//( *winfile_local ).data_file_root = StrDup( "~" );
			check = ExpandPath( "*/" );
			//lprintf( "checking path:%s", check );
			MakePath( check );
			ReleaseEx( check DBG_SRC );
			check = ExpandPath( ";/" );
			//lprintf( "checking path:%s", check );
			MakePath( check );
			ReleaseEx( check DBG_SRC );
		}
	}
}
static void InitGroups( void )
{
	struct Group* group;
	TEXTCHAR tmp[256];
	// known handle '0' is 'default' which is CurrentWorkingDirectory at load.
	group = New( struct Group );
	group->default_path = NULL;
	group->base_path = StrDup( GetCurrentPath( tmp, sizeof( tmp ) ) );
	group->name = StrDup( "Default" );
	AddLink( &( *winfile_local ).groups, group );
	// known handle '1' is the program's load path.
	group = New( struct Group );
	group->default_path = NULL;
#ifdef __ANDROID__
	// assets and other files are in the data directory
	group->base_path = StrDup( GetStartupPath() );
#else
	group->base_path = StrDup( GetProgramPath() );
#endif
	group->name = StrDup( "Program Path" );
	AddLink( &( *winfile_local ).groups, group );
	// known handle '1' is the program's start path.
	group = New( struct Group );
	group->default_path = NULL;
	group->base_path = StrDup( GetStartupPath() );
	group->name = StrDup( "Startup Path" );
	AddLink( &( *winfile_local ).groups, group );
	( *winfile_local ).have_default = TRUE;
}
static void commitFileGroup( struct Group* filegroup ) {
	TEXTCHAR tmp_ent[256];
	TEXTCHAR tmp[256];
	tnprintf( tmp_ent, sizeof( tmp_ent ), "file group/%s", filegroup->name );
	//lprintf( "option to save is %s", tmp );
#ifdef __NO_OPTIONS__
	tmp[0] = 0;
#else
	SACK_GetProfileString( GetProgramName(), tmp_ent, filegroup->default_path, tmp, sizeof( tmp ) );
#endif
	if( !tmp[0] && filegroup->default_path ) {
#ifndef __NO_OPTIONS__
		SACK_WriteProfileString( GetProgramName(), tmp_ent, filegroup->default_path );
#endif
	}
	ReleaseEx( filegroup->default_path DBG_SRC );
	filegroup->default_path = NULL;
}
static void InitMoreGroups( void ) {
	if( !( *winfile_local ).flags.have_default_groups ) {
		( *winfile_local ).flags.have_default_groups = 1;
#if !defined( __STATIC__ ) && !defined( __STATIC_GLOBALS__ )
		PVARTEXT pvt = VarTextCreate();
		vtprintf( pvt, "%s/share/SACK", GetInstallPath() );
		TEXTSTR path = ExpandPath( GetText(VarTextPeek( pvt )));
		GetFileGroup( "resources", path );
		ReleaseEx( path DBG_SRC ); VarTextEmpty( pvt );
		vtprintf( pvt, "%s/share/SACK/frames", GetInstallPath() );
		path = ExpandPath( GetText(VarTextPeek( pvt )));
		GetFileGroup( "frames", path );
		ReleaseEx( path DBG_SRC ); VarTextEmpty( pvt );
		vtprintf( pvt, "%s/share/SACK/images", GetInstallPath() );
		path = ExpandPath( GetText(VarTextPeek( pvt )));
		GetFileGroup( "images", path );
		ReleaseEx( path DBG_SRC ); VarTextEmpty( pvt );
		vtprintf( pvt, "%s/share/SACK/fonts", GetInstallPath() );
		path = ExpandPath( GetText(VarTextPeek( pvt )));
		GetFileGroup( "fonts", path );
		ReleaseEx( path DBG_SRC );
		VarTextDestroy( &pvt );
#endif
		( *winfile_local ).flags.finished_default_groups = 1;
		{
			struct Group* filegroup;
			INDEX idx;
			LIST_FORALL( ( *winfile_local ).groups, idx, struct Group*, filegroup ) {
				commitFileGroup( filegroup );
			}
		}
	}
}
static struct Group* GetGroupFilePath( CTEXTSTR group )
{
	struct Group* filegroup;
	INDEX idx;
	if( !( *winfile_local ).groups ) {
		InitGroups();
	}
	LIST_FORALL( ( *winfile_local ).groups, idx, struct Group*, filegroup )
	{
		if( StrCaseCmp( filegroup->name, group ) == 0 ) {
			break;
		}
	}
	return filegroup;
}
INDEX  GetFileGroup( CTEXTSTR groupname, CTEXTSTR default_path )
{
	struct Group* filegroup = GetGroupFilePath( groupname );
	if( !filegroup ) {
		filegroup = New( struct Group );
		filegroup->default_path = NULL;
		{
			TEXTCHAR tmp_ent[256];
			TEXTCHAR tmp[256];
			InitMoreGroups();
			tnprintf( tmp_ent, sizeof( tmp_ent ), "file group/%s", groupname );
			//lprintf( "option to save is %s", tmp );
#ifdef __NO_OPTIONS__
			tmp[0] = 0;
#else
			if( ( *winfile_local ).have_default && ( *winfile_local ).flags.finished_default_groups ) {
				SACK_GetProfileString( GetProgramName(), tmp_ent, default_path ? default_path : NULL, tmp, sizeof( tmp ) );
			}
			else
				tmp[0] = 0;
#endif
			if( tmp[0] ) {
				default_path = tmp;
			} else if( default_path ) {
				if( ( *winfile_local ).flags.finished_default_groups ) {
#ifndef __NO_OPTIONS__
					SACK_WriteProfileString( GetProgramName(), tmp_ent, default_path );
#endif
				}
				else
					filegroup->default_path = StrDup( default_path );
			}
		}
		filegroup->name = StrDup( groupname );
		if( default_path )
			filegroup->base_path = ExpandPath( default_path );
		else
			filegroup->base_path = StrDup( "." );
		AddLink( &( *winfile_local ).groups, filegroup );
	}
	return FindLink( &( *winfile_local ).groups, filegroup );
}
TEXTSTR GetFileGroupText( INDEX group, TEXTSTR path, int path_chars )
{
	struct Group* filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
	if( !filegroup ) {
		path[0] = 0;
		return 0;
	}
	StrCpyEx( path, filegroup->base_path, path_chars );
	return path;
}
TEXTSTR ExpandPathVariable( CTEXTSTR path )
{
	TEXTSTR subst_path = NULL;
	TEXTSTR end = NULL;
	TEXTSTR tmp_path = StrDup( path );
	TEXTSTR tmp = NULL;
	TEXTSTR newest_path = NULL;
	size_t  len;
	size_t  this_length;
	INDEX   group;
	struct  Group* filegroup;
	if( path ) {
		while( ( subst_path = (TEXTSTR)StrChr( tmp_path, '%' ) ) ) {
			end = (TEXTSTR)StrChr( ++subst_path, '%' );
			//lprintf( "Found magic subst in string" );
			if( end ) {
				this_length = StrLen( tmp_path );
				tmp = NewArray( TEXTCHAR, len = ( end - subst_path ) + 1 );
				tnprintf( tmp, len * sizeof( TEXTCHAR ), "%*.*s", (int)( end - subst_path ), (int)( end - subst_path ), subst_path );
				group = GetFileGroup( tmp, NULL );
				if( group != INVALID_INDEX ) {
					filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
  // must deallocate tmp
					Deallocate( TEXTCHAR*, tmp );
					newest_path = NewArray( TEXTCHAR, len = ( subst_path - tmp_path ) + StrLen( filegroup->base_path ) + ( this_length - ( end - tmp_path ) ) + 1 );
					//=======================================================================
					// Get rid of the ending '%' AND any '/' or '\' that might come after it
					//=======================================================================
					if( ( end[2] && ( end[1] == '/' || end[1] == '\\' ) ) || end[1] )
						tnprintf( newest_path, len, "%*.*s%s" SYS_PATHCHAR "%s", (int)( ( subst_path - tmp_path ) - 1 )
						        , (int)( ( subst_path - tmp_path ) - 1 )
						        , tmp_path, filegroup->base_path
						        , ( ( end + 1 )[0] == '/' || ( end + 1 )[0] == '\\' ) ? ( end + 2 ) : ( end + 1 ) );
					else
						tnprintf( newest_path, len, "%*.*s%s", (int)((subst_path - tmp_path) - 1)
						        , (int)((subst_path - tmp_path) - 1)
						        , tmp_path, filegroup->base_path
						        );
					Deallocate( TEXTCHAR*, tmp_path );
					tmp_path = ExpandPathVariable( newest_path );
					Deallocate( TEXTCHAR*, newest_path );
				}
				else {
					CTEXTSTR external_var = OSALOT_GetEnvironmentVariable( tmp );
					if( external_var ) {
  // must deallocate tmp
						Deallocate( TEXTCHAR*, tmp );
						newest_path = NewArray( TEXTCHAR, len = ( subst_path - tmp_path ) + StrLen( external_var ) + ( this_length - ( end - tmp_path ) ) + 1 );
						//=======================================================================
						// Get rid of the ending '%' AND any '/' or '\' that might come after it
						//=======================================================================
						if( (end[2] && (end[1] == '/' || end[1] == '\\')) || end[1] )
							tnprintf( newest_path, len, "%*.*s%s/%s", (int)( ( subst_path - tmp_path ) - 1 ), (int)( ( subst_path - tmp_path ) - 1 )
							        , tmp_path
							        , external_var
							        , ( ( end + 1 )[0] == '/' || ( end + 1 )[0] == '\\' ) ? ( end + 2 ) : ( end + 1 ) );
						else
							tnprintf( newest_path, len, "%*.*s%s", (int)((subst_path - tmp_path) - 1), (int)((subst_path - tmp_path) - 1)
							        , tmp_path
							        , external_var
							        );
						tmp_path = ExpandPathVariable( newest_path );
						Deallocate( TEXTCHAR*, newest_path );
					}
					else
						tmp_path = tmp;
				}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( ( *winfile_local ).flags.bLogOpenClose )
					lprintf( "transform subst [%s]", tmp_path );
#endif
			}
  // was only one %...
			else
				break;
		}
	}
	return tmp_path;
}
static void squash_dotdot( TEXTSTR path ) {
	int pathchar;
	TEXTSTR cur;
	TEXTSTR out;
	do {
		pathchar = -1;
		out = NULL;
		for( cur = path; cur[0]; cur++ ) {
			if( out ) (out++)[0] = cur[0];
			else if( cur[0] == '/' || cur[0] == '\\' ){
				if( pathchar < 0 ) {
					if( cur[1] !='.' || cur[2]!='.' || !( cur[3] == '\\' || cur[3] == '/' ) )
  // this will be a short diff (re int conversion)
						pathchar = (int)( cur - path );
				}  else {
					if( cur[1] ) {
						if( cur[1] == '.' ) {
							if( cur[2] ) {
								if( cur[2] == '.' ) {
									if( cur[3] ) {
										if( cur[3] == '/' || cur[3] == '\\' ) {
 // copy the rest of the path to good start.
											out = path + pathchar;
 // loop will increment 1... so this is 3.
											cur += 2;
										} else pathchar = (int)( cur - path );
									} else {
										path[pathchar] = 0;
										break;
									}
								} else pathchar = (int)( cur - path );
							} else break;
						} else pathchar = (int)( cur - path );
					} else break;
				}
			}
		}
		if( out ) out[0] = 0;
	} while( out );
}
TEXTSTR ExpandPathExx( CTEXTSTR path, struct file_system_interface* fsi DBG_PASS )
{
	TEXTSTR tmp_path;
	if( !path ) return NULL;
	tmp_path = StrDupEx( path DBG_RELAY );
	//LocalInit();
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "input path is [%s]", path );
#endif
	if( path ) {
		if( !fsi && !IsAbsolutePath( path ) ) {
			if( ( path[0] == '.' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				TEXTCHAR here[256];
				size_t len;
				GetCurrentPath( here, sizeof( here ) );
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s"
					, here
					, path[1] ? SYS_PATHCHAR : ""
					, path[1] ? ( path + 2 ) : "" );
			}
			else if( ( path[0] == '@' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = GetLibraryPath();
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here?here:""
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			}
//#if !defined( __STATIC__ ) && !defined( __STATIC_GLOBALS__ )
			else if( ( path[0] == ',' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = GetInstallPath();
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			}
//#endif
			else if( ( path[0] == '#' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = GetProgramPath();
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			} else if( ( path[0] == '~' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
#ifdef _WIN32
				here = OSALOT_GetEnvironmentVariable( "USERPROFILE" );
#else
				here = OSALOT_GetEnvironmentVariable( "HOME" );
#endif
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			} else if( ( path[0] == '*' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = ( *winfile_local ).data_file_root;
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			} else if( ( path[0] == ';' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = ( *winfile_local ).local_data_file_root;
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			} else if( path[0] == '?' && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				here = ( *winfile_local ).share_data_root;
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, "%s%s%s", here
				        , path[1] ? SYS_PATHCHAR : ""
				        , path[1]?path + 2:(path+1) );
			}
#if __ANDROID__
			{
				int len_base;
				TEXTCHAR here[256];
				size_t len;
				size_t ofs;
				GetCurrentPath( here, sizeof( here ) );
				if( StrStr( tmp_path, here ) )
					len = StrLen( here );
				else
					len = 0;
				/*
						if( (*winfile_local).flags.bLogOpenClose )
							lprintf( "Fix dots in [%s]", tmp_path );
						for( ofs = len+1; tmp_path[ofs]; ofs++ )
						{
							if( tmp_path[ofs] == '/' )
								tmp_path[ofs] = '.';
							if( tmp_path[ofs] == '\\' )
								tmp_path[ofs] = '.';
						}
						if( (*winfile_local).flags.bLogOpenClose )
						lprintf( "Fixed result [%s]", tmp_path );
					*/
			}
#endif
			if( tmp_path[0] == '~' && ( ( tmp_path[1] == '/' ) || ( tmp_path[1] == '\\' ) ) ) {
				CTEXTSTR here;
				size_t len;
				TEXTSTR tmp_;
#ifdef _WIN32
				here = OSALOT_GetEnvironmentVariable( "HOMEPATH" );
#else
				here = OSALOT_GetEnvironmentVariable( "HOME" );
#endif
				tmp_ = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( tmp_path ) ) );
				tnprintf( tmp_, len, "%s%s%s", here
				        , tmp_path[1] ? SYS_PATHCHAR : ""
				        , tmp_path[1]?tmp_path + 2:(tmp_path+1) );
				ReleaseEx( tmp_path DBG_SRC );
				tmp_path = tmp_;
			}
			if( tmp_path && StrChr( tmp_path, '%' ) != NULL ) {
				TEXTSTR freePath = tmp_path;
				tmp_path = ExpandPathVariable( tmp_path );
				ReleaseEx( freePath DBG_SRC );
			} else if( path && StrChr( path, '%' ) != NULL ) {
				tmp_path = ExpandPathVariable( path );
			}
		} else if( StrChr( path, '%' ) != NULL ) {
			tmp_path = ExpandPathVariable( path );
		} else {
			// is already duplicated, no changes were made.
			//tmp_path = StrDupEx( path DBG_RELAY );
		}
	}
	{
		TEXTSTR p = tmp_path;
		while( p[0] ) {
			if( p[0] == '/' || p[0] == '\\' )
				p[0] = SYSPATHCHAR[0];
			p++;
		}
	}
	squash_dotdot( tmp_path );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "output path is [%s]", tmp_path );
#endif
	return tmp_path;
}
#undef ExpandPathEx
TEXTSTR ExpandPathEx( CTEXTSTR path, struct file_system_interface* fsi ) {
	return ExpandPathExx( path, fsi DBG_SRC );
}
#define ExpandPathEx( path, fsi )  ExpandPathExx( path, fsi DBG_SRC )
#undef ExpandPath
TEXTSTR ExpandPath( CTEXTSTR path )
{
	return ExpandPathEx( path, NULL );
}
#define ExpandPath(path) ExpandPathExx( path, NULL DBG_SRC )
INDEX  SetGroupFilePath( CTEXTSTR group, CTEXTSTR path )
{
	struct Group* filegroup = GetGroupFilePath( group );
	if( !filegroup ) {
		TEXTCHAR tmp[256];
		filegroup = New( struct Group );
		filegroup->name = StrDup( group );
		filegroup->base_path = StrDup( path );
		tnprintf( tmp, sizeof( tmp ), "file group/%s", group );
#ifndef __NO_OPTIONS__
		if( ( *winfile_local ).have_default ) {
			TEXTCHAR tmp2[256];
			SACK_GetProfileString( GetProgramName(), tmp, "", tmp2, sizeof( tmp2 ) );
			if( StrCaseCmp( path, tmp2 ) )
				SACK_WriteProfileString( GetProgramName(), tmp, path );
		}
#endif
		AddLink( &( *winfile_local ).groups, filegroup );
		( *winfile_local ).have_default = TRUE;
	}
	else {
		Deallocate( TEXTCHAR*, filegroup->base_path );
		filegroup->base_path = StrDup( path );
	}
	return FindLink( &( *winfile_local ).groups, filegroup );
}
void SetDefaultFilePath( CTEXTSTR path )
{
	TEXTSTR tmp_path = NULL;
	struct Group* filegroup;
	LocalInit();
	filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, 0 );
	tmp_path = ExpandPath( path );
	if( ( *winfile_local ).groups && filegroup ) {
		Deallocate( TEXTSTR, filegroup->base_path );
		filegroup->base_path = StrDup( tmp_path ? tmp_path : path );
	}
	else {
		SetGroupFilePath( "Default", tmp_path ? tmp_path : path );
	}
	if( tmp_path )
		Deallocate( TEXTCHAR*, tmp_path );
}
static TEXTSTR PrependBasePathEx( INDEX groupid, struct Group* group, CTEXTSTR filename, LOGICAL expand_path )
{
	TEXTSTR real_filename = filename ? ExpandPath( filename ) : NULL;
	TEXTSTR fullname;
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "Prepend to {%s} %p %" _size_f, real_filename, group, groupid );
#endif
	if( ( *winfile_local ).groups ) {
		//SetDefaultFilePath( GetProgramPath() );
		if( !group ) {
			if( groupid < 4096 )
				group = ( struct Group* )GetLink( &( *winfile_local ).groups, groupid );
		}
	}
	if( !group || ( filename && ( IsAbsolutePath( real_filename ) ) ) ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "already an absolute path.  [%s]", real_filename );
#endif
		return real_filename;
	}
	{
		TEXTSTR tmp_path;
		size_t len;
		if( expand_path )
			tmp_path = ExpandPath( group->base_path );
		else
			tmp_path = group->base_path;
		fullname = NewArray( TEXTCHAR, len = StrLen( filename ) + StrLen( tmp_path ) + 2 );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "prepend %s[%s] with %s", group->base_path, tmp_path, filename );
#endif
		tnprintf( fullname, len, "%s" SYS_PATHCHAR "%s", tmp_path, real_filename );
		{
			// resolve recusive % paths...
			TEXTSTR tmp2 = ExpandPath( fullname );
			Deallocate( TEXTSTR, fullname );
			fullname = tmp2;
		}
#if __ANDROID__
		{
			int len_base;
			static TEXTCHAR here[256];
			static size_t len;
			size_t ofs;
			if( !here[0] ) {
				GetCurrentPath( here, sizeof( here ) );
			}
			if( StrStr( tmp_path, here ) )
				len = StrLen( here );
			else
				len = 0;
			/*
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( "Fix dots in [%s]", fullname );
				for( ofs = len+1; fullname[ofs]; ofs++ )
				{
					if( fullname[ofs] == '/' )
						fullname[ofs] = '.';
					if( fullname[ofs] == '\\' )
						fullname[ofs] = '.';
				}
			*/
		}
#endif
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "result %s", fullname );
#endif
		if( expand_path )
			Deallocate( TEXTCHAR*, tmp_path );
		Deallocate( TEXTCHAR*, real_filename );
	}
	return fullname;
}
static TEXTSTR PrependBasePath( INDEX groupid, struct Group* group, CTEXTSTR filename )
{
	return PrependBasePathEx( groupid, group, filename, TRUE );
}
TEXTSTR sack_prepend_path( INDEX group, CTEXTSTR filename )
{
	struct Group* filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
	TEXTSTR result = PrependBasePath( group, filegroup, filename );
	return result;
}
#ifdef __LINUX__
#define HANDLE int
#define INVALID_HANDLE_VALUE -1
#endif
void DetectUnicodeBOM( FILE* file ) {
	//00 00 FE FF     UTF-32, big-endian
	//FF FE 00 00     UTF-32, little-endian
	//FE FF           UTF-16, big-endian
	//FF FE           UTF-16, little-endian
	//EF BB BF        UTF-8
 //Encoding	Representation (hexadecimal)	Representation (decimal)	Bytes as CP1252 characters
 //UTF-8[t 1]		EF BB BF		239 187 191
 //UTF-16 (BE)		FE FF			254 255
 //UTF-16 (LE)		FF FE			255 254
 //UTF-32 (BE)		00 00 FE FF		0 0 254 255
 //UTF-32 (LE)		FF FE 00 00[t 2]	255 254 0 0
 //UTF-7[t 1]		2B 2F 76 38             43 47 118 56	+/v9
 //			2B 2F 76 39		43 47 118 43	+/v+
 //			2B 2F 76 2B             43 47 118 47	+/v/
 //			2B 2F 76 2F[t 3]	43 47 118 57	+/v8
 //			2B 2F 76 38 2D[t 4]	43 47 118 56 45	+/v8-
 //
 //UTF-1[t 1]		F7 64 4C	247 100 76
 //UTF-EBCDIC[t 1]	DD 73 66 73	221 115 102 115
 //SCSU[t 1]		0E FE FF[t 5]	14 254 255
 //BOCU-1[t 1]		FB EE 28	251 238 40
 //GB-18030[t 1]		84 31 95 33	132 49 149 51
	struct file* _file = ( struct file* )file;
	// file was opened with 't' flag, test what sort of 't' the file might be.
	// can result in conversion based on UNICODE (utf-16) compilation flag is set or not (UTF8).
	if( _file->textmode == TM_UNKNOWN ) {
		uint8_t bytes[5];
		size_t bytelength;
		_file->textmode = TM_BINARY;
		bytelength = sack_fread( bytes, 1, 5, file );
		sack_fseek( file, 0, SEEK_SET );
		if( bytelength < 5 ) {
			size_t n;
			for( n = bytelength; n < 5; n++ )
				bytes[n] = 0;
		}
		if( bytes[0] == 0xEF ) {
			// UTF8 test
			if( bytes[1] == 0xBB && bytes[2] == 0xBF ) {
				_file->textmode = TM_UTF8;
				sack_fseek( file, 3, SEEK_SET );
			}
			else {
				_file->textmode = TM_UTF8;
			}
		}
		else if( bytes[0] == 0xFF ) {
			// UTF32/16 LE test
			if( bytes[1] == 0xFE ) {
				if( bytes[2] == 0 && bytes[3] == 0 ) {
					_file->textmode = TM_UTF32LE;
				}
			}
		}
		else if( bytes[0] == 0xFE ) {
			// UTF16ZBE test
			if( bytes[1] == 0xFF ) {
				_file->textmode = TM_UTF16BE;
			}
			else {
				_file->textmode = TM_UTF8;
			}
		}
		else if( bytes[0] == 0 && bytes[1] == 0 ) {
			// UTF32BE test...
			if( bytes[2] == 0xFE && bytes[3] == 0xFF ) {
				_file->textmode = TM_UTF32BE;
			}
			else
				_file->textmode = TM_UTF8;
		}
		else {
		}
	}
}
static void DecodeFopenOpts( struct file* file, CTEXTSTR opts ) {
	CTEXTSTR op = opts;
	for( ; op[0]; op++ ) {
		if( op[0] == 'w' || op[0] == 'a' || op[0] == 'r' || op[0] == '+' )
			continue;
		if( op[0] == ' ' ) continue;
		if( op[0] == 't' ) {
			file->textmode = TM_UNKNOWN;
		}
		else if( op[0] == 'b' ) {
 // also the default.
			file->textmode = TM_BINARY;
		}
		else if( op[0] == ',' ) {
			const char* restore = op;
			op++;
			while( op[0] == ' ' ) op++;
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 's' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( op[0] == '=' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( StrCaseCmpEx( op, "unicode", 7 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
				op += 6;
			}
			else if( StrCaseCmpEx( op, "utf-16le", 8 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
				op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-8", 5 ) == 0 ) ) {
				file->textmode = TM_UTF8;
 // minus 1, becuase for loop will increment.
				op += 4;
			}
			else if( ( StrCaseCmpEx( op, "utf-16be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF16BE;
 // minus 1, becuase for loop will increment.
				op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32le", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32LE;
 // minus 1, becuase for loop will increment.
				op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32BE;
 // minus 1, becuase for loop will increment.
				op += 7;
			}
		}
	}
}
HANDLE sack_open( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE handle;
	struct file* file;
	INDEX idx;
	EnterCriticalSec( &( *winfile_local ).cs_files );
	LIST_FORALL( ( *winfile_local ).files, idx, struct file*, file )
	{
		if( StrCmp( file->name, filename ) == 0 ) {
			break;
		}
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	if( !file ) {
		struct Group* filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
		file = New( struct file );
		file->deleted = file->delete_on_close = 0;
		file->name = StrDup( filename );
		file->fullname = PrependBasePath( group, filegroup, filename );
		file->wfullname = CharWConvert( file->fullname );
		file->handles = NULL;
		file->files = NULL;
		file->group = group;
		EnterCriticalSec( &( *winfile_local ).cs_files );
		AddLink( &( *winfile_local ).files, file );
		LeaveCriticalSec( &( *winfile_local ).cs_files );
	}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "Open File: [%s]", file->fullname );
#endif
#ifdef __LINUX__
#  undef open
	{
		handle = open( file->fullname, opts );
	}
#  if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "open %s %d %d", file->fullname, handle, opts );
#  endif
#else
	switch( opts & 3 ) {
	case 0:
	default:
		handle = CreateFileW( file->wfullname
			, GENERIC_READ
			, FILE_SHARE_READ
			, NULL
			, ( ( opts & O_CREAT ) ? CREATE_ALWAYS : OPEN_EXISTING )
			, FILE_ATTRIBUTE_NORMAL
			, NULL );
		break;
	case 1:
		handle = CreateFileW( file->wfullname
			, GENERIC_WRITE
			, FILE_SHARE_READ | FILE_SHARE_WRITE
			, NULL
			, ( ( opts & O_CREAT ) ? CREATE_ALWAYS : OPEN_EXISTING )
			, FILE_ATTRIBUTE_NORMAL
			, NULL );
		break;
	case 2:
	case 3:
		handle = CreateFileW( file->wfullname
			, ( GENERIC_READ | GENERIC_WRITE )
			, FILE_SHARE_READ | FILE_SHARE_WRITE
			, NULL
			, ( ( opts & O_CREAT ) ? CREATE_ALWAYS : OPEN_EXISTING )
			, FILE_ATTRIBUTE_NORMAL
			, NULL );
		break;
	}
#  if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "open %s %p %08x", file->fullname, (POINTER)handle, opts );
#  endif
#endif
	if( handle == INVALID_HANDLE_VALUE ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "Failed to open file [%s]=[%s]", file->name, file->fullname );
#endif
		return INVALID_HANDLE_VALUE;
	}
	if( handle != INVALID_HANDLE_VALUE ) {
		HANDLE* holder = New( HANDLE );
		holder[0] = handle;
		AddLink( &file->handles, holder );
	}
	return handle;
}
struct file* FindFileByHandle( HANDLE file_file )
{
	struct file* file;
	INDEX idx;
	EnterCriticalSec( &( *winfile_local ).cs_files );
	LIST_FORALL( ( *winfile_local ).files, idx, struct file*, file )
	{
		INDEX idx2;
		HANDLE* check;
		LIST_FORALL( file->handles, idx2, HANDLE*, check )
		{
			if( check[0] == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	return file;
}
//----------------------------------------------------------------------------
LOGICAL sack_iset_eof( INDEX file_handle )
{
	HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
	HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef _WIN32
	return SetEndOfFile( handle );
#else
	return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
}
//----------------------------------------------------------------------------
struct file* FindFileByFILE( FILE* file_file )
{
	struct file* file;
	INDEX idx;
	// this should have initialized a long time before here...
	//LocalInit();
	EnterCriticalSec( &( *winfile_local ).cs_files );
	LIST_FORALL( ( *winfile_local ).files, idx, struct file*, file )
	{
		INDEX idx2;
		FILE* check;
		LIST_FORALL( file->files, idx2, FILE*, check )
		{
			if( check == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	return file;
}
//----------------------------------------------------------------------------
struct file* FindFileByName( INDEX group, char const* filename, struct file_system_mounted_interface* mount, INDEX* allocedIndex )
{
	struct file* file;
	INDEX idx;
	LocalInit();
	EnterCriticalSec( &( *winfile_local ).cs_files );
	//lprintf( "Find file: %s in %p", filename, winfile_local->files );
	LIST_FORALL( ( *winfile_local ).files, idx, struct file*, file )
	{
		//lprintf( "Is it %d %d %s?", !mount, file->mount == mount, file->name );
		if( ( file->group == group )
			&& ( PathCmp( file->name, filename ) == 0 )
			&& ( ( !mount ) || file->mount == mount ) ) {
			if( allocedIndex ) {
				AddLink( &file->files, allocedIndex );
				allocedIndex[0] = FindLink( &file->files, allocedIndex );
			}
			break;
		}
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	//if( file ) lprintf( "found file" ); else lprintf( "file not found" );
	return file;
}
//----------------------------------------------------------------------------
LOGICAL sack_set_eof( HANDLE file_handle )
{
	struct file* file;
	file = FindFileByFILE( (FILE*)(uintptr_t)file_handle );
	if( file ) {
		if( file->mount ) {
			file->mount->fsi->truncate( (void*)(uintptr_t)file_handle );
			//lprintf( "result is %d", file->mount->fsi->size( (void*)file_handle ) );
		}
		else {
#ifdef _WIN32
			;
#else
			truncate( file->fullname, sack_ftell( (FILE*)(uintptr_t)file_handle ) );
#endif
		}
		return TRUE;
	}
	else {
		HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, (INDEX)file_handle );
		HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef _WIN32
		return SetEndOfFile( handle );
#else
		return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_ftruncate( FILE* file_file )
{
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file ) {
		if( file->mount && file->mount->fsi ) {
			file->mount->fsi->truncate( (void*)file_file );
			//lprintf( "result is %d", file->mount->fsi->size( (void*)file_file ) );
		}
		else {
#ifdef _WIN32
			return _chsize( _fileno( file_file ), ftell( file_file ) ) == 0;
#else
			return truncate( file->fullname, sack_ftell( (FILE*)file_file ) ) == 0;
#endif
		}
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
long sack_tell( INDEX file_handle )
{
	HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
	HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef WIN32
 // must have GENERIC_READ and/or GENERIC_WRITE
	uint32_t length = SetFilePointer( handle
	// do not move pointer
		, 0
  // hFile is not large enough to need this pointer
		, NULL
  // provides offset from current position
		, FILE_CURRENT );
	return length;
#else
	return lseek( handle, 0, SEEK_SET );
#endif
}
//----------------------------------------------------------------------------
HANDLE sack_creat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_open( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_lseek( HANDLE file_handle, int pos, int whence )
{
#ifdef _WIN32
	return SetFilePointer( file_handle, pos, NULL, whence );
#else
	return lseek( file_handle, pos, whence );
#endif
}
//----------------------------------------------------------------------------
int sack_read( HANDLE file_handle, POINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastReadResult;
	//lprintf( "..." );
	return ( ReadFile( (HANDLE)file_handle, buffer, size, &dwLastReadResult, NULL ) ? dwLastReadResult : -1 );
#else
	return read( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
int sack_write( HANDLE file_handle, CPOINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastWrittenResult;
	return ( WriteFile( (HANDLE)file_handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL ) ? dwLastWrittenResult : -1 );
#else
	return write( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
INDEX sack_icreat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_iopen( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_close( HANDLE file_handle )
{
	struct file* file = FindFileByHandle( (HANDLE)file_handle );
	if( file ) {
		SetLink( &file->handles, (INDEX)file_handle, NULL );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "Close %s", file->fullname );
#endif
		Deallocate( wchar_t*, file->wfullname );
		/*
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file );
		DeleteLink( &(*winfile_local).files, file );
		*/
	}
	if( file_handle != INVALID_HANDLE_VALUE )
#ifdef _WIN32
		return CloseHandle( (HANDLE)file_handle );
#else
		return close( file_handle );
#endif
	return 0;
}
//----------------------------------------------------------------------------
INDEX sack_iopen( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE h;
	INDEX result;
	h = sack_open( group, filename, opts );
	if( h == INVALID_HANDLE_VALUE ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "Failed to open %s", filename );
#endif
		return INVALID_INDEX;
	}
	EnterCriticalSec( &( *winfile_local ).cs_files );
	{
		HANDLE* holder = New( HANDLE );
		holder[0] = h;
		AddLink( &( *winfile_local ).handles, holder );
		result = FindLink( &( *winfile_local ).handles, holder );
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "return iopen of [%s]=%p(%" _size_f ")?", filename, (void*)(uintptr_t)h, (size_t)result );
#endif
	return result;
}
//----------------------------------------------------------------------------
int sack_iclose( INDEX file_handle )
{
	int result;
	EnterCriticalSec( &( *winfile_local ).cs_files );
	{
		HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
		HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
		SetLink( &( *winfile_local ).handles, file_handle, 0 );
		Deallocate( HANDLE*, holder );
		result = sack_close( handle );
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_ilseek( INDEX file_handle, size_t pos, int whence )
{
	int result;
	EnterCriticalSec( &( *winfile_local ).cs_files );
	{
		HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
		HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef _WIN32
		result = SetFilePointer( handle, (LONG)pos, ( (PLONG)&pos ) + 1, whence );
#else
		result = lseek( handle, pos, whence );
#endif
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_iread( INDEX file_handle, POINTER buffer, int size )
{
	EnterCriticalSec( &( *winfile_local ).cs_files );
	{
		HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
		HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastReadResult;
		//lprintf( "... %p %p", file_handle, h );
		LeaveCriticalSec( &( *winfile_local ).cs_files );
		return ( ReadFile( handle, (POINTER)buffer, size, &dwLastReadResult, NULL ) ? dwLastReadResult : -1 );
#else
		return read( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_iwrite( INDEX file_handle, CPOINTER buffer, int size )
{
	EnterCriticalSec( &( *winfile_local ).cs_files );
	{
		HANDLE* holder = (HANDLE*)GetLink( &( *winfile_local ).handles, file_handle );
		HANDLE handle = holder ? holder[0] : INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastWrittenResult;
		LeaveCriticalSec( &( *winfile_local ).cs_files );
		return ( WriteFile( handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL ) ? dwLastWrittenResult : -1 );
#else
		return write( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_unlinkEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount )
{
	int noMount = 0;
	if( !mount ) {
		if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
		mount = FileSysThreadInfo.mounted_file_systems;
	}
	if( !mount )
		noMount = 1;
	while( mount || noMount ) {
		int okay = 1;
		if( mount->fsi ) {
			if( mount->fsi->exists( mount->psvInstance, filename ) ) {
				mount->fsi->_unlink( mount->psvInstance, filename );
				okay = 0;
			}
		}
		else {
			TEXTSTR tmp = PrependBasePath( group, NULL, filename );
			okay = sack_filesys_unlink( 0, filename );
			Deallocate( TEXTCHAR*, tmp );
		}
		if( !okay )
			return !okay;
		if( !noMount )
			mount = mount->nextLayer;
		else
			break;
	}
	return 0;
}
//----------------------------------------------------------------------------
int sack_unlink( INDEX group, CTEXTSTR filename )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	return sack_unlinkEx( group, filename, FileSysThreadInfo.mounted_file_systems );
}
//----------------------------------------------------------------------------
int sack_chdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount ) {
	struct Group* filegroup;
	int okay = 0;
	if( mount ) {
		if( mount->fsi && mount->fsi->_chdir ) {
			okay = mount->fsi->_chdir( mount->psvInstance, filename );
		}
	} else {
		filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
		if( ( *winfile_local ).groups && filegroup ) {
			Deallocate( TEXTSTR, filegroup->base_path );
			filegroup->base_path = StrDup( filename );
			okay = 1;
		}
		okay |= SetCurrentPath( filename );
	}
	return okay;
}
//----------------------------------------------------------------------------
int sack_mkdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount ) {
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
	while( mount ) {
		int okay = 0;
		if( !mount->writeable ) {
			mount = mount->nextLayer; continue;
		}
		if( mount->fsi && mount->fsi->is_directory ) {
			if( mount->fsi->is_directory( mount->psvInstance, tmp ) ) {
#if defined( WIN32 ) && defined( MSCVER )
				_set_doserrno( EEXIST );
#else
				errno = EEXIST;
#endif
				return FALSE;
			}
		}
		if( mount->fsi && mount->fsi->_mkdir ) {
			okay = mount->fsi->_mkdir( mount->psvInstance, tmp );
			if( okay ) {
				{
					struct directory* d;
					INDEX i;
					LIST_FORALL( ( *winfile_local ).directories, i, struct directory*, d ) {
						if( strcmp( d->name, filename ) == 0 ) {
							d->deleted = 0;
							break;
						}
					}
					if( !d ) {
						d = New( struct directory );
						d->name = StrDup( filename );
						d->fullname = (TEXTSTR)Hold( tmp );
						d->mount = mount;
						d->wfullname = CharWConvert( d->fullname );
						d->deleted = 0;
						AddLink( &( *winfile_local ).directories, d );
					}
				}
			}
		}
		if( okay ) {
			Deallocate( TEXTCHAR*, tmp );
			return !okay;
		}
		mount = mount->nextLayer;
	}
	Deallocate( TEXTCHAR*, tmp );
	return 0;
}
int sack_mkdir( INDEX group, CTEXTSTR filename ) {
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	return sack_mkdirEx( group, filename, FileSysThreadInfo.mounted_file_systems );
}
static int sack_filesys_mkdir( uintptr_t psv, CTEXTSTR filename )
{
	return MakePath( filename );
}
//----------------------------------------------------------------------------
int sack_rmdirEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface* mount ) {
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
	while( mount ) {
		int okay = 1;
		if( !mount->writeable ) {
			mount = mount->nextLayer; continue;
		}
		{
			struct directory* d;
			INDEX i;
			LIST_FORALL( ( *winfile_local ).directories, i, struct directory*, d ) {
				if( d->mount == mount && strcmp( d->name, filename ) == 0 ) {
					d->deleted = 1;
					break;
				}
			}
		}
		if( mount->fsi && mount->fsi->_rmdir ) {
			okay = mount->fsi->_rmdir( mount->psvInstance, tmp );
		}
		if( okay ) {
			Deallocate( TEXTCHAR*, tmp );
			return okay;
		}
		mount = mount->nextLayer;
	}
	Deallocate( TEXTCHAR*, tmp );
 // lie... we'll try to take care of that directory later, if they close the file in it.
	return 1;
}
int sack_rmdir( INDEX group, CTEXTSTR filename ) {
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	return sack_rmdirEx( group, filename, FileSysThreadInfo.mounted_file_systems );
}
static int sack_filesys_chdir( uintptr_t psv, CTEXTSTR filename ){
	return SetCurrentPath( filename );
}
static int sack_filesys_rmdir( uintptr_t psv, CTEXTSTR filename )
{
#ifdef __LINUX__
	int okay;
	okay = rmdir( filename );
	// unlink returns TRUE is 0, else error...
	return !okay;
#else
	int okay;
	//TEXTSTR tmp = PrependBasePath( group, NULL, filename );
	wchar_t* wfilename = CharWConvert( filename );
	okay = _wrmdir( wfilename );
	Deallocate( wchar_t*, wfilename );
 // unlink returns TRUE is 0, else error...
	return !okay;
#endif
}
#undef open
#undef fopen
//----------------------------------------------------------------------------
FILE* sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface* mount )
{
	FILE* handle = NULL;
	struct file* file;
	INDEX allocedIndex = INVALID_INDEX;
	LOGICAL memalloc = FALSE;
	LOGICAL single_mount = ( mount != NULL );
	LocalInit();
	EnterCriticalSec( &( *winfile_local ).cs_files );
	if( !mount ) {
		if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
		mount = FileSysThreadInfo.mounted_file_systems;
	}
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
  // skip roms...
		while( mount ) {
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->nextLayer;
		}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "open %s %p(%s) %s (%d)", filename, mount, mount?mount->name:"", opts, mount ? mount->writeable : 1 );
#endif
	file = FindFileByName( group, filename, mount, &allocedIndex );
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	if( !file ) {
		TEXTSTR tmpname = NULL;
		struct Group* filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
		file = New( struct file );
		file->deleted = file->delete_on_close = 0;
		memalloc = TRUE;
		DecodeFopenOpts( file, opts );
		if( !StrChr( opts, 'n' ) && StrChr( filename, '%' ) ) {
			tmpname = ExpandPathVariable( filename );
			filename = tmpname;
		}
		if( !StrChr( opts, 'n' ) && ( filename[0] == '@' ) || ( filename[0] == '*' ) || ( filename[0] == '~' ) ) {
			tmpname = ExpandPathEx( filename, NULL );
			filename = tmpname;
		}
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->mount = mount;
		if( ( !file->mount || !file->mount->fsi ) && !IsAbsolutePath( filename ) ) {
			tmpname = ExpandPath( filename );
			file->fullname = PrependBasePath( group, filegroup, tmpname );
			Deallocate( TEXTCHAR*, tmpname );
		}
		else {
			if( mount && group == 0 ) {
				file->fullname = ExpandPath( file->name );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
//				if( ( *winfile_local ).flags.bLogOpenClose )
//					lprintf( "full is %s", file->fullname );
#endif
			}
			else {
				TEXTSTR tmp;
				tmp = PrependBasePathEx( group, filegroup, file->name, !mount );
				file->fullname = ExpandPath( tmp );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
//				if( ( *winfile_local ).flags.bLogOpenClose )
//					lprintf( "full is %s %d", file->fullname, (int)group );
#endif
				Deallocate( TEXTSTR, tmp );
			}
			//file->fullname = file->name;
		}
		file->group = group;
		if( !StrChr( opts, 'n' ) && StrChr( file->fullname, '%' ) ) {
			if( allocedIndex != INVALID_INDEX )
				SetLink( &file->files, allocedIndex, NULL );
 // was a brand new file anway
			if( memalloc ) {
				DeleteLink( &( *winfile_local ).files, file );
				Deallocate( TEXTCHAR*, file->name );
				Deallocate( TEXTCHAR*, file->fullname );
				DeleteListEx( &file->files DBG_SRC );
				Deallocate( struct file*, file );
			}
			//DebugBreak();
			return NULL;
		}
		{
			char* name;
			for( name = file->name; name[0]; name++ ) {
				if( name[0] == '/' ) name[0] = SYSPATHCHAR[0];
			}
		}
		{
			char* name;
			for( name = file->fullname; name[0]; name++ ) {
				if( name[0] == '/' ) name[0] = SYSPATHCHAR[0];
			}
		}
		EnterCriticalSec( &( *winfile_local ).cs_files );
		//lprintf( "Adding file to winfile_local.files... %p", winfile_local->files);
		AddLink( &( *winfile_local ).files, file );
		allocedIndex = 0;
		LeaveCriticalSec( &( *winfile_local ).cs_files );
	}
	else {
 // file is undeleted now.
		file->deleted = 0;
	}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "Open File: [%s]", file->fullname );
#endif
	if( mount && mount->fsi ) {
		if( ( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) ) || !StrChr( opts, 'w' ) ) {
			struct file_system_mounted_interface* test_mount = mount;
			while( !handle && test_mount ) {
				if( test_mount->fsi ) {
					file->mount = test_mount;
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
//					if( ( *winfile_local ).flags.bLogOpenClose )
//						lprintf( "Call mount %s to check if file exists %s", test_mount->name, file->fullname );
#endif
					if( test_mount->fsi->exists( test_mount->psvInstance, file->fullname ) ) {
						handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, file->fullname, opts );
					}
					else {
						errno = ENOENT;
						if( single_mount ) {
							if( allocedIndex != INVALID_INDEX )
								SetLink( &file->files, allocedIndex, NULL );
								return NULL;
						}
					}
				}
				test_mount = test_mount->nextLayer;
			}
			SetLink( &file->files, allocedIndex, handle );
		}
		else {
			struct file_system_mounted_interface* test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount ) {
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
//					if( ( *winfile_local ).flags.bLogOpenClose )
//						lprintf( "Call mount %s to open file %s", test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, file->fullname, opts );
				}
				test_mount = test_mount->nextLayer;
			}
			SetLink( &file->files, allocedIndex, handle );
		}
	}
	if( !GetLinkCount( file->files ) ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "Failed to open file [%s]=[%s]", file->name, file->fullname );
#endif
		DeleteLink( &( *winfile_local ).files, file );
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file->fullname );
		DeleteListEx( &file->files DBG_SRC );
		Deallocate( struct file*, file );
		return NULL;
	}
	//AddLink( &file->files, handle );
	return handle;
}
//----------------------------------------------------------------------------
FILE* sack_fopen( INDEX group, CTEXTSTR filename, CTEXTSTR opts )
{
	return sack_fopenEx( group, filename, opts, NULL );
}
//----------------------------------------------------------------------------
FILE* sack_fsopenEx( INDEX group
	, CTEXTSTR filename
	, CTEXTSTR opts
	, int share_mode
	, struct file_system_mounted_interface* mount )
{
	FILE* handle = NULL;
	struct file* file;
	INDEX idx;
	LOGICAL single_mount = ( mount != NULL );
	LocalInit();
	EnterCriticalSec( &( *winfile_local ).cs_files );
	if( !mount ) {
		if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
		mount = FileSysThreadInfo.mounted_file_systems;
	}
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
  // skip roms...
		while( mount ) {
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->nextLayer;
		}
	LIST_FORALL( ( *winfile_local ).files, idx, struct file*, file )
	{
		if( ( file->group == group )
			&& ( StrCmp( file->name, filename ) == 0 )
			&& ( file->mount == mount ) ) {
			break;
		}
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	if( !file ) {
		struct Group* filegroup = ( struct Group* )GetLink( &( *winfile_local ).groups, group );
		file = New( struct file );
		DecodeFopenOpts( file, opts );
		file->deleted = file->delete_on_close = 0;
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->group = group;
		file->mount = mount;
		if( !mount || !mount->fsi )
			file->fullname = PrependBasePath( group, filegroup, filename );
		else
			file->fullname = StrDup( filename );
		EnterCriticalSec( &( *winfile_local ).cs_files );
		AddLink( &( *winfile_local ).files, file );
		LeaveCriticalSec( &( *winfile_local ).cs_files );
	}
	if( mount && mount->fsi ) {
		if( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) || !StrChr( opts, 'w' ) ) {
			struct file_system_mounted_interface* test_mount = mount;
			while( !handle && test_mount && test_mount->fsi ) {
				file->mount = test_mount;
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( ( *winfile_local ).flags.bLogOpenClose )
					lprintf( "Call mount %s to check if file exists %s", test_mount->name, file->fullname );
#endif
				if( test_mount->fsi->exists( test_mount->psvInstance, file->fullname ) ) {
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, file->fullname, opts );
				}
				if( !handle && single_mount ) {
					return NULL;
				}
				test_mount = test_mount->nextLayer;
			}
		}
		else {
			struct file_system_mounted_interface* test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount ) {
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
//					if( ( *winfile_local ).flags.bLogOpenClose )
//						lprintf( "Call mount %s to open file %s", test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, file->fullname, opts );
				}
				test_mount = test_mount->nextLayer;
			}
		}
	}
	if( !handle ) {
		return handle;
	}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "sack_open %s (%s)", file->fullname, opts );
#endif
	EnterCriticalSec( &( *winfile_local ).cs_files );
	AddLink( &file->files, handle );
	LeaveCriticalSec( &( *winfile_local ).cs_files );
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( ( *winfile_local ).flags.bLogOpenClose )
		lprintf( "Added FILE* %p and list is %p", handle, file->files );
#endif
	return handle;
}
//----------------------------------------------------------------------------
FILE* sack_fsopen( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode )
{
/*FileSysThreadInfo.mounted_file_systems*/
	return sack_fsopenEx( group, filename, opts, share_mode, NULL );
}
//----------------------------------------------------------------------------
static size_t sack_fsizeEx( FILE* file_file, struct file_system_mounted_interface* mount )
{
	if( mount && mount->fsi )
		return mount->fsi->size( file_file );
	return (size_t)0;
}
size_t sack_fsize( FILE* file_file ) {
	struct file* file;
	file = FindFileByFILE( file_file );
	return sack_fsizeEx( file_file, file ? file->mount : NULL );
}
static size_t sack_ftellEx( FILE* file_file, struct file_system_mounted_interface* mount )
{
	if( mount && mount->fsi )
		return mount->fsi->tell( file_file );
	return ftell( file_file );
}
size_t sack_ftell( FILE* file_file ) {
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_ftellEx( file_file, file->mount );
	return sack_ftellEx( file_file, NULL );
}
size_t  sack_fseekEx( FILE* file_file, size_t pos, int whence, struct file_system_mounted_interface* mount )
{
	if( mount && mount->fsi ) {
		return mount->fsi->seek( file_file, pos, whence );
	}
	if( fseek( file_file, (long)pos, whence ) )
		return -1;
	//struct file *file = FindFileByFILE( file_file );
	return ftell( file_file );
}
size_t  sack_fseek( FILE* file_file, size_t pos, int whence ) {
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_fseekEx( file_file, pos, whence, file->mount );
	return sack_fseekEx( file_file, pos, whence, NULL );
}
static int  sack_fflushEx( FILE* file_file, struct file_system_mounted_interface* mount )
{
	if( mount && mount->fsi ) {
		return mount->fsi->flush( file_file );
		//DeleteLink( &file->files, file_file );
		//file->fsi->close( file_file );
		//file_file = (FILE*)file->fsi->open( file->fullname );
		//AddLink( &file->files, file_file );
		//return 0;
	}
	return fflush( file_file );
}
int  sack_fflush( FILE* file_file )
{
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi ) {
		return sack_fflushEx( file_file, file->mount );
	}
	return fflush( file_file );
}
//----------------------------------------------------------------------------
int  sack_fclose( FILE* file_file )
{
	struct file* file;
	if( !file_file ) return -1;
	EnterCriticalSec( &( *winfile_local ).cs_files );
	file = FindFileByFILE( file_file );
	if( file ) {
		int status;
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "Closing %s", file->fullname );
#endif
		if( file->mount && file->mount->fsi )
			status = file->mount->fsi->_close( file_file );
		else {
			status = fclose( file_file );
			if( file->deleted ) {
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( ( *winfile_local ).flags.bLogOpenClose )
					lprintf( "deleted FILE* %p to be actually deleted...", file_file );
#endif
				sack_unlink( 0, file->fullname );
			}
		}
#if !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( ( *winfile_local ).flags.bLogOpenClose )
			lprintf( "deleted FILE* %p and list is %p", file_file, file->files );
#endif
		DeleteLink( &file->files, file_file );
		if( !GetLinkCount( file->files ) ) {
			DeleteLink( &( *winfile_local ).files, file );
			LeaveCriticalSec( &( *winfile_local ).cs_files );
			DeleteListEx( &file->files DBG_SRC );
			Deallocate( TEXTCHAR*, file->name );
			Deallocate( TEXTCHAR*, file->fullname );
			Deallocate( struct file*, file );
		}
		else
			LeaveCriticalSec( &( *winfile_local ).cs_files );
		return status;
	}
	LeaveCriticalSec( &( *winfile_local ).cs_files );
	return fclose( file_file );
}
//----------------------------------------------------------------------------
/*
static void transcodeOutputText( struct file* file, POINTER buffer, size_t size, POINTER* outbuf, size_t* outsize ) {
}
//----------------------------------------------------------------------------
static void transcodeInputText( struct file* file, POINTER buffer, size_t size, POINTER* outbuf, size_t* outsize ) {
}
*/
//----------------------------------------------------------------------------
size_t  sack_fread( POINTER buffer, size_t size, int count, FILE* file_file )
{
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return file->mount->fsi->_read( file_file, (char*)buffer, size * count );
	return fread( buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
size_t  sack_fwrite( CPOINTER buffer, size_t size, int count, FILE* file_file )
{
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi ) {
		size_t result;
		if( file->mount->fsi->copy_write_buffer && file->mount->fsi->copy_write_buffer() ) {
			POINTER dupbuf = malloc( size * count + 3 );
#ifdef _MSC_VER
#  pragma warning( disable: 6387 )
#endif
			memcpy( dupbuf, buffer, size * count );
			result = file->mount->fsi->_write( file_file, (const char*)dupbuf, size * count );
			free( dupbuf );
		}
		else
			result = file->mount->fsi->_write( file_file, (const char*)buffer, size * count );
		return result;
	}
	return fwrite( (POINTER)buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
TEXTSTR sack_fgets( TEXTSTR buffer, size_t size, FILE* file_file )
{
#ifdef _UNICODE
	//char *tmpbuf = NewArray( char, size+1);
	//TEXTSTR tmp_wbuf;
	fgets( (char*)buffer, size, file_file );
	//tmp_wbuf = CharWConvert( tmpbuf );
	//StrCpyEx( buffer, tmp_wbuf, size );
	return buffer;
#else
	struct file* file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi ) {
		size_t n;
		char* output = buffer;
		size = size - 1;
		buffer[size] = 0;
		for( n = 0; n < size; n++ ) {
			if( file->mount->fsi->_read( file_file, output, 1 ) ) {
				if( output[0] == '\n' ) {
					output[1] = 0;
					return buffer;
				}
				output++;
			}
			else {
				output[0] = 0;
				return NULL;
			}
		}
		if( n )
			return buffer;
		return NULL;
	}
	return fgets( buffer, (int)size, file_file );
#endif
}
//----------------------------------------------------------------------------
LOGICAL sack_existsEx( const char* filename, struct file_system_mounted_interface* mount )
{
	FILE* tmp;
	if( mount && mount->fsi && mount->fsi->exists ) {
		int result = mount->fsi->exists( mount->psvInstance, filename );
		return result;
	}
	else {
		{
			struct file* file = FindFileByName( 0, filename, mount, NULL );
			if( file )
				if( file->deleted ) return FALSE;
		}
#ifdef WIN32
		wchar_t* wfilename = CharWConvert( filename );
		{ wchar_t* tmp; if( LONG_PATHCHAR ) for( tmp = wfilename; tmp[0]; tmp++ ) if( tmp[0] == '/' ) tmp[0] = LONG_PATHCHAR; }
		if( ( tmp = _wfopen( wfilename, L"rb" ) ) )
#else
		if( ( tmp = fopen( filename, "rb" ) ) )
#endif
		{
			fclose( tmp );
#ifdef WIN32
			Deallocate( wchar_t*, wfilename );
#endif
			return TRUE;
		}
#ifdef WIN32
		Deallocate( wchar_t*, wfilename );
#endif
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_exists( const char* filename )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	struct file_system_mounted_interface* mount = FileSysThreadInfo.mounted_file_systems;
	while( mount ) {
		if( sack_existsEx( filename, mount ) ) {
			( *winfile_local ).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->nextLayer;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPathEx( const char* filename, struct file_system_mounted_interface* mount )
{
	if( mount && mount->fsi && mount->fsi->is_directory ) {
		{
			struct directory* d;
			INDEX i;
			LIST_FORALL( ( *winfile_local ).directories, i, struct directory*, d ) {
				if( d->mount == mount && strcmp( d->name, filename ) == 0 ) {
					if( d->deleted ) return FALSE;
					break;
				}
			}
		}
		int result = mount->fsi->is_directory( mount->psvInstance, filename );
		return result;
	} else if( !mount || !mount->fsi ) return sack_isPath( filename );
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPath( const char* filename )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	struct file_system_mounted_interface* mount = FileSysThreadInfo.mounted_file_systems;
	while( mount ) {
		if( sack_isPathEx( filename, mount ) ) {
			( *winfile_local ).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->nextLayer;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
int  sack_renameEx( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface* mount )
{
	int status;
	if( mount && mount->fsi ) {
		return mount->fsi->rename( mount->psvInstance, file_source, new_name );
	}
	else {
		TEXTSTR tmp_src = ExpandPath( file_source );
		TEXTSTR tmp_dst = ExpandPath( new_name );
#ifdef WIN32
		status = MoveFile( tmp_src, tmp_dst );
#else
#  ifdef UNICODE
		{
			char* tmpnames = CStrDup( tmp_src );
			char* tmpnamed = CStrDup( tmp_dst );
			status = rename( tmpnames, tmpnamed );
			Deallocate( char*, tmpnames );
			Deallocate( char*, tmpnamed );
		}
#  else
		status = rename( tmp_src, tmp_dst );
#  endif
#endif
		Deallocate( TEXTSTR, tmp_src );
		Deallocate( TEXTSTR, tmp_dst );
	}
	return status;
}
//----------------------------------------------------------------------------
int  sack_rename( CTEXTSTR file_source, CTEXTSTR new_name )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	return sack_renameEx( file_source, new_name, FileSysThreadInfo.mounted_file_systems );
}
//----------------------------------------------------------------------------
size_t GetSizeofFile( TEXTCHAR * name, uint32_t * unused )
{
	size_t size;
#ifdef __LINUX__
#  ifdef UNICODE
	char* tmpname = CStrDup( name );
		  // open MYFILE.TXT
	int hFile = open( tmpname,
			 // open for reading
		O_RDONLY );
	Deallocate( char*, tmpname );
#  else
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
		O_RDONLY );
#  endif
	if( hFile >= 0 ) {
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return 0;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	if( hFile != INVALID_HANDLE_VALUE ) {
		size = GetFileSize( hFile, (DWORD*)unused );
		if( sizeof( size ) > 4 && unused )
			size |= (uint64_t)( *unused ) << 32;
		CloseHandle( hFile );
		return size;
	}
	else
		return 0;
#endif
}
//-------------------------------------------------------------------------
uint32_t GetFileTimeAndSize( CTEXTSTR name
	, LPFILETIME lpCreationTime
	, LPFILETIME lpLastAccessTime
	, LPFILETIME lpLastWriteTime
	, int* IsDirectory
)
{
	uint32_t size;
#ifdef __LINUX__
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
		O_RDONLY );
	if( hFile >= 0 ) {
		struct stat statbuf;
		fstat( hFile, &statbuf );
		if( lpCreationTime )
			lpCreationTime[0] = statbuf.st_ctime;
		if( lpLastAccessTime )
			lpLastAccessTime[0] = statbuf.st_atime;
		if( lpLastWriteTime )
			lpLastWriteTime[0] = statbuf.st_mtime;
		//convert( &realtime, (time_t*)&statbuf.st_mtime );
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return 0;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	uint32_t extra_size;
	if( hFile != INVALID_HANDLE_VALUE ) {
		size = GetFileSize( hFile, (DWORD*)&extra_size );
		GetFileTime( hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime );
		if( IsDirectory ) {
			uint32_t dwAttr = GetFileAttributes( name );
			if( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
				( *IsDirectory ) = 1;
			else
				( *IsDirectory ) = 0;
		}
		CloseHandle( hFile );
		return size;
	}
	else
		return 0;
#endif
}
struct file_system_interface* sack_get_filesystem_interface( CTEXTSTR name )
{
	struct file_interface_tracker* fit;
	INDEX idx;
	LIST_FORALL( ( *winfile_local ).file_system_interface, idx, struct file_interface_tracker*, fit )
	{
		if( StrCaseCmp( fit->name, name ) == 0 )
			return fit->fsi;
	}
	return NULL;
}
void sack_set_default_filesystem_interface( struct file_system_interface* fsi )
{
	( *winfile_local ).default_file_system_interface = fsi;
}
void sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface* fsi )
{
	struct file_interface_tracker* fit = New( struct file_interface_tracker );
	fit->name = StrDup( name );
	fit->fsi = fsi;
	//LocalInit();
	AddLink( &( *winfile_local ).file_system_interface, fit );
}
#ifdef WIN32
typedef NTSTATUS( NTAPI* sNtSetInformationFile )
( HANDLE FileHandle,
	PIO_STATUS_BLOCK IoStatusBlock,
	PVOID FileInformation,
	ULONG Length,
	FILE_INFORMATION_CLASS FileInformationClass );
sNtSetInformationFile pNtSetInformationFile;
#ifdef __GNUC__
#  undef DeleteFile
#  define DeleteFile DoDeleteFile
#else
typedef enum _REAL_FILE_INFORMATION_CLASS {
	DupFileDirectoryInformation = 1,
	FileFullDirectoryInformation,
	FileBothDirectoryInformation,
	FileBasicInformation,
	FileStandardInformation,
	FileInternalInformation,
	FileEaInformation,
	FileAccessInformation,
	FileNameInformation,
	FileRenameInformation,
	FileLinkInformation,
	FileNamesInformation,
	FileDispositionInformation,
	FilePositionInformation,
	FileFullEaInformation,
	FileModeInformation,
	FileAlignmentInformation,
	FileAllInformation,
	FileAllocationInformation,
	FileEndOfFileInformation,
	FileAlternateNameInformation,
	FileStreamInformation,
	FilePipeInformation,
	FilePipeLocalInformation,
	FilePipeRemoteInformation,
	FileMailslotQueryInformation,
	FileMailslotSetInformation,
	FileCompressionInformation,
	FileObjectIdInformation,
	FileCompletionInformation,
	FileMoveClusterInformation,
	FileQuotaInformation,
	FileReparsePointInformation,
	FileNetworkOpenInformation,
	FileAttributeTagInformation,
	FileTrackingInformation,
	FileIdBothDirectoryInformation,
	FileIdFullDirectoryInformation,
	FileValidDataLengthInformation,
	FileShortNameInformation,
	FileIoCompletionNotificationInformation,
	FileIoStatusBlockRangeInformation,
	FileIoPriorityHintInformation,
	FileSfioReserveInformation,
	FileSfioVolumeInformation,
	FileHardLinkInformation,
	FileProcessIdsUsingFileInformation,
	FileNormalizedNameInformation,
	FileNetworkPhysicalNameInformation,
	FileIdGlobalTxDirectoryInformation,
	FileIsRemoteDeviceInformation,
	FileAttributeCacheInformation,
	FileNumaNodeInformation,
	FileStandardLinkInformation,
	FileRemoteProtocolInformation,
	FileMaximumInformation
} REAL_FILE_INFORMATION_CLASS, * PREAL_FILE_INFORMATION_CLASS;
typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime;
	LARGE_INTEGER LastAccessTime;
	LARGE_INTEGER LastWriteTime;
	LARGE_INTEGER ChangeTime;
	DWORD FileAttributes;
} FILE_BASIC_INFORMATION, * PFILE_BASIC_INFORMATION;
typedef struct _FILE_DISPOSITION_INFORMATION {
	BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, * PFILE_DISPOSITION_INFORMATION;
#endif
static FILE_BASIC_INFORMATION zero_file_basic_information;
LOGICAL windowDeepDelete( const char* path )
{
	WCHAR* pathw = CharWConvert( path );
	HANDLE handle;
	BY_HANDLE_FILE_INFORMATION info;
	FILE_DISPOSITION_INFORMATION disposition;
	IO_STATUS_BLOCK iosb;
	NTSTATUS status;
	handle = CreateFileW( pathw,
		FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | DELETE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,
		NULL );
	Deallocate( WCHAR*, pathw );
	if( handle == INVALID_HANDLE_VALUE ) {
		//SET_REQ_WIN32_ERROR(req, GetLastError());
		return FALSE;
	}
	if( !GetFileInformationByHandle( handle, &info ) ) {
		//SET_REQ_WIN32_ERROR(req, GetLastError());
		CloseHandle( handle );
		return FALSE;
	}
	if( info.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
		/* Do not allow deletion of directories, unless it is a symlink. When the
		 * path refers to a non-symlink directory, report EPERM as mandated by
		 * POSIX.1. */
		 /* Check if it is a reparse point. If it's not, it's a normal directory. */
		if( !( info.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT ) ) {
			CloseHandle( handle );
			return FALSE;
		}
		/* Read the reparse point and check if it is a valid symlink. If not, don't
		 * unlink. */
		 /*
		 if (fs__readlink_handle(handle, NULL, NULL) < 0) {
		   DWORD error = GetLastError();
		   if (error == ERROR_SYMLINK_NOT_SUPPORTED)
			 error = ERROR_ACCESS_DENIED;
		   CloseHandle(handle);
		   return FALSE;
		 }
	   */
	}
	if( info.dwFileAttributes & FILE_ATTRIBUTE_READONLY ) {
		/* Remove read-only attribute */
		FILE_BASIC_INFORMATION basic = zero_file_basic_information;
		basic.FileAttributes = ( info.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY ) |
			FILE_ATTRIBUTE_ARCHIVE;
		status = pNtSetInformationFile( handle,
			&iosb,
			&basic,
			sizeof basic,
			(FILE_INFORMATION_CLASS)FileBasicInformation );
		if( !NT_SUCCESS( status ) ) {
			CloseHandle( handle );
			return FALSE;
		}
	}
	/* Try to set the delete flag. */
	disposition.DeleteFile = TRUE;
	status = pNtSetInformationFile( handle,
		&iosb,
		&disposition,
		sizeof disposition,
		(FILE_INFORMATION_CLASS)FileDispositionInformation );
	if( NT_SUCCESS( status ) ) {
	}
	else {
		return FALSE;
	}
	CloseHandle( handle );
	return TRUE;
}
#endif
static int CPROC sack_filesys_unlink( uintptr_t psv, const char* filename ) {
	int okay = 0;
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	struct file* file = FindFileByName( 0, filename, ( *winfile_local )._mounted_file_systems, NULL );
	if( file ) file->deleted = 1;
#ifdef WIN32
	okay = windowDeepDelete( filename );
	if( !okay ) okay = DeleteFileA( filename );
#else
	okay = !unlink( filename );
#endif
	if( !okay ) {
		if( file )
			file->delete_on_close = 1;
	}
	return okay;
}
static size_t CPROC sack_filesys_size( void* file ) {
	size_t here = ftell( (FILE*)file );
	size_t length;
	fseek( (FILE*)file, 0, SEEK_END );
	length = ftell( (FILE*)file );
	if( length == (size_t)-1 ) {
		int e = errno;
#ifdef WIN32
		length = (size_t)_ftelli64( (FILE*)file );
		if( length == (size_t)-1 ) {
#endif
			lprintf( "ftell error %d", e );
#ifdef WIN32
		}
#endif
	}
#ifdef WIN32
	_fseeki64( (FILE*)file, here, SEEK_SET );
#else
	fseek( (FILE*)file, here, SEEK_SET );
#endif
	return length;
}
static size_t CPROC sack_filesys_tell( void* file ) { return ftell( (FILE*)file ); }
static void CPROC sack_filesys_truncate( void* file ) {
#ifdef _MSC_VER
 // disable ignoring return value of chsize; nothing to do if it fails.
#  pragma warning( disable:  6031 )
#endif
#if _WIN32
	_chsize_s( fileno( (FILE*)file ), _ftelli64( (FILE*)file ) );
#else
	ftruncate( fileno( (FILE*)file ), ftell( (FILE*)file ) );
#endif
}
static int CPROC sack_filesys_flush( void* file ) { return fflush( (FILE*)file ); }
static int CPROC sack_filesys_exists( uintptr_t psv, const char* file );
static LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char* original_name, const char* new_name );
static LOGICAL CPROC sack_filesys_copy_write_buffer( void ) { return FALSE; }
struct find_cursor_data {
	char* root;
	wchar_t* filemask;
	char* mask;
	char namebuf[256];
#ifdef WIN32
	intptr_t findHandle;
	struct _wfinddata_t fileinfo;
#else
	DIR* handle;
	struct dirent* de;
#endif
};
static	struct find_cursor* CPROC sack_filesys_find_create_cursor( uintptr_t psvInstance, const char* root, const char* filemask ) {
	struct find_cursor_data* cursor = New( struct find_cursor_data );
	char maskbuf[512];
	MemSet( cursor, 0, sizeof( *cursor ) );
	//snprintf( maskbuf, 512, "%s/%s", root ? root : ".", filemask?filemask:"*" );
	snprintf( maskbuf, 512, "%s" SYS_PATHCHAR "%s", root ? root : ".", "*" );
	cursor->mask = StrDup( filemask );
	cursor->root = StrDup( root ? root : "." );
	{
		//char* mask = ExpandPath( maskbuf );// StrDup( filemask ? filemask : "*" );
		cursor->filemask = CharWConvertLen( maskbuf, strlen( maskbuf ) );
		//Deallocate( char*, mask );
	}
#ifdef WIN32
	// windows mode is delayed until findfirst
#else
	cursor->handle = opendir( root ? root : "." );
#endif
	return ( struct find_cursor* )cursor;
}
static	int CPROC sack_filesys_find_first( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	cursor->findHandle = _wfindfirst( cursor->filemask, &cursor->fileinfo );
	//lprintf( "findFirst %p %p", cursor->findHandle, cursor );
	return ( cursor->findHandle != -1 );
#else
	if( cursor->handle ) {
		do {
			cursor->de = readdir( cursor->handle );
			//lprintf( "filefound? %s", cursor->de->d_name );
			if( cursor->de && cursor->de->d_type == DT_DIR) {
				//lprintf( "result with dir? %s", cursor->de->d_name );
					break;
			}
		} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
		return ( cursor->de != NULL );
	}
	return 0;
#endif
}
static	int CPROC sack_filesys_find_close( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	//int r =
	findclose( cursor->findHandle );
	//lprintf( "findClose %d %p", r, cursor );
#else
	if( cursor->handle )
		closedir( cursor->handle );
#endif
	Deallocate( char*, cursor->root );
	Deallocate( char*, cursor->mask );
	Deallocate( wchar_t*, cursor->filemask );
	Deallocate( struct find_cursor_data*, cursor );
	return 0;
}
static	int CPROC sack_filesys_find_next( struct find_cursor* _cursor ) {
	int r;
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	r = !_wfindnext( cursor->findHandle, &cursor->fileinfo );
	//lprintf( "findNext %d %p", r, cursor );
#else
	do {
		cursor->de = readdir( cursor->handle );
			//lprintf( "filefound? %s", cursor->de->d_name );
			if( cursor->de && cursor->de->d_type == DT_DIR) {
				//lprintf( "result with dir? %s", cursor->de->d_name );
				break;
			}
	} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
	r = ( cursor->de != NULL );
#endif
	return r;
}
static	char* CPROC sack_filesys_find_get_name( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
#   ifdef UNDER_CE
	return cursor->fileinfo.cFileName;
#   else
	{
		const wchar_t* tmp = cursor->fileinfo.name;
		char* out = cursor->namebuf;
		while( tmp[0] ) {
			out += ConvertToUTF8( out, GetUtfCharW( &tmp ) );
		}
		out[0] = 0;
	}
	return cursor->namebuf;
#   endif
#else
	return cursor->de->d_name;
#endif
}
static	size_t CPROC sack_filesys_find_get_size( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	if( cursor )
		return cursor->fileinfo.size;
	return 0;
#else
	if( cursor ) {
		struct stat s;
		char filename[280];
		snprintf( filename, 280, "%s/%s", cursor->root, cursor->de->d_name );
		if( stat( filename, &s ) ) {
			lprintf( "getsize stat error:%d", errno );
			return -2;
		}
		if( S_ISREG( s.st_mode ) )
			return s.st_size;
		return 0;
	}
#endif
	return 0;
}
static	uint64_t CPROC sack_filesys_find_get_ctime( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	if( cursor )
		return cursor->fileinfo.time_create;
	return 0;
#else
	if( cursor ) {
		struct stat s;
		char filename[280];
		snprintf( filename, 280, "%s/%s", cursor->root, cursor->de->d_name );
		if( stat( filename, &s ) ) {
			lprintf( "getsize stat error:%d", errno );
			return -2;
		}
		return s.st_ctime;
	}
#endif
	return 0;
}
static	uint64_t CPROC sack_filesys_find_get_wtime( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
	if( cursor )
		return cursor->fileinfo.time_write;
	return 0;
#else
	if( cursor ) {
		struct stat s;
		char filename[280];
		snprintf( filename, 280, "%s/%s", cursor->root, cursor->de->d_name );
		if( stat( filename, &s ) ) {
			lprintf( "getsize stat error:%d", errno );
			return -2;
		}
		return s.st_mtime;
	}
#endif
	return 0;
}
static	LOGICAL CPROC sack_filesys_find_is_directory( struct find_cursor* _cursor ) {
	struct find_cursor_data* cursor = ( struct find_cursor_data* )_cursor;
#ifdef WIN32
#  ifdef UNDER_CE
	return ( cursor->fileinfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY );
#  else
	//lprintf( "isDir %d %08x %p", ( cursor->fileinfo.attrib & _A_SUBDIR ), cursor->fileinfo.attrib, cursor );
	return ( cursor->fileinfo.attrib & _A_SUBDIR );
#  endif
#else
	char buffer[MAX_PATH_NAME];
	snprintf( buffer, MAX_PATH_NAME, "%s%s%s", cursor->root, cursor->root[0] ? "/" : "", cursor->de->d_name );
	return IsPath( buffer );
#endif
}
static	LOGICAL CPROC sack_filesys_is_directory( uintptr_t psvInstance, const char* buffer ) {
	return IsPath( buffer );
}
int sack_make_public( uintptr_t psvInstance, CTEXTSTR filename ) {
#ifdef __LINUX__
	TEXTSTR tmp = ExpandPath( filename );
	int r = chmod( tmp, 0777 );
	ReleaseEx( tmp DBG_SRC );
	return r;
#else
	return 0;
#endif
}
struct file_system_interface native_fsi = {
	sack_filesys_open
		, sack_filesys_close
		, sack_filesys_read
		, sack_filesys_write
		, sack_filesys_seek
		, sack_filesys_truncate
		, sack_filesys_unlink
		, sack_filesys_size
		, sack_filesys_tell
		, sack_filesys_flush
		, sack_filesys_exists
		, sack_filesys_copy_write_buffer
  //( uintptr_t psvInstance, const char *root, const char *filemask );
		, sack_filesys_find_create_cursor
		, sack_filesys_find_first
		, sack_filesys_find_close
		, sack_filesys_find_next
		, sack_filesys_find_get_name
		, sack_filesys_find_get_size
		, sack_filesys_find_is_directory
		, sack_filesys_is_directory
 // rename
		, sack_filesys_rename
   // file ioctl
		, NULL
   // file-system ioctl
		, NULL
		, sack_filesys_find_get_ctime
		, sack_filesys_find_get_wtime
 // legacy support
		, sack_filesys_mkdir
 // legacy support
		, sack_filesys_rmdir
 // lock( FILE* )
		, NULL
 // unlock( FILE* )
		, NULL
		, sack_make_public
		, sack_filesys_chdir
} ;
PRIORITY_PRELOAD( InitWinFileSysEarly, OSALOT_PRELOAD_PRIORITY - 1 )
{
	LocalInit();
	FileSysThreadInfo.default_mount = ( *winfile_local )._default_mount;
#ifdef WIN32
	pNtSetInformationFile = (sNtSetInformationFile)LoadFunction(
		"ntdll.dll",
		"NtSetInformationFile" );
#endif
}
#if !defined( __NO_OPTIONS__ )
PRELOAD( InitWinFileSys )
{
#  if !defined( __FILESYS_NO_FILE_LOGGING__ )
	( *winfile_local ).flags.bLogOpenClose = SACK_GetProfileIntEx( "SACK/filesys", "Log open and close", ( *winfile_local ).flags.bLogOpenClose, TRUE );
#  endif
}
#endif
static void* CPROC sack_filesys_open( uintptr_t psv, const char* filename, const char* opts ) {
	void* result;
#ifdef _WIN32
	wchar_t* wfilename = CharWConvert( filename );
	wchar_t* wopts = CharWConvert( opts );
	{ wchar_t* tmp; if( LONG_PATHCHAR ) for( tmp = wfilename; tmp[0]; tmp++ ) if( tmp[0] == '/' ) tmp[0] = LONG_PATHCHAR; }
	result = _wfopen( wfilename, wopts );
	Deallocate( wchar_t*, wfilename );
	Deallocate( wchar_t*, wopts );
	if( result )
	{
		int h = fileno( (FILE*)result );
		if( h >= 0 ) {
			SetHandleInformation( (HANDLE)_get_osfhandle(h), HANDLE_FLAG_INHERIT, 0 );
		}
	}
#else
	char *tmpFilename = StrDup( filename );
	{ char* tmp; if( LONG_PATHCHAR ) for( tmp = tmpFilename; tmp[0]; tmp++ ) if( tmp[0] == '\\' ) tmp[0] = LONG_PATHCHAR; }
	result = fopen( tmpFilename, opts );
	{
		int h = fileno( (FILE*)result );
		if( h >= 0 ) {
			int flags = fcntl( h, F_GETFD, 0 );
			if( flags >= 0 ) fcntl( h, F_SETFD, flags | FD_CLOEXEC );
		}
	}
	Deallocate( char*, tmpFilename );
#endif
	return result;
}
static int CPROC sack_filesys_exists( uintptr_t psv, const char* filename ) {
	//int result;
	//result = sack_existsEx( filename, NULL );//(*winfile_local).default_mount );
	FILE* tmp;
#ifdef WIN32
	wchar_t* wfilename = CharWConvert( filename );
	{ wchar_t* tmp; if( LONG_PATHCHAR ) for( tmp = wfilename; tmp[0]; tmp++ ) if( tmp[0] == '/' ) tmp[0] = LONG_PATHCHAR; }
	if( ( tmp = _wfopen( wfilename, L"rb" ) ) )
#else
	char *tmpFilename = StrDup( filename );
	{ char* tmp; if( LONG_PATHCHAR ) for( tmp = tmpFilename; tmp[0]; tmp++ ) if( tmp[0] == '\\' ) tmp[0] = LONG_PATHCHAR; }
	if( ( tmp = fopen( filename, "rb" ) ) )
#endif
	{
		fclose( tmp );
#ifdef WIN32
		Deallocate( wchar_t*, wfilename );
#else
		Deallocate( char*, tmpFilename );
#endif
		return TRUE;
	}
#ifdef WIN32
	Deallocate( wchar_t*, wfilename );
#endif
	return FALSE;
}
struct file_system_mounted_interface* sack_get_default_mount( void ) {
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	return FileSysThreadInfo.default_mount;
}
struct file_system_interface* sack_get_mounted_filesystem_interface( struct file_system_mounted_interface* mount ) {
	if( mount )
		return mount->fsi;
	return NULL;
}
uintptr_t sack_get_mounted_filesystem_instance( struct file_system_mounted_interface* mount ) {
	if( mount )
		return mount->psvInstance;
	return 0;
}
struct file_system_mounted_interface* sack_get_mounted_filesystem( const char* name )
{
	if( !FileSysThreadInfo._mounted_file_systems )FileSysThreadInfo._mounted_file_systems = &( *winfile_local )._mounted_file_systems;
	struct file_system_mounted_interface* root = FileSysThreadInfo.mounted_file_systems;
	while( root ) {
		if( root->name ) if( stricmp( root->name, name ) == 0 ) break;
		root = root->nextLayer;
	}
	return root;
}
void sack_unmount_filesystem( struct file_system_mounted_interface* mount )
{
	if( mount->meLayer )
		mount->meLayer[0] = mount->nextLayer;
}
LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char* original_name, const char* new_name ) {
	return sack_renameEx( original_name, new_name, NULL );
}
static void link_mount( struct file_system_mounted_interface* mount ) {
	struct file_system_mounted_interface* root = FileSysThreadInfo.mounted_file_systems;
	if( !root || ( root->priority >= mount->priority ) ) {
		if( mount->nextLayer = FileSysThreadInfo.mounted_file_systems )
			root->meLayer = &mount->nextLayer;
		mount->meLayer = &FileSysThreadInfo.mounted_file_systems;
		if( !root )
			FileSysThreadInfo.default_mount = mount;
 // higher priorirty, layer this thread's higher priority version.
		FileSysThreadInfo.mounted_file_systems = mount;
	}
	else {
		// allow a way to get away from the default filesystem.
		struct file_system_mounted_interface* check, * check_ = root;
		if( !root->nextLayer ) {
			root->nextLayer = mount;
			mount->meLayer = &root->nextLayer;
			mount->nextLayer = NULL;
		}
		else {
			for( check = root->nextLayer; check; check = check->nextLayer ) {
				if( check->priority >= mount->priority ) {
					check_->nextLayer = mount;
					mount->nextLayer = check;
					mount->meLayer = check_->meLayer;
					check_->meLayer = &mount->nextLayer;
					break;
				}
				check_ = check;
			}
			if( !check ) {
				check_->nextLayer = mount;
				mount->nextLayer = NULL;
				mount->meLayer = &check_->nextLayer;
			}
		}
	}
}
// does this get a new name too? does it have to?
struct file_system_mounted_interface* sack_remount_filesystem( const char* name, struct file_system_mounted_interface* oldMount, int priority, LOGICAL writable )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	struct file_system_mounted_interface* mount = New( struct file_system_mounted_interface );
	mount->name = name ? strdup( name ) : NULL;
	mount->priority = priority?priority:oldMount->priority;
	mount->writeable = oldMount->writeable && writable;
	mount->psvInstance = oldMount->psvInstance;
	mount->fsi = oldMount->fsi;
	link_mount( mount );
	return mount;
}
struct file_system_mounted_interface* sack_mount_filesystem( const char* name, struct file_system_interface* fsi, int priority, uintptr_t psvInstance, LOGICAL writable )
{
	if( !FileSysThreadInfo._mounted_file_systems ) threadInit();
	struct file_system_mounted_interface* mount = New( struct file_system_mounted_interface );
	mount->name = name ? strdup( name ) : NULL;
	mount->priority = priority;
	mount->psvInstance = psvInstance;
	mount->writeable = writable;
	mount->fsi = fsi;
	//lprintf( "Create mount called %s ", name );
	link_mount( mount );
	return mount;
}
int sack_vfprintf( FILE * file_handle, const char* format, va_list args )
{
	struct file* file;
	file = FindFileByFILE( file_handle );
	if( file->mount && file->mount->fsi ) {
		PVARTEXT pvt;
		PTEXT output;
		int r;
#ifdef UNICODE
		TEXTCHAR* _format = DupCStr( format );
#define format _format
#endif
		pvt = VarTextCreate();
		vvtprintf( pvt, format, args );
		output = VarTextPeek( pvt );
#ifdef UNICODE
		Deallocate( TEXTCHAR*, _format );
#  undef format
#endif
		r = (int)file->mount->fsi->_write( file_handle, (char*)GetText( output ), GetTextSize( output ) * sizeof( TEXTCHAR ) );
		VarTextDestroy( &pvt );
		return r;
	}
	else
		return vfprintf( file_handle, format, args );
}
int sack_fprintf( FILE * file, const char* format, ... )
{
	va_list args;
	va_start( args, format );
	return sack_vfprintf( file, format, args );
}
int sack_fputs( const char* format, FILE * file )
{
	if( format ) {
		size_t len = strlen( format );
		return (int)( sack_fwrite( format, 1, (int)len, file ) & 0x7FFFFFFF );
	}
	return 0;
}
uintptr_t sack_ioctl( FILE * file_handle, uintptr_t opCode, ... ) {
	struct file* file;
	va_list args;
	va_start( args, opCode );
	file = FindFileByFILE( file_handle );
	if( file && file->mount && file->mount->fsi && file->mount->fsi->ioctl ) {
		return file->mount->fsi->ioctl( (uintptr_t)file_handle, opCode, args );
	}
	else {
		// unknown file handle; ignore unknown ioctl.
	}
	return ENOTSUP;
}
uintptr_t sack_fs_ioctl( struct file_system_mounted_interface* mount, uintptr_t opCode, ... ) {
	va_list args;
	va_start( args, opCode );
	if( mount && mount->fsi && mount->fsi->fs_ioctl ) {
		return mount->fsi->fs_ioctl( mount->psvInstance, opCode, args );
	}
	else {
		// unknown file handle; ignore unknown ioctl.
	}
	return ENOTSUP;
}
LOGICAL SetFileLength( CTEXTSTR path, size_t length )
{
#ifdef __LINUX__
	// files are by default binary in linux
#  ifndef O_BINARY
#	   define O_BINARY 0
#  endif
#else
#  ifndef O_BINARY
#	   define O_BINARY 0x8000
#  endif
#endif
	INDEX file;
	file = sack_iopen( 0, path, O_RDWR | O_BINARY );
	if( file == INVALID_INDEX )
		return FALSE;
	sack_ilseek( file, length, SEEK_SET );
	sack_iset_eof( file );
	sack_iclose( file );
	return TRUE;
}
void sack_filesys_enable_thread_mounts( void ) {
	FileSysThreadInfo.default_mount = NULL;
	FileSysThreadInfo._mounted_file_systems = &FileSysThreadInfo.thread_local_mounted_file_systems;
}
int sack_flock( FILE* file_ ) {
	struct file *file = FindFileByFILE( file_ );
	if( file ) {
		if( file->mount->fsi->_lock )
			return file->mount->fsi->_lock( file_ );
	}
	return 0;
}
int sack_funlock( FILE* file_ ) {
	struct file* file = FindFileByFILE( file_ );
	if( file ) {
		if( file->mount->fsi->_unlock )
			return file->mount->fsi->_unlock( file_ );
	}
	return 0;
}
int make_public( CTEXTSTR filename ) {
	struct file_system_mounted_interface*mount =sack_get_default_mount();
	if( mount && mount->fsi->_make_public ) return mount->fsi->_make_public( mount->psvInstance, filename );
	errno = ENOENT;
	return -1;
}
int make_public_mount( CTEXTSTR filename, struct file_system_mounted_interface*mount ) {
	if( mount && mount->fsi->_make_public ) return mount->fsi->_make_public( mount->psvInstance, filename );
	errno = ENOENT;
	return -1;
}
FILESYS_NAMESPACE_END
#ifdef _MSC_VER
#  pragma warning( default: 6387 )
 // disable ignoring return value of chsize; nothing to do if it fails.
#  pragma warning( default: 6031 )
#endif
#ifdef UNDEF_FILESYS_DEFS
#   undef UNDEF_FILESYS_DEFS
#   undef FILESYSTEM_LIBRARY_SOURCE
#   undef NO_UNICODE_C
#   undef WINFILE_COMMON_SOURCE
#   undef FIX_RELEASE_COM_COLLISION
#endif
#define NO_UNICODE_C
#ifdef _MSC_VER
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
 // windows lean_and_mean
#ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#endif
#else
 // opendir etc..
#endif
FILESYS_NAMESPACE
#ifndef MAX_PATH_NAME
#  define MAX_PATH_NAME 512
#endif
// DEBUG_COMPARE 1 == full debug
// DEBUG_COMPARE 2 == quieter debug
#ifdef _DEBUG
#define DEBUG_COMPARE 4
#else
#define DEBUG_COMPARE 999
#endif
//--------------------------------------------------------------------------
 int  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase )
{
	int m = 0, n = 0;
	int anymatch;
	int wasanymatch, wasmaskmatch;
	int matchone;
	TEXTCHAR namech, maskch;
	if( !mask )
		return 1;
	if( !name )
		return 0;
try_mask:
	anymatch = 0;
	wasanymatch = 0;
	wasmaskmatch = 0;
	matchone = 0;
#if ( DEBUG_COMPARE < 3 )
	lprintf( "Check %s vs %s", mask + m, name );
#endif
	do
	{
		if( mask[m] == '\t' || mask[m] == '|' )
		{
			//lprintf( "Found mask seperator - skipping to next mask :%s", mask + m + 1 );
			n = 0;
			m++;
			continue;
		}
		while( mask[m] == '*' )
		{
			anymatch = 1;
			m++;
		}
		while( mask[m] == '?' )
		{
#if ( DEBUG_COMPARE < 2 )
         //Log( "Match any one character" );
#endif
			matchone++;
			m++;
		}
		if( !keepcase && name[n]>= 'a' && name[n] <= 'z' )
			namech = name[n] - ('a' - 'A');
		else if( name[n] == '/' )
			namech = '\\';
		else
			namech = name[n];
		if( !keepcase && mask[m]>= 'a' && mask[m] <= 'z' )
			maskch = mask[m] - ('a' - 'A');
		else if( mask[m] == '/' )
			maskch = '\\';
		else
			maskch = mask[m];
		if( matchone )
		{
			matchone--;
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( "Check %c == %c?", maskch, namech ),
#endif
				  maskch == namech )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( " yes." );
#endif
			 if( anymatch )
			 {
				 wasanymatch = n+1;
				 wasmaskmatch = m+1;
				 anymatch = 0;
			}
			 n++;
			 m++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( " no. Any match?" ),
#endif
				  anymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( " yes");
#endif
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( " No. wasanymatch?" ),
#endif
				  wasanymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( " yes. reset to anymatch." );
#endif
			n = wasanymatch - 1;
			m = wasmaskmatch - 1;
			anymatch = 1;
			n++;
		}
		else
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( " No. match failed." );
#endif
			break;
		}
	}while( name[n] );
	// 0 or more match a *
	// so auto match remaining *
	while( mask[m] && mask[m] == '*' )
		m++;
#if ( DEBUG_COMPARE < 3 )
	lprintf( "Skipping to next mask" );
#endif
	if( mask[m] &&
		 ( mask[m] != '\t' &&
			mask[m] != '|' ) )
	{
		int mask_m = m;
		while( mask[m] )
		{
			if( mask[m] == '\t' || mask[m] == '|' )
			{
				n = 0;
				m++;
				break;
			}
			m++;
		}
		if( mask[m] )
			goto try_mask;
		m = mask_m;
	}
	//lprintf( "Result: %d %c %d", matchone, mask[m], name[n] );
	// match ???? will not match abc
	// a??? abc not match
	if( !matchone && (!mask[m] || mask[m] == '\t' || mask[m] == '|' ) && !name[n] )
		return 1;
	return  0;
}
//--------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef struct result_buffer
{
	TEXTSTR buffer;
	int len;
	int result_len;
} RESULT_BUFFER, *PRESULT_BUFFER;
static void CPROC MatchFile( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
{
	PRESULT_BUFFER buffer = (PRESULT_BUFFER)psvUser;
	buffer->result_len = tnprintf( buffer->buffer, buffer->len*sizeof(TEXTCHAR), "%s", name );
}
int  GetMatchingFileName ( CTEXTSTR filemask, enum ScanFileFlags  flags, TEXTSTR pResult, int nResult )
{
	void *info = NULL;
	RESULT_BUFFER result_buf;
	result_buf.buffer = pResult;
	result_buf.len = nResult;
	result_buf.result_len = 0;
	// may need a while loop here...
	// but I'm just going to result the first matching anyhow.
	while( ScanFiles( NULL, filemask, &info, MatchFile, flags, (uintptr_t)&result_buf ) );
	return result_buf.result_len;
}
//---------------------------------------------------------------------------
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#ifdef UNDER_CE
#define finddata_t WIN32_FIND_DATA
#define findfirst FindFirstFile
#define findnext  FindNextFile
#define findclose FindClose
#else
#  ifdef UNICODE
#define finddata_t _wfinddata_t
#define findfirst _wfindfirst
#define findnext  _wfindnext
#define findclose _findclose
#  else
#define finddata_t _finddata_t
#define findfirst _findfirst
#define findnext  _findnext
#define findclose _findclose
#  endif
#endif
#else
#endif
typedef struct myfinddata {
#ifdef WIN32
#  ifdef _MSC_VER
#define HANDLECAST intptr_t
	intptr_t
#  else
#define HANDLECAST int
	int
#  endif
#else
#  define HANDLECAST DIR*
	DIR*
#endif
		handle;
#  ifdef WIN32
#    ifdef UNDER_CE
	WIN32_FIND_DATA fd;
#    else
	struct _wfinddata_t fd;
#  endif
#endif
	struct find_cursor *cursor;
	INDEX scanning_interface_index;
	LOGICAL new_mount;
	LOGICAL single_mount;
	struct file_system_mounted_interface *scanning_mount;
	TEXTCHAR buffer[MAX_PATH_NAME];
	TEXTCHAR file_buffer[MAX_PATH_NAME];
	TEXTCHAR basename[MAX_PATH_NAME];
	TEXTCHAR findmask[MAX_PATH_NAME];
	wchar_t *findmaskw;
	struct myfinddata *current;
	struct myfinddata *prior;
	struct myfinddata **root_info;
} MFD, *PMFD;
#define findhandle(pInfo) ( ((PMFD)(*pInfo))->handle)
#define finddata(pInfo) ( &((PMFD)(*pInfo))->fd)
#define findbuffer(pInfo) ( ((PMFD)(*pInfo))->buffer)
#define findbasename(pInfo) ( ((PMFD)(*pInfo))->basename)
#define findmask(pInfo)     ( ((PMFD)(*pInfo))->findmask)
#define findmaskw(pInfo)     ( ((PMFD)(*pInfo))->findmaskw)
#define findinfo(pInfo)     (((PMFD)(*pInfo)))
#define findcursor(pInfo)     ( ((PMFD)(*pInfo))->cursor)
struct find_cursor *GetScanFileCursor( void *pInfo ) {
	PMFD mfd = (PMFD)pInfo;
	return mfd->cursor;
}
 int  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
           , enum ScanFileFlags flags
           , uintptr_t psvUser
		   , LOGICAL begin_sub_path
		   , struct file_system_mounted_interface *mount
		   )
{
	PMFD pDataCurrent = (PMFD)(pInfo);
	PMFD pData = (PMFD)(*pInfo);
	TEXTSTR tmp_base = NULL;
	enum ScanFileProcessFlags sendflags;
	int processed = 0;
#ifndef WIN32
	struct dirent *de;
#endif
	if( begin_sub_path )
	{
		pInfo = (void**)&(pDataCurrent->current);
	}
	else
		pDataCurrent = NULL;
	//lprintf( "Search in %s for %s   %d %d", base?base:"(NULL)", mask?mask:"(*)", (*pInfo)?((PMFD)*pInfo)->scanning_mount:0, (*pInfo)?((PMFD)*pInfo)->single_mount:0 );
	if( !*pInfo || begin_sub_path || ((PMFD)*pInfo)->new_mount )
	{
		TEXTCHAR findmask[4096+32];
		wchar_t findmaskw[256];
		pData = (PMFD)(*pInfo);
		if( !pData )
		{
			*pInfo = Allocate( sizeof( MFD ) );
			pData = (PMFD)(*pInfo);
			if( !( pData->scanning_mount = mount ) )
			{
				if( !winfile_local )
					SimpleRegisterAndCreateGlobal( winfile_local );
				//lprintf( "... %p", winfile_local );
				pData->single_mount = FALSE;
				pData->scanning_mount = FileSysThreadInfo.mounted_file_systems;
			}
			else
				pData->single_mount = TRUE;
			if( !pData->scanning_mount )
			{
				Deallocate( PMFD, pData );
				if( tmp_base )
					Release( tmp_base );
				return 0;
			}
			if( pData->scanning_mount->fsi && pData->scanning_mount->fsi->find_create_cursor )
			{
				char *tmp1, *tmp2;
				//lprintf( "create cursor" );
				tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
				pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, tmp2 = CStrDup( tmp_base ), tmp1 = CStrDup( mask ) );
				Deallocate( char*, tmp1 );
				Deallocate( char*, tmp2 );
			}
			else
			{
				//lprintf( "no cursor" );
				pData->cursor = NULL;
			}
		}
		else
		{
			if( pData->new_mount )
			{
				if( pData->scanning_mount->fsi && pData->scanning_mount->fsi->find_create_cursor )
				{
					//lprintf( "create cursor (new mount)" );
					tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
					pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, CStrDup( tmp_base ), CStrDup( mask ) );
				}
				else
					pData->cursor = NULL;
			}
		}
		pData->new_mount = FALSE;
		pData->current = NULL;
		pData->prior = pDataCurrent;
		if( pDataCurrent )
		{
			pData->root_info = pDataCurrent->root_info;
			pInfo = (void**)pData->root_info;
		}
		else
		{
			pData->root_info = (struct myfinddata**)pInfo;
		}
		(*pData->root_info) = pData;
		if( base )
		{
			TEXTSTR tmp;
			StrCpyEx( findbasename(pInfo), tmp = ExpandPathEx( base, pData->scanning_mount?pData->scanning_mount->fsi:NULL ), MAX_PATH_NAME );
			Release( tmp );
			StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
		}
		else
		{
			CTEXTSTR p = pathrchr( mask );
			if( p )
			{
				StrCpyEx( findbasename(pInfo), mask, p - mask + 1 );
				StrCpyEx( findmask(pInfo), p + 1, MAX_PATH_NAME );
				//mask = p + 1;
			}
			else
			{
				StrCpyEx( findbasename(pInfo), "", 2 );
				StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
			}
		}
		findmaskw(pInfo) = CharWConvertLen( findmask( pInfo ), strlen( findmask( pInfo ) ) );
		if( findbasename(pInfo)[0] )
			tnprintf( findmask, sizeof(findmask), "%s" PATHCHAR "*", findbasename(pInfo) );
		else {
			tnprintf( findmask, sizeof( findmask ), "*" );
		}
		{
			wchar_t* out = findmaskw;
			const char* tmp = findmask;
			while( tmp[0] ) {
				out += ConvertToUTF16( out, GetUtfChar( &tmp ) );
			}
			out[0] = 0;
		}
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL ) {
#ifndef _WIN32
			de = NULL;
#endif
			if( pData->scanning_mount->fsi->find_first( findcursor(pInfo) ) )
				findhandle(pInfo) = 0;
			else
				findhandle(pInfo) = (HANDLECAST)-1;
		} else {
#ifdef WIN32
			findhandle(pInfo) = _wfindfirst( findmaskw, finddata(pInfo) );
#else
			lprintf( "opendir [%s]", findbasename(pInfo) );
			if( !findbasename(pInfo)[0] ) {
				TEXTSTR tmp;
				tmp = ExpandPathEx( ".", pData->scanning_mount?pData->scanning_mount->fsi:NULL );
				findhandle( pInfo ) = opendir( tmp );
				Deallocate( TEXTSTR, tmp );
			} else
				findhandle( pInfo ) = opendir( findbasename(pInfo) );
			if( !findhandle(pInfo ) )
				findhandle(pInfo) = (HANDLECAST)-1;
			else
				de = readdir( (DIR*)findhandle( pInfo ) );
#endif
		}
		if( findhandle(pInfo) == (HANDLECAST)-1 )
		{
			PMFD prior = pData->prior;
			//lprintf( "first use of cursor or first open of directoy failed..." );
			if( pData->scanning_mount && pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( (struct find_cursor*)findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				// but it failed... so ... don't close
				//closedir( findhandle( pInfo ) );
#endif
			}
			pData->scanning_mount =  pData->scanning_mount ->nextLayer;
			if( !pData->scanning_mount || pData->single_mount )
			{
				(*pData->root_info) = pData->prior;
				if( !begin_sub_path ) {
					Release( pData ); pInfo[0] = NULL;
				}
				//lprintf( "%p %d", prior, processed );
				if( tmp_base )
					Release( tmp_base );
				return prior?processed:0;
			}
			pData->new_mount = TRUE;
				if( tmp_base )
					Release( tmp_base );
			return 1;
		}
	}
	else
	{
		int r;
getnext:
		//lprintf( "returning customer..." );
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			r = !pData->scanning_mount->fsi->find_next( findcursor( pInfo ) );
		else
		{
#ifdef _WIN32
			r = _wfindnext( findhandle(pInfo), finddata( pInfo ) );
#else
			de = readdir( (DIR*)findhandle( pInfo ) );
			//lprintf( "using %p got %p", findhandle( pInfo ), de );
			r = (de == NULL);
#endif
		}
		if( r )
		{
			PMFD prior = pData->prior;
			//lprintf( "nothing left to find..." );
			if( pData->scanning_mount && pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				closedir( (DIR*)findhandle(pInfo));
#endif
			}
			pData->scanning_mount =  pData->scanning_mount ->nextLayer;
			//lprintf( "Step mount... %p %d", pData->scanning_mount, pData->single_mount );
			if( !pData->scanning_mount || pData->single_mount )
			{
				//lprintf( "done with mounts?" );
				(*pData->root_info) = pData->prior;
				Release( pData );
				if( prior )
					prior->current = NULL;
				if( !processed && !begin_sub_path )
				{
					//pInfo = (void**)&(prior->prior->current);
					pData = prior;
					if( pData )
						goto getnext;
				}
				if( tmp_base )
					Release( tmp_base );
				return (*pInfo)?processed:0;
			}
			pData->new_mount = TRUE;
			if( tmp_base )
				Release( tmp_base );
			return 1;
		}
	}
	if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
	{
		char * path = pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) );
		//lprintf( "... %s", path );
		if( !strcmp( ".", path ) ||
		    !strcmp( "..", path ) )
		goto getnext;
	}
	else
	{
#ifdef WIN32
		{
			const wchar_t* tmp = finddata( pInfo )->name;
			char* out = findbuffer( pInfo );
			while( tmp[0] ) {
				out += ConvertToUTF8( out, GetUtfCharW( &tmp ) );
			}
			out[0] = 0;
		}
		//lprintf( "... %s", finddata(pInfo)->name );
		if( !StrCmp( ".", findbuffer(pInfo) ) ||
		    !StrCmp( "..", findbuffer(pInfo) ) )
#else
		if( !StrCmp( ".", de->d_name ) ||
		    !StrCmp( "..", de->d_name ) )
#endif
			goto getnext;
	}
 // if nameonly - have to rebuild the correct name.
	if( !(flags & SFF_NAMEONLY) )
	{
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
		{
			tnprintf( pData->file_buffer, MAX_PATH_NAME, "%s", pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			if( findbasename( pInfo )[0] )
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s" PATHCHAR "%s", findbasename(pInfo), pData->file_buffer );
			else
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s", pData->file_buffer );
		}
		else
		{
#ifdef WIN32
#  ifdef UNDER_CE
			tnprintf( pData->file_buffer, MAX_PATH_NAME, "%s", finddata( pInfo )->cFileName );
			tnprintf( pData->buffer, MAX_PATH_NAME, "%s" PATHCHAR "%s", findbasename(pInfo), finddata(pInfo)->cFileName );
#  else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, "%ls", finddata(pInfo)->name );
			tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%s", findbasename(pInfo), findbasename( pInfo )[0]?PATHCHAR:"", pData->file_buffer );
#  endif
#else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, "%s", de->d_name );
			tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%s", findbasename(pInfo), findbasename( pInfo )[0]?PATHCHAR:"", de->d_name );
#endif
		}
	}
	else
	{
		if( flags & SFF_SUBCURSE )
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%s"
					  , pData->prior?pData->prior->buffer:""
					  , pData->prior?PATHCHAR:""
					, pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) )
					);
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%s"
						  , pData->prior?pData->prior->buffer:""
						  , pData->prior?PATHCHAR:""
						  , finddata(pInfo)->cFileName );
#  else
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%ls"
						  , pData->prior?pData->prior->buffer:""
						  , pData->prior?PATHCHAR:""
						  , finddata(pInfo)->name );
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s%s%s"
					  , pData->prior?pData->prior->buffer:""
					  , pData->prior?PATHCHAR:""
					  , de->d_name );
					  lprintf( "resulting is %s", pData->buffer );
#endif
			}
		}
		else
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s", pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s", finddata(pInfo)->cFileName );
#  else
				tnprintf( pData->buffer, MAX_PATH_NAME, "%ls", finddata(pInfo)->name );
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, "%s", de->d_name );
#endif
			}
		}
	}
 // force nul termination...
	pData->buffer[MAX_PATH_NAME-1] = 0;
#ifdef UNICODE
	{
		char *pDataBuffer = CStrDup( pData->buffer );
#else
#  define pDataBuffer pData->buffer
#endif
	int isDir = ( ( pData->scanning_mount && pData->scanning_mount->fsi
			&& ( pData->scanning_mount->fsi->find_is_directory
				&& pData->scanning_mount->fsi->find_is_directory( findcursor( pInfo ) ) ) )
			|| ( !( pData->scanning_mount ? pData->scanning_mount->fsi : NULL )
#ifdef WIN32
#  ifdef UNDER_CE
				&& ( finddata( pInfo )->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
#  else
				&& ( finddata( pInfo )->attrib & _A_SUBDIR )
#  endif
#else
				&& IsPath( pData->buffer )
#endif
				) );
	//lprintf( "Check if %s is a directory...", pData->buffer );
	if( ( flags & ( SFF_DIRECTORIES | SFF_SUBCURSE ) )
		&& isDir )
	{
#ifdef UNICODE
		Deallocate( char *, pDataBuffer );
#else
#  undef pDataBuffer
#endif
		//lprintf( "... it is?" );
		if( flags & SFF_DIRECTORIES )
		{
			if( Process != NULL )
			{
				//lprintf( "Send %s", pData->buffer );
				Process( psvUser, pData->buffer, SFF_DIRECTORY );
				processed = 1;
			}
			//return 1;
		}
		if( flags & SFF_SUBCURSE )
		{
			//int ofs = 0;
			TEXTCHAR tmpbuf[MAX_PATH_NAME + 512];
			if( flags & SFF_NAMEONLY )
			{
				// even in name only - need to have this full buffer for subcurse.
				if( pData->scanning_mount && pData->scanning_mount->fsi )
				{
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), "%s" SYSPATHCHAR "%s", findbasename( pInfo ), pData->scanning_mount->fsi->find_get_name( findcursor( pInfo ) ) );
				}
				else
				{
#ifdef WIN32
#  ifdef UNDER_CE
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), "%s" SYSPATHCHAR "%s", findbasename( pInfo ), finddata( pInfo )->cFileName );
#  else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), "%s" SYSPATHCHAR "%ls", findbasename( pInfo ), finddata( pInfo )->name );
#  endif
#else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), "%s" SYSPATHCHAR "%s", findbasename( pInfo ), de->d_name );
#endif
				}
				//lprintf( "process sub... %s %s", tmpbuf, findmask(pInfo)  );
				processed |= ScanFilesEx( tmpbuf, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
			else
			{
				//lprintf( "process sub..." );
				processed |= ScanFilesEx( pData->buffer, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
		}
		if( !processed )
			goto getnext;
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo) ? 1 : 0;
	}
#ifdef UNICODE
	Deallocate( char *, pDataBuffer );
	}
#else
#  undef pDataBuffer
#endif
	if( ( sendflags = SFF_DIRECTORY, ( ( flags & SFF_DIRECTORIES ) && isDir ) )
	  || ( (sendflags = (enum ScanFileProcessFlags)0), CompareMask( findmask( pInfo )
#ifdef WIN32
#  ifdef UNDER_CE
																							  , finddata(pInfo)->cFileName
#  else
																							  , pData->file_buffer
#  endif
#else
																							  , pData->scanning_mount?pData->scanning_mount->fsi->find_get_name( findcursor( pInfo ) ) : de->d_name
#endif
																								// yes this is silly - but it's correct...
																							  , (flags & SFF_IGNORECASE)?0:0 ) ) )
	{
		//lprintf( "Send %s", pData->buffer );
		if( Process != NULL ) {
			//lprintf( "Process with flags:%s %d", pData->buffer, sendflags );
			Process( psvUser, pData->buffer, sendflags );
		}
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo)?1:0;
	}
	if( tmp_base )
		Release( tmp_base );
	return (*pInfo)?1:0;
}
int  ScanFiles ( CTEXTSTR base
                , CTEXTSTR mask
                , void **pInfo
                , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, enum ScanFileProcessFlags flags )
                , enum ScanFileFlags flags
                , uintptr_t psvUser )
 {
	 return ScanFilesEx( base, mask, pInfo, Process, flags, psvUser, FALSE, NULL );
 }
//---------------------------------------------------------------------------
 void  ScanDrives ( void (CPROC*Process)(uintptr_t user, CTEXTSTR letter, int flags)
									, uintptr_t user )
{
#ifdef WIN32
#  ifdef UNDER_CE
	Process( user, "", SFF_DRIVE );
#  else
	uint32_t drives;
	int i;
	drives = GetLogicalDrives();
	for( i = 0; i < 26; i++ )
	{
		TEXTCHAR name[2];
		name[1] = 0;
		if( drives & ( 1 << i ) )
		{
			name[0] = 'A' + i;
			if( Process )
				Process( user, name, SFF_DRIVE );
		}
	}
#  endif
#endif
}
#undef findhandle
#undef finddata
#undef findbuffer
#undef findbasename
#undef findmask
#undef findmaskw
#undef findinfo
#undef findcursor
FILESYS_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2017++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 *
 * see also - include/logging.h
 *
 */
//#define SUPPORT_LOG_ALLOCATE
//#define DEFAULT_OUTPUT_STDERR
//#define DEFAULT_OUTPUT_STDOUT
#define COMPUTE_CPU_FREQUENCY
#define NO_UNICODE_C
//#undef UNICODE
#ifdef __LCC__
#include <intrinsics.h>
#endif
#ifdef __LINUX__
#ifndef _GNU_SOURCE
// timegm - ISOC2X feature
#  define _GNU_SOURCE
#endif
 // struct sockaddr_un
#include <sys/un.h>
#endif
#ifdef __ANDROID__
#include <android/log.h>
#endif
#ifdef WIN32
#ifndef _ARM_
 // unlink
#endif
#endif
// okay this brings TIGHT integration.... but standardization for core levels.
#ifndef __NO_OPTIONS__
#endif
#ifdef __cplusplus
#include <cstdio>
#endif
LOGGING_NAMESPACE
#ifndef _SH_DENYWR
#  define _SH_COMPAT 0x00
#  define _SH_DENYRW 0x10
#  define _SH_DENYWR 0x20
#  define _SH_DENYRD 0x30
#  define _SH_DENYNO 0x40
#  define _SH_SECURE 0x80
#endif
struct syslog_local_data {
int cannot_log;
#define cannot_log (*syslog_local).cannot_log
uint64_t cpu_tick_freq;
#define cpu_tick_freq (*syslog_local).cpu_tick_freq
// (*syslog_local).flags that control the operation of system logging....
struct state_flags{
	BIT_FIELD bInitialized : 1;
	BIT_FIELD bUseDay : 1;
	BIT_FIELD bUseDeltaTime : 1;
	BIT_FIELD bLogTime : 1;
	BIT_FIELD bLogHighTime : 1;
	BIT_FIELD bLogCPUTime : 1;
	BIT_FIELD bProtectLoggedFilenames : 1;
	BIT_FIELD bLogProgram : 1;
	BIT_FIELD bLogThreadID : 1;
	BIT_FIELD bLogOpenAppend : 1;
	BIT_FIELD bLogOpenBackup : 1;
	BIT_FIELD bLogSourceFile : 1;
	BIT_FIELD bOptionsLoaded : 1;
	BIT_FIELD group_ok : 1;
	BIT_FIELD bUseStdout : 1;
	BIT_FIELD bUseStderr : 1;
} flags;
// a conserviative minimalistic configuration...
//} (*syslog_local).flags = { 0,0,1,0,1,0,1,1,0};
 TEXTCHAR *pProgramName;
#define pProgramName (*syslog_local).pProgramName
 UserLoggingCallback UserCallback;
//#define User1Callback (*syslog_local).UserCallback
 enum syslog_types logtype;
#define logtype (*syslog_local).logtype
 // default log EVERYTHING
 uint32_t nLogLevel;
#define nLogLevel (*syslog_local).nLogLevel
 // bits enabled and disabled for custom mesasges...
 uint32_t nLogCustom;
#define nLogCustom (*syslog_local).nLogCustom
// = "LOG";
 CTEXTSTR gFilename;
#define gFilename (*syslog_local).gFilename
 FILE *file;
 SOCKET   hSock;
#define hSock (*syslog_local).hSock
 SOCKET   hSyslogdSock;
 // assume this works, until it fails
 int bCPUTickWorks;
#define bCPUTickWorks (*syslog_local).bCPUTickWorks
 uint64_t tick_bias;
 uint64_t lasttick;
 uint64_t lasttick2;
 LOGICAL bStarted;
 LOGICAL bLogging;
 LOGICAL bSyslogdLogging;
	PLINKQUEUE buffers;
#if defined( WIN32 )
	DWORD next_lprintf_tls;
#elif defined( __LINUX__ )
	pthread_key_t next_lprintf_tls;
#endif
};
#ifdef __ANDROID__
//#  if !USE_CUSTOM_ALLOCER
//#    define __STATIC_GLOBALS__
//#  endif //!USE_CUSTOM_ALLOCER
#endif
#ifndef __STATIC_GLOBALS__
struct syslog_local_data *syslog_local;
#else
struct syslog_local_data _syslog_local;
struct syslog_local_data *syslog_local = &_syslog_local;
#endif
static void free_next_info( void );
static void DoSystemLog( const TEXTCHAR *buffer );
//----------------------------------------------------------------------------
// we should really wait until the very end to cleanup?
PRIORITY_ATEXIT( CleanSyslog, ATEXIT_PRIORITY_SYSLOG )
{
	enum syslog_types _logtype;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
		return;
#endif
	_logtype = logtype;
	if( ( _logtype == SYSLOG_AUTO_FILE && (*syslog_local).file ) || ( _logtype == SYSLOG_NONE ) )
		lprintf( "Final log - syslog clos(ing)ed." );
 // this was dynamic allocated memory, and it is now gone.
	pProgramName = NULL;
	logtype = SYSLOG_NONE;
	switch( _logtype )
	{
  // usually this is stderr ... don't do anything
	case SYSLOG_FILE:
		break;
	case SYSLOG_FILENAME:
		sack_fclose( (*syslog_local).file );
		break;
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	case SYSLOG_SOCKET_SYSLOGD:
		closesocket( (*syslog_local).hSyslogdSock );
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		break;
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	case SYSLOG_UDP:
	case SYSLOG_UDPBROADCAST:
		closesocket( hSock );
		hSock = INVALID_SOCKET;
		break;
#endif
	default:
		// else... no resources to cleanup
		break;
	}
}
#if 0
        /*
         * this code would ideally check to see if
         * the cpu rdtsc instruction worked....
         * someday we should consider using the rdtscp instruction
         * but that will require fetching CPU characteristics
         * - SEE mmx.asm in src/imglib/
         */
void TestCPUTick( void )
{
	uint64_t tick, _tick;
	int n;
	bCPUTickWorks = 1;
	_tick = tick = GetCPUTick();
	for( n = 0; n < 10000000; n++ )
	{
#ifdef GCC
		//asm( "cpuid\n" );
#endif
		tick = GetCPUTick();
		if( tick > _tick )
		{
			//lprintf( "%020Ld %020Ld", _tick, tick );
			_tick = tick;
		}
		else
		{
			lprintf( "CPU TICK FAILED!" );
			bCPUTickWorks = 0;
			break;
		}
		Relinquish();
	}
}
#endif
#ifdef __WATCOMC__
unsigned __int64 rdtsc( void);
#pragma aux rdtsc = 0x0F 0x31 value [edx eax] parm nomemory modify exact [edx eax] nomemory;
//#pragma aux GetCPUTicks3 = "rdtsc"   "mov dword ptr tick, eax"	   "mov dword ptr tick+4, edx "
#endif
uint64_t GetCPUTick(void )
{
/*
 * being the core of CPU tick layer type stuff
 * this should result in ticks, and fail ticks
 * to return reasonable defaults...
 * I guess there should be a tick_base to result
 * the same type of number when it does go backwards
 */
	if( bCPUTickWorks )
	{
#if defined( __LCC__ )
		return _rdtsc();
#elif defined( __WATCOMC__ )
		uint64_t tick = rdtsc();
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#elif defined( _MSC_VER )
#  ifdef _M_CEE_PURE
		//return System::DateTime::now;
		return 0;
#  else
#   if defined( _WIN64 )
		uint64_t tick = __rdtsc();
#   else
		static uint64_t tick;
#     if _ARM_
		tick = tick+1;
#     else
		_asm rdtsc;
		_asm mov dword ptr [tick], eax;
		_asm mov dword ptr [tick + 4], edx;
#     endif
#   endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#  endif
#elif defined( __GNUC__ ) && !defined( __arm__ ) && !defined( __aarch64__ ) && !defined( __asmjs__ )
		union {
			uint64_t tick;
			PREFIX_PACKED struct { uint32_t low, high; } PACKED parts;
		}tick;
#ifndef PEDANTIC_TEST
		asm( "rdtsc\n" : "=a"(tick.parts.low), "=d"(tick.parts.high) );
#endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick.tick;
		else if( tick.tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick.tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick.tick;
		return tick.tick;
#else
		DebugBreak();
#endif
	}
/*GetTickCount()*/
	return (*syslog_local).tick_bias + (timeGetTime() * 1000);
}
uint64_t GetCPUFrequency( void )
{
#ifdef COMPUTE_CPU_FREQUENCY
	{
		uint64_t cpu_tick, _cpu_tick;
		uint32_t tick, _tick;
		cpu_tick = _cpu_tick = GetCPUTick();
/*GetTickCount()*/
		tick = _tick = timeGetTime();
		cpu_tick_freq = 0;
/*GetTickCount()*/
		while( bCPUTickWorks && ( ( tick = timeGetTime() ) - _tick ) < 25 );
		cpu_tick = GetCPUTick();
		if( bCPUTickWorks )
 // microseconds;
			cpu_tick_freq = ( ( cpu_tick - _cpu_tick ) / ( tick - _tick ) )  / 1000;
	}
#else
	cpu_tick_freq = 1;
#endif
	return cpu_tick_freq;
}
void SetDefaultName( CTEXTSTR path, CTEXTSTR name, CTEXTSTR extra )
{
	TEXTCHAR *newpath;
	size_t len;
// = GetProgramPath();
	static CTEXTSTR filepath;
// = GetProgramName();
	static CTEXTSTR filename;
	if( path )
	{
		if( filepath )
			Release( (POINTER)filepath );
		filepath = StrDup( path );
	}
	if( name )
	{
		if( filename )
			Release( (POINTER)filename );
		filename = StrDup( name );
	}
	if( !filepath ) {
#ifdef _WIN32
		filepath = ExpandPath( "*/" );
#else
		filepath = ExpandPath( ";/" );
#endif
	}
	if( !filename )
		filename = StrDup( GetProgramName() );
	if( !filename )
		filename = "org.d3x0r.sack";
	// this has to come from C heap.. my init isn't done yet probably and
	// sharemem will just fai(*syslog_local).  (it's probably trying to log... )
	newpath = (TEXTCHAR*)malloc( len = sizeof(TEXTCHAR)*(9 + StrLen( filepath ) + StrLen( filename ) + (extra?StrLen(extra):0) + 5) );
#ifdef __cplusplus_cli
	tnprintf( newpath, len, "%s%s%s.cli.log", filepath, filename, extra?extra:"" );
#else
	tnprintf( newpath, len, "%s%s%s.log", filepath, filename, extra?extra:"" );
#endif
//( newpath ); // use the C heap.
	gFilename = newpath;
	//free( newpath ); // get rid of this ...
}
#ifndef __NO_OPTIONS__
static void LoadOptions( void )
{
	if( !(*syslog_local).flags.bOptionsLoaded )
	{
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName()
																 , "SACK/Logging/Log Source File"
																 , (*syslog_local).flags.bLogSourceFile, TRUE );
#ifndef __ANDROID__
		// android has a system log that does just fine/ default startup sets that.
		if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Enable System Log"
										, 0
										, TRUE ) )
		{
			logtype = SYSLOG_SYSTEM;
			(*syslog_local).flags.bLogProgram = 1;
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Enable File Log"
										, ( logtype == SYSLOG_AUTO_FILE )
										, TRUE ) )
		{
			//logtype = SYSLOG_AUTO_FILE;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogOpenBackup = 1;
			(*syslog_local).flags.bLogProgram = 1;
		}
		// set all default parts of the name.
		// this overrides options with options available from SQL database.
		if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Default Log Location is current directory", 0, TRUE ) )
		{
			// override filepath, if log exception.
			TEXTCHAR buffer[256];
			GetCurrentPath( buffer, sizeof( buffer ) );
			SetDefaultName( buffer, NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Default Log Location is exectuable directory", 0, TRUE ) )
		{
			SetDefaultName( GetProgramPath(), NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Default Log Location is common data directory", 1, TRUE ) )
		{
			SetDefaultName( NULL, NULL, NULL );
		}
		else
		{
			TEXTCHAR buffer[256];
			// if this is blank, then length result from getprofilestring is 0, and default is with the program.
			// so I'll lave functionality as expected for a default.
			SACK_GetProfileStringEx( GetProgramName(), "SACK/Logging/Default Log Location", "", buffer, sizeof( buffer ), TRUE );
			if( buffer[0] )
			{
				SetDefaultName( buffer, NULL, NULL );
			}
		}
		(*syslog_local).flags.bUseStdout = SACK_GetProfileIntEx( GetProgramName()
																 , "SACK/Logging/Use STDOUT"
																 , (*syslog_local).flags.bLogSourceFile, TRUE );
		(*syslog_local).flags.bUseStderr = SACK_GetProfileIntEx( GetProgramName()
																 , "SACK/Logging/Use STDERR"
																 , (*syslog_local).flags.bLogSourceFile, !(*syslog_local).flags.bUseStdout );
#endif
		if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Send Log to UDP", 0, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Broadcast UDP", 0, TRUE ) )
				logtype = SYSLOG_UDPBROADCAST;
			else
				logtype = SYSLOG_UDP;
		}
		nLogLevel = SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Default Log Level (1001:all, 100:least)", nLogLevel, TRUE );
		// use the defaults; they may be overriden by reading the options.
		(*syslog_local).flags.bLogThreadID = SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Thread ID", (*syslog_local).flags.bLogThreadID, TRUE );
		(*syslog_local).flags.bLogProgram = SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Program", (*syslog_local).flags.bLogProgram, TRUE );
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Source File", (*syslog_local).flags.bLogSourceFile, TRUE );
		if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log CPU Tick Time and Delta", (*syslog_local).flags.bLogCPUTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_CPU|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Time as Delta", (*syslog_local).flags.bUseDeltaTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_HIGH|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Time", (*syslog_local).flags.bLogTime, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), "SACK/Logging/Log Date", (*syslog_local).flags.bUseDay, TRUE ) )
			{
				SystemLogTime( SYSLOG_TIME_LOG_DAY|SYSLOG_TIME_HIGH );
			}
			else
				SystemLogTime( SYSLOG_TIME_HIGH );
		}
		else
			SystemLogTime( 0 );
		(*syslog_local).flags.bOptionsLoaded = 1;
	}
}
#endif
//static int init_complete;
void InitSyslog( int ignore_options )
{
#ifndef __STATIC_GLOBALS__
	if( syslog_local )
	{
#ifndef __NO_OPTIONS__
		if( !ignore_options )
			LoadOptions();
#endif
		return;
	}
	SimpleRegisterAndCreateGlobal( syslog_local );
#endif
	if( !(*syslog_local).flags.bInitialized )
	{
		//logtype = SYSLOG_FILE;
		//(*syslog_local).file = stderr;
#if defined( WIN32 )
		(*syslog_local).next_lprintf_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &((*syslog_local).next_lprintf_tls), NULL );
#endif
		(*syslog_local).flags.bLogThreadID = 1;
		hSock = INVALID_SOCKET;
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		bCPUTickWorks = 1;
 // default log EVERYTHING
		nLogLevel = LOG_NOISE-1;
#ifdef __ANDROID__
		{
			logtype = SYSLOG_SYSTEM;
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
		}
#else
#  if defined( _DEBUG ) || defined( DEFAULT_OUTPUT_STDERR ) || defined( DEFAULT_OUTPUT_STDOUT )
		{
#    if defined( __LINUX__ ) && 0
			logtype = SYSLOG_SOCKET_SYSLOGD;
			(*syslog_local).flags.bLogProgram = 1;
#    else
			/* using SYSLOG_AUTO_FILE option does not require this to be open.
			* it is opened on demand.
			*/
			(*syslog_local).flags.bLogOpenBackup = 0;
#      if !defined( DEFAULT_OUTPUT_STDERR ) &&  !defined( DEFAULT_OUTPUT_STDOUT )
			if( (*syslog_local).flags.bUseStdout ){
				logtype = SYSLOG_FILE;
				(*syslog_local).file = stdout;
			} else if( (*syslog_local).flags.bUseStdout ) {
				logtype = SYSLOG_FILE;
				(*syslog_local).file = stderr;
			} else {
				logtype = SYSLOG_AUTO_FILE;
				(*syslog_local).flags.bLogOpenBackup = 1;
			}
#      endif
#        if defined( DEFAULT_OUTPUT_STDERR )
		( *syslog_local ).file = stderr;
		logtype = SYSLOG_FILE;
#        else
		( *syslog_local ).file = stdout;
		logtype = SYSLOG_FILE;
#        endif
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
#    endif
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			//SetDefaultName( NULL, NULL, NULL );
			//lprintf( "Syslog Initializing, debug mode, startup programname.log\n" );
		}
#  else
		// stderr?
		logtype = SYSLOG_NONE;
		(*syslog_local).file = NULL;
#  endif
#endif
		(*syslog_local).flags.bInitialized = 1;
	}
#ifndef __NO_OPTIONS__
	if( !ignore_options )
		LoadOptions();
#else
	(*syslog_local).flags.bOptionsLoaded = 1;
#  ifndef __ANDROID__
	SetDefaultName( NULL, NULL, NULL );
#  endif
#endif
}
PRIORITY_PRELOAD( InitSyslogPreload, SYSLOG_PRELOAD_PRIORITY )
{
	InitSyslog( 1 );
}
// delay reading options (unless we had to because of a logging requirement) but all core
// logging should be disabled (usually) until after init.
// that will allow these to be set with interface.conf defaults.
// but still fairly early...
PRIORITY_PRELOAD( InitSyslogPreloadWithOptions, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
	InitSyslog( 0 );
	OnThreadExit( free_next_info );
}
PRIORITY_PRELOAD( InitSyslogPreloadAllowGroups, DEFAULT_PRELOAD_PRIORITY + 1 )
{
	(*syslog_local).flags.group_ok = 1;
}
//----------------------------------------------------------------------------
CTEXTSTR GetTimeEx( int bUseDay )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	if( bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), "%02d/%02d/%d %02d:%02d:%02d"
		       , st.wMonth, st.wDay, st.wYear
		       , st.wHour, st.wMinute, st.wSecond );
	else
		tnprintf( timebuffer, sizeof(timebuffer), "%02d:%02d:%02d"
		       , st.wHour, st.wMinute, st.wSecond );
	return timebuffer;
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
				, sizeof( timebuffer )
				, (bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
			  , timething );
#endif
	return timebuffer;
}
CTEXTSTR GetTime( void )
{
	return GetTimeEx( (*syslog_local).flags.bUseDay );
}
CTEXTSTR GetPackedTime( void )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	tnprintf( timebuffer, sizeof(timebuffer), "%04d%02d%02d%02d%02d%02d"
	        , st.wYear
	        , st.wMonth, st.wDay
	        , st.wHour, st.wMinute, st.wSecond );
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
	        , sizeof( timebuffer )
	        , "%Y%m%d%H%M%S"
	        , timething );
#endif
	return timebuffer;
}
int GetTimeZone( void ){
    time_t gmt, rawtime = time(NULL);
    struct tm *ptm;
#if !defined(WIN32)
    struct tm gbuf;
    ptm = gmtime_r(&rawtime, &gbuf);
#else
    ptm = gmtime(&rawtime);
#endif
    // Request that mktime() looksup dst in timezone database
    ptm->tm_isdst = -1;
    gmt = mktime(ptm);
	{
		int seconds = (int)difftime( rawtime, gmt );
		int sign = 1;
		if( seconds < 0 ) {
			sign = -1;
			seconds = -seconds;
		}
		return sign * (((seconds / 60 / 60) * 100) + ((seconds / 60) % 60));
	}
}
void ConvertTickToTime( int64_t tick, PSACK_TIME st ) {
	int8_t tz = (int8_t)tick;
	int sign = (tz < 0) ? -1 : 1;
	if( tz < 0 ) tz = -tz;
#ifdef _WIN32
	static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
	tick >>= 8;
	tick *= 10000LL;
	tick += EPOCH;
	// Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
	// This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
	// until 00:00:00 January 1, 1970
	SYSTEMTIME  system_time;
	FILETIME    file_time;
	file_time.dwLowDateTime = tick & 0xFFFFFFFF;
	file_time.dwHighDateTime = ( tick >> 32 ) & 0xFFFFFFFF;
	FileTimeToSystemTime( &file_time, &system_time );
	st->yr = system_time.wYear;
	st->mo = (uint8_t)system_time.wMonth;
	st->dy = (uint8_t)system_time.wDay;
	st->hr = (uint8_t)system_time.wHour;
	st->mn = (uint8_t)system_time.wMinute;
	st->sc = (uint8_t)system_time.wSecond;
	st->ms = system_time.wMilliseconds;
	st->zhr = sign* (( tz * 15 ) / 60);
	st->zmn = (tz*15) % 60;
#else
	struct timeval tv;
	struct tm tm;
	tv.tv_sec = ( tick >> 8 ) / 1000;
	tv.tv_usec =  ( ( tick >> 8 ) % 1000 ) * 1000;
	localtime_r( &tv.tv_sec, &tm );
	st->yr = tm.tm_year + 1900;
	st->mo = tm.tm_mon+1;
	st->dy = tm.tm_mday;
	st->hr = tm.tm_hour;
	st->mn = tm.tm_min;
	st->sc = tm.tm_sec;
	st->ms = tv.tv_usec / 1000;
	st->zhr = sign* (( tz * 15 ) / 60);
	st->zmn = (tz*15) % 60;
#endif
}
int64_t GetTimeOfDay( uint64_t* tick, int8_t* ptz )
{
	//struct timezone tzp;
	int tz = GetTimeZone();
	if( tz < 0 )
 // -840/15 = -56
		tz = -(((-tz / 100) * 60) + (-tz % 100)) / 15;
	else
 // -840/15 = -56  720/15 = 48
		tz = (((tz / 100) * 60) + (tz % 100)) / 15;
	tick[0] = timeGetTime64ns();
	tick[0] += (int64_t)tz * 900 * (int64_t)1000000000;
	ptz[0] = tz;
	return ( tick[0] /1000000 )<<8 | (tz&0xFF);
#ifdef _WIN32
	// Note: some broken versions only have 8 trailing zero's, the correct epoch has 9 trailing zero's
	// This magic number is the number of 100 nanosecond intervals since January 1, 1601 (UTC)
	// until 00:00:00 January 1, 1970
	static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
	SYSTEMTIME  system_time;
	FILETIME    file_time;
	uint64_t    time;
	GetSystemTime( &system_time );
	SystemTimeToFileTime( &system_time, &file_time );
	time = ((uint64_t)file_time.dwLowDateTime);
	time += ((uint64_t)file_time.dwHighDateTime) << 32;
	return (((uint64_t)((time - EPOCH) / 10000L)) << 8) | (tz & 0xFF);
#else
	{
		struct timeval tp;
		gettimeofday( &tp, NULL );
		return  (((uint64_t)(tp.tv_sec * 1000L) + (uint64_t)(tp.tv_usec)) << 8) | (tz & 0xFF);
	}
#endif
}
int64_t ConvertTimeToTick( PSACK_TIME st ) {
	int tz;
	int sign = st->zhr < 0 ? -1 : 1;
	tz = sign * (((sign*st->zhr * 60) + st->zmn) / 15);
#ifdef _WIN32
	SYSTEMTIME  system_time;
	FILETIME    file_time;
	uint64_t    time;
	system_time.wYear = st->yr;
	system_time.wMonth = st->mo;
	system_time.wDay = st->dy;
	system_time.wHour = st->hr;
	system_time.wMinute = st->mn;
	system_time.wSecond = st->sc;
	system_time.wMilliseconds = st->ms;
	SystemTimeToFileTime( &system_time, &file_time );
	static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
	time = ((uint64_t)file_time.dwLowDateTime);
	time += ((uint64_t)file_time.dwHighDateTime) << 32;
	return (((uint64_t)((time - EPOCH) / 10000L)) << 8) | (tz & 0xFF);
#else
	struct tm t;
	time_t t_of_day;
	t.tm_year = st->yr - 1900;
           // Month, 0 - jan
	t.tm_mon = st->mo-1;
          // Day of the month
	t.tm_mday = st->dy;
	t.tm_hour = st->hr;
	t.tm_min = st->mn;
	t.tm_sec = st->sc;
        // Is DST on? 1 = yes, 0 = no, -1 = unknown
	t.tm_isdst = 0;
	t_of_day = timegm( &t );
	return ((((int64_t)t_of_day) * 1000ULL + st->ms) << 8) | (tz&0xFF);
#endif
}
//----------------------------------------------------------------------------
 // no gettime of day - no milliseconds
#ifndef BCC16
static TEXTCHAR *GetTimeHigh( void )
{
#  if defined WIN32 && !defined( __ANDROID__ )
	 static TEXTCHAR timebuffer[256];
	static SYSTEMTIME _st;
	SYSTEMTIME st, st_save;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		GetLocalTime( &st );
		st_save = st;
		if( !_st.wYear )
			_st = st;
		st.wMilliseconds -= _st.wMilliseconds;
		if( st.wMilliseconds & 0x8000 )
		{
			st.wMilliseconds = (st.wMilliseconds+1000) & 0xFFFF;
			st.wSecond--;
		}
		st.wSecond -= _st.wSecond;
		if( st.wSecond & 0x8000 )
		{
			st.wSecond += 60;
			st.wMinute--;
		}
		st.wMinute -= _st.wMinute;
		if( st.wMinute & 0x8000 )
		{
			st.wMinute += 60;
			st.wHour--;
		}
		st.wHour -= _st.wHour;
		if( st.wHour & 0x8000 )
			st.wHour += 24;
		_st = st_save;
	}
	else
		GetLocalTime( &st );
	if( (*syslog_local).flags.bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), "%02d/%02d/%d %02d:%02d:%02d.%03d"
		        , st.wMonth, st.wDay, st.wYear
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
	else
		tnprintf( timebuffer, sizeof(timebuffer), "%02d:%02d:%02d.%03d"
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
#  else
	static char timebuffer[256];
	static struct timeval _tv;
	static struct tm _tm;
	struct timeval tv, tv_save;
	struct tm *timething, tm, tm_save;
	int len;
	gettimeofday( &tv, NULL );
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		tv_save = tv;
		timething = localtime( &tv.tv_sec );
		tm = tm_save = *timething;
		if( !_tm.tm_year )
		{
			_tm = *timething;
			_tv = tv;
		}
		tv.tv_usec -= _tv.tv_usec;
		if( tv.tv_usec < 0 )
		{
			tv.tv_usec += 1000000;
			tm.tm_sec--;
		}
		tm.tm_sec -= _tm.tm_sec;
		if( tm.tm_sec < 0 )
		{
			tm.tm_sec += 60;
			tm.tm_min--;
		}
		tm.tm_min -= _tm.tm_min;
		if( tm.tm_min < 0 )
		{
			tm.tm_min += 60;
			tm.tm_hour--;
		}
		tm.tm_hour -= _tm.tm_hour;
		if( tm.tm_hour < 0 )
			tm.tm_hour += 24;
		_tm = tm_save;
		_tv = tv_save;
	}
	else
	{
		timething = localtime( &tv.tv_sec );
		tm = *timething;
	}
	len = strftime( timebuffer
	               , sizeof( timebuffer )
	               , ((*syslog_local).flags.bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
					  , &tm );
#  undef snprintf
	snprintf( timebuffer + len, 5, ".%03ld", tv.tv_usec / 1000 );
	/*
	// this code is kept in case borland's compiler don't like it.
	{
		time_t timevalnow;
		time(&timevalnow);
		timething = localtime( &timevalnow );
		strftime( timebuffer
		        , sizeof( timebuffer )
		        , "%m/%d/%Y %H:%M:%S.000"
		        , timething );
	}
	*/
#  endif
	return timebuffer;
}
#else
#  define GetTimeHigh GetTime
#endif
uint32_t ConvertTickToMicrosecond( uint64_t tick )
{
	if( bCPUTickWorks )
	{
		if( !cpu_tick_freq )
			GetCPUFrequency();
		if( !cpu_tick_freq )
			return 0;
		return (uint32_t)(tick / cpu_tick_freq);
	}
	else
		return (uint32_t)tick;
}
void PrintCPUDelta( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end )
{
#ifdef COMPUTE_CPU_FREQUENCY
	if( !cpu_tick_freq )
		GetCPUFrequency();
	if( cpu_tick_freq )
		tnprintf( buffer, buflen, "%" _64f ".%03" _64f
				 , ((tick_end-tick_start) / cpu_tick_freq ) / 1000
				 , ((tick_end-tick_start) / cpu_tick_freq ) % 1000
				 );
	else
#endif
		tnprintf( buffer, buflen, "%" _64fs, tick_end - tick_start
			    );
}
static TEXTCHAR *GetTimeHighest( void )
{
	uint64_t tick;
	static TEXTCHAR timebuffer[64];
	tick = GetCPUTick();
	if( !(*syslog_local).lasttick2 )
		(*syslog_local).lasttick2 = tick;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
#ifdef UNICODE
		size_t ofs = 0;
		tnprintf( timebuffer, sizeof( timebuffer ), "%20lld" " ", tick );
		ofs += StrLen( timebuffer );
#else
		int ofs = tnprintf( timebuffer, sizeof( timebuffer ), "%20" _64fs " ", tick );
#endif
		PrintCPUDelta( timebuffer + ofs, sizeof( timebuffer ) - ofs, (*syslog_local).lasttick2, tick );
		(*syslog_local).lasttick2 = tick;
	}
	else
		tnprintf( timebuffer, sizeof( timebuffer ), "%20" _64fs, tick );
	// have to find a generic way to get this from _asm( rdtsc );
	return timebuffer;
}
static CTEXTSTR GetLogTime( void )
{
	if( (*syslog_local).flags.bLogTime )
	{
		if( (*syslog_local).flags.bLogHighTime )
		{
			return GetTimeHigh();
		}
		else if( (*syslog_local).flags.bLogCPUTime )
		{
			return GetTimeHighest();
		}
		else
		{
			return GetTime();
		}
	}
	return "";
}
//----------------------------------------------------------------------------
#ifndef __DISABLE_UDP_SYSLOG__
#  if !defined( FBSD ) && !defined(__QNX__)
#    if defined( __MAC__ )
static SOCKADDR saLogBroadcast  = { 8, 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 8, 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 8, 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    else
static SOCKADDR saLogBroadcast  = { 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    endif
#  else
static SOCKADDR saLogBroadcast  = { 2, 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff };
static SOCKADDR saLog  = { 2, 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01  };
static SOCKADDR saBind = { 2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  };
#  endif
static void UDPSystemLog( const TEXTCHAR *message )
{
#ifdef HAVE_IDLE
	while( (*syslog_local).bLogging )
		Idle();
#endif
	(*syslog_local).bLogging = 1;
	if( !(*syslog_local).bStarted )
	{
#ifdef _WIN32
#ifndef MAKEWORD
#define MAKEWORD(a,b) (((a)<<8)|(b))
#endif
  // used to start up the socket services...
		WSADATA ws;
		if( WSAStartup( MAKEWORD(1,1), &ws ) )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
#endif
		(*syslog_local).bStarted = TRUE;
	}
	if( hSock == INVALID_SOCKET )
	{
		LOGICAL bEnable = TRUE;
		hSock = socket(PF_INET,SOCK_DGRAM,0);
		if( hSock == INVALID_SOCKET )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
		if( bind(hSock,&saBind,sizeof(SOCKADDR)) )
		{
			closesocket( hSock );
			hSock = INVALID_SOCKET;
			(*syslog_local). bLogging = 0;
			return;
		}
#ifndef BCC16
		if( setsockopt( hSock, SOL_SOCKET
		              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
		{
			Log( "Failed to set sock opt - BROADCAST" );
		}
#endif
	}
	{
		//INDEX nSent;
		int nSend;
		static TEXTCHAR realmsg[1024];
 /*"[%s]"*/
		nSend = tnprintf( realmsg, sizeof( realmsg ), "%s"
				  //, pProgramName
		                , message );
		message = realmsg;
#ifdef __cplusplus_cli
		char *tmp = CStrDup( realmsg );
#  define SENDBUF tmp
#else
#  define SENDBUF message
#endif
		sendto( hSock, (const char *)SENDBUF, nSend, 0
		      , (logtype == SYSLOG_UDPBROADCAST)
		        ? &saLogBroadcast
		        : &saLog
		      , sizeof( SOCKADDR ) );
#ifdef __cplusplus_cli
		Release( tmp );
#endif
		if( logtype != SYSLOG_UDPBROADCAST )
 // allow logging agents time to pick this up...
			Relinquish();
	}
	(*syslog_local).bLogging = 0;
}
#endif
//----------------------------------------------------------------------------
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
#    if !defined( FBSD ) && !defined(__QNX__)
#       if defined( __MAC__ )
static struct sockaddr_un saSyslogdAddr  = { 11, AF_UNIX, "/dev/log" };
#       else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, "/dev/log" };
#       endif
#    else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, {"/dev/log"} };
#    endif
static void SyslogdSystemLog( const TEXTCHAR *message )
{
	while( (*syslog_local).bSyslogdLogging )
#    ifdef HAVE_IDLE
		Idle();
#    else
		Relinquish();
#    endif
	//fprintf( stderr, "present." );
	(*syslog_local).bSyslogdLogging = 1;
	if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
	{
		(*syslog_local).hSyslogdSock = socket(AF_UNIX,SOCK_DGRAM,0);
		if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
		{
			//fprintf( stderr, "failed..." );
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
		if(connect((*syslog_local).hSyslogdSock,(struct sockaddr *)&saSyslogdAddr,sizeof(saSyslogdAddr)) )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
	}
	if( (*syslog_local).hSyslogdSock != INVALID_SOCKET )
	{
		if( send( (*syslog_local).hSyslogdSock, message, StrLen( message ), 0 ) == 0 )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		}
	}
	(*syslog_local).bSyslogdLogging = 0;
}
#  endif
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
#  ifdef __EMSCRIPTEN_
LOGICAL IsBadReadPtr( CPOINTER pointer, uintptr_t len )
{
   return FALSE;
}
#  else
//---------------------------------------------------------------------------
struct map_entry {
	uintptr_t low;
	uintptr_t high;
};
typedef struct map_entry MEMORYREADPTRMAPENTRY;
#define MAXMEMORYREADPTRMAPENTRYSPERSET 512
DeclareSet( MEMORYREADPTRMAPENTRY );
static PMEMORYREADPTRMAPENTRYSET entryPool;
static int compare_addr( uintptr_t a, uintptr_t b )
{
	struct map_entry *ma = (struct map_entry *)a;
	struct map_entry *mb = (struct map_entry *)b;
	if( ma->low < mb->low || ma->high <= mb->low )
		return -1;
	if( ma->high > mb->high || ma->low >= mb->high )
		return 1;
	// else ma->low <= b && ma->high >= b
	return 0;
}
static int check_addr( uintptr_t psv, uintptr_t key )
{
	struct map_entry *ma = (struct map_entry *)key;
	if( psv < ma->low )
		return -1;
	if( psv > ma->high )
		return 1;
	return 0;
}
static void delete_addr( CPOINTER data, uintptr_t key )
{
	Release( (POINTER)key );
}
LOGICAL IsBadReadPtr( CPOINTER pointer, uintptr_t len )
{
	static size_t last_low, last_high;
	static PTREEROOT map_index;
 // reference unused.
	(void)len;
	static FILE *maps;
	uintptr_t ptr = (uintptr_t)pointer;
	// quick check last known result
	if( ptr >= last_low && ptr <= last_high )
		return FALSE;
	if( !map_index ){
		map_index = CreateBinaryTreeExtended( BT_OPT_NODUPLICATES, compare_addr, delete_addr DBG_SRC );
	}
	if( !maps )
		maps = fopen( "/proc/self/maps", "rt" );
	else {
		struct map_entry *found;
		if( found = (struct map_entry *)LocateInBinaryTree( map_index, ptr, check_addr ) ) {
			last_low = found->low;
			last_high = found->high;
			return FALSE;
		}
		fseek( maps, 0, SEEK_SET );
	}
	//fprintf( stderr, "Testing a pointer..\n" );
	if( maps )
	{
		struct map_entry *tmp;
		char line[256];
		while( fgets( line, sizeof(line)-1, maps ) )
		{
			size_t low, high;
			//tmp = (struct map_entry *)Allocate( sizeof( struct map_entry ) );
//(struct map_entry *)Allocate( sizeof( struct map_entry ) );
			tmp = GetFromSet( MEMORYREADPTRMAPENTRY, &entryPool );
			sscanf( line, "%zx-%zx", &tmp->low, &tmp->high );
			//fprintf( stderr, "%s" "Find: %08" PTRSZVALfx " Low: %08" PTRSZVALfx " High: %08" PTRSZVALfx "\n"
			//		 , line, pointer, low, high );
			if( !AddBinaryNode( map_index, tmp, (uintptr_t)tmp ) )
			{
				// if the node existed before, then it didn't match...
				Release( (POINTER)tmp );
				continue;
			}
			if( ptr >= tmp->low && ptr <= tmp->high )
			{
				last_low = tmp->low;
				last_high = tmp->high;
				return FALSE;
			}
		}
	}
	//fprintf( stderr, "%p is not valid. %d", pointer, errno );
	return TRUE;
}
//---------------------------------------------------------------------------
 // emscripten
#endif
#endif
static void FileSystemLog( CTEXTSTR message )
{
	if( (*syslog_local).file )
	{
#ifdef SUPPORT_LOG_ALLOCATE
		fputs( message, (*syslog_local).file );
		fputs( "\n", (*syslog_local).file );
		fflush( (*syslog_local).file );
#else
#  ifdef UNICODE
		fputws( message, (*syslog_local).file );
		fputws( "\n", (*syslog_local).file );
#  else
		sack_fputs( message, (*syslog_local).file );
		sack_fputs( "\n", (*syslog_local).file );
#  endif
		sack_fflush( (*syslog_local).file );
#endif
	}
}
static void BackupFile( const TEXTCHAR *source, int source_name_len, int n )
{
	FILE *testfile;
	INDEX group;
	testfile = sack_fsopenEx( group = GetFileGroup( "system.logs", GetProgramPath() ), source, "rt", _SH_DENYWR, NULL );
	if( testfile )
	{
		TEXTCHAR backup[256];
		sack_fclose( testfile );
		// move file to backup..
		tnprintf( backup, sizeof( backup ), "%*.*s.%d"
				  , source_name_len
				  , source_name_len
				  , source, n );
		if( n < 10 )
		{
			BackupFile( backup
							, source_name_len
							, n+1 );
		}
		else
			sack_unlink( group, source );
		//lprintf( "%s->%s", source, backup );
		sack_rename( source, backup );
	}
}
void DoSystemLog( const TEXTCHAR *buffer )
{
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		InitSyslog( 1 );
		if( logtype == SYSLOG_AUTO_FILE && !(*syslog_local).file )
		{
			// cannot log until system log is complete
			return;
		}
		if( ( logtype == SYSLOG_UDPBROADCAST ) || ( logtype == SYSLOG_UDP ) )
			return;
	}
#endif
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	if( logtype == SYSLOG_SOCKET_SYSLOGD )
		SyslogdSystemLog( buffer );
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	if( logtype == SYSLOG_UDP
		|| logtype == SYSLOG_UDPBROADCAST )
		UDPSystemLog( buffer );
#else
 // needs to exist because next thing is else if
	if( 0 )
		;
#endif
	else if( ( logtype == SYSLOG_FILE ) || ( logtype == SYSLOG_AUTO_FILE ) )
	{
		if( logtype == SYSLOG_AUTO_FILE )
		{
			if( !(*syslog_local).file && gFilename )
			{
				int n_retry = 0;
			retry_again:
 // disable logging - internal functions might inadvertantly log something...
				logtype = SYSLOG_NONE;
				if(
#ifdef SUPPORT_LOG_ALLOCATE
					0 &&
#endif
					!(*syslog_local).flags.bOptionsLoaded )
				{
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, "wt" );
#else
					(*syslog_local).file = sack_fsopen( 0, gFilename, "wt"
#  ifdef _UNICODE
						", ccs=UNICODE"
#  endif
						, _SH_DENYWR );
#endif
				}
				else
				{
					if(
#ifdef SUPPORT_LOG_ALLOCATE
						0 &&
#endif
						(*syslog_local).flags.bLogOpenBackup )
					{
						BackupFile( gFilename, (int)StrLen( gFilename ), 1 );
					}
					else if( (*syslog_local).flags.bLogOpenAppend )
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, "at+" );
#else
					(*syslog_local).file = sack_fsopen( (*syslog_local).flags.group_ok?GetFileGroup( "system.logs", GetProgramPath() ):(INDEX)0, gFilename, "at+"
#  ifdef _UNICODE
						", ccs=UNICODE"
#  endif
						, _SH_DENYWR );
#endif
					if( (*syslog_local).file )
						fseek( (*syslog_local).file, 0, SEEK_END );
					else
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, "wt" );
#else
					(*syslog_local).file = sack_fsopenEx( (*syslog_local).flags.group_ok?GetFileGroup( "system.logs", GetProgramPath() ):(INDEX)0, gFilename, "wt"
#  ifdef _UNICODE
							", ccs=UNICODE"
#  endif
							, _SH_DENYWR, NULL );
#endif
				}
				//logtype = SYSLOG_AUTO_FILE;
				if( !(*syslog_local).file )
				{
					if( n_retry < 500 )
					{
						TEXTCHAR tmp[10];
						tnprintf( tmp, sizeof( tmp ), "%d", n_retry++ );
						SetDefaultName( NULL, NULL, tmp );
						goto retry_again;
					}
					else
						// can't open the logging file, stop trying now, will save us trouble in the future
						logtype = SYSLOG_NONE;
				}
				else
					logtype = SYSLOG_AUTO_FILE;
			}
		}
		FileSystemLog( buffer );
	}
#if defined( _WIN32 ) || defined( __ANDROID__ )
	else if( logtype == SYSLOG_SYSTEM )
	{
#  ifdef __cplusplus_cli
		// requires referenced xperdex.classes... if this doesn't compile, please add the reference
		//xperdex::classes::Log::log( gcnew System::String( buffer ) );
		//System::Console::WriteLine( gcnew System::String( buffer ) );
		//System::Diagnostics::Debug
#  else
#    ifdef __ANDROID__
		{
			static char *program_string;
			char *string = CStrDup( buffer );
			if( !program_string )
				program_string = CStrDup( GetProgramName() );
			if( !program_string )
				program_string = "com.unknown.app";
			__android_log_print( ANDROID_LOG_INFO, program_string, string );
			Release( string );
		}
#    else
		OutputDebugString( buffer );
		OutputDebugString( "\n" );
#    endif
#  endif
	}
	else
#endif
	if( logtype == SYSLOG_CALLBACK )
		(*syslog_local).UserCallback( buffer );
}
	static volatile uint32_t openLock;
	static volatile uint32_t lowLevelLock;
void SystemLogFL( const TEXTCHAR *message FILELINE_PASS )
{
	static TEXTCHAR buffer[4096];
	static TEXTCHAR threadid[32];
	static TEXTCHAR sourcefile[256];
	CTEXTSTR logtime;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return;
		openLock = 0;
	}
#endif
	if( cannot_log )
		return;
	if( !(*syslog_local).flags.group_ok && openLock )
		return;
	while( LockedExchange( &lowLevelLock, 1 ) ) Relinquish();
	logtime = GetLogTime();
	if( (*syslog_local).flags.bLogSourceFile && pFile )
	{
#ifndef _LOG_FULL_FILE_NAMES
		CTEXTSTR p;
		for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
#endif
		tnprintf( sourcefile, sizeof( sourcefile ), "" FILELINE_FILELINEFMT  FILELINE_RELAY );
	}
	else
		sourcefile[0] = 0;
	if( (*syslog_local).flags.bLogThreadID ) {
#ifdef WIN32
		tnprintf( threadid, sizeof( threadid ), "%012" _64fX "~", GetThisThreadID() );
#else
		tnprintf( threadid, sizeof( threadid ), "%012" _64fX ":%d~", GetThisThreadID(), (int)(GetThisThreadID()&0x7FFFFFFF) );
#endif
	}
	if( pFile )
		tnprintf( buffer, sizeof( buffer )
				  , "%s%s%s%s%s%s%s"
				  , logtime, logtime[0]?"|":""
				  , (*syslog_local).flags.bLogThreadID?threadid:""
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):""
				  , (*syslog_local).flags.bLogProgram?"@":""
				  , (*syslog_local).flags.bLogSourceFile?sourcefile:""
				  , message );
	else
		tnprintf( buffer, sizeof( buffer )
				  , "%s%s%s%s%s%s"
				  , logtime, logtime[0]?"|":""
				  , (*syslog_local).flags.bLogThreadID?threadid:""
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):""
				  , (*syslog_local).flags.bLogProgram?"@":""
				  , message );
	DoSystemLog( buffer );
	lowLevelLock = 0;
}
void BinaryToString( PVARTEXT pvt, const uint8_t* buffer, size_t size DBG_PASS ) {
	size_t nOut = size;
	const uint8_t* data = buffer;
	// should make this expression something in signed_usigned_comparison...
	while( nOut && !( nOut & ( ( (size_t)1 ) << ( ( sizeof( nOut ) * CHAR_BIT ) - 1 ) ) ) ) {
		TEXTCHAR cOut[96];
		size_t ofs = 0;
		size_t x;
		ofs = 0;
		for( x = 0; x < nOut && x < 16; x++ )
			 ofs += tnprintf( cOut + ofs, sizeof( cOut ) / sizeof( TEXTCHAR ) - ofs, "%02X ", (unsigned char)data[x] );
		// space fill last partial buffer
		for( ; x < 16; x++ )
			 ofs += tnprintf( cOut + ofs, sizeof( cOut ) / sizeof( TEXTCHAR ) - ofs, "   " );
		for( x = 0; x < nOut && x < 16; x++ ) {
			 if( data[x] >= 32 && data[x] < 127 )
				 ofs += tnprintf( cOut + ofs, sizeof( cOut ) / sizeof( TEXTCHAR ) - ofs, "%c", (unsigned char)data[x] );
			 else
				 ofs += tnprintf( cOut + ofs, sizeof( cOut ) / sizeof( TEXTCHAR ) - ofs, "." );
		}
		VarTextAddDataEx( pvt, cOut, ofs DBG_RELAY );
		VarTextAddCharacterEx( pvt, '\n' DBG_RELAY);
		nOut -= x;
		data += x;
	}
}
void  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS )
{
	size_t nOut = size;
	const uint8_t* data = buffer;
#ifndef _LOG_FULL_FILE_NAMES
	if( pFile )
	{
		CTEXTSTR p;
		for( p = pFile + (pFile?StrLen(pFile) -1:0);p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
	}
#endif
	// should make this expression something in signed_usigned_comparison...
	while( nOut && !( nOut & ( ((size_t)1) << ( ( sizeof( nOut ) * CHAR_BIT ) - 1 ) ) ) )
	{
		TEXTCHAR cOut[96];
		size_t ofs = 0;
		size_t x;
		ofs = 0;
		for ( x=0; x<nOut && x<16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, "%02X ", (unsigned char)data[x] );
		// space fill last partial buffer
		for( ; x < 16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, "   " );
		for ( x=0; x<nOut && x<16; x++ )
		{
			if( data[x] >= 32 && data[x] < 127 )
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, "%c", (unsigned char)data[x] );
			else
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, "." );
		}
		SystemLogFL( cOut FILELINE_RELAY );
		nOut -= x;
		data += x;
	}
}
#undef LogBinaryEx
 void  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS )
{
#ifdef _DEBUG
	LogBinaryFL( buffer,size DBG_RELAY );
#else
	LogBinaryFL( buffer,size FILELINE_NULL );
#endif
}
#undef LogBinary
 void  LogBinary ( const uint8_t* buffer, size_t size )
{
	LogBinaryFL( buffer,size, NULL, 0 );
}
void  SetSystemLog ( enum syslog_types type, const void *data )
{
	if( (*syslog_local).file && ( logtype != SYSLOG_FILE ) )
	{
		FILE *close_file = (*syslog_local).file;
  // reset this first, in case logging closing.
		(*syslog_local).file = NULL;
      if( !( close_file == stderr || close_file == stdout ) )
			sack_fclose( close_file );
	}
	if( type == SYSLOG_FILE )
	{
		if( data )
		{
			logtype = type;
			(*syslog_local).file = (FILE*)data;
		}
	}
	else if( type == SYSLOG_FILENAME )
	{
		FILE *log;
		log = sack_fsopen( GetFileGroup( "system.logs", GetProgramPath() ), (CTEXTSTR)data, "wt"
#ifdef _UNICODE
				", ccs=UNICODE"
#endif
				, _SH_DENYWR );
		(*syslog_local).file = log;
		logtype = SYSLOG_FILE;
	}
	else if( type == SYSLOG_CALLBACK )
	{
		(*syslog_local).UserCallback = (UserLoggingCallback)(uintptr_t)data;
	}
	else
	{
		logtype = type;
	}
	//SystemLog( "thing is: " STRSYM( (SYSLOG_EXTERN) ) );
}
 void  SystemLogTime ( LOGICAL enable )
{
	(*syslog_local).flags.bLogTime = FALSE;
	(*syslog_local).flags.bUseDay = FALSE;
	(*syslog_local).flags.bUseDeltaTime = FALSE;
	(*syslog_local).flags.bLogHighTime = FALSE;
	(*syslog_local).flags.bLogCPUTime = FALSE;
	if( enable )
	{
		(*syslog_local).flags.bLogTime = TRUE;
		if( enable & SYSLOG_TIME_HIGH )
			(*syslog_local).flags.bLogHighTime = TRUE;
		if( enable & SYSLOG_TIME_LOG_DAY )
			(*syslog_local).flags.bUseDay = TRUE;
		if( enable & SYSLOG_TIME_DELTA )
			(*syslog_local).flags.bUseDeltaTime = TRUE;
		if( enable & SYSLOG_TIME_CPU )
			(*syslog_local).flags.bLogCPUTime = TRUE;
	}
}
// information for the call to _real_lprintf file and line information...
struct next_lprint_info{
	// please use this enter when resulting a function, and leave from said function.
	// oh - but then we couldn't exist before crit sec code...
	//CRITICALSECTION cs;
	uint32_t nLevel;
	CTEXTSTR pFile;
	int nLine;
};
#define next_lprintf (*_next_lprintf)
static struct next_lprint_info *GetNextInfo( void )
{
	struct next_lprint_info *next;
#ifdef USE_CUSTOM_ALLOCER
#  if defined( WIN32 )
	if( !( next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls ) ) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = (struct next_lprint_info*)malloc( sizeof( struct next_lprint_info ) ) );
#  elif defined( __LINUX__ )
	if( !( next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls ) ) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = (struct next_lprint_info*)malloc( sizeof( struct next_lprint_info ) ) );
#  endif
#else
#  if defined( WIN32 )
	if( !(next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls )) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  elif defined( __LINUX__ )
	if( !(next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls )) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  endif
#endif
	return next;
}
void free_next_info( void ) {
	struct next_lprint_info *next;
#ifdef USE_CUSTOM_ALLOCER
#  if defined( WIN32 )
	if( ( next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls ) ) ){
		TlsSetValue( (*syslog_local).next_lprintf_tls, NULL );
		free( next );
	}
#  elif defined( __LINUX__ )
	if( ( next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls ) ) ) {
		pthread_setspecific( (*syslog_local).next_lprintf_tls, NULL );
		free( next );
	}
#  endif
#else
#  if defined( WIN32 )
	if( (next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls )) ) {
		TlsSetValue( (*syslog_local).next_lprintf_tls, NULL );
		Release( next );
	}
#  elif defined( __LINUX__ )
	if( (next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls )) ) {
		pthread_setspecific( (*syslog_local).next_lprintf_tls, NULL );
		Release( next );
	}
#  endif
#endif
}
static INDEX CPROC _null_vlprintf ( CTEXTSTR format, va_list args )
{
 // fix unused
   (void)format;
 // fix unused
   (void)args;
	return 0;
}
static INDEX CPROC _real_vlprintf ( CTEXTSTR format, va_list args )
{
#ifdef _DEBUG
	// this can be used to force logging early to stdout
	struct next_lprint_info *_next_lprintf = GetNextInfo();
#endif
	if( cannot_log )
		return 0;
	if( logtype != SYSLOG_NONE )
	{
		CTEXTSTR logtime = GetLogTime();
		size_t ofs;
		// because of threading concerns... either I dynamically allocate this...
		// or lock it.... or ...
		TEXTCHAR *buffer;
		TEXTCHAR threadid[32];
		cannot_log = 1;
		if( !(*syslog_local).buffers )
		{
			int n;
			(*syslog_local).buffers = CreateLinkQueue();
			for( n = 0; n < 6; n++ )
				EnqueLink( &(*syslog_local).buffers, (POINTER)1 );
			for( n = 0; n < 6; n++ )
				DequeLink( &(*syslog_local).buffers );
		}
		buffer = (TEXTCHAR*)DequeLink( &(*syslog_local).buffers );
		if( !buffer )
		{
			//DoSystemLog( "Adding Logging Buffer" );
			buffer = NewArray( TEXTCHAR, 4096 );
		}
		// at this point we're not doing internal allocations...
		cannot_log = 0;
		if( logtime[0] )
			ofs = tnprintf( buffer, 4095, "%s|"
							  , logtime );
		else
			ofs = 0;
		// argsize - the program's giving us file and line
		// debug for here or not, this must be used.
		if( (*syslog_local).flags.bLogThreadID ) {
#ifdef WIN32
			tnprintf( threadid, sizeof( threadid ), "%012" _64fX "~", GetThisThreadID() );
#else
			tnprintf( threadid, sizeof( threadid ), "%012" _64fX ":%d~", GetThisThreadID(), (int)(GetThisThreadID()&0x7FFFFFFF) );
#endif
		}
#ifdef UNDER_CE
		tnprintf( buffer + ofs, 4095 - ofs, "%s%s%s"
				  , (*syslog_local).flags.bLogThreadID?threadid:""
				  , (*syslog_local).flags.bLogProgram?GetProgramName():""
				  , (*syslog_local).flags.bLogProgram?"@":""
				  );
		ofs += StrLen( buffer + ofs );
#else
		tnprintf( buffer + ofs, 4095 - ofs, "%s%s%s"
				  , (*syslog_local).flags.bLogThreadID?threadid:""
				  , (*syslog_local).flags.bLogProgram?GetProgramName():""
				  , (*syslog_local).flags.bLogProgram?"@":""
				  );
		ofs += StrLen( buffer + ofs );
#endif
		{
#ifdef _DEBUG
			CTEXTSTR pFile;
#ifndef _LOG_FULL_FILE_NAMES
			CTEXTSTR p;
#endif
			uint32_t nLine;
			if( (*syslog_local).flags.bLogSourceFile && ( pFile = next_lprintf.pFile ) )
			{
				if( (*syslog_local).flags.bProtectLoggedFilenames )
					if( IsBadReadPtr( pFile, 2 ) )
						pFile = "(Unloaded file?)";
#   ifndef _LOG_FULL_FILE_NAMES
				for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
					if( p[0] == '/' || p[0] == '\\' )
					{
						pFile = p+1;break;
					}
#   endif
				nLine = next_lprintf.nLine;
				tnprintf( buffer + ofs, 4095 - ofs, "%s(%" _32f "):"
									, pFile, nLine );
				ofs += StrLen( buffer + ofs );
			}
#endif
			vsnprintf( buffer + ofs, 4095 - ofs, format, args );
			// okay, so even the above is unsafe, because Micro$oft has
			// decreed to be stupid.
			buffer[4095] = 0;
		}
		DoSystemLog( buffer );
		{
			cannot_log = 1;
			EnqueLink( &(*syslog_local).buffers, buffer );
			cannot_log = 0;
		}
	}
	//LeaveCriticalSec( &next_lprintf.cs );
	return 0;
}
static INDEX CPROC _real_lprintf( CTEXTSTR f, ... )
{
	va_list args;
	va_start( args, f );
	return _real_vlprintf( f, args );
}
static INDEX CPROC _null_lprintf( CTEXTSTR f, ... )
{
 // fix unused
   (void)f;
	return 0;
}
RealVLogFunction  _vxlprintf ( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
	_next_lprintf = GetNextInfo();
	next_lprintf.nLevel = level;
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_vlprintf;
		return _real_vlprintf;
	}
	else if( level <= nLogLevel )
	{
		return _real_vlprintf;
	}
	return _null_vlprintf;
}
RealLogFunction _xlprintf( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return _null_lprintf;
		//return _null_lprintf;
		openLock = 0;
	}
#else
	if( !(*syslog_local).flags.bInitialized )
		InitSyslog(1);
#endif
	_next_lprintf = GetNextInfo();
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_lprintf;
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	else if( level <= nLogLevel )
	{
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	return _null_lprintf;
}
#ifdef __WATCOMC__
// # again - WATCOM Compiler warning here, function
// defined, but never referenced.  This is true,
// but when the linker comes around to it, it cares for the
// presense of this function in order to force floating support
// for printf and scanf, since this is module is passed ANY
// format and ANY paramter, it may require floating point.
// no special handling required for GCC, lcc, MSVC
static int f(void )
{
	extern int fltused_;
	return fltused_ + (int)f;
	//int n = fltused_; // force inclusion of math libs...
}
#endif
void ProtectLoggedFilenames( LOGICAL bEnable )
{
	(*syslog_local).flags.bProtectLoggedFilenames = bEnable;
}
void SetSystemLoggingLevel( uint32_t nLevel )
{
	if( nLevel & LOG_CUSTOM )
	{
		nLogCustom |= nLevel & ( LOG_CUSTOM_BITS );
	}
	else if( nLevel & LOG_CUSTOM_DISABLE )
	{
		nLogCustom &= ~( nLevel & ( LOG_CUSTOM_BITS ) );
	}
	else
		nLogLevel = nLevel;
}
void SetSyslogOptions( FLAGSETTYPE *options )
{
	// the mat operations don't turn into valid bitfield operators. (watcom)
 // open for append, else open for write //-V616
	(*syslog_local).flags.bLogOpenAppend = TESTFLAG( options, SYSLOG_OPT_OPENAPPEND )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogOpenBackup = TESTFLAG( options, SYSLOG_OPT_OPEN_BACKUP )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogProgram = TESTFLAG( options, SYSLOG_OPT_LOG_PROGRAM_NAME )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogThreadID = TESTFLAG( options, SYSLOG_OPT_LOG_THREAD_ID )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogSourceFile = TESTFLAG( options, SYSLOG_OPT_LOG_SOURCE_FILE )?1:0;
}
LOGGING_NAMESPACE_END
//---------------------------------------------------------------------------
// $Log: syslog.c,v $
// Revision 1.74  2005/05/30 11:56:36  d3x0r
// various fixes... working on psilib update optimization... various stabilitizations... also extending msgsvr functionality.
//
// < --- CUT ALL LOGGING --- >
//
// Revision 1.56  2003/12/04 10:41:30  panther
// remove watcom compile only option code
//
//
#define NO_UNICODE_C
#ifdef _MSC_VER
//#define NO_CRT_SECURE_WARNINGS
#endif
#define DEFINE_DEFAULT_IMAGE_INTERFACE
 // sockaddr, createaddress(str,defport)
#define FULL_TRACE
#define LOG_LINES_READ
////#define DEBUG_SLOWNESS
//#define DEBUG_SAVE_CONFIG
//#if defined( GCC ) && !defined( __arm__ )
//#define NEED_ASSEMBLY_CALLER
//#endif
#define DO_LOGGING
/*
 *  Creator: Jim Buckeyne
 *  Header for configscript.lib(bag.lib)
 *  Provides definitions for handling configuration files
 *  or any particular file which has machine generated
 *  characteristics, it can handle translators to decrypt
 *  encrypt.  Method of operation is to create a configuration
 *  evaluator, then AddConfiguratMethod()s to it.
 *  configuration methods are format descriptors for the lines
 *  and a routine which is called when such a line is matched.
 *  One might think of it as a trigger library for MUDs ( a
 *  way to trigger an event based on certain text input,
 *  variations in the text input may be assigned as variables
 *  to be used within the event.
 *
 *  More about configuration string parsing is available in
 *  $(SACK_BASE)/src/configlib/config.rules text file.
 *
 *  A vague attempt at providing a class to derrive a config-
 *  uration reader class, which may contain private data
 *  within such a class, or otherwise provide an object with
 *  simple namespace usage. ( add(), go() )
 *
 *  This library also imlements several PTEXT based methods
 *  which can evaluate text segments into valid binary types
 *  such as text to integer, float, color, etc.  Some of the type
 *  validators applied for the format argument matching of added
 *  methods are available for external reference.
 *
 */
#ifndef CONFIGURATION_SCRIPT_HANDLER
#define CONFIGURATION_SCRIPT_HANDLER
#ifdef CONFIGURATION_LIBRARY_SOURCE
#define CONFIGSCR_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define CONFIGSCR_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
namespace sack {
	/* <combinewith configscript.h>
	   \ \                          */
	namespace config {
#endif
typedef char *__arg_list[1];
typedef __arg_list arg_list;
// declare 'va_list args = NULL;' to use successfully...
// the resulting thing is of type va_list.
typedef struct va_args_tag va_args;
enum configArgType {
	CONFIG_ARG_STRING,
	CONFIG_ARG_INT64,
	CONFIG_ARG_FLOAT,
	CONFIG_ARG_DATA,
	CONFIG_ARG_DATA_SIZE,
	CONFIG_ARG_LOGICAL,
	CONFIG_ARG_FRACTION,
	CONFIG_ARG_COLOR,
};
struct va_args_tag {
	int argsize; arg_list *args; arg_list *tmp_args; int argCount;
};
//#define va_args struct { int argsize; arg_list *args; arg_list *tmp_args; }
#define init_args(name) name.argCount = 0; name.argsize = 0; name.args = NULL;
  // 32 bits.
#define ARG_STACK_SIZE 4
#define PushArgument( argset, argType, type, arg )	                                 ((argset.args = (arg_list*)Preallocate( argset.args		                        , argset.argsize += ((sizeof( enum configArgType )				                 + sizeof( type )				                                   + (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) ) )	        ?(argset.argCount++)	                                                        ,((*(enum configArgType*)(argset.args))=(argType))	                         ,(*(type*)((((uintptr_t)argset.args)+sizeof(enum configArgType)+ (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) = (arg))	   ,0	                                                                        :0)
#define PopArguments( argset ) { Release( argset.args ); argset.args=NULL; }
#define pass_args(argset) (( (argset).tmp_args = (argset).args )	                        ,(*(arg_list*)(&argset.tmp_args)))
/*
 * Config methods are passed an arg_list
 * parameters from arg_list are retrieved using
 * PARAM( arg_list_param_name, arg_type, arg_name );
 * ex.
 *
 *   PARAM( args, char *, name );
 *    // results in a variable called name
 *    // initialized from the first argument in arg_list args;
 */
#define my_va_arg(ap,type)     ((ap)[0]+=        ((sizeof(enum configArgType)+sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)),        (*(type *)((ap)[0]-((sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
#define my_va_arg_type(ap,type)     (         (*(type *)((ap)[0]-(sizeof(enum configArgType)+(sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
//#define my_va_next_arg_type(ap,type)     (*(type *)((ap)[0]))
#define my_va_next_arg_type(ap)     ( ( *(enum configArgType *)((ap)[0]) ) )
#define PARAM_COUNT( args ) (((int*)(args+1))[0])
#define PARAM( args, type, name ) type name = my_va_arg( args, type )
#define PARAMEX( args, type, name, argTypeName ) type name = my_va_arg( args, type ); enum configArgType argTypeName = my_va_arg_type(args)
#define FP_PARAM( args, type, name, fa ) type (CPROC*name)fa = (type (CPROC*)fa)(my_va_arg( args, void *))
typedef struct config_file_tag* PCONFIG_HANDLER;
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void );
#define CreateConfigurationHandler CreateConfigurationEvaluator
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch );
#define DestroyConfigurationHandler DestroyConfigurationEvaluator
// this pushes all prior state information about configuration file
// processing, and allows a new set of rules to be made...
CONFIGSCR_PROC( void, BeginConfiguration )( PCONFIG_HANDLER pch );
// begins a sub configuration, and marks to save it for future use
// so we don't have to always recreate the configuration states...
CONFIGSCR_PROC( LOGICAL, BeginNamedConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR name );
// then, when you're done with the new set of rules (end of config section)
// use this to restore the prior configuration state.
CONFIGSCR_PROC( void, EndConfiguration )( PCONFIG_HANDLER pch );
typedef uintptr_t (CPROC*USER_CONFIG_HANDLER)( uintptr_t, arg_list args );
typedef uintptr_t( CPROC*USER_CONFIG_HANDLER_EX )(uintptr_t, uintptr_t, arg_list args);
CONFIGSCR_PROC( void, AddConfigurationEx )( PCONFIG_HANDLER pch
														, CTEXTSTR format
														, USER_CONFIG_HANDLER Process DBG_PASS );
CONFIGSCR_PROC( void, AddConfigurationExx )(PCONFIG_HANDLER pch
	, CTEXTSTR format
	, USER_CONFIG_HANDLER_EX Process, uintptr_t processHandler DBG_PASS);
//CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch
//					, char *format
//													 , USER_CONFIG_HANDLER Process );
// make a nice wrapper - otherwise we get billions of complaints.
//#define AddConfiguration(pch,format,process) AddConfiguration( (pch), (format), process )
#define AddConfiguration(pch,f,pr) AddConfigurationEx(pch,f,pr DBG_SRC )
#define AddConfigurationMethod AddConfiguration
// FILTER receives a uintptr_t that was given at configuration (addition to handler)
// it receives a PTEXT block of (binary) data... and must result with
// PTEXT segments which are lines which may or may not have \r\n\\ all
// of which are removed before being resulted to the application.
//   POINTER* is a pointer to a pointer, this pointer may be used
//      for private state data.  The last line of the configuration will
//      call the filter chain with NULL to flush data...
typedef PTEXT (CPROC*USER_FILTER)( POINTER *, PTEXT );
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter );
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch );
CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch, uintptr_t (CPROC *Process)( uintptr_t ) );
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) );
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch
															  , CTEXTSTR name
															  , uintptr_t psv
															  );
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR block, size_t size, uintptr_t psv );
/*
 * TO BE IMPLEMENTED
 *
CONFIGSCR_PROC( int, vcsprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, va_list args );
CONFIGSCR_PROC( int, csprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, ... );
*/
CONFIGSCR_PROC( int, GetBooleanVar )( PTEXT *start, LOGICAL *data );
CONFIGSCR_PROC( int, GetColorVar )( PTEXT *start, CDATA *data );
//CONFIGSCR_PROC( int, IsBooleanVar )( PCONFIG_ELEMENT pce, PTEXT *start );
//CONFIGSCR_PROC( int, IsColorVar )( PCONFIG_ELEMENT pce, PTEXT *start );
// takes a binary block of data and creates a base64-like string which may be stored.
CONFIGSCR_PROC( void, EncodeBinaryConfig )( TEXTSTR *encode, POINTER data, size_t length );
// this isn't REALLY the same function that's used, but serves the same purpose...
CONFIGSCR_PROC( int, DecodeBinaryConfig )( CTEXTSTR String, POINTER *binary_buffer, size_t *buflen );
CONFIGSCR_PROC( CTEXTSTR, FormatColor )( CDATA color );
CONFIGSCR_PROC( void, StripConfigString )( TEXTSTR out, CTEXTSTR in );
CONFIGSCR_PROC( void, ExpandConfigString )( TEXTSTR out, CTEXTSTR in );
#ifdef __cplusplus
//typedef uintptr_t CPROC ::(*USER_CONFIG_METHOD)( ... );
typedef class config_reader {
   PCONFIG_HANDLER pch;
public:
	config_reader() {
      pch = CreateConfigurationEvaluator();
	}
	~config_reader() {
		if( pch ) DestroyConfigurationEvaluator( pch );
      pch = (PCONFIG_HANDLER)NULL;
	}
	inline void add( CTEXTSTR format, USER_CONFIG_HANDLER Process )
	{
      AddConfiguration( pch, format, Process );
	}
   /*
	inline void add( char *format, USER_CONFIG_METHOD Process )
	{
		union {
			struct {
				uint32_t junk;
            USER_CONFIG_HANDLER Process
			} c;
         USER_CONFIG_METHOD Process;
		} x;
      x.Process = Process;
      AddConfiguration( pch, format, x.c.Process );
		}
      */
	inline int go( CTEXTSTR file, POINTER p )
	{
		return ProcessConfigurationFile( pch, file, (uintptr_t)p );
	}
} CONFIG_READER;
#endif
#ifdef __cplusplus
 //namespace sack { namespace config {
}
SACK_NAMESPACE_END
using namespace sack::config;
#endif
#endif
// $Log: configscript.h,v $
// Revision 1.17  2004/12/05 15:32:06  panther
// Some minor cleanups fixed a couple memory leaks
//
// Revision 1.16  2004/08/13 16:48:19  d3x0r
// added ability to put filters on config script data read.
//
// Revision 1.15  2004/02/18 20:46:37  d3x0r
// Add some aliases for badly named routines
//
// Revision 1.14  2004/02/08 23:33:15  d3x0r
// Add a iList class for c++, public access to building parameter va_lists
//
// Revision 1.13  2003/12/09 16:15:56  panther
// Define unhnalded callback set
//
// Revision 1.12  2003/11/09 22:31:58  panther
// Fix CPROC indication on endconfig method
//
// Revision 1.11  2003/10/13 04:25:14  panther
// Fix configscript library... make sure types are consistant (watcom)
//
// Revision 1.10  2003/10/12 02:47:05  panther
// Cleaned up most var-arg stack abuse ARM seems to work.
//
// Revision 1.9  2003/09/24 02:53:58  panther
// Define c++ wrapper for config script library
//
// Revision 1.8  2003/07/24 22:49:01  panther
// Modify addconfig method macro to auto typecast - dangerous by simpler
//
// Revision 1.7  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.6  2003/04/17 09:32:51  panther
// Added true/false result from processconfigfile.  Added default load from /etc to msgsvr and display
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#ifdef __cplusplus
namespace sack { namespace config {
using namespace sack::math::fraction;
#endif
#ifdef __LINUX__
#define stricmp strcasecmp
#define strnicmp strncasecmp
#endif
#define CompareText(l1,l2)	( StrCaseCmp( GetText(l1), GetText(l2) ) )
// all matches to content are done case insensitive.
// consider vector/array declarations
enum config_types {
	CONFIG_UNKNOWN
	// must match case-insensative exact length.
	// literal text
	, CONFIG_TEXT
	// a yes/no field may be 0/1, y[es]/n[o], on/off
	//
	, CONFIG_YESNO
	, CONFIG_TRUEFALSE = CONFIG_YESNO
	, CONFIG_ONOFF = CONFIG_YESNO
	, CONFIG_OPENCLOSE = CONFIG_YESNO
	, CONFIG_BOOLEAN = CONFIG_YESNO
	// may not have a . point - therefore the . is a terminator and needs
	// to match the next word.
	, CONFIG_INTEGER
	// has to be a floating point number (perhaps integral ie. no decimal)
	, CONFIG_FLOAT
	// binary data storage - stored as base64 encoded passed as PDATA
	, CONFIG_BINARY
	// formated number [+/-][[ ]## ]##[/##]
	, CONFIG_FRACTION
	// matches any single word.
	, CONFIG_SINGLE_WORD
	// protocol://[user[:password]](ip/name)[:port][/filepath][?cgi]
	// by convention this will not contain spaces... but perhaps
	// &20; (?)
	, CONFIG_URL
	// matches several words in a row - the end word to match is supplied.
	, CONFIG_MULTI_WORD
	// file name - does not have any path part.
	// the following are all treated like multi_word since file names/paths
	// may contain spaces
	, CONFIG_FILE
	// ends in a / or \,
	, CONFIG_PATH
	// may have path and filename
	, CONFIG_FILEPATH
	// (IP/name)[:port]
	, CONFIG_ADDRESS
	// end of configuration line (match assumed)
	, CONFIG_PROCEDURE
	, CONFIG_PROCEDURE_EX
	, CONFIG_COLOR
 // to save as an option after variables
	, CONFIG_NOTHING
};
typedef struct config_element_tag CONFIG_ELEMENT, *PCONFIG_ELEMENT;
struct config_element_tag
{
	enum config_types type;
// if a match is found, follow this to next.
	struct config_test_tag *next;
// single word uses this for multi-part phrases that are words
	struct config_test_tag *built_next;
	struct config_element_tag *prior;
 // this is where we came from
	struct config_element_tag **ppMe;
	struct {
		BIT_FIELD vector : 1;
 // prior == actual segment...
		BIT_FIELD multiword_terminator : 1;
 // prior == actual segment...
		BIT_FIELD singleword_terminator : 1;
 // already checked and matched...
		BIT_FIELD matched : 1;
		// careful - assembly here requires absolute known
		// posisitioning - -fpack-struct will short-change
		// this structure to the minimal number of bits.
		BIT_FIELD filler:28;
	} flags;
 // used with vector fields.
	uint32_t element_count;
 // multiword needs to add to possible_checks
	struct config_file_tag *pch;
  // the current test this is a member of (in var or const list)
	struct config_test_tag *Check;
 // relates to the word element this terminates
	struct config_element_tag *word_element;
	union {
		PTEXT pText;
		struct {
				LOGICAL bTrue;
		} truefalse;
		uint64_t integer_number;
		double float_number;
 // also pFilename, pPath, pURL
		TEXTSTR pWord;
		struct {
 // also pFilename, pPath, pURL
			TEXTSTR pWord;
 // also this ends single word...
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} singleword;
		// maybe pURL should be burst into
		//	( address, user, password, path, page, params )
		SOCKADDR *psaSockaddr;
		struct {
			TEXTSTR pWords;
				 // next thing to match...
				 // this is probably a constant text thing, but
				 // may be say an integer, filename, or some known
				 // format thing...
//struct config_element_tag *pEnd;
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} multiword;
		FRACTION fraction;
		USER_CONFIG_HANDLER Process;
		struct {
			USER_CONFIG_HANDLER_EX Process;
			uintptr_t arg;
		} ProcessEx;
		CDATA Color;
		struct {
			size_t length;
			POINTER data;
		} binary;
 // these are value holders... if there is a vector field,
	} data[1];
				// either the count will be specified, or this will have to
				// be auto expanded....
};
#define CONFIG_EMPTY_EXTRA ,NULL,NULL,NULL,NULL,{0,0,0,0,0},0,NULL,NULL,NULL,{{0}}
typedef struct config_test_tag
{
	// this constant list could be a more optimized structure like
	// a tree...
  // list of words which are constant to be checked.
	PLIST pConstElementList;
	// list of fields which are variables.
	PLIST pVarElementList;
} CONFIG_TEST, *PCONFIG_TEST;
#define MAXCONFIG_TESTSPERSET 128
DeclareSet( CONFIG_TEST );
#define MAXCONFIG_ELEMENTSPERSET 128
DeclareSet( CONFIG_ELEMENT );
struct config_multi_word {
 // the element that matched
	PCONFIG_ELEMENT pce;
 // the element that matched
	PCONFIG_ELEMENT pceEnd;
 // text line that matched
	TEXTSTR matched;
};
struct config_check {
 // each test might iterate the word differently
	PTEXT word;
 // the current state of this test.
	PCONFIG_TEST Check;
	PDATALIST multiWords;
};
typedef struct config_file_tag CONFIG_HANDLER;
struct config_file_tag
{
	// this needs to be the first element -
	// address of this IS the address of main structure
	CONFIG_TEST ConfigTestRoot;
	PDATASTACK ConfigStateStack;
	FILE *file;
	//gcroot<System::IO::StreamReader^> sr;
	//gcroot<System::IO::FileStream^> fs;
	PTEXT blocks;
	// this should be more than one...
	// and each will be called in order that it was
	// added, very importatn first in first process
	PLIST filters;
 // a scratch pointer addrss passd to each filter ... (per config handler)
	PLIST filter_data;
	//uintptr_t (CPROC *filter)(uintptr_t,int *,char**);
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
	PCONFIG_ELEMENTSET elements;
	PCONFIG_TESTSET test_elements;
	LOGICAL config_recovered;
	CTEXTSTR save_config_as;
 // history of saved configuration states...
	PLIST states;
	struct config_file_flags {
 // if used, don't release
		BIT_FIELD bConfigSaveNameUsed : 1;
		BIT_FIELD bUnicode : 1;
		BIT_FIELD bUnicode8 : 1;
	} flags;
 // list of possible config_check_tags that are valid...
	PDATALIST possible_checks;
	struct config_check *current_possible;
};
typedef struct configuation_state *PCONFIG_STATE;
typedef struct configuation_state {
	LOGICAL recovered;
	CTEXTSTR name;
	CONFIG_TEST ConfigTestRoot;
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
} CONFIG_STATE;
struct configscript_global {
	//LOGICAL bSaveMemDebug;
	int _last_allocate_logging;
	int _disabled_allocate_logging;
	struct {
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
		BIT_FIELD bLogUnhandled : 1;
		BIT_FIELD bLogTraceBuild : 1;
		BIT_FIELD bLogLines : 1;
		BIT_FIELD bLogTrace : 1;
	} flags;
};
#ifdef g
#  undef g
#endif
#ifndef __STATIC_GLOBALS__
static struct configscript_global *global_config_data;
PRIORITY_PRELOAD( InitGlobalConfigScript, CONFIG_SCRIPT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( global_config_data );
}
#else
static struct configscript_global _global_config_data;
static struct configscript_global *global_config_data = &_global_config_data;
#endif
#define g (*global_config_data)
void DoInit( void )
{
#ifndef __STATIC_GLOBALS__
	if( !global_config_data )
		SimpleRegisterAndCreateGlobal( global_config_data );
#endif
	if( !g.flags.bInitialized )
	{
		g.flags.bDisableMemoryLogging = 1;
		g.flags.bLogUnhandled = 0;
		g.flags.bInitialized = 1;
	}
}
PRELOAD( InitGlobalConfig2 )
{
	DoInit();
#if !defined( __NO_OPTIONS__ )
	// later, set options - core startup configs like sql.config cannot read options.
	g.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( "SACK/Config Script", "Disable Memory Logging", g.flags.bDisableMemoryLogging, TRUE );
	g.flags.bLogUnhandled = SACK_GetProfileIntEx( "SACK/Config Script", "Log Unhandled if no application handler", g.flags.bLogUnhandled, TRUE );
	g.flags.bLogTraceBuild = SACK_GetProfileIntEx( "SACK/Config Script", "Log configuration building(trace)", g.flags.bLogTraceBuild, TRUE );
	g.flags.bLogTrace = SACK_GetProfileIntEx( "SACK/Config Script", "Log configuration processing(trace)", g.flags.bLogTrace, TRUE );
	g.flags.bLogLines = SACK_GetProfileIntEx( "SACK/Config Script", "Log configuration line input", g.flags.bLogLines, TRUE );
#endif
}
//#else
//#define g global_config_data
//static GLOBAL g;
//#endif
//---------------------------------------------------------------------
void LogElementEx( CTEXTSTR leader, PCONFIG_ELEMENT pce DBG_PASS)
#define LogElement(leader,pc) LogElementEx(leader,pc DBG_SRC )
{
	if( !pce )
	{
		_lprintf(DBG_RELAY)( "Nothing." );
		return;
	}
	switch( pce->type )
	{
	case CONFIG_UNKNOWN:
		_lprintf(DBG_RELAY)( "This thing was never configured?" );
		break;
	case CONFIG_TEXT:
		_lprintf(DBG_RELAY)( "%s text constant: %s", leader, GetText( pce->data[0].pText ) );
		break;
	case CONFIG_BOOLEAN:
		_lprintf(DBG_RELAY)( "%s a boolean", leader );
		break;
	case CONFIG_INTEGER:
		_lprintf(DBG_RELAY)( "%s integer", leader );
		break;
	case CONFIG_COLOR:
		_lprintf(DBG_RELAY)( "%s color", leader );
		break;
	case CONFIG_BINARY:
		_lprintf(DBG_RELAY)( "%s binary", leader );
		break;
	case CONFIG_FLOAT:
		_lprintf(DBG_RELAY)( "%s Floating", leader );
		break;
	case CONFIG_FRACTION:
		_lprintf(DBG_RELAY)( "%s fraction", leader );
		break;
	case CONFIG_SINGLE_WORD:
		_lprintf(DBG_RELAY)( "%s a single word:%p", leader, pce->data[0].pWord );
		break;
	case CONFIG_MULTI_WORD:
		_lprintf(DBG_RELAY)( "%s a multi word", leader );
		break;
	case CONFIG_PROCEDURE:
		_lprintf(DBG_RELAY)( "%s a procedure to call.", leader );
		break;
	case CONFIG_PROCEDURE_EX:
		_lprintf( DBG_RELAY )("%s a procedure to call.", leader);
		break;
	case CONFIG_URL:
	_lprintf(DBG_RELAY)( "%s a url?", leader );
	break;
	case CONFIG_FILE:
	_lprintf(DBG_RELAY)( "%s a filename", leader );
	break;
	case CONFIG_PATH:
	_lprintf(DBG_RELAY)( "%s a path name", leader );
	break;
	case CONFIG_FILEPATH:
	_lprintf(DBG_RELAY)( "%s a full path and file name", leader );
	break;
	case CONFIG_ADDRESS:
	_lprintf(DBG_RELAY)( "%s an address", leader );
	break;
	default:
		_lprintf(DBG_RELAY)( "Do not know what this is." );
		break;
	}
}
//---------------------------------------------------------------------
void DumpConfigurationEvaluator( PCONFIG_HANDLER pch )
{
	INDEX idx;
	PCONFIG_ELEMENT pce;
	LIST_FORALL( pch->ConfigTestRoot.pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( "const", pce );
	}
	LIST_FORALL( pch->ConfigTestRoot.pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( "var", pce );
	}
}
//---------------------------------------------------------------------
// man what a friggin mess just to deal with ANY
// kind of mangled input and spit out some kinda lines
// uhmm...
static PTEXT CPROC FilterLines( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		size_t skip;
		int lastread;
		PTEXT linebuf;
	} *data = (struct my_scratch_data*)scratch[0];
	size_t total_length;
	size_t n;
	size_t thisskip;
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].skip = 0;
		data[0].linebuf = 0;
		data[0].lastread = 0;
	}
	else if( !data )
		return NULL;
 // skip N characters in first buffer.
	thisskip = data->skip;
	if( buffer )
	{
		data->lastread = FALSE;
		data->linebuf = SegAppend( data->linebuf, buffer );
	}
#if 0
	// this routine is a low level raw data input, line result routine.
	// it would be the sort of thing that produces zerosegs.
	// this will NEVER run - the above condition catches it.
	else if( buffer && !GetTextSize( buffer ) )
	{
		// if the buffer is a zeroseg, then it's a end of line marker.
		// assuming other things filter before this.... in reality
		// burst returns newlines I think?
		PTEXT text = data->linebuf;
		data->lastread = FALSE;
		Release( scratch[0] );
		scratch[0] = NULL;
		if( text )
		{
			LineRelease( buffer );
			lprintf( "Returning buffer [%s]", GetText( text ) );
			return text;
		}
		else
		{
			lprintf( "Returning buffer [%s]", GetText( buffer ) );
 // pass it on to others - end of stream..
			return buffer;
		}
	}
#endif
	else if( !buffer )
	{
		if( data->lastread )
		{
			PTEXT final = NULL;
			if( data->linebuf )
				final = SegCreateFromText( GetText( data->linebuf ) + data->skip );
			LineRelease( data->linebuf );
			Release( scratch[0] );
			scratch[0] = NULL;
			if( g.flags.bLogLines )
				lprintf( "Returning buffer [%s]", GetText( final ) );
			return final;
		}
	}
	buffer = data->linebuf;
	total_length = 0;
	while( buffer )
	{
		// full new buffer, which may or may not add to prior segments...
		int end = 0;
		size_t length = GetTextSize( buffer );
		CTEXTSTR chardata = GetText( buffer );
		//lprintf( "Considering buffer %s", GetText( buffer ) + data->skip );
		if( !length )
			LineRelease( SegGrab( buffer ) );
		for( n = thisskip; n < length; n++ )
		{
			if( chardata[n] == '\n' ||
				chardata[n] == '\r' )
			{
				if( chardata[n] == '\n' )
				{
					end = 1;
 // include this character.
					n++;
					//lprintf( "BLANK LINE - CONSUMED" );
					break;
				}
 // \r\r is two lines too
				if( end )
				{
					break;
				}
				end = 1;
			}
			else if( end )
			{
				// any other character... after a \r.. don't include the character.
				break;
			}
		}
		total_length += n - thisskip;
		if( end )
		{
			// new character, trim at -1 from here...
			PTEXT result = SegCreate( (int32_t)total_length );
			size_t ofs;
			buffer = data->linebuf;
			thisskip = data->skip;
			n = thisskip;
			ofs = 0;
			while( ofs < total_length )
			{
				size_t len = GetTextSize( buffer );
				if( len > ( len - thisskip ) )
					len = len - thisskip;
				if( len > ( total_length - ofs ) )
					len = total_length - ofs;
				MemCpy( GetText( result ) + ofs
					, GetText( buffer ) + thisskip
					, sizeof( TEXTCHAR)*len );
				ofs += len;
				n += len;
				if( ofs < total_length )
				{
					n = 0;
					thisskip = 0;
					buffer = NEXTLINE( buffer );
				}
			}
			if( buffer )
			{
				data->skip = n;
				LineRelease( SegBreak( buffer ) );
				data->linebuf = buffer;
			}
			else
				data->skip = 0;
			GetText(result)[total_length] = 0;
			//lprintf( "Considering buffer %s", GetText( result ) );
			if( g.flags.bLogLines )
				lprintf( "Returning buffer [%s]", GetText( result ) );
			return result;
		}
		else
		{
			//lprintf( "Had no end within the buffer, waiting for another..." );
		}
 // no more skips.
		thisskip = 0;
		buffer = NEXTLINE( buffer );
	}
	data->lastread = TRUE;
	return NULL;
}
//---------------------------------------------------------------------
static PTEXT CPROC FilterTerminators( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		PTEXT newline;
	} *data = (struct my_scratch_data*)scratch[0];
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].newline = NULL;
	}
	else if( !data )
		return NULL;
	if( !buffer )
	{
		if( data[0].newline )
		{
			PTEXT tmp = data[0].newline;
			data[0].newline = NULL;
			return tmp;
		}
		else
			return NULL;
	}
	{
		int modified;
		int end = TRUE;
		// filter \r\n\\ just cause...
		data[0].newline = SegAppend( data[0].newline, buffer );
		while( buffer )
		{
			TEXTSTR chardata = GetText( buffer );
			size_t length = GetTextSize( buffer );
			//LogBinary( chardata, length );
			do
			{
				modified = 0;
				if( length && chardata[length-1] == '\n' )
				{
					//Log( "Removing newline..." );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\r' )
				{
					//lprintf( "Removing cr..." );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\\' )
				{
					if( ( length > 1 ) && ( chardata[length-2] != '\\' ) )
					{
						//lprintf( "Removing continue slash..." );
						end = FALSE;
						length--;
						modified = 1;
					}
				}
			} while( modified );
			if( !length )
			{
				LineRelease( SegGrab( buffer ) );
				data[0].newline = NULL;
				return NULL;
			}
			chardata[length] = 0;
			//lprintf( "Resulting line: %s", chardata );
			SetTextSize( buffer, length );
			buffer = NEXTLINE( buffer );
		}
		if( end )
		{
			PTEXT result = data[0].newline;
			data[0].newline = NULL;
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
/* does not need scratch buffer... */
static PTEXT CPROC FilterEscapesAndComments( POINTER *scratch, PTEXT pText )
{
	TEXTSTR text = GetText( pText );
	PTEXT pNewText;
   (void)scratch;
 /*&& strchr( text, '\\' )*/
	if( text )
	{
		PTEXT tmp;
		tmp = pNewText = TextDuplicate( pText, FALSE );
		while( tmp )
		{
			int dest = 0, src = 0;
			text = GetText( tmp );
			while( text && text[src] )
			{
				if( text[src] == '\\' )
				{
					src++;
					switch( text[src] )
					{
					case 0:
						lprintf( "Continuation at end of line... save this and append next line please." );
						break;
					default:
						text[dest++] = text[src];
						break;
					}
				}
				else
				{
					if( text[src] == '#' )
						break;
					text[dest++] = text[src];
				}
				src++;
			}
			text[dest] = 0;
			SetTextSize( tmp, dest );
			tmp = NEXTLINE( tmp );
		}
		LineRelease( pText );
	}
	else
		pNewText = pText;
	return pNewText;
}
//---------------------------------------------------------------------
static PTEXT get_line(PCONFIG_HANDLER pch
							, int bReturnBlank )
{
  // character for workspace
#define WORKSPACE 1024
	FILE *source = pch->file;
	PLIST *filters = &pch->filters;
	PLIST *filter_data = &pch->filter_data;
	PTEXT newline = NULL;
	int one_more_read = 0;
	//if( !source && !pch->blocks )
	//	return NULL;
	// create a workspace to read input from the file.
	// read a line of input from the file.
	// can't use fgets with encrypted data, but have to use something
	// more like read(), pass to decrypt, then decode lines.
	{
		INDEX idx;
		PTEXT (CPROC *filter)(POINTER*,PTEXT);
		size_t readlen;
		do
		{
			int didone;
		do_filters:
			do
			{
				didone = FALSE;
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					// request any existing data without adding more...
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( "Process line: %s", GetText( newline ) );
					//lprintf( "after filter %d line = %s", idx, GetText( newline ) );
					if( newline )
					{
						one_more_read = 0;
						didone = TRUE;
					}
					else
					{
						//lprintf( "no more newline... it's been deleted..." );
 // had one, lost it, try for another from the top of blank...
						if( didone )
						{
							if( bReturnBlank )
								return SegCreate(0);
							didone = 0;
							break;
						}
					}
				}
			}
			while( !newline && didone );
			if( !newline )
			{
				if( source )
				{
					char buffer[WORKSPACE];
					wchar_t wbuffer[WORKSPACE];
					newline = NULL;
					if( pch->flags.bUnicode )
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( wbuffer, sizeof( wchar_t ), WORKSPACE-1, source ) ) )
							{
								wbuffer[readlen] = 0;
								newline = SegCreateFromWideLen( wbuffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
					else
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( buffer, sizeof( char ), WORKSPACE-1, source ) ) )
							{
								buffer[readlen] = 0;
								newline = SegCreateFromCharLen( buffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
				}
				else
				{
					if( !one_more_read )
					{
						newline = pch->blocks;
 // received block.
						pch->blocks = NULL;
						one_more_read = 1;
					}
					else if( !newline )
					{
						readlen = 0;
						one_more_read = 0;
					}
				}
				if( newline || one_more_read )
					goto do_filters;
				/*
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( "Process line: %s", GetText( newline ) );
					if( !newline )
						break; // get next bit of data ....
				}
				*/
			}
		}
		while( !newline && readlen );
	}
		// return the line read from the file.
	return newline;
}
//---------------------------------------------------------------------
static PTEXT GetConfigurationLine( PCONFIG_HANDLER pConfigHandler )
{
	PTEXT line, p;
	while( ( line = get_line( pConfigHandler
									, pConfigHandler->Unhandled?TRUE:FALSE ) ) )
	{
		if( g.flags.bLogLines )
			lprintf( "Process line: %s", GetText( line ) );
		p = burst( line );
		LineRelease( line );
		if( g.flags.bLogTrace || g.flags.bLogLines )
		{
			{
				PTEXT x = p;
				while( x )
				{
					lprintf( "Word is: %s (%" _size_f ",%d)", GetText( x ), GetTextSize( x ), x->format.position.offset.spaces );
					x = NEXTLINE( x );
				}
			}
			{
				PTEXT tmp = BuildLine( p );
				lprintf( "input: %s", GetText( tmp ) );
				LineRelease( tmp );
			}
		}
		if( p &&
			GetTextSize( p ) )
		{
			return p;
		}
 // drop and consume blank lines.
		else
		{
			//lprintf( "Okay got a blank line... might handle it with 'unhandled'" );
			//if( pConfigHandler->Unhandled )
			//	pConfigHandler->Unhandled( pConfigHandler->psvUser, NULL );
			if( p )
				LineRelease(p);
		}
	}
	return NULL;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Is____Var results in true/false, plus the config element is filled
// with the current value.  start will also be updated to the current
// location to process.  Otherwise, false will be returned, the element
// will remain uninitialized, and start will not be updated.
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS );
int IsAnyVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	return IsAnyVarEx( pce, start DBG_SRC );
}
#define IsAnyVar(a,b) IsAnyVarEx(a,b DBG_SRC )
//---------------------------------------------------------------------
int IsConstTextEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
#define IsConstText(a,b) IsConstTextEx(a,b DBG_SRC )
{
	if( pce->type != CONFIG_TEXT )
	{
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( "Testing %s vs %s", GetText( *start ), GetText( pce->data[0].pText ) );
	if( CompareText( *start, pce->data[0].pText ) == 0 )
	{
		if( g.flags.bLogTrace )
			lprintf( "%s matched %s", GetText( *start ), GetText( pce->data[0].pText ) );
		*start = NEXTLINE( *start );
		return TRUE;
	}
	if( g.flags.bLogTrace )
		lprintf( "isn't constant..." );
	return FALSE;
}
//---------------------------------------------------------------------
static CTEXTSTR charset1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+";
static CTEXTSTR charset2 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY.-Z+";
typedef union bintobase{
	struct {
		uint8_t bytes[3];
	} bin;
	// these need to be unsigned.
	// the warning is 'nonstandard extension used : bit field types other than int'
	// but 'int' will NOT work, because it's signed.
	struct {
		uint32_t data1 : 6;
		uint32_t data2 : 6;
		uint32_t data3 : 6;
		uint32_t data4 : 6;
	} base;
} BINBASE;
void EncodeBinaryConfig( TEXTSTR *encode, POINTER data, size_t length )
{
	BINBASE convert;
	CTEXTSTR charset = charset2;
	unsigned char *p;
	TEXTCHAR *q;
	uint32_t l;
	int bExtraBytes;
	q = (TEXTCHAR*)((*encode) = NewArray( TEXTCHAR, ( ( ( 1 + (length + 2) / 3 ) * 4 ) + 3 ) * 2 ));
	(q++)[0]= '[';
	p = (unsigned char*)&length;
	convert.bin.bytes[0] = (p++)[0];
	convert.bin.bytes[1] = (p++)[0];
	convert.bin.bytes[2] = (p++)[0];
#define EXPLOIT_BURST_FEATURE()	if( ((q[-1] == '+')?(q[0]='0'),1:0 ) ||	 ((q[-1] == '.')?(q[0]='1'),1:0 ) ||											((q[-1] == '-')?(q[0]='2'),1:0 ) )												{																	q[-1] = '.';											q++;														}
	(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	p = (unsigned char*)data;
	for( l = 0; l < length - 2; l += 3 )
	{
		convert.bin.bytes[0] = (p++)[0];
		convert.bin.bytes[1] = (p++)[0];
		convert.bin.bytes[2] = (p++)[0];
		(q++)[0] = charset[convert.base.data1];
		EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
		EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
		EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
		EXPLOIT_BURST_FEATURE();
	}
	bExtraBytes = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[0] = (p++)[0];
		l++;
	}
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[1] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[1] = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[2] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[2] = 0;
	if( bExtraBytes )
	{
		(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	}
	(q++)[0]= '}';
	(q++)[0] = 0;
}
//---------------------------------------------------------------------
int DoDecodeBinary( PTEXT *start, POINTER *binary_buffer, size_t *buflen )
{
	static int *reverse;
	static int reverse1[256];
	static int reverse2[256];
	size_t failsafe_len;
	CTEXTSTR charset;
	POINTER failsafe_buffer;
	if( reverse1['B'] == 0 )
	{
		int c;
		for( c = 0; charset2[c]; c++ )
		{
			reverse1[(int)charset1[c]] = c;
			reverse2[(int)charset2[c]] = c;
		}
	}
	if( !buflen )
		buflen = &failsafe_len;
	if( !binary_buffer )
		binary_buffer = &failsafe_buffer;
	(*buflen) = 0;
	(*binary_buffer) = NULL;
	if( GetText( *start )[0] == '{' )
	{
		reverse = reverse1;
		charset = charset1;
	}
	else if( GetText( *start )[0] == '[' )
	{
		reverse = reverse2;
		charset = charset2;
	}
	else
		charset = NULL;
	if( charset )
	{
		BINBASE convert;
		size_t len;
		CTEXTSTR p = GetText( NEXTLINE( *start ) );
		// looks like a good chance this is a binary blob
		char *q;
		TEXTCHAR ch;
#define HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION()	  if( (ch=(p++)[0]) == '.' ) {	if( p[0] == '0' ) {p++;ch='+';}								else if ( p[0] == '1' ) {p++;ch = '.';}					else if ( p[0] == '2' ) {p++;ch = '-';}					}
		// if it is empty data... null, and 0
		if( NEXTLINE( *start ) &&
			( ( charset == charset1 && GetText( NEXTLINE( *start  ) )[0] == '}' )
			|| ( charset == charset2 && GetText( NEXTLINE( *start  ) )[0] == ']' ) ) )
		{
			(*binary_buffer) = NULL;
			(*buflen) = 0;
 // step from { onto }
			(*start) = NEXTLINE( *start );
 // step from } onto next token
			(*start) = NEXTLINE( *start );
			return TRUE;
		}
		if( !GetText( NEXTLINE( NEXTLINE( *start  ) ) ) ||
			( GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != '}'
			&& GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != ']' )
		)
		{
			return FALSE;
		}
		// HANLDE_BURST_EXPLOIT converts .0, .1, .2 into .-+ characters... and sets 'ch'
		// to the character to find.
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data1 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data2 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data3 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data4 = reverse[(int)ch];
		q = (char*)buflen;
		q[0] = convert.bin.bytes[0];
		q[1] = convert.bin.bytes[1];
		q[2] = convert.bin.bytes[2];
		// may be as much as 2 extra bytes (expressed as 3)
		(*binary_buffer) = Allocate( len = (*buflen) );
		q = (char*)(*binary_buffer);
		while( p[0] && len )
		{
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data1 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data2 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data3 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data4 = reverse[(int)ch];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[0];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[1];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[2];
		}
 // step from { onto 0235
		(*start) = NEXTLINE( *start );
 // step from 25234 onto }
		(*start) = NEXTLINE( *start );
 // step from } onto next token
		(*start) = NEXTLINE( *start );
		return TRUE;
	}
	else
	{
		(*binary_buffer) = NULL;
		(*buflen) = 0;
	}
	return FALSE;
}
int DecodeBinaryConfig( CTEXTSTR string, POINTER *binary_buffer, size_t *buflen )
{
	int status;
	PTEXT tmp1 = SegCreateFromText( string );
	PTEXT start = burst( tmp1 );
 // save this decode updates position...
	PTEXT delete_string = start;
	LineRelease( tmp1 );
	status = DoDecodeBinary( &start, binary_buffer, buflen );
	LineRelease( delete_string );
	return status;
}
int IsBinaryVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_BINARY )
		return FALSE;
	if( pce->data[0].binary.data )
	{
		Release( pce->data[0].binary.data );
		//pce->data[0].binary.data = NULL; // decode binary should do this?!
	}
	return DoDecodeBinary( start, &pce->data[0].binary.data, &pce->data[0].binary.length );
}
//---------------------------------------------------------------------
int IsBooleanVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	size_t len = GetTextSize( *start );
	int bOkay = FALSE;
	if( pce && pce->type != CONFIG_BOOLEAN )
		return FALSE;
	//lprintf( "Is %s boolean?", GetText( *start ) );
#define CmpMin(constlen)  ((len <= (constlen))?(len):0)
#define NearText(text,const)	( CmpMin( sizeof( const ) - 1 ) &&							( StrCaseCmpEx( GetText( text ), const, len ) == 0 ) )
	if( NearText( *start, "yes" ) ||
		NearText( *start, "1" ) ||
		NearText( *start, "on" ) ||
		NearText( *start, "true" ) ||
		NearText( *start, "open" )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 1;
		bOkay = TRUE;
	}
	else if( NearText( *start, "no" ) ||
			NearText( *start, "0" ) ||
			NearText( *start, "off" ) ||
		NearText( *start, "false" ) ||
		NearText( *start, "close" )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 0;
		bOkay = TRUE;
	}
	else if( NearText( *start, "are" ) ||
			NearText( *start, "is" ) )
	{
		PTEXT word;
		bOkay = TRUE;
		if(pce)pce->data[0].truefalse.bTrue = 1;
		if( ( word = NEXTLINE( *start ) ) )
		{
		if( NearText( *start, "not" ) )
		{
				if(pce)pce->data[0].truefalse.bTrue = 0;
				*start = word;
		}
		}
	}
	if( bOkay )
	{
		*start = NEXTLINE( *start );
		return bOkay;
	}
	return FALSE;
}
int GetBooleanVar( PTEXT *start, LOGICAL *data )
{
	CONFIG_ELEMENT element = { CONFIG_BOOLEAN CONFIG_EMPTY_EXTRA };
	if( IsBooleanVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].truefalse.bTrue;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
static TEXTCHAR maxbase1[] = "0123456789abcdefghijklmnopqrstuvwxyz";
static TEXTCHAR maxbase2[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
int TextToInt( CTEXTSTR text, int64_t* out )
{
	struct {
		uint32_t neg : 1;
		uint32_t success : 1;
	} flags;
	uint32_t base;
	int64_t accum;
	flags.neg = 0;
	flags.success = 1;
	if( text[0] == '-' )
	{
		flags.neg = 1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	base = 10;
	if( text[0] == '0' )
	{
		base = 8;
		text++;
		if( text[0] == 'x' )
		{
				base = 16;
				text++;
		}
		else if( text[0] == 'b' )
		{
				base = 2;
				text++;
		}
	}
	accum = 0;
	while( text[0] )
	{
		CTEXTSTR c;
		uint32_t val;
		if( ( c = StrChr( maxbase1, text[0] ) ) ) val = (uint32_t)(c - maxbase1);
		if( !c ) if( ( c = StrChr( maxbase2, text[0] ) ) ) val = (uint32_t)(c - maxbase2);
		if( !c ) { flags.success = 0; break; }
		if( val < base )
		{
				accum *= base;
				accum += val;
		}
		else
		{
			// yeah this works... there are times when badly behaved programs generate
			// output that should not match...
			// launch at screenX by ScreenY	"launch at %i by %i" fails
			// launch at 50 by 59						"					works
			// another rule that took launchat %w by %w could also work... in case
			// there is some variadric thing .. but a different config proc will probably be
			// called for such a case.
				//Log3( "Base Error : [%c]%s is not within base %d", text[0], text+1, base );
				flags.success = 0;
				break;
		}
		text++;
	}
	if( flags.success )
	{
		if( out )
		{
			if( flags.neg )
				*out = -accum;
			else
				*out = accum;
		}
		return TRUE;
	}
	return FALSE;
}
int IsIntegerVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	CTEXTSTR text;
	int64_t accum;
	if( pce->type != CONFIG_INTEGER )
		return FALSE;
	text = GetText( *start );
	if( TextToInt( text, &accum ) )
	{
		pce->data[0].integer_number = accum;
		*start = NEXTLINE( *start );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsColorVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_COLOR )
		return FALSE;
	// might consider color names also, (of course that table
	// would have to be configurable)
	//lprintf( "COlor testing: %s", GetText( *start ) );
	if( GetText( *start )[0] == '$' )
	{
		int ofs = 0;
		PTEXT val = NEXTLINE( *start );
		if( GetTextSize( *start ) == 1 )
			val = NEXTLINE( *start );
		else
		{
			val = *start;
			ofs = 1;
		}
		// potentially a hex variation...
		if( val )
		{
			uint32_t accum = 0;
			CTEXTSTR digit;
			digit = GetText( val ) + ofs;
			//lprintf( "COlor testing: %s", digit );
			while( digit && digit[0] )
			{
				int n;
				CTEXTSTR p;
				n = 16;
				p = StrChr( maxbase1, digit[0] );
				if( p )
					n = (uint32_t)(p-maxbase1);
				else
				{
					p = StrChr( maxbase2, digit[0] );
					if( p )
						n = (uint32_t)(p-maxbase2);
				}
				if( n < 16 )
				{
					accum *= 16;
					accum += n;
				}
				else
					break;
				digit++;
			}
			if( ( digit - GetText( val ) ) < 6 )
			{
				lprintf( "Perhaps an error in color variable..." );
				pce->data[0].Color = accum | 0xFF000000;
			}
			else
			{
				if( ( digit - GetText( val ) ) == 6 )
					pce->data[0].Color = accum | 0xFF000000;
				else
					pce->data[0].Color = accum;
			}
			{
				uint32_t file_color = pce->data[0].Color;
				COLOR_CHANNEL a = (COLOR_CHANNEL)( file_color >> 24 ) & 0xFF;
				COLOR_CHANNEL r = (COLOR_CHANNEL)( file_color >> 16 ) & 0xFF;
				COLOR_CHANNEL grn = (COLOR_CHANNEL)( file_color >> 8 ) & 0xFF;
				COLOR_CHANNEL b = (COLOR_CHANNEL)( file_color >> 0 ) & 0xFF;
				pce->data[0].Color = AColor( r,grn,b,a );
			}
			//Log4( "Color is: $%08X/(%d,%d,%d)"
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
		}
		return TRUE;
	}
	else if( GetText( *start )[0] == '(' )
	{
		// potentially a parenthetical variation.
		PTEXT val;
		int components = 0;
		uint32_t color = 0;
		for( val = *start;
			val && GetText( val )[0] != ')';
			val = NEXTLINE( val ) )
		{
			int64_t accum = 0;
			//lprintf( "Test : %s", GetText( val ) );
			if( GetText(val)[0] == ',' )
				continue;
			if( TextToInt( GetText( val ), &accum ) )
			{
				components++;
				color <<= 8;
				color |= ( accum & 0xFF );
			}
		}
		if( val )
		{
			pce->data[0].Color = color;
			if( components < 4 )
				pce->data[0].Color |= 0xFF000000;
			//Log4( "Color is: $%08X/(%d,%d,%d)"
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
			return TRUE;
		}
	}
	return FALSE;
}
int GetColorVar( PTEXT *start, CDATA *data )
{
	CONFIG_ELEMENT element = { CONFIG_COLOR CONFIG_EMPTY_EXTRA};
	if( IsColorVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].Color;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFloatVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
   (void)start;
	if( pce->type != CONFIG_FLOAT )
		return FALSE;
	//text = GetText( *start );
	lprintf( "Floating values are not processed yet." );
	return FALSE;
}
//---------------------------------------------------------------------
int IsFractionVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	int32_t accum1, accum2, accum3;
	int neg1, neg2, neg3;
	PTEXT current;
	CTEXTSTR text;
	if( pce->type != CONFIG_FRACTION )
		return FALSE;
	// this may consume multiple segments (4?)  (+/-)##(1) ##(2)/(3)##(4)
	current = *start;
	text = GetText( current );
	accum1 = 0;
	neg1 = 1;
	if( text[0] == '-' )
	{
		neg1 = -1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	while( text[0] && text[0] >= '0' && text[0] <= '9' )
	{
		accum1 *= 10;
		accum1 += text[0] - '0';
		text++;
	}
	if( text[0] )
	{
		lprintf( "Error in first argument of format of fraction." );
		return FALSE;
	}
// collect numerator after whole number.
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	accum2 = 0;
		neg2 = 1;
	if( text[0] == '/' )
	{
		//lprintf( "Promoting whole to numerator, getting denominaotr" );
		neg2	= neg1;
		accum2 = accum1;
		neg1	= 1;
		accum1 = 0;
		goto collect_denominator;
	}
	if( text[0] == '-' )
	{
		neg2 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum2 *= 10;
		accum2 += text[0] - '0';
		text++;
		}
		if( text[0] )
		lprintf( "Error in format of numerator" );
	}
	else
	{
	//lprintf( "End of line before numerator" );
		pce->data[0].fraction.numerator = accum1;
		pce->data[0].fraction.denominator = neg1;
		*start = NEXTLINE( current );
	return TRUE;
	}
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	if( text[0] != '/' )
	{
		lprintf( "No denominator specified - error in fraction." );
		return FALSE;
	}
	}
	else
	{
	lprintf( "End of line before '/'" );
	}
collect_denominator:
	current = NEXTLINE( current );
	if( current )
	{
		text = GetText( current );
		accum3 = 0;
		neg3 = 1;
		if( text[0] == '-' )
		{
		neg3 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum3 *= 10;
		accum3 += text[0] - '0';
		text++;
		}
		if( text[0] )
		{
		lprintf( "Error in format of denominator." );
		return FALSE;
		}
		//Log7( "%d*%d+%d / %d*%d*%d*%d", accum1, accum3, accum2, neg1, neg2, neg3, accum3 );
		pce->data[0].fraction.numerator = accum1 * accum3 + accum2;
		pce->data[0].fraction.denominator = neg1 * neg2 * neg3 * accum3;
		*start = NEXTLINE( current );
	}
	else
	{
		lprintf( "End of line before denominator." );
		return FALSE;
	}
	return TRUE;
}
//---------------------------------------------------------------------
int IsSingleWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	int matched = 1;
	INDEX idx;
	struct config_element_tag *default_EOL = NULL;
	//PTEXT __start = *start;
	if( pce->type != CONFIG_SINGLE_WORD )
		return FALSE;
	if( pce->data[0].singleword.pWord )
	{
		Release( pce->data[0].singleword.pWord );
		pce->data[0].singleword.pWord = NULL;
	}
	LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
		pEnd->flags.matched = FALSE;
	}
	while( *start )
	{
		if( pWords )
		{
			if( (*start)->format.position.offset.spaces )
			{
				pce->next = pce->built_next;
				//if( pWords )
				//	LineRelease( pWords );
				// so at a space, stop appending.
				if( g.flags.bLogTrace )
					lprintf( "next word has spaces... [%s](%d)", GetText( *start ), (*start)->format.position.offset.spaces );
				break;
			}
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
				PTEXT _start = *start;
				if( ( matched = IsAnyVar( pEnd, start ) ) != 0 )
				{
					pce->data[0].singleword.pWhichEnd = pEnd;
					pce->next = pEnd->next;
					if( g.flags.bLogTrace )
						lprintf( "Failed check for var check.." );
 // restore start..
					*start = _start;
					break;
				}
				else if( pEnd->type == CONFIG_NOTHING ) {
					pce->data[0].singleword.pWhichEnd = pEnd;
					pce->next = pEnd->next;
					if( !default_EOL )
						default_EOL = pce;
				}
				//*start = _start;
				//return TRUE;
			}
		}
		// was more than one word.
		if( pWords && ( (*start)->format.position.offset.spaces || (*start)->format.position.offset.tabs ) ) {
			LineRelease( pWords );
			pWords = NULL;
			return FALSE;
		}
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		if( g.flags.bLogTrace )
			lprintf( "Appending more to single word...[%s]", GetText( (*start) ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else if( g.flags.bLogTrace )
			lprintf( "is alright - gathered to end of line ok." );
	}
	if( pWords )
	{
		PTEXT pText;
		pWords->format.position.offset.spaces= 0;
		pText = BuildLine( pWords );
		LineRelease( pWords );
		if( g.flags.bLogTrace )
			lprintf( "Setting text word..." );
		pce->data[0].singleword.pWord = StrDup( GetText( pText ) );
		LineRelease( pText );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsMultiWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	int matched = 1;
	int matches = 0;
	PTEXT pWords = NULL;
	INDEX idx;
	struct config_element_tag *default_EOL = NULL;
	if( pce->type != CONFIG_MULTI_WORD )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		// this is held external to this now...
		//Release( pce->data[0].multiword.pWords );
		//pce->data[0].multiword.pWords = NULL;
	}
	LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
		pEnd->flags.matched = FALSE;
	}
	while( *start )
	{
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
 // already found a match for this and added it.
			if( pEnd->flags.matched ) continue;
			PTEXT was_start;
			was_start = start[0];
			if( ( matched = IsAnyVar( pEnd, start ) ) != 0 ){
				struct config_check new_check;
				struct config_multi_word multi_match;
				PDATALIST pdl = pce->pch->current_possible->multiWords;
				new_check.word = *start;
				start[0] = was_start;
				new_check.Check = pEnd->next;
				new_check.multiWords = CreateDataList( sizeof( struct config_multi_word ));
				//lprintf( "Alloc list %p:", new_check.multiWords );
				if( pdl )
				{
					INDEX idx2;
					struct config_multi_word* oldMatch;
					DATA_FORALL( pdl, idx2, struct config_multi_word*, oldMatch ){
						Hold( oldMatch->matched );
						AddDataItem( &new_check.multiWords, oldMatch );
					}
				}
				multi_match.pce = pce;
				multi_match.pceEnd = pEnd;
				{
					PTEXT out;
					pWords->format.position.offset.spaces = 0;
					out = BuildLine( pWords );
					multi_match.matched = StrDup( GetText( out ) );
					LineRelease( out );
				}
				AddDataItem( &new_check.multiWords, &multi_match );
				//new_check.multiWords = pce;
				AddDataItem( &pce->pch->possible_checks, &new_check );
				pEnd->flags.matched = TRUE;
				matches++;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p %p", pEnd, pEnd->next );
				//pce->data[0].multiword.pWhichEnd = pEnd;
				//pce->next = pEnd->next;
				//break;
			}
			else if( !default_EOL && pEnd->type == CONFIG_NOTHING ) {
				default_EOL = pEnd;
			}
		}
		/*
		if( pEnd ) {
			// try another rule with current words matching...
			continue;
		}
		*/
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else {
			if( default_EOL ) {
				struct config_check new_check;
				struct config_multi_word multi_match;
				PDATALIST pdl = pce->pch->current_possible->multiWords;
				matches++;
				new_check.word = *start;
				new_check.Check = default_EOL->next;;
				new_check.multiWords = CreateDataList( sizeof( struct config_multi_word ));
				//lprintf( "Alloc list %p:", new_check.multiWords );
				if( pdl )
				{
					INDEX idx2;
					struct config_multi_word* oldMatch;
					DATA_FORALL( pdl, idx2, struct config_multi_word*, oldMatch ){
						Hold( oldMatch->matched );
						AddDataItem( &new_check.multiWords, oldMatch );
					}
				}
				multi_match.pce = pce;
				multi_match.pceEnd = default_EOL;
				{
					PTEXT out;
					pWords->format.position.offset.spaces = 0;
					out = BuildLine( pWords );
					multi_match.matched = StrDup( GetText( out ) );
					LineRelease( out );
				}
				AddDataItem( &new_check.multiWords, &multi_match );
				//new_check.multiWords = pce;
				AddDataItem( &pce->pch->possible_checks, &new_check );
			} else {
				LineRelease( pWords );
				pWords = NULL;
			}
			if( g.flags.bLogTrace )
				lprintf( "is alright - gathered to end of line ok. (or matched)" );
		}
	}
	//if( !pWords )
	//	pWords = SegCreate(0);
	LineRelease( pWords );
	pWords = NULL;
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			TEXTSTR buf = StrDup( GetText( out ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	/* can have empty space for multiword, but was an OK result anyway...*/
	return matches > 0;
}
//---------------------------------------------------------------------
int IsPathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	INDEX idx;
	if( pce->type != CONFIG_PATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
		pEnd->flags.matched = 0;
	}
	while( *start  )
	{
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFileVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	INDEX idx;
	if( pce->type != CONFIG_FILE )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
		pEnd->flags.matched = 0;
	}
	while( *start )
	{
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
			break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFilePathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	INDEX idx;
	if( pce->type != CONFIG_FILEPATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
		pEnd->flags.matched = 0;
	}
	while( *start )
	{
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
#if !defined( __NO_NETWORK__ ) && 0
int IsAddressVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_ADDRESS )
		return FALSE;
	if( pce->data[0].psaSockaddr )
	{
		ReleaseAddress( pce->data[0].psaSockaddr );
		pce->data[0].psaSockaddr = NULL;
	}
	while( *start && !(*start)->format.position.offset.spaces )
	{
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT pText = BuildLine( pWords );
			LineRelease( pWords );
			pce->data[0].psaSockaddr = CreateSockAddress( (CTEXTSTR)GetText( pText ), 0 );
			LineRelease( pText );
		}
		return TRUE;
	}
	return FALSE;
}
#endif
//---------------------------------------------------------------------
int IsURLVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_URL )
		return FALSE;
	return FALSE;
}
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
{
	if( !pce || !start )
	{
		//lprintf( "No pce or no start" );
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( "IsAnyVar" );
	if( pce->type == CONFIG_NOTHING && !(*start) )
		return TRUE;
	return( ( IsConstText( pce, start ) ) ||
			( IsBooleanVar( pce, start ) ) ||
			( IsBinaryVar( pce, start ) ) ||
			( IsIntegerVar( pce, start ) ) ||
			( IsFloatVar( pce, start ) ) ||
			( IsFractionVar( pce, start ) ) ||
			( IsSingleWordVar( pce, start ) ) ||
			( IsMultiWordVar( pce, start ) ) ||
			( IsPathVar( pce, start ) ) ||
			( IsFileVar( pce, start ) ) ||
			( IsFilePathVar( pce, start ) ) ||
			( IsURLVar( pce, start ) ) ||
			( IsColorVar( pce, start ) ) );
}
//---------------------------------------------------------------------
//#define PushArgument( type, arg ) ( (parampack = Preallocate( parampack, argsize += sizeof( arg )) )?(*(type*)(parampack) = (arg)),0:0)
//#define PopArguments( sz ) Release( parampack )
//---------------------------------------------------------------------
void DoProcedure( uintptr_t *ppsvUser, PCONFIG_TEST Check, PTEXT line )
{
	INDEX idx;
	PCONFIG_ELEMENT pce = NULL;
	va_args parampack;
	PTEXT builtLine = BuildLine( line );
	TEXTSTR textLine = GetText( builtLine );
#ifdef __WATCOMC__
	va_args save_parampack;
#endif
	init_args( parampack );
	PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, textLine );
	LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		if( pce->type == CONFIG_PROCEDURE || pce->type == CONFIG_PROCEDURE_EX )
		{
			if( pce->data[0].Process)
			{
				PCONFIG_ELEMENT pcePush = pce->prior;
				// push arguments in reverse order...
				//lprintf( "Calling process... " );
				while( pcePush )
				{
					if( g.flags.bLogTrace )
						LogElement( "pushing", pcePush );
					switch( pcePush->type )
					{
					case CONFIG_TEXT:
						break;
					case CONFIG_BINARY:
						PushArgument( parampack, CONFIG_ARG_DATA, POINTER, pcePush->data[0].binary.data );
						PushArgument( parampack, CONFIG_ARG_DATA_SIZE, size_t, pcePush->data[0].binary.length );
						break;
					case CONFIG_BOOLEAN:
						{
							LOGICAL val = pcePush->data[0].truefalse.bTrue;
							PushArgument( parampack, CONFIG_ARG_LOGICAL, LOGICAL, val );
						}
						break;
					case CONFIG_INTEGER:
						PushArgument( parampack, CONFIG_ARG_INT64, int64_t, pcePush->data[0].integer_number );
						break;
					case CONFIG_FLOAT:
						PushArgument( parampack, CONFIG_ARG_FLOAT, float, (float)pcePush->data[0].float_number );
						break;
					case CONFIG_FRACTION:
						PushArgument( parampack, CONFIG_ARG_FRACTION, FRACTION, pcePush->data[0].fraction );
						break;
					case CONFIG_SINGLE_WORD:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].pWord );
						break;
					case CONFIG_COLOR:
						PushArgument( parampack, CONFIG_ARG_COLOR, CDATA, pcePush->data[0].Color );
						break;
					case CONFIG_MULTI_WORD:
					case CONFIG_FILEPATH:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].multiword.pWords );
						break;
					default:
						break;
					}
					//lprintf( "Total args are now: %d", argsize );
					pcePush = pcePush->prior;
				}
				if( pce->type == CONFIG_PROCEDURE_EX )
					(*ppsvUser) = pce->data[0].ProcessEx.Process( *ppsvUser, pce->data[0].ProcessEx.arg, pass_args( parampack ) );
				else
					(*ppsvUser) = pce->data[0].Process( *ppsvUser, pass_args(parampack) );
				PopArguments( parampack );
 // done, end of list, please leave and do not iterate further!
				break;
			}
		}
		else
		{
			switch( pce->type )
			{
			case CONFIG_MULTI_WORD:
			case CONFIG_SINGLE_WORD:
				// null content ?
				break;
			default:
				// actually this probably means that there was no content to complete
				// the match, and NULL is not a valid responce to data...
				lprintf( "Multiple options here for what to do at end of line?" );
			}
		}
	}
	LineRelease( builtLine );
}
void ProcessConfigurationLine( PCONFIG_HANDLER pch, PTEXT line )
		{
			PCONFIG_TEST Check = &pch->ConfigTestRoot;
			PTEXT word = line;
			PTEXT this_word;
			LOGICAL processed = FALSE;
			struct config_check *this_check;
			struct config_check tmp_check;
 // empty the data list
			EmptyDataList( &pch->possible_checks );
			tmp_check.multiWords = NULL;
			tmp_check.word = word;
			tmp_check.Check = Check;
			AddDataItem( &pch->possible_checks, &tmp_check );
//word && Check )
			while( 1 )
			{
				INDEX check_idx;
				check_idx = 0;
				pch->current_possible = this_check = (struct config_check*)GetDataItem( &pch->possible_checks, check_idx );
				if( this_check
 // otherwise it's a multiword part...
				   && this_check->Check )
				{
					INDEX idx;
					PCONFIG_ELEMENT pce = NULL;
					if( this_check->multiWords )
					{
						INDEX idx2;
						struct config_multi_word *cmw;
						DATA_FORALL( this_check->multiWords, idx2, struct config_multi_word*, cmw ){
							cmw->pce->data->multiword.pWords = cmw->matched;
							cmw->pce->data->multiword.pWhichEnd = cmw->pceEnd;
							cmw->pce->next = this_check->Check;
						}
					}
					Check = this_check->Check;
					// keep this_word to reset the word for the variable check vs constant check
					this_word = word = this_check->word;
					if( !word ) {
						//lprintf( "Could have just matched to end of line and all is well..." );
						processed = TRUE;
						DoProcedure( &pch->psvUser, Check, line );
					} else {
						// remove this item; if it further matches another state will be added.
						if( g.flags.bLogTrace && Check->pConstElementList )
							lprintf( "Test word (%s) vs constant elements", GetText( word ) );
						LIST_FORALL( Check->pConstElementList, idx, PCONFIG_ELEMENT, pce )
						{
							if( g.flags.bLogTrace )
								lprintf( "Is %s == %s?", GetText( word ), GetText( pce->data[0].pText ) );
							if( IsConstText( pce, &word ) )
							{
								//Check = pce->next;
								if( this_check->multiWords ) {
									INDEX idx2;
									struct config_multi_word* cmw;
									DATA_FORALL( this_check->multiWords, idx2, struct config_multi_word*, cmw ) {
										Hold( cmw->matched );
									}
									//lprintf( "Hold list %p:", this_check->multiWords );
									tmp_check.multiWords = (PDATALIST)Hold( this_check->multiWords );
								}
								else tmp_check.multiWords = NULL;
								tmp_check.word = word;
								tmp_check.Check = pce->next;
								AddDataItem( &pch->possible_checks, &tmp_check );
								word = this_word;
								// all constants that matched would be this check...
								break;
							}
						}
						if( g.flags.bLogTrace && Check->pVarElementList )
							lprintf( "Test word (%s) vs variable elements", GetText( word ) );
						{
							// even if it matched a static comparison, it might also match a variable argument...
							// if( !pce )
							{
								int found = 0;
								LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
								{
									// end of the line, match should be the process...
									if( g.flags.bLogTrace )
									{
										lprintf( "Is %s a Thing", GetText( word ) );
										LogElement( "Thing is", pce );
									}
									if( IsAnyVar( pce, &word ) )
									{
										if( g.flags.bLogTrace ) lprintf( "Yes, it is (one of those)." );
										if( !word && !pce->next ) {
											if( g.flags.bLogTrace ) lprintf( "And it completed a match." );
											processed = TRUE;
											DoProcedure( &pch->psvUser, Check, line );
											return;
										} else {
											found++;
											if( pce->type != CONFIG_MULTI_WORD ) {
												// multiword adds combinations itself...
												if( this_check->multiWords ) {
													INDEX idx2;
													struct config_multi_word* cmw;
													DATA_FORALL( this_check->multiWords, idx2, struct config_multi_word*, cmw ) {
														Hold( cmw->matched );
													}
													//lprintf( "Hold list %p:", this_check->multiWords );
													tmp_check.multiWords = (PDATALIST)Hold( this_check->multiWords );
												}
												else tmp_check.multiWords = NULL;
												tmp_check.word = word;
												tmp_check.Check = pce->next;
												AddDataItem( &pch->possible_checks, &tmp_check );
											}
										        word = this_word;
										}
										if( g.flags.bLogTrace )
											lprintf( "pce->next is %p  word is %p(%s)", pce->next, word, GetText( word ) );
										//Check = pce->next;
										//break;
									}
									else if( g.flags.bLogTrace )
									{
										lprintf( "But it's not anything I know." );
									}
								}
							        if( g.flags.bLogTrace )
									lprintf( "is %s (%d times)", found?"found":"Not found", found );
								if( pch->possible_checks->Cnt == 0 )
								{
									// unhandled can't really be handled here...
									PTEXT pLine = BuildLine( line );
									if( g.flags.bLogTrace )
										lprintf( "Line not matched[%s]", GetText( pLine ) );
									if( pch->Unhandled )
										pch->Unhandled( pch->psvUser, GetText( pLine ) );
									else
									{
										if( g.flags.bLogUnhandled )
											xlprintf(LOG_NOISE)( "Unknown Configuration Line(No unhandled proc): %s", GetText( pLine ) );
									}
									LineRelease( pLine );
									break;
								}
							}
						}
					}
					if( this_check->multiWords ){
						struct config_multi_word* check;
						INDEX idx;
						DATA_FORALL( this_check->multiWords, idx, struct config_multi_word*, check ){
							ReleaseEx( check->matched DBG_SRC );
						}
						//lprintf( "Delete list %p:", this_check->multiWords );
						DeleteDataList( &this_check->multiWords );
					}
					DeleteDataItem( &pch->possible_checks, check_idx );
				} else {
					//Check = NULL;
					break;
				}
			}
			if( !processed )
			{
				//lprintf( "Fell off the end the line processor, still have data..." );
				if( pch->Unhandled ) {
					PTEXT pLine = BuildLine( line );
					pch->Unhandled( pch->psvUser, GetText( pLine ) );
					LineRelease( pLine );
				}
			}
			// cleanup any leftover states
			while( pch->possible_checks->Cnt ) {
				this_check = (struct config_check*)GetDataItem( &pch->possible_checks, 0 );
				if( this_check->multiWords ){
					struct config_multi_word* check;
					INDEX idx;
					DATA_FORALL( this_check->multiWords, idx, struct config_multi_word*, check ){
						ReleaseEx( check->matched DBG_SRC );
					}
					//lprintf( "Delete list %p:", this_check->multiWords );
					DeleteDataList( &this_check->multiWords );
				}
				DeleteDataItem( &pch->possible_checks, 0 );
			}
		}
static void TestUnicode( PCONFIG_HANDLER pch )
{
	int return_pos = 0;
	pch->flags.bUnicode	= 0;
	{
		char charbuf[64];
 // could be really short
		size_t len_read;
		size_t char_check;
		int ascii_unicode = 1;
		len_read = sack_fread( charbuf, 1, 64, pch->file );
		if( len_read >= 2
			&& ( ( ((uint16_t*)charbuf)[0] == 0xFEFF )
		      || ( ((uint16_t*)charbuf)[0] == 0xFFFE )
		      || ( ((uint16_t*)charbuf)[0] == 0xFDEF ) ) )
		{
			return_pos = 2;
			pch->flags.bUnicode = 1;
		}
		else if( len_read >= 2
			&& ( charbuf[0] == (char)0xef ) && ( charbuf[1] == (char)0xbb ) && ( charbuf[0] == (char)0xbf ) )
		{
			return_pos = 1;
			pch->flags.bUnicode8 = 1;
		}
		else for( char_check = 0; char_check < len_read; char_check++ )
		{
		// every other byte is a 0 for flat unicode text...
			if( ( char_check & 1 ) && ( charbuf[char_check] != 0 ) )
			{
				ascii_unicode = 0;
				break;
			}
		}
		if( ascii_unicode )
		{
			pch->flags.bUnicode = 1;
		}
		else
		{
			int ascii = 1;
			for( char_check = 0; char_check < len_read; char_check++ )
				if( charbuf[char_check] & 0x80 )
				{
					ascii = 0;
					break;
				}
			if( ascii )
			{
				// hmm this is probably a binary thing?
			}
		}
	}
	sack_fseek( pch->file, return_pos, SEEK_SET );
	// rewind
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch, CTEXTSTR name, uintptr_t psv )
{
	TEXTCHAR pathname[1024];
	PTEXT line;
#if !defined( __ANDROID__ ) && !defined( __EMSCRIPTEN__ )
 // don't prefix with anything.
	int absolute_path = IsAbsolutePath( name );
#endif
	pch->file = sack_fopen( 0, name, "rb" );
#if !defined( __ANDROID__ ) && !defined( __EMSCRIPTEN__ )
	if( !pch->file && !absolute_path )
	{
		tnprintf( pathname, sizeof( pathname ), "./%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
/*
   library path will never happen anymore...
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), "@/%s", name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
*/
	if( !pch->file && !absolute_path )
	{
		// ~/.Freedom Collective/app/<name>
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), ";/%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
	if( !pch->file && !absolute_path )
	{
		// /var/Freedom Collective/(program)/<name>
		// this is a global writable path(should be)
		// creation of files is probably conservative...
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), "*/%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
	if( !pch->file && !absolute_path )
	{
		// installed configurations/<name>  share/SACK/conf
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), "?/conf/%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
	/* program path might be useful */
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		// with the program.
		tnprintf( pathname, sizeof( pathname ), "#/%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		// system global
		tnprintf( pathname, sizeof( pathname ), "/etc/%s", name );
		pch->file = sack_fopen( 0, pathname, "rb" );
	}
#endif
	pch->psvUser = psv;
	if( pch->file )
	{
		TestUnicode( pch );
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		sack_fclose( pch->file );
		if( pch->EndProcess )
			pch->EndProcess( pch->psvUser );
		pch->file = NULL;
		return TRUE;
	}
	else
	{
		//lprintf( "Failed to open config file: %s", name );
		return FALSE;
	}
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR data, size_t size, uintptr_t psv )
{
	pch->psvUser = psv;
	{
		PTEXT line;
		PTEXT block = SegCreate( size + 1 );
		MemCpy( GetText( block ), data, size );
		GetText( block )[size] = 0;
		SetTextSize( block, size );
		pch->blocks = block;
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		// this block will have been moved into internal accumulators.
		//LineRelease( block );
	}
	return pch->psvUser;
}
//---------------------------------------------------------------------
static PCONFIG_ELEMENT NewConfigTestElement( PCONFIG_HANDLER pch )
{
 //&(PCONFIG_ELEMENT)Allocate( sizeof( CONFIG_ELEMENT ) );
	PCONFIG_ELEMENT pceNew = GetFromSet( CONFIG_ELEMENT, &pch->elements );
	MemSet( pceNew, 0, sizeof( CONFIG_ELEMENT ) );
	pceNew->pch = pch;
	return pceNew;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
static PCONFIG_TEST NewConfigTest( PCONFIG_HANDLER pch )
{
 //(PCONFIG_TEST)AllocateEx( sizeof( CONFIG_TEST ) DBG_RELAY );
	PCONFIG_TEST pctNew = GetFromSet( CONFIG_TEST, &pch->test_elements );
	MemSet( pctNew, 0, sizeof( CONFIG_TEST ) );
	// I don't actually have to create list...
	// they will be filled in and allocated on demand.
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pConstElementList = NULL;
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pVarElementList = NULL;
	return pctNew;
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pct );
//---------------------------------------------------------------------
void BeginConfiguration( PCONFIG_HANDLER pch )
{
	// pushes the config file handler state...
	if( pch )
	{
		CONFIG_STATE save_state;
		if( !pch->ConfigStateStack )
			pch->ConfigStateStack = CreateDataStack( sizeof( CONFIG_STATE ) );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Saving config and psvUser is %08x", pch->psvUser );
		DumpConfigurationEvaluator( pch );
#endif
		save_state.recovered = pch->config_recovered;
		save_state.ConfigTestRoot = pch->ConfigTestRoot;
		save_state.psvUser = pch->psvUser;
		save_state.EndProcess = pch->EndProcess;
		save_state.Unhandled = pch->Unhandled;
		save_state.name = pch->save_config_as;
		pch->flags.bConfigSaveNameUsed = 1;
		PushData( &pch->ConfigStateStack, &save_state );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "<BEGIN>" );
#endif
		pch->ConfigTestRoot.pConstElementList = NULL;
		pch->ConfigTestRoot.pVarElementList = NULL;
		pch->EndProcess = NULL;
		pch->Unhandled = NULL;
		pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Setting config as not savable." );
#endif
		pch->save_config_as = NULL;
	}
}
LOGICAL BeginNamedConfiguration( PCONFIG_HANDLER pch, CTEXTSTR name )
{
	// returns true if the configuration previously exists...
	// returns false if it needs to be built.
	INDEX idx;
	PCONFIG_STATE state;
	LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
	{
		if( StrCmp( state->name, name ) == 0 )
		{
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "found previous config, setting this up, and resulting." );
#endif
			BeginConfiguration( pch );
			pch->ConfigTestRoot = state->ConfigTestRoot;
			pch->EndProcess = state->EndProcess;
			pch->Unhandled = state->Unhandled;
			pch->config_recovered = TRUE;
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "Beginning a named configuration..." );
#endif
			pch->save_config_as = state->name;
#ifdef DEBUG_SAVE_CONFIG
			DumpConfigurationEvaluator( pch );
#endif
			return TRUE;
		}
	}
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "No previous found, setting this up to save at end config..." );
#endif
	BeginConfiguration( pch );
	pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Setting named configuration." );
#endif
	pch->flags.bConfigSaveNameUsed = 0;
	pch->save_config_as = StrDup( name );
	return FALSE;
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int dealloc );
// this is more like a pop configuration.
void EndConfiguration( PCONFIG_HANDLER pch )
{
	PCONFIG_STATE prior_state;
	//PCONFIG_TEST prior;
	if( pch->EndProcess )
		pch->EndProcess( pch->psvUser );
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "<END>" );
#endif
	prior_state = (PCONFIG_STATE)PopData( &pch->ConfigStateStack );
	if( prior_state )
	{
		if( pch->save_config_as )
		{
			if( !pch->config_recovered )
			{
				CONFIG_STATE *state = New( CONFIG_STATE );
				state->ConfigTestRoot = pch->ConfigTestRoot;
				state->EndProcess = pch->EndProcess;
				state->Unhandled = pch->Unhandled;
				pch->flags.bConfigSaveNameUsed = 1;
				state->name = pch->save_config_as;
				AddLink( &pch->states, state );
			}
			// otherwise there's no action to do... already have it saved.
		}
		else
		{
			//lprintf( "Config was not saved, destroying." );
			DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
		}
		// didn't recover from states list.
		pch->config_recovered = prior_state->recovered;
		pch->ConfigTestRoot = prior_state->ConfigTestRoot;
		pch->EndProcess = prior_state->EndProcess;
		pch->Unhandled = prior_state->Unhandled;
		pch->psvUser = prior_state->psvUser;
		pch->save_config_as = prior_state->name;
	}
}
PCONFIG_ELEMENT _AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS )
{
	PTEXT pTemp = SegCreateFromText( format );
	PTEXT pLine;
	PTEXT pWord;
	struct {
		uint32_t vartag : 1;
		uint32_t vector : 1;
		uint32_t ignore_new : 1;
		uint32_t store_next_as_end : 1;
		uint32_t also_store_next_as_end : 1;
		uint32_t store_as_end : 1;
		uint32_t also_store_as_end : 1;
	}flags;
	PCONFIG_TEST pct;
	PCONFIG_ELEMENT pceNew, pcePrior;
	((uint32_t*)&flags)[0] = 0;
	//flags.dw = 0;
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
	if( g.flags.bLogTraceBuild )
		lprintf( "Burst..." );
//#endif
	pLine = burst( pTemp );
	LineRelease( pTemp );
	pct = &pch->ConfigTestRoot;
	pceNew = NewConfigTestElement( pch );
	pcePrior = NULL;
	pWord = pLine;
	while( pWord )
	{
		if( g.flags.bLogTraceBuild )
			lprintf( "Evaluating %s ... ", GetText( pWord ) );
		if( flags.vartag )
		{
			CTEXTSTR pWordText = GetText( pWord );
			if( pWordText[0] == 'v' )
			{
				flags.vector = 1;
				pWordText++;
				if( !pWordText[0] )
				{
					lprintf( "Format: %s", format );
					lprintf( "Configuration error %%v[no type]" );
				}
				LineRelease( pLine );
				lprintf( "Destroy config element %p", pceNew );
				DestroyConfigElement( pch, pceNew );
				return NULL;
			}
			switch( pWordText[0] )
			{
			case 'b':
				//lprintf( "is a boolean..." );
				pceNew->type = CONFIG_BOOLEAN;
				pceNew->flags.vector = flags.vector;
				break;
			case 'B':
				//lprintf( "is a binary..." );
				pceNew->type = CONFIG_BINARY;
				pceNew->flags.vector = flags.vector;
				break;
			case 'i':
				//lprintf( "Is an integer... ") ;
				pceNew->type = CONFIG_INTEGER;
				pceNew->flags.vector = flags.vector;
				break;
			case 'c':
				pceNew->type = CONFIG_COLOR;
				pceNew->flags.vector = flags.vector;
				break;
			case 'f':
				pceNew->type = CONFIG_FLOAT;
				pceNew->flags.vector = flags.vector;
				break;
			case 'q':
				pceNew->type = CONFIG_FRACTION;
				pceNew->flags.vector = flags.vector;
				break;
			case 'w':
				if( g.flags.bLogTraceBuild )
					lprintf( "Setting new as type SINGLE_WORD" );
				pceNew->type = CONFIG_SINGLE_WORD;
				pceNew->flags.vector = flags.vector;
				flags.also_store_next_as_end = 1;
				break;
			case 'm':
				if( g.flags.bLogTraceBuild )
					lprintf( "Setting new as type MULTI_WORD" );
				pceNew->type = CONFIG_MULTI_WORD;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'u':
				pceNew->type = CONFIG_URL;
				pceNew->flags.vector = flags.vector;
				break;
			case 'd':
				pceNew->type = CONFIG_PATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'n':
				pceNew->type = CONFIG_FILE;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'p':
				pceNew->type = CONFIG_FILEPATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'a':
				pceNew->type = CONFIG_ADDRESS;
				pceNew->flags.vector = flags.vector;
				break;
			default:
				lprintf( "Format: %s", format );
				lprintf( "Unknown format character: %c", pWordText[0] );
				flags.ignore_new = 1;
				break;
			}
			if( !flags.ignore_new )
			{
				if( g.flags.bLogTraceBuild )
					lprintf( "Not ignoring the new thing..." );
				if( flags.store_as_end )
				{
					if( g.flags.bLogTraceBuild )
						lprintf( "Storing as end..." );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
 //-V522
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								break;
							}
						}
						if( !pEnd ){
							pceNew->Check = NULL;
							pceNew->word_element = pcePrior;
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
							pct = pceNew->next = pceNew->built_next = NewConfigTest( pch );
							if( g.flags.bLogTrace )
								lprintf( "%p pceNew next is %p", pceNew, pct );
						}
						else{
							if( g.flags.bLogTrace )
								lprintf( "Need to do something with original to chain?" );
							DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
							pct = pEnd->next;
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					if( flags.store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.store_as_end = 1;
						flags.store_next_as_end = 0;
					}
					if( flags.also_store_as_end )
					{
						if( g.flags.bLogTraceBuild )
							lprintf( "Also Storing as end..." );
						pceNew->Check = NULL;
						pceNew->word_element = pcePrior;
						AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
						pceNew->flags.singleword_terminator = 1;
						flags.also_store_as_end = 0;
					}
					if( flags.also_store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.also_store_as_end = 1;
						flags.also_store_next_as_end = 0;
					}
					{
						INDEX idx;
						PCONFIG_ELEMENT pceCheck;
						LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pceCheck )
						{
							if( pceCheck->type == pceNew->type )
							{
								// any data set will be overwritten...
								// uhmm should probably update to new links.
								if( !pceCheck->next )
								{
									lprintf( "Something fishy here... second instance of same type..." );
								}
								pcePrior = pceCheck;
								pct = pceCheck->next;
								break;
							}
						}
						if( !pceCheck )
						{
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTraceBuild)
								lprintf( "Adding into a new config test" );
//#endif
							pceNew->Check = pct;
							pceNew->word_element = NULL;
							AddLink( &pct->pVarElementList, pceNew );
							pct = pceNew->next = pceNew->built_next = NewConfigTest( pch );
							pceNew->prior = pcePrior;
							pcePrior = pceNew;
							pceNew = NewConfigTestElement( pch );
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTraceBuild )
								lprintf( "Added." );
//#endif
						}
					}
				}
			}
			else
			{
				lprintf( "ignoreing NEW!?" );
			}
			flags.vartag = 0;
			flags.vector = 0;
			flags.ignore_new = 0;
		}
		else
		{
			if( TextIs( pWord, "%" ) )
			{
				if( g.flags.bLogTraceBuild )
					lprintf( "next thing is a format character" );
				flags.vartag = 1;
			}
 // is static text - literal match.
			else
			{
				INDEX idx;
				PCONFIG_ELEMENT pConst = NULL;
				if( g.flags.bLogTraceBuild )
					lprintf( "Storing %s as a constant text", GetText( pWord ) );
				if( flags.store_as_end )
				{
					pceNew->type = CONFIG_TEXT;
					if( g.flags.bLogTraceBuild )
						lprintf( "Adding %s as the terminator", GetText( pWord ) );
					pceNew->data[0].pText = SegDuplicate( pWord );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								if( SameText( pceNew->data[0].pText, pEnd->data[0].pText ) == 0 )
									break;
							}
						}
						if( !pEnd ){
							if( g.flags.bLogTrace )
								lprintf( "Added new terminator branch... pce needs a pct" );
							pceNew->Check = NULL;
							pceNew->word_element = pcePrior;
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
							pct = pceNew->next = pceNew->built_next = NewConfigTest( pch );
						}
						else{
							// use existing one, so delete this one.
							DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
							pct = pEnd->next;
							if( g.flags.bLogTrace )
								lprintf( "Recovered an old pce to resume from...%p", pEnd );
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pConst )
					{
						if( IsConstText( pConst, &pWord ) )
						{
							pct = pConst->next;
							break;
						}
 // this is not always cleared...
						pConst = NULL;
					}
 // continue outer loop (while word)
					if( pConst )
					{
						if( g.flags.bLogTraceBuild )
							lprintf( "Found constant already in tree" );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTraceBuild )
								lprintf( "Also Storing as end... %s", GetText( pceNew->data[0].pText ) );
							pceNew->Check = NULL;
							pceNew->word_element = pcePrior;
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						continue;
					}
					else
					{
						if( g.flags.bLogTraceBuild )
							lprintf( "Adding new constant to tree:%s", GetText( pWord ) );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTraceBuild )
								lprintf( "Also Storing as end... %s", GetText( pceNew->data[0].pText ) );
							pceNew->Check = NULL;
							pceNew->word_element = pcePrior;
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						pceNew->type = CONFIG_TEXT;
						pceNew->data[0].pText = SegDuplicate( pWord );
						pceNew->Check = pct;
						pceNew->word_element = NULL;
						AddLink( &pct->pConstElementList, pceNew );
						pct = pceNew->next = pceNew->built_next = NewConfigTest( pch);
						pceNew->prior = pcePrior;
						pcePrior = pceNew;
						pceNew = NewConfigTestElement(pch );
					}
				}
			}
		}
		pWord = NEXTLINE( pWord );
		if( !pWord && flags.store_next_as_end ) {
			flags.store_as_end = 1;
		}
		flags.store_next_as_end = 0;
		if( !pWord && ( flags.also_store_next_as_end ) ) {
			flags.also_store_as_end = 1;
		}
		flags.also_store_next_as_end = 0;
	}
	if( flags.store_as_end || flags.also_store_as_end ) {
		pceNew->type = CONFIG_NOTHING;
		pceNew->Check = NULL;
		pceNew->word_element = pcePrior;
		AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
		if( flags.also_store_as_end )
			pceNew->flags.singleword_terminator = 1;
		else
			pceNew->flags.multiword_terminator = 1;
		pceNew->prior = pcePrior;
		pct = pceNew->next = pceNew->built_next = NewConfigTest( pch );
		if( g.flags.bLogTraceBuild )
			lprintf( "%p pceNew next is %p", pceNew, pct );
		pcePrior = pceNew;
		pceNew = NewConfigTestElement( pch );
		flags.also_store_as_end = flags.store_as_end = 0;
	}
	LineRelease( pLine );
	// end of the format line - add the procedure.
	pceNew->prior = pcePrior;
	// no need to update pcePrior - we're done.
	pceNew->type = CONFIG_PROCEDURE;
	pceNew->data[0].Process = Process;
	pceNew->Check = pct;
	pceNew->word_element = NULL;
	AddLink( &pct->pVarElementList, pceNew );
	return pceNew;
}
void AddConfigurationExx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER_EX Process, uintptr_t arg DBG_PASS ) {
	PCONFIG_ELEMENT element = _AddConfigurationEx( pch, format, (USER_CONFIG_HANDLER)Process DBG_RELAY );
	if( !element )
		return;
	element->type = CONFIG_PROCEDURE_EX;
	element->data[0].ProcessEx.Process = Process;
	element->data[0].ProcessEx.arg = arg;
}
void AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS ) {
	_AddConfigurationEx( pch, format, Process DBG_RELAY );
}
//---------------------------------------------------------------------
#undef AddConfiguration
CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process )
{
	AddConfigurationEx( pch, format, Process DBG_SRC );
}
//---------------------------------------------------------------------
	CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch
													, uintptr_t (CPROC *Process)( uintptr_t ) )
{
	pch->EndProcess = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) )
{
	pch->Unhandled = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void )
{
	PCONFIG_HANDLER pch;
	DoInit();
	if( g.flags.bDisableMemoryLogging )
	{
		if( !(g._disabled_allocate_logging++) )
		{
			g._last_allocate_logging = ClearAllocateLogging( FALSE );
		}
	}
	pch = (PCONFIG_HANDLER)Allocate( sizeof( CONFIG_HANDLER ) );
	MemSet( pch, 0, sizeof( *pch ) );
	pch->possible_checks = CreateDataList( sizeof( struct config_check) );
	// break input chunks into lines....
	AddLink( &pch->filters, FilterLines );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterLines ), 0 );
	// end the lines at # (also remove \r, \n)
	AddLink( &pch->filters, FilterTerminators );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterTerminators ), 0 );
	// get rid of \\ and \# to replace with appropriate things
	// since \# might be escaped, this is the only place I can handle the '#' character
	// to terminate lines at comment points.
	AddLink( &pch->filters, FilterEscapesAndComments );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterEscapesAndComments ), 0 );
	//pch->ConfigTestRoot.pConstElementList = NULL; //CreateList();
	//pch->ConfigTestRoot.pVarElementList = NULL;//CreateList();
	return pch;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch )
{
	EmptyList( &pch->filters );
}
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter )
{
	AddLink( &pch->filters, filter );
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pce )
{
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy element %p %p", pch, pce );
#endif
	DestroyConfigTest( pch, pce->next, TRUE );
	switch( pce->type )
	{
	case CONFIG_BINARY:
		if( pce->data[0].binary.data )
			Release( pce->data[0].binary.data );
		break;
	case CONFIG_TEXT:
		if( pce->data[0].pText )
			LineRelease( pce->data[0].pText );
		break;
	case CONFIG_SINGLE_WORD:
		if( pce->data[0].pWord )
			Release( pce->data[0].pWord );
		{
			struct config_element_tag *pEnd;
			INDEX idx;
			if(0)
			LIST_FORALL( pce->data[0].singleword.pEnds, idx, struct config_element_tag *, pEnd ) {
#ifdef DEBUG_SAVE_CONFIG
				lprintf( "Destroy config element %p", pEnd );
#endif
				DestroyConfigElement( pch, pEnd );
			}
		}
		DeleteList( &pce->data[0].singleword.pEnds );
		break;
	case CONFIG_MULTI_WORD:
		// this is a temp workspace now, data is released in other ways.
		//if( pce->data[0].multiword.pWords )
		//	Release( pce->data[0].multiword.pWords );
		if( pce->data[0].multiword.pEnds ) {
			struct config_element_tag *pEnd;
			INDEX idx;
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ) {
#ifdef DEBUG_SAVE_CONFIG
				lprintf( "Destroy config element %p", pEnd );
#endif
				DestroyConfigElement( pch, pEnd );
			}
		}
		DeleteList( &pce->data[0].multiword.pEnds );
		break;
	case CONFIG_URL:
	case CONFIG_PATH:
	case CONFIG_FILE:
	case CONFIG_FILEPATH:
	case CONFIG_ADDRESS:
		break;
	case CONFIG_COLOR:
	case CONFIG_PROCEDURE:
	case CONFIG_PROCEDURE_EX:
	case CONFIG_UNKNOWN:
	case CONFIG_BOOLEAN:
	case CONFIG_INTEGER:
	case CONFIG_FRACTION:
	case CONFIG_FLOAT:
	case CONFIG_NOTHING:
		break;
	}
	DeleteFromSet( CONFIG_ELEMENT, pch->elements, pce );
	//Release( pce );
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int deallocate )
{
	PCONFIG_ELEMENT pce;
	INDEX idx;
	if( !pct )
		return;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy Config %p %p", pch, pct );
#endif
	LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete const element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pConstElementList );
	LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete var element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pVarElementList );
	// a pconfig_handler has one static root - guaranteed root.
	// if this pct IS the root, don't attempt to delete from set
	if( deallocate )
		//if( pct != &pch->ConfigTestRoot )
		DeleteFromSet( CONFIG_TEST, pch->test_elements, pct );
	//Release( pct );
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch )
{
	// since as noted in the structure
	//	// address of this IS the address of main structure
	// the configtest Release() will quickly free this .
	PLIST save_list_pConstElementList = pch->ConfigTestRoot.pConstElementList;
	PLIST save_list_pVarElementList = pch->ConfigTestRoot.pVarElementList;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy evaluator %p", pch );
#endif
	DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
	DeleteDataList( &pch->possible_checks );
	{
		INDEX idx;
		PCONFIG_STATE state;
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			if( ( save_list_pConstElementList
				&& (state->ConfigTestRoot.pConstElementList == save_list_pConstElementList ))
				|| ( save_list_pVarElementList
					&& (state->ConfigTestRoot.pVarElementList == save_list_pVarElementList ) )
			)
			{
				//probably this was the error I found in the field... there were
				// probably macros or something that caused excessive layering.
				// or - it was the old bug of not saving the state quite correctly.
				continue;
			}
			DestroyConfigTest( pch, &state->ConfigTestRoot, FALSE );
		}
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			Release( (POINTER)state->name );
			Release( state );
		}
	}
	if( pch->save_config_as && !pch->flags.bConfigSaveNameUsed )
		Release( (POINTER)pch->save_config_as );
	//lprintf( "Setting memory logging to %d", _last_allocate_logging );
	if( g.flags.bDisableMemoryLogging )
		if( g._disabled_allocate_logging )
		{
			g._disabled_allocate_logging--;
			if( !g._disabled_allocate_logging )
			{
				ResetAllocateLogging( g._last_allocate_logging );
			}
		}
	DeleteList( &pch->states );
	DeleteList( &pch->filters );
	DeleteList( &pch->filter_data );
	DeleteSet( (PGENERICSET*)&(pch->elements) );
	DeleteSet( (PGENERICSET*)&(pch->test_elements) );
	Release( pch );
}
void StripConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\\' )
		{
			switch( in[1] )
			{
			case 'n':
				in++;
				out[0] = '\n';
				break;
			default:
				out[0] = in[1];
				in++;
				break;
			}
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
void ExpandConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\n' )
		{
			out[0] = '\\';
			out++;
			out[0] = 'n';
		}
		else if( in[0] == '\\' )
		{
			out[0] = '\\';
			out++;
			out[0] = '\\';
		}
		else if( in[0] == '#' )
		{
			out[0] = '\\';
			out++;
			out[0] = '#';
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
CTEXTSTR FormatColor( CDATA color )
{
	static TEXTCHAR color_buf[14];
	tnprintf( color_buf, sizeof( color_buf ), "$%02X%02X%02X%02X"
			, (int)AlphaVal( color )
			, (int)RedVal( color )
			, (int)GreenVal( color )
			, (int)BlueVal( color )
			);
	return color_buf;
}
#ifdef __cplusplus
 //namespace sack { namespace config {
}}
#endif
//#define DEBUG_LIBRARY_LOADING
//#define DEBUG_WINDOWS_TREMINATE
#define NO_UNICODE_C
#define SYSTEM_CORE_SOURCE
#define FIX_RELEASE_COM_COLLISION
#define TASK_INFO_DEFINED
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
// setenv()
#ifndef _POSIX_C_SOURCE
#  define _POSIX_C_SOURCE 2
#endif
#define _POSIX_SOURCE
#ifdef WIN32
//#undef StrDup
//#undef StrRChr
#endif
#ifdef WIN32
#include <tlhelp32.h>
#include <psapi.h>
#endif
#ifdef __QNX__
#include <devctl.h>
#include <sys/procfs.h>
#endif
#ifdef __LINUX__
#include <sys/wait.h>
extern char **environ;
#  ifndef __MAC__
#    include <elf.h>
#  endif
#endif
#ifdef __cplusplus
using namespace sack::timers;
#endif
//--------------------------------------------------------------------------
struct task_info_tag;
SACK_SYSTEM_NAMESPACE
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
typedef struct handle_info_tag
{
	//struct mydatapath_tag *pdp;
 // partial inputs...
	PTEXT pLine;
	char *name;
	int       bNextNew;
	PTHREAD   hThread;
#ifdef WIN32
   // read/write handle
	HANDLE    handle;
#else
	int       pair[2];
   // read/write handle
	int       handle;
#endif
} HANDLEINFO, *PHANDLEINFO;
struct taskOutputStruct {
	PTASK_INFO task;
	LOGICAL stdErr;
};
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
struct task_info_tag {
	struct {
  // TerminateProgram() was called against this process
		volatile uint8_t closed;
 // StopProgram() was called against this process
		volatile uint8_t process_ended;
 // the wait for exit thread already exited...
		volatile uint8_t process_signaled_end;
		BIT_FIELD bSentIoTerminator : 1;
		BIT_FIELD log_input : 1;
		BIT_FIELD runas_root : 1;
		BIT_FIELD useCtrlBreak : 1;
		BIT_FIELD useEventSignal : 1;
		//BIT_FIELD noKillOnExit : 1;
	} flags;
	TaskEnd EndNotice;
	TaskOutput OutputEvent;
	TaskOutput OutputEvent2;
	uintptr_t psvEnd;
	HANDLEINFO hStdIn;
	HANDLEINFO hStdOut;
	HANDLEINFO hStdErr;
	volatile PTHREAD pOutputThread;
	volatile PTHREAD pOutputThread2;
	struct taskOutputStruct args1;
	struct taskOutputStruct args2;
 // flags passed to create the process
	int spawn_flags;
#if defined(WIN32)
	int launch_flags;
 // used for event to shutdown a task
	char name[256];
	HANDLE hReadOut, hWriteOut;
	HANDLE hReadErr, hWriteErr;
	HANDLE hReadIn, hWriteIn;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
   DWORD exitcode;
	HWND taskWindow;
#elif defined( __LINUX__ )
   int hReadOut, hWriteOut;
   int hReadErr, hWriteErr;
	int hReadIn, hWriteIn;
   volatile pid_t pid;
   int pty;
   uint32_t exitcode;
#endif
};
typedef struct loaded_function_tag
{
	uint32_t references;
	void (CPROC*function)(void );
	struct loaded_library_tag *library;
	DeclareLink( struct loaded_function_tag );
  // can be an integer value... instead of a string...
	CTEXTSTR name;
 // this is more than 1; allocation pads extra bytes for the name.
	TEXTCHAR _name[1];
} FUNCTION, *PFUNCTION;
#ifdef WIN32
typedef HMODULE HLIBRARY;
#else
typedef void* HLIBRARY;
#endif
typedef struct loaded_library_tag
{
 // when unloading...
	uintptr_t nLibrary;
	HLIBRARY library;
	LOGICAL mapped;
	PFUNCTION functions;
	DeclareLink( struct loaded_library_tag );
	int loading;
#ifdef _WIN32
 // points into full_name after last slash - just library name
	wchar_t* name;
// this is appended after full_name and is l.library_path
	wchar_t* alt_full_name;
	wchar_t* cur_full_name;
	//wchar_t* orig_name;
// this is more than 1; allocation pads extra bytes for the name. prefixed iwth l.load_path
	wchar_t* full_name;
// this is more than 1; allocation pads extra bytes for the name. prefixed iwth l.load_path
	TEXTCHAR name_data[1];
#else
 // points into full_name after last slash - just library name
	TEXTCHAR* name;
// this is appended after full_name and is l.library_path
	TEXTCHAR* alt_full_name;
	TEXTCHAR* cur_full_name;
	//TEXTCHAR* orig_name;
// this is more than 1; allocation pads extra bytes for the name. prefixed iwth l.load_path
	TEXTCHAR full_name[1];
#endif
} LIBRARY, *PLIBRARY;
struct local_systemlib_data {
	CTEXTSTR install_path;
	CTEXTSTR load_path;
	CTEXTSTR library_path;
	CTEXTSTR common_data_path;
	struct system_local_flags{
		BIT_FIELD bLog : 1;
		BIT_FIELD bInitialized : 1;
		BIT_FIELD shutdown : 1;
		BIT_FIELD bLogExec : 1;
	} flags;
  // pointer to just filename part...
	CTEXTSTR filename;
	TEXTCHAR *work_path;
	PLIST system_tasks;
	PLIBRARY libraries;
	PTREEROOT pFunctionTree;
	LOGICAL allow_spawn;
	int nLibrary;
	LOGICAL (CPROC*ExternalLoadLibrary)( const char *filename );
 // please Release or Deallocate the reutrn value
	char * (CPROC*ExternalFindProgram)( const char *filename );
	PDATALIST killEventCallbacks;
#ifdef WIN32
	// on XP this is in PSAPI.DLL later it's in Kernel32.DLL
	BOOL (WINAPI* EnumProcessModules)( HANDLE hProcess, HMODULE *lphModule
	                                 , DWORD cb, LPDWORD lpcbNeeded );
#endif
};
#ifdef SYSTEM_CORE_SOURCE
static struct local_systemlib_data local_systemlib__;
#endif
#ifndef SYSTEM_CORE_SOURCE
extern
#endif
	struct local_systemlib_data *local_systemlib;
#ifdef l
#   undef l
#endif
#define l (*local_systemlib)
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline );
struct callback_info {
	int ( *cb )( uintptr_t );
	uintptr_t psv;
	int deleted;
};
#ifdef __MAC__
//sourced from https://github.com/comex/myvmmap/blob/master/myvmmap.c Jan/7/2018
#  include <mach/mach.h>
#  if __IPHONE_OS_VERSION_MIN_REQUIRED
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
kern_return_t mach_vm_region(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name);
int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);
int proc_regionfilename(int pid, uint64_t address, void * buffer, uint32_t buffersize);
#  else
#    include <mach/mach_vm.h>
#    include <libproc.h>
#  endif
//#include <stdio.h>
#  include <assert.h>
#  include <mach-o/loader.h>
#  include <mach-o/nlist.h>
//#include <string.h>
//#include <stdbool.h>
//#include <stdlib.h>
//#include <setjmp.h>
//#include <sys/queue.h>
//#include <sys/param.h>
#  if !__IPHONE_OS_VERSION_MIN_REQUIRED
#    include <Security/Security.h>
#  endif
#endif
//-------------------------------------------------------------------------
//  Function/library manipulation routines...
//-------------------------------------------------------------------------
typedef struct task_info_tag TASK_INFO;
#ifdef __ANDROID__
static CTEXTSTR program_name;
static CTEXTSTR program_path;
static CTEXTSTR library_path;
static CTEXTSTR working_path;
void SACKSystemSetProgramPath( CTEXTSTR path )
{
	program_path = DupCStr( path );
}
void SACKSystemSetProgramName( CTEXTSTR name )
{
	program_name = DupCStr( name );
}
void SACKSystemSetWorkingPath( CTEXTSTR name )
{
	working_path = DupCStr( name );
}
void SACKSystemSetLibraryPath( CTEXTSTR name )
{
	library_path = DupCStr( name );
}
#endif
#ifdef HAVE_ENVIRONMENT
CTEXTSTR OSALOT_GetEnvironmentVariable(CTEXTSTR name)
{
#ifdef WIN32
	static int env_size;
	static wchar_t *env;
	static char* lastResult;
	wchar_t* wName = CharWConvert( name );
	int size;
	if( size = GetEnvironmentVariableW( wName, NULL, 0 ) )
	{
		if( size > env_size )
		{
			if( env )
				ReleaseEx( (POINTER)env DBG_SRC );
			env = NewArray( wchar_t, size + 10 );
			env_size = size + 10;
		}
		if( GetEnvironmentVariableW( wName, env, env_size ) ) {
			if( lastResult ) Deallocate( char*, lastResult );
			lastResult = WcharConvert( env );
			Deallocate( wchar_t*, wName );
			return lastResult;
		}
	}
	Deallocate( wchar_t*, wName );
	return NULL;
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		static TEXTCHAR *result;
		if( result )
			ReleaseEx( result DBG_SRC );
		result = DupCStr( getenv( tmpname ) );
		ReleaseEx( tmpname DBG_SRC );
	}
#else
	return getenv( name );
#endif
#endif
}
void OSALOT_SetEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	wchar_t *wName = CharWConvert( name );
	wchar_t *wValue = CharWConvert( value );
	SetEnvironmentVariableW( wName, wValue );
	Deallocate( wchar_t*, wName );
	Deallocate( wchar_t*, wValue );
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( value );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	if( !value )
		unsetenv( name );
	else
		setenv( name, value, TRUE );
#endif
#endif
}
void OSALOT_AppendEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	uint32_t length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, "%s;%s", oldpath, value );
#  else
	snprintf( newpath, length, "%s;%s", oldpath, value );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	size_t maxlen;
	newpath = NewArray( TEXTCHAR, maxlen = ( StrLen( oldpath ) + StrLen( value ) + 2 ) );
	tnprintf( newpath, maxlen, "%s:%s", oldpath, value );
#ifdef UNICODE
	{
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpvalue DBG_SRC );
	}
	ReleaseEx( oldpath DBG_SRC );
	ReleaseEx( tmpname DBG_SRC );
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
void OSALOT_PrependEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 )|| defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	int length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, "%s;%s", value, oldpath );
#  else
	snprintf( newpath, length, "%s;%s", value, oldpath );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	int length;
	newpath = NewArray( TEXTCHAR, length = StrLen( oldpath ) + StrLen( value ) + 1 );
	tnprintf( newpath, length, "%s:%s", value, oldpath );
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
#endif
#if __EMSCRIPTEN__
// NoOp For all.
#define SystemInit()
#else
#ifdef __MAC__
static bool is_64bit;
static mach_port_t task;
static int pid;
static task_dyld_info_data_t dyld_info;
static jmp_buf recovery_buf;
static int read_from_task(void *p, mach_vm_address_t addr, mach_vm_size_t size) {
    mach_vm_size_t outsize;
    kern_return_t kr = mach_vm_read_overwrite(task, addr, size, (mach_vm_address_t) p, &outsize);
    if(kr || outsize != size) {
#if 0
        fprintf(stderr, "read_from_task(0x%llx, 0x%llx): ", (long long) addr, (long long) size);
        if(kr)
            fprintf(stderr, "kr=%d\n", (int) kr);
        else
            fprintf(stderr, "short read\n");
#endif
				return 0;
        //_longjmp(recovery_buf, 1);
    }
		return 1;
}
static uint64_t read_64(char **pp) {
    return *(*(uint64_t **)pp)++;
}
static uint32_t read_32(char **pp) {
    return *(*(uint32_t **)pp)++;
}
static mach_vm_address_t read_ptr(char **pp) {
    return is_64bit ? read_64(pp) : read_32(pp);
}
static void lookup_dyld_images() {
    char all_images[12], *p = all_images;
    if( !read_from_task(p, dyld_info.all_image_info_addr + 4, 12) )
			return;
    uint32_t info_array_count = read_32(&p);
    mach_vm_address_t info_array = read_ptr(&p);
    if(info_array_count > 10000) {
        fprintf(stderr, "** dyld image info had malformed data.\n");
        return;
    }
    size_t size = (is_64bit ? 24 : 12) * info_array_count;
    char *image_info = NewArray( char, size);
    p = image_info;
    if( !read_from_task(p, info_array, size) )
			return;
    for(uint32_t i = 0; i < info_array_count; i++) {
        mach_vm_address_t
            load_address = read_ptr(&p),
            file_path_addr = read_ptr(&p);
 // file_mod_date
        read_ptr(&p);
        //if(_setjmp(recovery_buf))
        //    continue;
        char path[MAXPATHLEN + 1];
        if( !read_from_task(path, file_path_addr, sizeof(path)) )
				   continue;
        if(strnlen(path, sizeof(path)) == sizeof(path))
            fprintf(stderr, "** dyld image info had malformed data.\n");
        else {
					  AddMappedLibrary( path, dlopen( path, 0 ) );
            //printf( "PATH:%s %p", path, load_address );
            //printf( "  load is %p\n", dlopen( path, 0 ) );
            //if( dlsym( load_address, "dlsym" )) printf( "** FOUND DLSYM**\n");
          }
    }
    return;
}
void loadMacLibraries(struct local_systemlib_data *init_l) {
    bool got_showaddr = false;
    mach_vm_address_t showaddr;
    pid = getpid();
    task = mach_task_self();
    char path[MAXPATHLEN];
    size_t path_size;
    if((path_size = proc_pidpath(pid, path, sizeof(path))))
        path[path_size] = 0;
    else
        strcpy(path, "~/");
    //printf("%d: %s\n", pid, path);
    {
		TEXTCHAR *ext, *ext1;
		ext = (TEXTSTR)StrRChr( (CTEXTSTR)path, '.' );
		if( ext )
				ext[0] = 0;
		ext1 = (TEXTSTR)pathrchr( path );
		if( ext1 )
		{
			ext1[0] = 0;
			(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( path DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( path DBG_SRC );
			(*init_l).load_path = StrDupEx( "" DBG_SRC );
		}
	}
    assert(!task_info(task, TASK_DYLD_INFO, (task_info_t) &dyld_info, (mach_msg_type_number_t[]) {TASK_DYLD_INFO_COUNT}));
    is_64bit = dyld_info.all_image_info_addr >= (1ull << 32);
    lookup_dyld_images();
}
#endif
#ifdef _WIN32
static uintptr_t KillEventThread( PTHREAD thread ) {
	char *eventName = (char*)GetThreadParam( thread );
	HANDLE hRestartEvent = NULL;
	{
		// I don't know that this is stricly required;
		//   There was a error in the service checking for signaled event...
		PSECURITY_DESCRIPTOR psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH );
		InitializeSecurityDescriptor( psd, SECURITY_DESCRIPTOR_REVISION );
		SetSecurityDescriptorDacl( psd, TRUE, NULL, FALSE );
		SECURITY_ATTRIBUTES sa = { 0 };
		sa.nLength = sizeof( sa );
		sa.lpSecurityDescriptor = psd;
		sa.bInheritHandle = FALSE;
		//lprintf( "Creating event:%s", eventName );
		//HANDLE hEvent = CreateEvent( &sa, TRUE, FALSE, TEXT( "Global\\Test" ) );
		hRestartEvent = CreateEvent( &sa, FALSE, FALSE, eventName );
		LocalFree( psd );
		eventName[0] = 0;
	}
	DWORD status = WaitForSingleObject( hRestartEvent, INFINITE );
	if( status == WAIT_OBJECT_0 ) {
		INDEX idx;
		struct callback_info* ci;
		//int( *cb )( void );
		int preventShutdown = 0;
		DATA_FORALL( l.killEventCallbacks, idx, struct callback_info*, ci ) {
			//lprintf( "callback: %p %p %d", ci->cb, ci->psv, ci->deleted );
			if( !ci->deleted )
				preventShutdown |= ci->cb(ci->psv);
		}
		//lprintf( "Callbacks done: %d", preventShutdown );
		if( !preventShutdown ) {
			InvokeExits();
			exit( 0 );
		}
	}
	CloseHandle( hRestartEvent );
	return 0;
}
void EnableExitEvent( void ) {
	char eventName[256];
	snprintf( eventName, 256, "Global\\%s:exit", GetProgramName() );
	//lprintf( "Starting exit event thread... %s", eventName );
	ThreadTo( KillEventThread, (uintptr_t)eventName );
	while( eventName[0] ) Relinquish();
}
#endif
#ifdef __LINUX__
static char *exitEventName;
static int hDir;
ATEXIT( cleanupEvent ) {
	if( exitEventName ) {
		unlinkat( hDir, exitEventName, 0 );
		Deallocate( char*, exitEventName ); exitEventName = NULL;
	}
}
static uintptr_t KillEventThread( PTHREAD thread ) {
	char *eventName      = (char *)GetThreadParam( thread );
	exitEventName = StrDup( eventName );
	char bRestartEvent = 0;
	{
		int hDir = open( "/tmp", O_RDONLY | O_DIRECTORY );
		int rc   = mkfifoat( hDir, eventName, 0666 );
		if( rc ) {
			// failure
		}
		int file = openat( hDir, eventName, O_RDONLY );
 // ack done init...
		eventName[ 0 ] = 0;
		int status = read( file, &bRestartEvent, sizeof( bRestartEvent ) );
		if( status > 0 ) {
			INDEX idx;
			struct callback_info *ci;
			unlinkat( hDir, exitEventName, 0 );
			Deallocate( char*, exitEventName );
			exitEventName = NULL;
			close( file );
			// int( *cb )( void );
			int preventShutdown = 0;
			DATA_FORALL( l.killEventCallbacks, idx, struct callback_info *, ci ) {
				// lprintf( "callback: %p %p %d", ci->cb, ci->psv, ci->deleted );
				if( !ci->deleted )
					preventShutdown |= ci->cb( ci->psv );
			}
			// lprintf( "Callbacks done: %d", preventShutdown );
			if( !preventShutdown ) {
				InvokeExits();
				exit( 0 );
			}
		}
else lprintf( "Failure %d", status );
	}
	return 0;
}
void EnableExitEvent( void ) {
	char eventName[ 256 ];
	snprintf( eventName, 256, "Global\\%s:exit", GetProgramName() );
	// lprintf( "Starting exit event thread... %s", eventName );
	ThreadTo( KillEventThread, (uintptr_t)eventName );
	while( eventName[ 0 ] )
		Relinquish();
}
#endif
void AddKillSignalCallback( int ( *cb )( uintptr_t ), uintptr_t psv ) {
	struct callback_info ci;
	ci.cb      = cb;
	ci.psv     = psv;
	ci.deleted = 0;
	if( !l.killEventCallbacks )
		l.killEventCallbacks = CreateDataList( sizeof( struct callback_info ) );
	AddDataItem( &l.killEventCallbacks, &ci );
}
void RemoveKillSignalCallback( int ( *cb )( uintptr_t ), uintptr_t psv ) {
	struct callback_info *ci;
	INDEX idx;
	DATA_FORALL( l.killEventCallbacks, idx, struct callback_info *, ci ) {
		if( ci->cb == cb && ci->psv == psv ) {
			ci->deleted = TRUE;
			break;
		}
	}
}
static void CPROC SetupSystemServices( POINTER mem, uintptr_t size )
{
	struct local_systemlib_data *init_l = (struct local_systemlib_data *)mem;
#ifdef _WIN32
	extern void InitCo( void );
	InitCo();
	{
		TEXTCHAR filepath[256];
		TEXTCHAR *ext, *ext1;
		GetModuleFileName( NULL, filepath, sizeof( filepath ) );
		ext = (TEXTSTR)StrRChr( (CTEXTSTR)filepath, '.' );
		if( ext )
			ext[0] = 0;
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( filepath DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( filepath DBG_SRC );
			(*init_l).load_path = StrDupEx( "" DBG_SRC );
		}
#ifndef USE_LIBRARY_INSTALL_PATH
		{
			TEXTCHAR tmp[MAXPATH];
			snprintf( tmp, MAXPATH, "%s/..", (*init_l).load_path );
			(*init_l).install_path = ( ExpandPath( tmp ) );
		}
#endif
		GetModuleFileName( LoadLibrary( TARGETNAME ), filepath, sizeof( filepath ) );
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			if( filepath[0] == '\\' && filepath[1] == '\\' && filepath[2] == '?' && filepath[3] == '\\' )
				(*init_l).library_path = StrDupEx( filepath +4 DBG_SRC );
			else
				(*init_l).library_path = StrDupEx( filepath DBG_SRC );
#ifdef USE_LIBRARY_INSTALL_PATH
			{
				TEXTCHAR tmp[MAXPATH];
				snprintf( tmp, MAXPATH, "%s/..", (*init_l).library_path );
				(*init_l).install_path = ( ExpandPath( tmp ) );
			}
#endif
		}
		else
		{
			(*init_l).load_path = StrDupEx( "" DBG_SRC );
		}
#ifdef HAVE_ENVIRONMENT
		OSALOT_SetEnvironmentVariable( "MY_LOAD_PATH", filepath );
#endif
	}
#else
#  if defined( __QNX__ )
	{
		struct dinfo_s {
			procfs_debuginfo info;
			char pathbuffer[_POSIX_PATH_MAX];
		};
		struct dinfo_s dinfo;
		char buf[256], *pb;
		int proc_fd;
		proc_fd = open("/proc/self/as",O_RDONLY);
		if( proc_fd >= 0 )
		{
			int status;
			status = devctl( proc_fd, DCMD_PROC_MAPDEBUG_BASE, &dinfo, sizeof(dinfo),
								 0 );
			if( status != EOK )
			{
				lprintf( "Error in devctl() call. %s",
						  strerror(status) );
				(*init_l).filename = "FailedToReadFilenaem";
				(*init_l).load_path = ".";
				(*init_l).work_path = ".";
				return;
			}
			close(proc_fd);
		}
		snprintf( buf, 256, "/%s", dinfo.info.path );
		pb = (char*)pathrchr(buf);
		if( pb )
		{
			pb[0]=0;
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( buf DBG_SRC );
			buf[0] = '.';
			buf[1] = 0;
		}
		if( StrCmp( buf, "/." ) == 0 )
			GetCurrentPath( buf, 256 );
		//lprintf( "My execution: %s", buf);
		(*init_l).load_path = StrDupEx( buf DBG_SRC );
		OSALOT_SetEnvironmentVariable( "MY_LOAD_PATH", (*init_l).load_path );
		//strcpy( pMyPath, buf );
		GetCurrentPath( buf, sizeof( buf ) );
		OSALOT_SetEnvironmentVariable( "MY_WORK_PATH", buf );
		(*init_l).work_path = StrDupEx( buf DBG_SRC );
		SetDefaultFilePath( (*init_l).work_path );
	}
#  else
	// this might be clever to do, auto export the LD_LIBRARY_PATH
	// but if we loaded this library, then didn't we already have a good path?
	// use /proc/self to get to cmdline
	// which has the whole invokation of this process.
#    ifdef __ANDROID__
	(*init_l).filename = GetProgramName();
	(*init_l).load_path = GetProgramPath();
	if( !(*init_l).filename || !(*init_l).load_path )
	{
		char buf[256];
		FILE *maps = fopen( "/proc/self/maps", "rt" );
		LOGICAL progPathSet = FALSE;
		while( maps && fgets( buf, 256, maps ) )
		{
			size_t start;
			size_t end;
			// remove newline from buf
			if( !progPathSet ) {
				TEXTSTR eol = StrChr( buf, '\n' );
				if( eol ) eol[0] = 0;
				TEXTSTR tail = StrRChr( buf+49, '/' );
				if( tail && tail[0] ) tail++;
				else tail  = buf+49;
				if( StrCmp( tail, program_name ) == 0 ) {
					tail[-1] = 0;
					SACKSystemSetProgramPath( buf+49 );
					progPathSet = TRUE;
				}
			}
			sscanf( buf, "%zx", &start );
			char *endbuf = strchr( buf, '-' );
			endbuf++;
			sscanf( endbuf, "%zx", &end );
			if( ((size_t)SetupSystemServices >= start ) && ((size_t)SetupSystemServices <= end ) )
			{
				char *myname;
				char *mypath;
				void *lib;
				char *myext;
				fclose( maps );
				maps = NULL;
				if( strlen( buf ) > 49 )
				mypath = strdup( buf + 49 );
				myext = strrchr( mypath, '.' );
				myname = strrchr( mypath, '/' );
				if( myname )
				{
					myname[0] = 0;
					myname++;
				}
				else
					myname = mypath;
				if( myext )
				{
					myext[0] = 0;
				}
				//LOGI( "my path [%s][%s]", mypath, myname );
				// do not auto load libraries
				if( !progPathSet ) {
					SACKSystemSetProgramPath( mypath );
					(*init_l).load_path =  DupCStr( mypath );
					SACKSystemSetProgramName( myname );
					(*init_l).filename = DupCStr( myname );
				}
				SACKSystemSetLibraryPath( buf );
				break;
			}
		}
	}
#    else
	//if( !(*init_l).filename || !(*init_l).load_path )
	{
		/* #include unistd.h, stdio.h, string.h */
		{
			char buf[256];
#       ifndef __MAC__
			char *pb;
			int n;
			n = readlink("/proc/self/exe",buf,256);
			if( n >= 0 )
			{
 //linux
				buf[n]=0;
				if( !n )
				{
					strcpy( buf, "." );
 // fbsd
					buf[ n = readlink( "/proc/curproc/",buf,256)]=0;
				}
			}
			else
				strcpy( buf, ".") ;
			pb = strrchr(buf,'/');
			if( pb )
				pb[0]=0;
			else
				pb = buf - 1;
			//lprintf( "My execution: %s %s", buf, pb+1);
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
#ifndef USE_LIBRARY_INSTALL_PATH
			{
				TEXTCHAR tmp[MAXPATH];
				snprintf( tmp, MAXPATH, "%s/..", buf );
				(*init_l).install_path = ( ExpandPath( tmp ) );
			}
#endif
			(*init_l).load_path = StrDupEx( buf DBG_SRC );
#       endif
			local_systemlib = init_l;
			AddMappedLibrary( "dummy", NULL );
#       ifdef __MAC__
			loadMacLibraries( init_l );
#       endif
#ifndef __STATIC_GLOBALS__
         // allow retriggering init for some reason.
			local_systemlib = NULL;
#endif
			{
				PLIBRARY library = (*init_l).libraries;
				while( library )
				{
					if( StrCaseCmp( library->name, TARGETNAME ) == 0 )
						break;
					library = library->next;
				}
				if( !library ) {
					lprintf( "FATALITY:Did not manage to find self:%s", TARGETNAME );
					PLIBRARY library = (*init_l).libraries;
					while( library )
					{
						lprintf( "library->name:%s", library->name );
						library = library->next;
					}
				}
				if( library )
				{
					char *dupname;
					char *path;
					dupname = StrDup( library->full_name );
					path = strrchr( dupname, '/' );
					if( path )
						path[0] = 0;
					(*init_l).library_path = dupname;
#ifdef USE_LIBRARY_INSTALL_PATH
					{
						TEXTCHAR tmp[MAXPATH];
						snprintf( tmp, MAXPATH, "%s/..", dupname );
						(*init_l).install_path = ( ExpandPath( tmp ) );
					}
#endif
				}
				else
					(*init_l).library_path = ".";
			}
			setenv( "MY_LOAD_PATH", (*init_l).load_path, TRUE );
			//strcpy( pMyPath, buf );
			GetCurrentPath( buf, sizeof( buf ) );
			setenv( "MY_WORK_PATH", buf, TRUE );
			(*init_l).work_path = StrDupEx( buf DBG_SRC );
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "LD_LIBRARY_PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).library_path)) );
				sprintf( newpath, "%s:%s", (*init_l).library_path
						 , oldpath );
				setenv( "LD_LIBRARY_PATH", newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).load_path)) );
				sprintf( newpath, "%s:%s", (*init_l).load_path
						 , oldpath );
				setenv( "PATH", newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		//<x`int> rathar: main() { char buf[1<<7]; buf[readlink("/proc/self/exe",buf,1<<7)]=0; puts(buf); }
		//<x`int> main() {  }
		//<x`int>
	}
#    endif
#  endif
#endif
}
static void SystemInit( void )
{
	if( !local_systemlib )
	{
#ifdef __STATIC_GLOBALS__
		local_systemlib = &local_systemlib__;
		SetupSystemServices( local_systemlib, sizeof( local_systemlib[0] ) );
#else
		RegisterAndCreateGlobalWithInit( (POINTER*)&local_systemlib, sizeof( *local_systemlib ), "system", SetupSystemServices );
#endif
#ifdef WIN32
		if( !l.flags.bInitialized )
		{
			TEXTCHAR filepath[256];
			GetCurrentPath( filepath, sizeof( filepath ) );
			l.work_path = StrDupEx( filepath DBG_SRC );
			SetDefaultFilePath( l.work_path );
#ifdef HAVE_ENVIRONMENT
			OSALOT_SetEnvironmentVariable( "MY_WORK_PATH", filepath );
#endif
			l.flags.bInitialized = 1;
#  ifdef WIN32
			l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction( "psapi.dll", "EnumProcessModules");
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction("kernel32.dll", "EnumProcessModules");
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction("kernel32.dll", "K32EnumProcessModules" );
#  endif
		}
#endif
	}
}
PRIORITY_PRELOAD( SetupPath, OSALOT_PRELOAD_PRIORITY )
{
	SystemInit();
}
 // if __EMSCRIPTEN__
#endif
#ifndef __NO_OPTIONS__
PRELOAD( SetupSystemOptions )
{
	//lprintf( "SYSTEM OPTION INIT" );
	l.flags.bLogExec = SACK_GetProfileIntEx( GetProgramName(), "SACK/System/Enable Logging exec()", 0, TRUE );
	l.flags.bLog = SACK_GetProfileIntEx( GetProgramName(), "SACK/System/Enable Logging", 0, TRUE );
	if( SACK_GetProfileIntEx( GetProgramName(), "SACK/System/Auto prepend program location to PATH environment", 0, TRUE ) ){
		//lprintf( "Add %s to path", l.load_path );
		OSALOT_PrependEnvironmentVariable( "PATH", l.load_path );
	}
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
#ifndef _M_CEE_PURE
static BOOL CALLBACK CheckWindowAndSendKill( HWND hWnd, LPARAM lParam )
{
	uint32_t idThread, idProcess;
	PTASK_INFO task = (PTASK_INFO)lParam;
	idThread = GetWindowThreadProcessId( hWnd, (LPDWORD)&idProcess );
	/*
	{
		TEXTCHAR title[256];
		GetWindowText( hWnd, title, sizeof( title ) );
		lprintf( "Window [%s] = %d %d", title, idProcess, idThread );
	}
	*/
	if( task->pi.dwProcessId == idProcess )
	{
		// found the window to kill...
		PostThreadMessage( idThread, WM_QUIT, 0xD1E, 0 );
		return FALSE;
	}
	return TRUE;
}
#endif
//--------------------------------------------------------------------------
int CPROC EndTaskWindow( PTASK_INFO task )
{
	return EnumWindows( CheckWindowAndSendKill, (LPARAM)task );
}
#endif
//--------------------------------------------------------------------------
#if 0
#  ifdef WIN32
#    if _MSC_VER
#      pragma runtime_checks( "sru", off )
#    endif
static DWORD STDCALL SendCtrlCThreadProc( void *data )
{
	return GenerateConsoleCtrlEvent( CTRL_C_EVENT, 0 );
}
static DWORD STDCALL SendBreakThreadProc( void* data ) {
	return GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, 0 );
}
#    if _MSC_VER
#      pragma runtime_checks( "sru", restore )
#    endif
#  endif
#endif
#ifdef _WIN32
struct process_id_pair {
	DWORD parent;
	DWORD child;
};
void ProcIdFromParentProcId( DWORD dwProcessId, PDATALIST *ppdlProcs ) {
	if( !dwProcessId ) {
		//lprintf( "Don't search for proces id 0..." );
		ppdlProcs[0] = NULL;
		return;
	}
	struct process_id_pair pair = { GetCurrentProcessId(), dwProcessId };
	DWORD dwMe = GetCurrentProcessId();
// vector<PROCID> vec;
	PDATALIST pdlProcs = CreateDataList( sizeof( struct process_id_pair ) );
	//int i = 0;
	INDEX maxId = 1;
	INDEX minId = 0;
	HANDLE hp = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );
	PROCESSENTRY32 pe = { 0 };
	pe.dwSize = sizeof( PROCESSENTRY32 );
	AddDataItem( &pdlProcs, &pair );
	while( 1 ) {
		int found;
		INDEX idx;
		struct process_id_pair*procId;
		found = 0;
		if( Process32First( hp, &pe ) ) {
			do {
  // NEXTALL steps index 1.
				idx = minId-1;
				if( pe.th32ParentProcessID == dwMe ) continue;
				//lprintf( "Check  %d %d", pe.th32ParentProcessID, pe.th32ProcessID );
				DATA_NEXTALL( pdlProcs, idx, struct process_id_pair*, procId ) {
					//lprintf( " subCheck %d %d %d %d", idx, maxId, pe.th32ParentProcessID, procId->child );
					if( idx > maxId ) break;
					if( pe.th32ParentProcessID == procId->child ) {
						found = 1;
						pair.parent = procId->child;
						pair.child = pe.th32ProcessID;
						{
							INDEX idx;
							struct process_id_pair* procId;
							DATA_FORALL( pdlProcs, idx, struct process_id_pair*, procId ) {
								if( procId->parent == pair.parent && procId->child == pair.child ) break;
							}
							if( !procId ) AddDataItem( &pdlProcs, &pair );
						}
						//lprintf( "Found child %d %d", pair.parent, pair.child );
					}
				}
			} while( Process32Next( hp, &pe ) );
			minId = maxId;
			maxId = pdlProcs->Cnt;
		}
		if( !found )
			break;
	}
	CloseHandle( hp );
	ppdlProcs[0] = pdlProcs;
}
struct handle_data {
	unsigned long process_id;
	HWND window_handle;
};
PDATALIST GetProcessTree( PTASK_INFO task ){
	INDEX idx;
	INDEX idx2;
	struct process_id_pair* pair;
	PDATALIST pdlProcs;
	PDATALIST pdlResult = NULL;
	struct process_tree_pair *checkPair;
	struct process_tree_pair resultPair;
	ProcIdFromParentProcId( task->pi.dwProcessId, &pdlProcs );
	DATA_FORALL( pdlProcs, idx, struct process_id_pair*, pair ) {
		struct process_tree_pair *parent;
		INDEX parent_id = INVALID_INDEX;
		//struct process_tree_pair *checkPair;
		INDEX child_id = INVALID_INDEX;
		DATA_FORALL( pdlResult, idx2, struct process_tree_pair*, checkPair ) {
			if( checkPair->process_id == pair->parent ) {
				parent_id = idx2;
				parent = checkPair;
			}
			if( checkPair->process_id == pair->child )
				child_id = idx2;
		}
		if( parent_id < 0 ){
			resultPair.process_id = pair->parent;
			resultPair.parent_id = -1;
			resultPair.child_id = child_id;
			resultPair.next_id = -1;
			AddDataItem( &pdlResult, &resultPair );
			parent_id = 0;
			parent = (struct process_tree_pair *)GetDataItem( &pdlResult, 0 );
		}
		if( child_id < 0 ){
			resultPair.process_id = pair->child;
			resultPair.parent_id = parent_id;
			resultPair.child_id = -1;
			if( parent->child_id < 0 )
				resultPair.next_id = -1;
			else
				resultPair.next_id = parent->child_id;
			parent->child_id = pdlResult->Cnt;
			AddDataItem( &pdlResult, &resultPair );
		}
	}
	DeleteDataList( &pdlProcs );
	return pdlResult;
}
BOOL is_main_window( HWND handle ) {
	return GetWindow( handle, GW_OWNER ) == (HWND)0 && IsWindowVisible( handle );
}
BOOL CALLBACK enum_windows_callback( HWND handle, LPARAM lParam ) {
	struct handle_data* data = (struct handle_data*)lParam;
	unsigned long process_id = 0;
	GetWindowThreadProcessId( handle, &process_id );
	if( data->process_id != process_id || !is_main_window( handle ) )
		return TRUE;
	data->window_handle = handle;
	return FALSE;
}
HWND find_main_window( unsigned long process_id ) {
	struct handle_data data;
	data.process_id = process_id;
	data.window_handle = 0;
	EnumWindows( enum_windows_callback, (LPARAM)&data );
	return data.window_handle;
}
struct move_window {
	PTASK_INFO task;
	int timeout, left, top, width, height;
	uintptr_t psv;
	void (*cb)( uintptr_t, LOGICAL );
};
struct style_window{
	PTASK_INFO task;
	int timeout;
	uint32_t windowStyle, windowExStyle, classStyle;
	uintptr_t psv;
	void ( *cb )( uintptr_t, int );
};
HWND RefreshTaskWindow( PTASK_INFO task ) {
	return task->taskWindow = find_main_window( task->pi.dwProcessId );
}
static uintptr_t moveTaskWindowThread( PTHREAD thread ) {
	struct move_window* move = (struct move_window*)GetThreadParam( thread );
	uint32_t time = timeGetTime();
	BOOL success = FALSE;
	int tries = 0;
	//lprintf( "move Thread: %d", time );
	while( (int)( timeGetTime() - time ) < move->timeout ) {
		//lprintf( "move Thread(time): %d", timeGetTime() - time );
		HWND hWndProc = move->task->taskWindow ?move->task->taskWindow :find_main_window( move->task->pi.dwProcessId );
		int atx, aty, atw, ath;
		if( !hWndProc ) {
			WakeableSleep( 100 );
			continue;
		}
		move->task->taskWindow = hWndProc;
		while( (int)( timeGetTime() - time ) < move->timeout ) {
			//lprintf( "move window(time): %d", timeGetTime() - time );
			{
				RECT rect;
				GetWindowRect( hWndProc, &rect );
				atx = rect.left;
				aty = rect.top;
				atw = rect.right - rect.left;
				ath = rect.bottom - rect.top;
				//lprintf( "Get Pos1 :%d %d %d %d %d", tries, rect.left, rect.top, atw, ath );
			}
			if( atx != move->left || aty != move->top || atw != move->width || ath != move->height ) {
				success = SetWindowPos( hWndProc, HWND_TOPMOST, move->left, move->top, move->width, move->height, 0 );
				SetWindowPos( hWndProc, HWND_NOTOPMOST, move->left, move->top, move->width, move->height, 0 );
				//lprintf( "Success:%d %d %d %d %d", success, move->left, move->top, move->width, move->height );
			} else {
				//lprintf( "Window is already positioned correctly" );
				success = 1;
				break;
			}
			tries++;
			if( tries < 3 ) {
				WakeableSleep( 100 );
				continue;
			} else break;
		}
		if( !success ) {
			DWORD dwError = GetLastError();
			lprintf( "Failed to move window? %d Trying again...", dwError );
			continue;
		} else {
			break;
		}
	}
	//lprintf( "Done Move...%d", success );
	if( move->cb ) move->cb( move->psv, success );
	Deallocate( struct move_window*, move );
	return 0;
}
static uintptr_t styleTaskWindowThread( PTHREAD thread ){
	struct style_window* style = (struct style_window*)GetThreadParam( thread );
	uint32_t time = timeGetTime();
	int success = 0;
	int tries = 0;
	//lprintf( "style Thread: %d", time );
	while( (int)( timeGetTime() - time ) < style->timeout ){
		//lprintf( "style Thread(time): %d", timeGetTime() - time );
		HWND hWndProc = style->task->taskWindow ? style->task->taskWindow : find_main_window( style->task->pi.dwProcessId );
		int windowStyle, windowExStyle, classStyle;
		if( !hWndProc ){
			WakeableSleep( 100 );
			continue;
		}
		style->task->taskWindow = hWndProc;
		while( (int)( timeGetTime() - time ) < style->timeout ){
			//lprintf( "style window(time): %d", timeGetTime() - time );
			windowStyle = (int)GetWindowLongPtr( hWndProc, GWL_STYLE );
			windowExStyle = (int)GetWindowLongPtr( hWndProc, GWL_EXSTYLE );
			classStyle = (int)GetClassLongPtr( hWndProc, GCL_STYLE );
			success = 0;
			if( ( style->windowStyle != -1 ) && ( windowStyle != style->windowStyle ) )
				SetWindowLongPtr( hWndProc, GWL_STYLE, style->windowStyle );
			else success |= 1;
			if( ( style->windowExStyle != -1 ) && ( windowExStyle != style->windowExStyle ) )
				SetWindowLongPtr( hWndProc, GWL_EXSTYLE, style->windowExStyle );
			else success |= 2;
			if( ( style->classStyle != -1 ) && ( classStyle != style->classStyle ) )
				SetClassLongPtr( hWndProc, GWL_EXSTYLE, style->windowExStyle );
			else success |= 4;
			if( success == ( 1 | 2 | 4 ) )
				break;
			tries++;
			if( tries < 3 ){
				WakeableSleep( 100 );
				continue;
			} else break;
		}
		if( success != 7 ){
			lprintf( "Failed to set window styles? Trying again..." );
			continue;
		} else{
			break;
		}
	}
	//lprintf( "Done Move...%d", success );
	if( style->cb ) style->cb( style->psv, success );
	Deallocate( struct style_window*, style );
	return 0;
}
char* GetWindowTitle( PTASK_INFO task ) {
	HWND hWndProc = task->taskWindow ? task->taskWindow : find_main_window( task->pi.dwProcessId );
	char* str = NewArray( char, 256 );
	if( hWndProc ) {
		GetWindowText( hWndProc, str, 256 );
	} else
		StrCpy( str, "No Window" );
	return str;
}
struct find_monitor_data {
	int device;
	int monitor;
	int* x; int* y;
	int* width; int* height;
	int found;
};
static BOOL WINAPI addMonitor( HMONITOR hMonitor,
	HDC hDC_null,
	LPRECT pRect,
	LPARAM dwParam
) {
	struct find_monitor_data* data = (struct find_monitor_data*)dwParam;
	MONITORINFOEX monitorInfo;
	monitorInfo.cbSize = sizeof( monitorInfo );
	GetMonitorInfo( hMonitor, (LPMONITORINFO)& monitorInfo);
	if( data->monitor > 0 ) {
		if( !( --data->monitor ) ) {
			data->found = 1;
			data->x[0] = pRect->left;
			data->y[0] = pRect->top;
			data->width[0] = pRect->right - pRect->left;
			data->height[0] = pRect->bottom - pRect->top;
			return FALSE;
		}
	} else {
		for( int numStart = 0; monitorInfo.szDevice[numStart]; numStart++ ) {
			if( monitorInfo.szDevice[numStart] >= '0' && monitorInfo.szDevice[numStart] <= '9' ) {
				int devNum = atoi( monitorInfo.szDevice + numStart );
				if( devNum == data->device ) {
					data->found = 1;
					data->x[0] = pRect->left;
					data->y[0] = pRect->top;
					data->width[0] = pRect->right - pRect->left;
					data->height[0] = pRect->bottom - pRect->top;
					return FALSE;
				}
				break;
			}
		}
	}
	return TRUE;
}
static int _GetDisplaySizeEx ( int nDisplay, int monitor
	, int* x, int* y
	, int* width, int* height ) {
	{
		struct find_monitor_data data;
		if( monitor >= 0 ) {
			data.monitor = monitor;
			data.device = 0;
		} else {
			data.monitor = -1;
			data.device = nDisplay;
		}
		data.x = x;
		data.y = y;
		data.width = width;
		data.height = height;
		data.found = 0;
		EnumDisplayMonitors( NULL
			, NULL
			, addMonitor
			, (LPARAM)&data
		);
		return data.found;
	}
#if 0
	if( nDisplay >= 0 ) {
		TEXTSTR teststring = NewArray( TEXTCHAR, 20 );
		//int idx;
		int v_test = 0;
		int i;
		DISPLAY_DEVICE dev;
		DEVMODE dm;
		if( x ) ( *x ) = 0;
		if( y ) ( *y ) = 0;
		if( width ) ( *width ) = 1920;
		if( height ) ( *height ) = 1080;
		dm.dmSize = sizeof( DEVMODE );
		dm.dmDriverExtra = 0;
		dev.cb = sizeof( DISPLAY_DEVICE );
		for( v_test = 0; !found && ( v_test < 2 ); v_test++ ) {
			// go ahead and try to find V devices too... not sure what they are, but probably won't get to use them.
			tnprintf( teststring, 20, "\\\\.\\DISPLAY%s%d", ( v_test == 1 ) ? "V" : "", nDisplay );
			for( i = 0;
 // all devices
				!found && EnumDisplayDevices( NULL
					, i
					, &dev
 // dwFlags
					, 0
				); i++ ) {
				if( EnumDisplaySettings( dev.DeviceName, ENUM_CURRENT_SETTINGS, &dm ) ) {
					//if( l.flags.bLogDisplayEnumTest )
					lprintf( "display(cur) %s is at %d,%d %dx%d", dev.DeviceName, dm.dmPosition.x, dm.dmPosition.y, dm.dmPelsWidth, dm.dmPelsHeight );
				} else if( EnumDisplaySettings( dev.DeviceName, ENUM_REGISTRY_SETTINGS, &dm ) ) {
					//if( l.flags.bLogDisplayEnumTest )
					lprintf( "display(reg) %s is at %d,%d %dx%d", dev.DeviceName, dm.dmPosition.x, dm.dmPosition.y, dm.dmPelsWidth, dm.dmPelsHeight );
				} else {
					lprintf( "Found display name, but enum current settings failed? %s %d", teststring, GetLastError() );
					continue;
				}
				if( StrCaseCmp( teststring, dev.DeviceName ) == 0 ) {
					//if( l.flags.bLogDisplayEnumTest )
					//	lprintf( "[%s] might be [%s]", teststring, dev.DeviceName );
					if( x )
						( *x ) = dm.dmPosition.x;
					if( y )
						( *y ) = dm.dmPosition.y;
					if( width )
						( *width ) = dm.dmPelsWidth;
					if( height )
						( *height ) = dm.dmPelsHeight;
					found = 1;
					break;
				}
			}
		}
		Deallocate( char*, teststring );
	}
	return found;
#endif
}
void StyleTaskWindow( PTASK_INFO task, int timeout, int windowStyle, int windowExStyle, int classStyle, void cb(uintptr_t, int ), uintptr_t psv ) {
	struct style_window* style = New( struct style_window );
	style->task = task;
	style->timeout = timeout;
	style->windowStyle = windowStyle;
	style->windowExStyle = windowExStyle;
	style->classStyle = classStyle;
	style->cb = cb;
	style->psv = psv;
	ThreadTo( styleTaskWindowThread, (uintptr_t)style );
}
void MoveTaskWindow( PTASK_INFO task, int timeout, int left, int top, int width, int height, void cb(uintptr_t, LOGICAL ), uintptr_t psv ) {
	struct move_window* move = New( struct move_window );
	move->task = task;
	move->timeout = timeout;
	move->left = left;
	move->top = top;
	move->width = width;
	move->height = height;
	move->cb = cb;
	move->psv = psv;
	ThreadTo( moveTaskWindowThread, (uintptr_t)move );
}
void MoveTaskWindowToDisplay( PTASK_INFO task, int timeout, int display, void cb( uintptr_t, LOGICAL ), uintptr_t psv ) {
	struct move_window* move = New( struct move_window );
	move->task = task;
	move->timeout = timeout;
	//lprintf( "TaskToDisplay %d", display );
	if( !_GetDisplaySizeEx( display, -1, &move->left, &move->top, &move->width, &move->height ) ) {
		Deallocate( struct move_window*, move );
		if( cb ) cb( psv, FALSE );
		return;
	}
	move->cb = cb;
	move->psv = psv;
	ThreadTo( moveTaskWindowThread, (uintptr_t)move );
}
void MoveTaskWindowToMonitor( PTASK_INFO task, int timeout, int display, void cb( uintptr_t, LOGICAL ), uintptr_t psv ) {
	struct move_window* move = New( struct move_window );
	move->task = task;
	move->timeout = timeout;
	//lprintf( "TaskToMonitor %d", display );
	if( !_GetDisplaySizeEx( -1, display, &move->left, &move->top, &move->width, &move->height ) ) {
		Deallocate( struct move_window*, move );
		if( cb ) cb( psv, FALSE );
		return;
	}
	move->cb = cb;
	move->psv = psv;
	ThreadTo( moveTaskWindowThread, (uintptr_t)move );
}
#endif
LOGICAL CPROC StopProgram( PTASK_INFO task )
{
	task->flags.process_ended = 1;
	if( task->pOutputThread )
		WakeThread( task->pOutputThread );
	if( task->pOutputThread2 )
		WakeThread( task->pOutputThread2 );
#ifdef WIN32
#ifndef UNDER_CE
	int error;
	int exited = 0;
	//ExitProcess()
 // sometimes we can't get back the launched process? rude.
	if( task->pi.dwProcessId )
	{
		HWND hWndMain = task->taskWindow?task->taskWindow:find_main_window( task->pi.dwProcessId );
		if( hWndMain ) {
			TEXTCHAR title[256];
			GetWindowText( hWndMain, title, 256 );
			lprintf( "Sending WM_CLOSE to %p %s %s", hWndMain, task->name, title );
			SendMessage( hWndMain, WM_CLOSE, 0, 0 );
		}
		else if( !task->flags.useEventSignal ) {
			DWORD dwKillId = task->pi.dwProcessId;
			if( task->spawn_flags & LPP_OPTION_NEW_GROUP ) {
				IgnoreBreakHandler( ( 1 << CTRL_C_EVENT ) | ( 1 << CTRL_BREAK_EVENT ) );
#ifdef DEBUG_WINDOWS_TREMINATE
				lprintf( "Killing child %d? %s", dwKillId, task->name );
#endif
				//MessageBox( NULL, "pause", "pause", MB_OK );
				FreeConsole();
				BOOL a = AttachConsole( dwKillId );
				if( !a ) {
					DWORD dwError = GetLastError();
					lprintf( "Failed to attachConsole %d %d %d", a, dwError, dwKillId );
				}
				if( !task->flags.useCtrlBreak )
					if( !GenerateConsoleCtrlEvent( CTRL_C_EVENT, dwKillId ) ) {
						error = GetLastError();
						lprintf( "Failed to send CTRL_C_EVENT %d %d", dwKillId, error );
					} else lprintf( "Success sending ctrl C?" );
				else
					if( !GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, dwKillId ) ) {
						error = GetLastError();
						lprintf( "Failed to send CTRL_BREAK_EVENT %d %d", dwKillId, error );
					} else lprintf( "Success sending ctrl break?" );
				IgnoreBreakHandler( 0 );
			} else {
				lprintf( "Process wasn't in a new group - would end up killing self. %s (maybe can use event signal option?", task->name );
			}
		}
//#if 0
		// this is pretty niche; was an attempt to handle when ctrl-break and ctrl-c events failed.
		if( task->flags.useEventSignal )
		{
			char eventName[256];
			HANDLE hEvent;
			snprintf( eventName, 256, "Global\\%s:exit", task->name );
			hEvent = OpenEvent( EVENT_MODIFY_STATE, FALSE, eventName );
			//lprintf( "Signal process event: %s", eventName );
			if( hEvent != NULL ) {
				//lprintf( "Opened event:%p %s %d", hEvent, eventName, GetLastError() );
				if( !SetEvent( hEvent ) ) {
					lprintf( "Failed to set event? %d", GetLastError() );
				}
				CloseHandle( hEvent );
			}
		}
//#endif
	}
	// try and copy some code to it..
	if( !exited )
#if 0
		// this is bad, and just causes the remote to crash; left for reference.
		if( task->pi.hProcess && FALSE )
		{
			POINTER mem = VirtualAllocEx( task->pi.hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
			DWORD err = GetLastError();
			lprintf( "Trying to do remote thread... %p %d", mem, err );
			if( mem ) {
				SIZE_T written;
				if( WriteProcessMemory( task->pi.hProcess, mem,
					(LPCVOID)SendCtrlCThreadProc, 1024, &written ) ) {
					DWORD dwThread;
 //-V575
					HANDLE hThread = CreateRemoteThread( task->pi.hProcess, NULL, 0
						, (LPTHREAD_START_ROUTINE)mem, NULL, 0, &dwThread );
					err = GetLastError();
					if( hThread ) {
						//lprintf( "waiting for task to self terminate" );
						if( WaitForSingleObject( task->pi.hProcess, 1000 ) != WAIT_OBJECT_0 ) {
							lprintf( "Not exited after a second" );
							return FALSE;
						} else {
							lprintf( "Exited for sure." );
							return TRUE;
						}
					} else {
						lprintf( "Failed to create remote thread %d", GetLastError() );
					}
				}
			}
		}
#endif
#endif
	if( (!task->pi.hProcess) || WaitForSingleObject( task->pi.hProcess, 1 ) != WAIT_OBJECT_0 ) {
		//lprintf( "don't think it exited" );
		return FALSE;
	} else {
		//lprintf( "it definitly exited..." );
		return TRUE;
	}
#else
//lprintf( "need to send kill() to signal process to stop" );
#ifndef PEDANTIC_TEST
	kill( task->pid, SIGTERM );
#endif
#endif
	return FALSE;
}
uintptr_t TerminateProgramEx( PTASK_INFO task, int options ) {
	//lprintf( "TerminateProgram Task?%p %d", task, task->flags.closed );
	if( task ) {
		if( !task->flags.closed ) {
			task->flags.closed = 1;
			//lprintf( "%ld, %ld %p %p", task->pi.dwProcessId, task->pi.dwThreadId, task->pi.hProcess, task->pi.hThread );
#if defined( WIN32 )
			if( options & TERMINATE_PROGRAM_CHAIN ) {
				INDEX idx;
				struct process_id_pair* pair;
				PDATALIST pdlProcs;
				PLINKSTACK stack = NULL;
				ProcIdFromParentProcId( task->pi.dwProcessId, &pdlProcs );
				DATA_FORALL( pdlProcs, idx, struct process_id_pair*, pair ) {
					lprintf( "Got Pair: %d %d", pair->parent, pair->child );
					PushLink( &stack, pair );
					//dwKillId = pair->child;
				}
				while( pair = (struct process_id_pair*)PopLink( &stack ) ) {
					HANDLE hChild = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pair->child );
					if( hChild != INVALID_HANDLE_VALUE ) {
						TerminateProcess( hChild, 0xdead );
						CloseHandle( hChild );
					} else lprintf( "Failed to open child process handle...", GetLastError() );
				}
				DeleteLinkStack( &stack );
				DeleteDataList( &pdlProcs );
			} else {
				// if not already ended...
				if( WaitForSingleObject( task->pi.hProcess, 0 ) != WAIT_OBJECT_0 ) {
					if( !TerminateProcess( task->pi.hProcess, 0xD3ad ) ) {
						//HANDLE hTmp;
						lprintf( "Failed to terminate process... " );
					}
				}
			}
#else
#ifndef PEDANTIC_TEST
			kill( task->pid, SIGKILL );
#endif
			// wait a moment for it to die...
#endif
		}
	}
	return 0;
}
uintptr_t TerminateProgram( PTASK_INFO task )
{
	return TerminateProgramEx( task, 0 );
}
//--------------------------------------------------------------------------
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv )
{
	if( task )
		task->psvEnd = psv;
}
//--------------------------------------------------------------------------
uint32_t GetTaskExitCode( PTASK_INFO task )
{
	if( task )
		return task->exitcode;
	return 0;
}
uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread )
{
	PTASK_INFO task = (PTASK_INFO)GetThreadParam( pThread );
#ifdef __LINUX__
 // StopProgram(); this thread already exited on this?
	while( ( !task->flags.process_ended
 /*terminated*/
	       && !task->flags.closed )
	    && ( !task->pid
	       || ( task->OutputEvent && !task->pOutputThread )
	       || ( task->OutputEvent2 && !task->pOutputThread2 ) ) ) {
		IdleFor( 100 );
	}
#endif
	// this should be considered the owner of this.
	if( !task->EndNotice )
	{
		// application is dumb, hold the task for him; otherwise
		// the application is aware that after EndNotification the task is no longer valid.
		Hold( task );
	}
	//if( task->EndNotice )
	{
		// allow other people to delete it...
		//Hold( task );
#if defined( WIN32 )
		WaitForSingleObject( task->pi.hProcess, INFINITE );
		GetExitCodeProcess( task->pi.hProcess, &task->exitcode );
#elif defined( __LINUX__ )
		if( task->pid )
		{
			int status;
			pid_t result;
			result = waitpid( task->pid, &status, 0 );
			task->exitcode = status;
			/*
			if( WIFEXITED(status)){
				lprintf( "waitpid exited:%d", status );
			}else if( WIFSTOPPED(status)){
				lprintf( "waitpid stopped:%d", status );
			}else if( WIFSIGNALED(status)){
				lprintf( "waitpid signaled:%d", status );
			}
			lprintf( "waitpid said: %zd %d", result, status );
			*/
		} else
			task->exitcode = -666;
#endif
		task->flags.process_signaled_end = 1;
		//lprintf( "Task Ended, have to wake and remove pipes " );
		if( task->hStdOut.hThread || task->hStdErr.hThread )
		{
#ifdef _WIN32
			uint32_t now = timeGetTime();
			while( ( timeGetTime() - now ) < 100 && ( task->hStdOut.hThread || task->hStdErr.hThread ) )
				Relinquish();
			//lprintf( "Stalled before cancel?", ( task->hStdOut.hThread || task->hStdErr.hThread ) );
			// vista++ so this won't work for XP support...
			static BOOL (WINAPI *MyCancelSynchronousIo)( HANDLE hThread ) = (BOOL(WINAPI*)(HANDLE))-1;
			if( (uintptr_t)MyCancelSynchronousIo == (uintptr_t)-1 )
				MyCancelSynchronousIo = (BOOL(WINAPI*)(HANDLE))LoadFunction( "kernel32.dll", "CancelSynchronousIo" );
			if( MyCancelSynchronousIo )
			{
				///lprintf( "!!! Cancelling syncrhous IO " );
				if( task->hStdOut.hThread )
					if( !MyCancelSynchronousIo( GetThreadHandle( task->hStdOut.hThread ) ) )
					{
						DWORD dwError = GetLastError();
						// maybe the read wasn't queued yet....
						lprintf( "Failed to cancel IO on thread %d %d", GetThreadHandle( task->hStdOut.hThread ), dwError );
					}
				if( task->hStdErr.hThread )
					if( !MyCancelSynchronousIo( GetThreadHandle( task->hStdErr.hThread ) ) )
					{
						DWORD dwError = GetLastError();
						// maybe the read wasn't queued yet....
						lprintf( "Failed to cancel IO on thread %d %d", GetThreadHandle( task->hStdErr.hThread ), dwError );
					}
			}
			else
			{
				static BOOL (WINAPI *MyCancelIoEx)( HANDLE hFile,LPOVERLAPPED ) = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))-1;
				//lprintf( "Trying CancelIo instead?" );
				if( (uintptr_t)MyCancelIoEx == (uintptr_t)-1 )
					MyCancelIoEx = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))LoadFunction( "kernel32.dll", "CancelIoEx" );
				if( MyCancelIoEx ) {
					if( task->hStdOut.hThread )
						MyCancelIoEx( task->hStdOut.handle, NULL );
					if( task->hStdErr.hThread )
						MyCancelIoEx( task->hStdErr.handle, NULL );
				} else {
					DWORD written;
					// if I can't cancel, send something oob to wake up the thread.
					task->flags.bSentIoTerminator = 1;
					if( !WriteFile( task->hWriteOut, "\x04", 1, &written, NULL ) )
						lprintf( "write stdout pipe failed! %d", GetLastError() );
					if( !WriteFile( task->hWriteErr, "\x04", 1, &written, NULL ) )
						lprintf( "write stderr pip failed! %d", GetLastError() );
				}
			}
#endif
		}
		// wait for task last output before notification of end of task.
		//lprintf( "Task is exiting... %p %p", task->pOutputThread, task->pOutputThread2 );
		{
			uint32_t now = timeGetTime();
			while( ( ( timeGetTime()-now)< 500 )
			       && ( task->pOutputThread || task->pOutputThread2 ) )
				Relinquish();
		}
		//lprintf( "Task Exit didn't finish - output threads are stuck." );
		if( task->EndNotice )
			task->EndNotice( task->psvEnd, task );
#if defined( __LINUX__ )
		if( task->pty > 0 )
			close( task->pty );
		//lprintf( "Never did close that handle?");
#endif
#if defined( WIN32 )
		//lprintf( "Closing process and thread handles." );
		if( task->hReadIn    != INVALID_HANDLE_VALUE ) CloseHandle( task->hReadIn );
		if( task->hReadOut   != INVALID_HANDLE_VALUE ) CloseHandle( task->hReadOut );
		if( task->hReadErr   != INVALID_HANDLE_VALUE ) CloseHandle( task->hReadErr );
		if( task->hWriteIn   != INVALID_HANDLE_VALUE ) CloseHandle( task->hWriteIn );
		if( task->hWriteOut  != INVALID_HANDLE_VALUE ) CloseHandle( task->hWriteOut );
		if( task->hWriteErr  != INVALID_HANDLE_VALUE ) CloseHandle( task->hWriteErr );
		//lprintf( "Closing process handle %p", task->pi.hProcess );
		if( task->pi.hProcess )
		{
			CloseHandle( task->pi.hProcess );
			task->pi.hProcess = 0;
		}
		if( task->pi.hThread )
		{
			CloseHandle( task->pi.hThread );
			task->pi.hThread = 0;
		}
#endif
		ReleaseEx( task DBG_SRC );
	}
	//TerminateProgram( task );
	return 0;
}
//--------------------------------------------------------------------------
#ifdef WIN32
static BOOL CALLBACK EnumDesktopProc( LPTSTR lpszDesktop,
												 LPARAM lParam
												)
{
	lprintf( "Desktop found [%s]", lpszDesktop );
	return 1;
}
void EnumDesktop( void )
{
	// I'm running on some windows station, right?
	//HWINSTA GetProcessWindowStation();
	if( EnumDesktops( NULL, EnumDesktopProc, (LPARAM)(uintptr_t)0 ) )
	{
		// returned non-zero value from enumdesktopproc?
		// failed to find?
	}
}
static BOOL CALLBACK EnumStationProc( LPTSTR lpszWindowStation, LPARAM lParam )
{
	lprintf( "station found [%s]", lpszWindowStation );
	return 1;
}
void EnumStations( void )
{
	if( EnumWindowStations( EnumStationProc, 0 ) )
	{
	}
}
void SetDefaultDesktop( void )
{
	//return;
	{
	HDESK lngDefaultDesktop;
	HWINSTA lngWinSta0;
	HWINSTA station = GetProcessWindowStation();
	HDESK desk = GetThreadDesktop( GetCurrentThreadId() );
	DWORD length;
	char buffer[256];
	lprintf( "Desktop this is %p %p", station, desk );
	GetUserObjectInformation( desk, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( "desktop is %s", buffer );
	GetUserObjectInformation( station, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( "station is %s", buffer );
	EnumDesktop();
	EnumStations();
	// these should be const strings, but they're not... add typecast for GCC
	lngWinSta0 = OpenWindowStation( (LPTSTR)"WinSta0", FALSE, WINSTA_ALL_ACCESS );
	//lngWinSta0 = OpenWindowStation("msswindowstation", FALSE, WINSTA_ALL_ACCESS );
	lprintf( "sta = %p %d", lngWinSta0, GetLastError() );
	if( !SetProcessWindowStation(lngWinSta0) )
		lprintf( "Failed station set?" );
	// these should be const strings, but they're not... add typecast for GCC
	lngDefaultDesktop = OpenDesktop( (LPTSTR)"Default", 0, FALSE, 0x10000000);
	//lngDefaultDesktop = OpenDesktop("WinSta0", 0, FALSE, 0x10000000);
	lprintf( "defa = %p", lngDefaultDesktop );
	if( !SetThreadDesktop(lngDefaultDesktop) )
		lprintf( "Failed desktop set?" );
	}
}
		/*
 HDESK WINAPI OpenInputDesktop(
  __in  DWORD dwFlags,
  __in  BOOL fInherit,
  __in  ACCESS_MASK dwDesiredAccess
);
*/
DWORD GetExplorerProcessID()
{
	static TEXTCHAR process_find[128];
	HANDLE hSnapshot;
	PROCESSENTRY32 pe32;
	DWORD temp = 0;
	ZeroMemory(&pe32,sizeof(pe32));
	if( !process_find[0] )
	{
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), "SACK/System/Impersonate Process", "explorer.exe", process_find, sizeof( process_find ), TRUE );
#else
		strcpy( process_find, "explorer.exe" );
#endif
	}
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if(Process32First(hSnapshot,&pe32))
	{
		do
		{
			//lprintf( "Thing is %s", pe32.szExeFile );
			if(!StrCmp(pe32.szExeFile,process_find))
			{
				//MessageBox(0,pe32.szExeFile,"test",0);
				temp = pe32.th32ProcessID;
				break;
			}
		}while(Process32Next(hSnapshot,&pe32));
	}
	return temp;
}
void ImpersonateInteractiveUser( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	SetDefaultDesktop();
	processID = GetExplorerProcessID();
	//lprintf( "Enum EDesktops..." );
	//EnumDesktop();
	//lprintf( "explorer is %p", processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							FALSE,
							processID );
		if( hProcess)
		{
			//lprintf( "Success getting process %p", hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( "Sucess opening token" );
				if( ImpersonateLoggedOnUser( hToken ) )
					;
				else
					lprintf( "Fail impersonate %d", GetLastError() );
				CloseHandle( hToken );
			}
			else
				lprintf( "Failed opening token %d", GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( "Failed open process: %d", GetLastError() );
	}
	else
		lprintf( "Failed get explorer process: %d", GetLastError() );
}
HANDLE GetImpersonationToken( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	processID = GetExplorerProcessID();
	//lprintf( "Enum EDesktops..." );
	//EnumDesktop();
	//lprintf( "explorer is %p", processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							FALSE,
							processID );
		if( hProcess)
		{
			//lprintf( "Success getting process %p", hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( "Sucess opening token" );
				//if( ImpersonateLoggedOnUser( hToken ) )
				//   ;
				//else
				//   lprintf( "Fail impersonate %d", GetLastError() );
				//CloseHandle( hToken );
			}
			else
				lprintf( "Failed opening token %d", GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( "Failed open process: %d", GetLastError() );
	}
	else
		lprintf( "Failed get explorer process: %d", GetLastError() );
	return hToken;
}
void EndImpersonation( void )
{
 //-V530
	RevertToSelf();
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline )
{
#if 0
#if defined( OLD_MINGW_SUX ) || defined( __WATCOMC__ )
	typedef struct _SHELLEXECUTEINFO {
		DWORD     cbSize;
		ULONG     fMask;
		HWND      hwnd;
 // null default
		LPCTSTR   lpVerb;
		LPCTSTR   lpFile;
		LPCTSTR   lpParameters;
		LPCTSTR   lpDirectory;
		int       nShow;
		HINSTANCE hInstApp;
		LPVOID    lpIDList;
		LPCTSTR   lpClass;
		HKEY      hkeyClass;
		DWORD     dwHotKey;
		union {
			HANDLE hIcon;
			HANDLE hMonitor;
		} DUMMYUNIONNAME;
		HANDLE    hProcess;
	} SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO;
#endif
#endif
	SHELLEXECUTEINFOW execinfo;
	MemSet( &execinfo, 0, sizeof( execinfo ) );
	execinfo.cbSize = sizeof( SHELLEXECUTEINFO );
  // need this to get process handle back for terminate later
	execinfo.fMask = SEE_MASK_NOCLOSEPROCESS
		| ( ( task->spawn_flags & LPP_OPTION_DO_NOT_HIDE) ? 0 : SEE_MASK_FLAG_NO_UI )
		| ( ( task->spawn_flags & LPP_OPTION_NEW_CONSOLE ) ? 0 : SEE_MASK_NO_CONSOLE )
		//| SEE_MASK_NOASYNC
		;
	execinfo.lpFile = CharWConvert( program );
	execinfo.lpDirectory = CharWConvert( path );
	{
		TEXTCHAR *params;
		params = GetText( cmdline );
		if( params[0] == '\"' ) {
			params++;
			for( ; params[0] && params[0] != '\"'; params++ );
		}
		for( ; params[0] && params[0] != ' '; params++ );
		for( ; params[0] && params[0] == ' '; params++ );
		if( params[0] )
		{
			//lprintf( "adding extra parames [%s]", params );
			execinfo.lpParameters = CharWConvert( params );
		}
	}
	execinfo.nShow = (( task->spawn_flags&LPP_OPTION_DO_NOT_HIDE)? SW_SHOWNORMAL:SW_HIDE);
	if( task->flags.runas_root )
		execinfo.lpVerb = CharWConvert( "runas" );
	if( ShellExecuteExW( &execinfo ) )
	{
		if( (uintptr_t)execinfo.hInstApp > 32)
		{
			switch( (uintptr_t)execinfo.hInstApp )
			{
			case 42:
#ifdef _DEBUG
				//lprintf( "No association picked : %p (gle:%d)", (uintptr_t)execinfo.hInstApp , GetLastError() );
#endif
				break;
			}
#ifdef _DEBUG
			//lprintf( "sucess with shellexecute of(%p) %s ", execinfo.hInstApp, program );
#endif
			Deallocate( LPCWSTR, execinfo.lpVerb );
			if( execinfo.lpFile ) Deallocate( LPCWSTR, execinfo.lpFile );
			if( execinfo.lpDirectory ) Deallocate( LPCWSTR, execinfo.lpDirectory );
			task->pi.hProcess = execinfo.hProcess;
			task->pi.dwProcessId = GetProcessId( task->pi.hProcess );
			task->pi.hThread = 0;
			return TRUE;
		}
		else
		{
			Deallocate( LPCWSTR, execinfo.lpVerb );
			if( execinfo.lpFile ) Deallocate( LPCWSTR, execinfo.lpFile );
			if( execinfo.lpDirectory ) Deallocate( LPCWSTR, execinfo.lpDirectory );
			//switch( (uintptr_t)execinfo.hInstApp )
			{
			//default:
				lprintf( "Shell exec error : %p (gle:%d)", (uintptr_t)execinfo.hInstApp , GetLastError() );
				//break;
			}
			return FALSE;
		}
	}
	else
		lprintf( "Shellexec error %d", GetLastError() );
	Deallocate( LPCWSTR, execinfo.lpVerb );
	if( execinfo.lpFile ) Deallocate( LPCWSTR, execinfo.lpFile );
	if( execinfo.lpDirectory ) Deallocate( LPCWSTR, execinfo.lpDirectory );
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv )
{
	return LaunchPeerProgramExx( program, path, args
						            , LPP_OPTION_DO_NOT_HIDE | LPP_OPTION_NEW_GROUP
										, NULL, EndNotice, psv DBG_SRC );
}
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args )
{
	return LaunchProgramEx( program, path, args, NULL, 0 );
}
//--------------------------------------------------------------------------
static void InvokeLibraryLoad( void )
{
	void (CPROC *f)(void);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRoot( "SACK/system/library/load_event" );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		if( !GetRegisteredIntValue( data, "ran" ) ) {
			f = GetRegisteredProcedureExx( data, (CTEXTSTR)NULL, void, name, (void));
			if( f ) {
				f();
			}
			RegisterIntValue( (CTEXTSTR)data, "ran", 1 );
		}
	}
}
// dispatch late scheduled preloaded scheduled library loads.
PRIORITY_PRELOAD( checkLibraryLoads, 1000 ) { InvokeLibraryLoad(); }
// look for all the libraries that are currently already loaded (so we know to just load them the normal way)
#define Seek(a,b) (((uintptr_t)a)+(b))
static void LoadExistingLibraries( void )
{
#ifdef WIN32
	DWORD n = 256;
	HMODULE *modules = NewArray( HMODULE, 256 );
	DWORD needed;
	if( !l.EnumProcessModules )
	{
		//lprintf( "Failed to load EnumProcessModules" );
		return;
	}
	l.EnumProcessModules( GetCurrentProcess(), modules, sizeof( HMODULE ) * 256, &needed );
	if( needed / sizeof( HMODULE ) == n )
		lprintf( "loaded module overflow" );
	needed /= sizeof( HMODULE );
	for( n = 0; n < needed; n++ )
	{
		POINTER real_memory = modules[n];
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)real_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( real_memory, source_dos_header->e_lfanew );
		PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
		PIMAGE_EXPORT_DIRECTORY exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( real_memory, dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );
		const char *dll_name = (const char*) Seek( real_memory, exp_dir->Name );
		if( exp_dir->Name > source_nt_header->OptionalHeader.SizeOfImage )
		{
			dll_name = "Invalid_Name";
		}
#ifdef UNICODE
		{
			TEXTSTR _dll_name = DupCStr( dll_name );
#define dll_name _dll_name
#endif
			AddMappedLibrary( dll_name, modules[n] );
#ifdef UNICODE
			Deallocate( TEXTSTR, _dll_name );
#undef dll_name
		}
#endif
	}
#endif
#ifdef __MAC__
	lookup_dyld_images();
#else
#  ifdef __LINUX__
	{
		FILE *maps;
		char buf[256];
		maps = sack_fopenEx( 0, "/proc/self/maps", "rt", sack_get_mounted_filesystem( "native" ) );
		//lprintf( "maps? %p", maps);
		while( maps && sack_fgets( buf, 256, maps ) )
		{
			//lprintf( "Line:", buf );
			char *libpath = strchr( buf, '/' );
			char *split = strchr( buf, '-' );
			if( libpath && split )
			{
				char *dll_name = strrchr( libpath, '/' );
				size_t start, end;
				char perms[8];
				size_t offset;
				int scanned;
				offset = strlen( buf );
				if( offset < 2 )
					continue;
				buf[offset-1] = 0;
				scanned = sscanf( buf, "%zx-%zx %s %zx", &start, &end, perms, &offset );
				//lprintf( "so sscanf said: %d %d", scanned, offset );
				if( scanned == 4 && offset == 0 )
				{
					//lprintf( "Perms:%s", perms );
					if( ( end - start ) > 4 )
						if( ( ((unsigned char*)start)[0] == ELFMAG0 )
						   && ( ((unsigned char*)start)[1] == ELFMAG1 )
						   && ( ((unsigned char*)start)[2] == ELFMAG2 )
							&& ( ((unsigned char*)start)[3] == ELFMAG3 ) )
						{
							//lprintf( "Add library %s %p", dll_name + 1, start );
							AddMappedLibrary( libpath, (POINTER)start );
						}
				}
			}
		}
		sack_fclose( maps );
	}
#  endif
#endif
}
SYSTEM_PROC( LOGICAL, IsMappedLibrary)( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
#ifdef _WIN32
		if( library->library && StrCaseCmp_u8u16( libname, library->name ) == 0 )
			break;
#else
		if( library->library && StrCaseCmp( libname, library->name ) == 0 )
			break;
#endif
		library = library->next;
	}
	if( library )
		return TRUE;
	return FALSE;
}
SYSTEM_PROC( void, AddMappedLibrary)( CTEXTSTR libname, POINTER image_memory )
{
	PLIBRARY library = l.libraries;
	static int loading;
	if( !l.libraries && !loading )
	{
		loading = 1;
		LoadExistingLibraries();
		library = l.libraries;
		loading = 0;
		if( !image_memory )
			return;
	}
	while( library )
	{
#ifdef _WIN32
		if( StrCaseCmp_u8u16( libname, library->name ) == 0 )
			break;
#else
		if( StrCaseCmp( libname, library->name ) == 0 )
			break;
#endif
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library && image_memory )
	{
		size_t maxlen = StrLen( libname ) + 1;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
		library->alt_full_name = NULL;
#ifdef _WIN32
		// full_name isn't name_data
		library->full_name = CharWConvert( libname );
		library->name = (wchar_t*)pathrchrW( library->full_name );
#else
		// full_name is equivalent to name_data
		StrCpy( library->full_name, libname );
		library->name = (char*)pathrchr( library->full_name );
#endif
		if( library->name )
			library->name++;
		else
			library->name = library->full_name;
		library->functions = NULL;
		library->mapped = TRUE;
		library->library = (HLIBRARY)image_memory;
		InvokeLibraryLoad();
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
	}
}
void DeAttachThreadToLibraries( LOGICAL attach )
{
	PLIBRARY library = l.libraries;
	if( 0 )
	while( library )
	{
		if( library->mapped )
		{
#ifdef WIN32
			PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
			PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
			PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
			void(WINAPI*entry_point)(void*, DWORD, void*) = (void(WINAPI*)(void*,DWORD,void*))Seek( library->library, source_nt_header->OptionalHeader.AddressOfEntryPoint );
			{
				// thread local storage fixup
				PIMAGE_TLS_DIRECTORY tls = (PIMAGE_TLS_DIRECTORY)Seek( library->library, dir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress );
				DWORD n;
				if( dir[IMAGE_DIRECTORY_ENTRY_TLS].Size )
				{
					for( n = 0; n < dir[IMAGE_DIRECTORY_ENTRY_TLS].Size / sizeof( IMAGE_TLS_DIRECTORY ); n++ )
					{
						POINTER data;
						DWORD dwInit;
						size_t size_init = ( tls->EndAddressOfRawData - tls->StartAddressOfRawData );
						size_t size = size_init + tls->SizeOfZeroFill;
						/*
						printf( "something %d\n", dir[IMAGE_DIRECTORY_ENTRY_TLS].Size );
						printf( "%p %p %p(%d) %p\n"
									, tls->AddressOfCallBacks
									, tls->StartAddressOfRawData, tls->EndAddressOfRawData
									, ( tls->EndAddressOfRawData - tls->StartAddressOfRawData ) + tls->SizeOfZeroFill
									, tls->AddressOfIndex );
						*/
						dwInit = (*((DWORD*)tls->AddressOfIndex));
						if( attach )
						{
							data = NewArray( uint8_t, size );
#ifdef _MSC_VER
#  ifdef __64__
#  else
							{
								_asm mov ecx, fs:[2ch];
								_asm mov eax, dwInit;
								_asm mov edx, data;
								_asm mov dword ptr [ecx+eax*4], edx;
							}
#  endif
#endif
							//TlsSetValue( dwInit, data );
							memcpy( data, (POINTER)tls->StartAddressOfRawData, size_init );
							memset( ((uint8_t*)data) + size_init, 0, tls->SizeOfZeroFill );
						}
						else
						{
							data = TlsGetValue( dwInit );
							Deallocate( POINTER, data );
						}
					}
				}
			}
			entry_point( library->library, attach?DLL_THREAD_ATTACH:DLL_THREAD_DETACH, 0 );
#endif
		}
		library = library->next;
	}
}
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR libname, CTEXTSTR funcname, LOGICAL bPrivate  DBG_PASS )
{
	PLIBRARY library;
#ifdef _DEBUG
#  ifdef _WIN32
	struct {
		wchar_t* name;
		DWORD error;
	} errors[4] ;
#  endif
#endif
	SystemInit();
	library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
#ifdef _WIN32
		if( StrCaseCmp_u8u16( libname, library->name ) == 0 )
			break;
#else
		if( StrCaseCmp( libname, library->name ) == 0 )
			break;
#endif
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library )
	{
		size_t fullnameLen;
		size_t orignameLen;
		size_t curnameLen;
		TEXTCHAR curPath[MAXPATH];
		size_t maxlen;
		size_t libnameLen;
		libname = ExpandPath( libname );
		libnameLen = StrLen( libname );
		GetCurrentPath( curPath, sizeof( curPath ) );
		maxlen = (fullnameLen = StrLen( l.load_path ) + 1 + libnameLen + 1)
			+ (orignameLen = libnameLen + 1)
			+ (curnameLen = StrLen( curPath ) + 1 + libnameLen + 1)
			+ StrLen( l.library_path ) + 1
			;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
 // depth counter
		library->loading = 0;
#ifdef _WIN32
		if( !IsAbsolutePath( libname ) ) {
		   // where the program loaded from? library loaded from
			snprintf( library->name_data, maxlen, "%s/%s", l.load_path, libname );
			{
				char* n; for( n = library->name_data; n[0]; n++ ) if( n[0] == '/' ) n[0] = '\\';
				library->full_name = CharWConvert( library->name_data );
			}
			// the original name (converted)
			snprintf( library->name_data, maxlen, "%s", libname );
			{
				char* n; for( n = library->name_data; n[0]; n++ ) if( n[0] == '/' ) n[0] = '\\';
				library->name = CharWConvert( library->name_data );
			}
			// where this library loaded from
			snprintf( library->name_data, maxlen, "%s/%s", l.library_path, libname );
			{
				char* n; for( n = library->name_data; n[0]; n++ ) if( n[0] == '/' ) n[0] = '\\';
				library->alt_full_name = CharWConvert( library->name_data );
			}
			// where this user currenty is
			snprintf( library->name_data, maxlen, "%s/%s", curPath, libname );
			{
				char* n; for( n = library->name_data; n[0]; n++ ) if( n[0] == '/' ) n[0] = '\\';
				library->cur_full_name = CharWConvert( library->name_data );
			}
		} else {
			snprintf( library->name_data, maxlen, "%s", libname );
			{
				char* n; for( n = library->name_data; n[0]; n++ ) if( n[0] == '/' ) n[0] = '\\';
				library->full_name = CharWConvert( library->name_data );
				library->name = (wchar_t*)pathrchrW( library->full_name );
				if( library->name ) library->name++;
				else library->name = library->full_name;
			}
			library->name = library->full_name;
			Hold( library->name );
			library->alt_full_name = library->full_name;
			Hold( library->alt_full_name );
			library->cur_full_name = library->full_name;
			Hold( library->cur_full_name );
		}
#else
		//lprintf( "New library %s", libname );
		if( !IsAbsolutePath( libname ) ) {
			library->cur_full_name = library->full_name + fullnameLen ;
			library->alt_full_name = library->full_name + fullnameLen + curnameLen;
			library->name = library->full_name
				+ tnprintf( library->full_name, maxlen, "%s/", l.load_path );
			tnprintf( library->name, maxlen, "%s", libname );
			tnprintf( library->cur_full_name, maxlen, "%s/%s", curPath, libname );
			tnprintf( library->alt_full_name, maxlen, "%s/%s", l.library_path, libname );
		} else {
			StrCpy( library->full_name, libname );
			library->name = (char*)pathrchr( library->full_name );
			library->cur_full_name = library->full_name;
			library->alt_full_name = library->full_name;
			//library->long_name = library->full_name;
			library->loading = 0;
			if( library->name )
				library->name++;
			else
				library->name = library->full_name;
		}
#endif
		library->library = NULL;
		library->mapped = FALSE;
		library->functions = NULL;
		library->loading++;
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
#ifdef _WIN32
		// with deadstart suspended, the library can safely register
		// all of its preloads.  Then invoke will release suspend
		// so final initializers in application can run.
		if( l.ExternalLoadLibrary && !library->library )
		{
			PLIBRARY check;
#  ifdef UNICODE
			char *libname = CStrDup( library->name );
#  else
//#        define libname library->name
#  endif
			//lprintf( "trying external load...%s", library->name );
			l.ExternalLoadLibrary( libname );
#  ifdef UNICODE
			Deallocate( char*, libname );
#  else
#        undef libname
#  endif
			// during external load, it will end up adding a library that has
			// a valid handle, this entry is no longer good and we should use that one.
			// THe full name probably won't match.
			for( check = l.libraries; check; check = check->next )
			{
				// result will be in the local list of libraries (duplicating this one)
				// and will reference the same name(or a byte duplicate)
				if( check != library && !check->loading
					&& ( StrCaseCmpW( check->full_name, library->full_name ) == 0
						|| StrCaseCmpW( check->name, library->name ) == 0 ) )
				{
					UnlinkThing( library );
#ifdef _WIN32
					Deallocate( wchar_t*, library->alt_full_name );
					Deallocate( wchar_t*, library->cur_full_name );
					Deallocate( wchar_t*, library->full_name );
					Deallocate( wchar_t*, library->name );
#endif
					Deallocate( PLIBRARY, library );
					library = check;
					// loaded....
					goto get_function_name;
				}
			}
		}
		ReleaseEx( (TEXTSTR)libname DBG_SRC );
		library->loading--;
	}
	SuspendDeadstart();
	{
	int err1 = 0, err2 = 0, err3 = 0, err4 = 0;
	if( !library->library ) {
 //-V595
		library->library = LoadLibraryExW( library->cur_full_name, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR| LOAD_LIBRARY_SEARCH_DEFAULT_DIRS );
		err1             = GetLastError();
#  ifdef _DEBUG
		errors[0].name = library->cur_full_name;
		errors[0].error = GetLastError();
#  endif
	}
	if( !library->library ) {
#  ifdef DEBUG_LIBRARY_LOADING
		lprintf( "trying load...%s", library->full_name );
#  endif
		library->library = LoadLibraryExW( library->full_name, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS );
		err2             = GetLastError();
#  ifdef _DEBUG
		errors[1].name = library->full_name;
		errors[1].error = GetLastError();
#  endif
	}
	if( !library->library ) {
		library->library = LoadLibraryExW( library->alt_full_name, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS );
		err3             = GetLastError();
#  ifdef _DEBUG
		errors[2].name = library->alt_full_name;
		errors[2].error = GetLastError();
#  endif
	}
	if( !library->library ) {
		library->library = LoadLibraryExW( library->name, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS );
		err4 = GetLastError();
#  ifdef _DEBUG
		errors[3].name = library->name;
		errors[3].error = GetLastError();
#  endif
		//if( !library->library ) lprintf( "Failed load basic:%s %d", library->name, GetLastError() );
	}
	if( !library->library ) {
		if( !library->loading ) {
			//if( l.flags.bLog )
#  ifdef _DEBUG
			for( int i = 0; i < 4; i++ )
				lprintf( "Error LoadLibrary: %5d %ls %d", errors[i].error, errors[i].name, i==0?err1:i==1?err2:i==2?err3:err4 );
#  else
			_xlprintf( 2 DBG_RELAY )("Attempt to load [%ls][%ls][%ls]%ls(%s) failed. %d %d %d %d"
					, library->cur_full_name
					, library->full_name
					, library->alt_full_name
					, library->name
					, funcname ? funcname : "all"
					, err1, err2, err3, err4
 //-V595
					);
#  endif
			ReleaseEx( library->cur_full_name DBG_SRC );
			ReleaseEx( library->full_name DBG_SRC );
			ReleaseEx( library->alt_full_name DBG_SRC );
			ReleaseEx( library->name DBG_SRC );
			UnlinkThing( library );
			ReleaseEx( library DBG_SRC );
		}
		ResumeDeadstart();
		return NULL;
	}
	}
#else
	}
	SuspendDeadstart();
#  ifndef __ANDROID__
		// ANDROID This will always fail from the application manager.
#    ifdef UNICODE
		{
			char *tmpname = CStrDup( library->alt_full_name );
			library->library = dlopen( tmp, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
			Release( tmpname );
		}
#    else
		library->library = dlopen( library->alt_full_name, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
#    endif
		if( !library->library )
		{
			if( l.flags.bLog )
				_xlprintf( 2 DBG_RELAY)( "Attempt to load %s%s(%s) failed: %s.", bPrivate?"(local)":"(global)"
				          , library->alt_full_name, funcname?funcname:"all", dlerror() );
#  endif
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( library->full_name );
				library->library = dlopen( tmpname, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			library->library = dlopen( library->full_name, RTLD_LAZY|(bPrivate?RTLD_LOCAL:RTLD_GLOBAL) );
#  endif
			if( !library->library )
			{
				if( l.flags.bLog )
					_xlprintf( 2 DBG_RELAY)( "Attempt to load  %s%s(%s) failed: %s.", bPrivate?"(local)":"(global)"
							, library->full_name, funcname?funcname:"all", dlerror() );
				library->library = dlopen( library->cur_full_name, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
				if( !library->library )
				{
					if( l.flags.bLog )
						_xlprintf( 2 DBG_RELAY)( "Attempt to load  %s%s(%s) failed: %s.", bPrivate?"(local)":"(global)"
								, library->cur_full_name, funcname?funcname:"all", dlerror() );
					library->library = dlopen( library->name, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
					if( !library->library )
					{
						if( l.flags.bLog )
							_xlprintf( 2 DBG_RELAY)( "Attempt to load  %s%s(%s) failed: %s.", bPrivate?"(local)":"(global)"
									, library->name, funcname?funcname:"all", dlerror() );
						UnlinkThing( library );
						ReleaseEx( library DBG_SRC );
						ResumeDeadstart();
						return NULL;
//else lprintf( "Success opening:%s", library->name );
					}
//else lprintf( "Success opening:%s", library->cur_full_name );
				}
//else lprintf( "Success opening:%s", library->full_name );
			}
#  ifndef __ANDROID__
//else lprintf( "Success opening:%s", library->alt_full_name );
		}
#  endif
#endif
		{
			//DebugBreak();
			ResumeDeadstart();
			// (old news?)actually bInitialDone will not be done sometimes
			// and we need to force this here.
			// (2023) this is probably not needed now; the single flag for
			// bHeldDeadstart in names loading interfaces was probably resuming
			// and extra time too soon; this is harmless to do though.
			// InvokeDeadstart();
		}
		InvokeLibraryLoad();
	//}
#ifdef _WIN32
get_function_name:
#endif
	if( funcname )
	{
		PFUNCTION function = library->functions;
		while( function )
		{
			if( ((uintptr_t)function->name & 0xFFFF ) == (uintptr_t)function->name ) {
				if( function->name == funcname )
					break;
			} else
				if( StrCmp( function->name, funcname ) == 0 )
					break;
			function = function->next;
		}
		if( !function )
		{
			int len;
			if( library->mapped )
			{
#ifdef WIN32
				PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
				PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
				if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE )
					lprintf( "Basic signature check failed; not a library" );
				if( source_nt_header->Signature != IMAGE_NT_SIGNATURE )
					lprintf("Basic NT signature check failed; not a library" );
				if( source_nt_header->FileHeader.SizeOfOptionalHeader )
					if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
						lprintf("Optional header signature is incorrect..." );
				{
					PIMAGE_DATA_DIRECTORY dir;
					PIMAGE_EXPORT_DIRECTORY exp_dir;
					DWORD n;
					int ord;
					dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
					exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( library->library, dir[0].VirtualAddress );
					{
						void (**f)(void) = (void (**)(void))Seek( library->library, exp_dir->AddressOfFunctions );
						char **names = (char**)Seek( library->library, exp_dir->AddressOfNames );
						uint16_t *ords = (uint16_t*)Seek( library->library, exp_dir->AddressOfNameOrdinals );
						if( ( ord = ((uintptr_t)funcname & 0xFFFF ) ) == (uintptr_t)funcname )
						{
							return (generic_function)Seek( library->library, (uintptr_t)f[ord-exp_dir->Base] );
						}
						else
						{
							for( n = 0; n < exp_dir->NumberOfFunctions; n++ )
							{
								char *name = (char*)Seek( library->library, (uintptr_t)names[n] );
								int result;
#  ifdef UNICODE
								TEXTCHAR *_name = DupCStr( name );
#    define name _name
#  endif
								result = StrCmp( name, funcname );
#  ifdef UNICODE
								Deallocate( TEXTCHAR *,_name );
#    undef name _name
#  endif
								if( result == 0 )
								{
									if( ( ((uintptr_t)f[ords[n]] ) < ( dir[0].VirtualAddress + dir[0].Size ) )
										&& ( ((uintptr_t)f[ords[n]] ) > dir[0].VirtualAddress ) )
									{
										char *tmpname;
										char *name = (char*)Seek( library->library, (uintptr_t)f[ords[n]] );
										char *fname = name;
#  ifdef UNICODE
										TEXTCHAR *_tmp_fname;
										TEXTCHAR *_tmp_func;
#  endif
										int len;
										generic_function f;
										while( fname[0] && fname[0] != '.' )
											fname++;
										if( fname[0] )
											fname++;
										tmpname = NewArray( char, len = (int)( fname - name ) + 5 );
										snprintf( tmpname, len, "%*.*s.dll", (int)(fname-name)-1, (int)(fname-name)-1, name );
										//lprintf( "%s:%s = %s:%s", library->name, funcname, tmpname, fname );
#  ifdef UNICODE
										_tmp_fname = DupCStr(tmpname);
										_tmp_func = DupCStr(fname);
#    define tmpname _tmp_fname
#    define fname    _tmp_func
#  endif
										f = LoadFunction( tmpname, fname );
#  ifdef UNICODE
										Deallocate( TEXTCHAR *, _tmp_fname );
										Deallocate( TEXTCHAR *, _tmp_func );
#    undef tmpname
#    undef fname
#  endif
										Deallocate( char *, tmpname );
										return f;
									}
									//lprintf( "%s  %s is %d  %d = %p %p", library->name, name, n, ords[n], f[n], f[ords[n]] );
									return (generic_function)Seek( library->library, (uintptr_t)f[ords[n]] );
								}
							}
						}
					}
				}
#endif
				return NULL;
			}
			else
			{
				if( ( (uintptr_t)funcname & 0xFFFF ) == (uintptr_t)funcname )
				{
					function = NewPlus( FUNCTION, len=0 );
					function->name = funcname;
				}
				else
				{
					function = NewPlus( FUNCTION, (len=(sizeof(TEXTCHAR)*( (uint32_t)StrLen( funcname ) + 1 ) ) ) );
					function->name = function->_name;
					tnprintf( function->_name, len, "%s", funcname );
				}
			}
			function->library = library;
			function->references = 0;
#ifdef _WIN32
#  ifdef __cplusplus_cli
			char *procname = CStrDup( function->name );
			if( l.flags.bLog )
				lprintf( "Get:%s", procname );
			if( !(function->function = (generic_function)GetProcAddress( library->library, procname )) )
#  else
#    ifdef _UNICODE
			{
			char *tmp;
#    endif
			  if( l.flags.bLog )
				lprintf( "Get:%s", (((uintptr_t)function->name&0xFFFF)==(uintptr_t)function->name)?function->name:"ordinal" );
			if( !(function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																						  , tmp = DupTextToChar( function->name )
#    else
																						  , function->name
#    endif
																						  )) )
#  endif
			{
				TEXTCHAR tmpname[128];
#  ifdef UNICODE
				snwprintf( tmpname, sizeof( tmpname ), "_%s", funcname );
#  else
				snprintf( tmpname, sizeof( tmpname ), "_%s", funcname );
#  endif
#  ifdef __cplusplus_cli
				char *procname = CStrDup( tmpname );
				if( l.flags.bLog )
					lprintf( "Get:%s", procname );
				function->function = (generic_function)GetProcAddress( library->library, procname );
				ReleaseEx( procname DBG_SRC );
#  else
				if( l.flags.bLog )
					lprintf( "Get:%s", function->name );
				function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																					  , charConvert( tmpname )
#    else
																					  , tmpname
#    endif
																					  );
#  endif
			}
#  ifdef __cplusplus_cli
			ReleaseEx( procname DBG_SRC );
#  else
#    ifdef _UNICODE
			Deallocate( char *, tmp );
			}
#    endif
#  endif
			if( !function->function )
			{
				if( l.flags.bLog )
					_xlprintf( 2 DBG_RELAY)( "Attempt to get function %s from %s failed. %d", funcname, libname, GetLastError() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#else
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( function->name );
				library->library = dlsym( library->library, tmpname );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			function->function = (generic_function)dlsym( library->library, function->name );
#  endif
			 if( !(function->function) )
			{
				char tmpname[128];
				snprintf( tmpname, 128, "_%s", funcname );
				function->function = (generic_function)dlsym( library->library, tmpname );
			}
			if( !function->function )
			{
				_xlprintf( 2 DBG_RELAY)( "Attempt to get function %s from %s failed. %s", funcname, libname, dlerror() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#endif
			if( !l.pFunctionTree )
				l.pFunctionTree = CreateBinaryTree();
			//lprintf( "Adding function %p", function->function );
			AddBinaryNode( l.pFunctionTree, function, (uintptr_t)function->function );
			LinkThing( library->functions, function );
		}
		function->references++;
		return function->function;
	}
	else
	{
/*extend precisionfirst*/
 // success, but no function possible.
		return (generic_function)((uintptr_t)library->nLibrary);
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, TRUE DBG_RELAY );
}
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	while( library )
	{
#ifdef _WIN32
		if( StrCaseCmp_u8u16( libname, library->name ) == 0 )
			return library->library;
#else
		if( StrCaseCmp( library->name, libname ) == 0 )
			return library->library;
#endif
		library = library->next;
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, FALSE DBG_RELAY );
}
#undef LoadFunction
SYSTEM_PROC( generic_function, LoadFunction )( CTEXTSTR libname, CTEXTSTR funcname )
{
	return LoadFunctionEx( libname,funcname DBG_SRC);
}
//-------------------------------------------------------------------------
// pass the address of the function pointer - this
// will gracefully erase that reference also.
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function *f DBG_PASS )
{
	if( !f  )
		return 0;
	_xlprintf( 1 DBG_RELAY )( "Unloading function %p", *f );
	if( (uintptr_t)(*f) < 1000 )
	{
		// unload library only...
  // invalid result...
		if( !(*f) )
			return 0;
		{
			PLIBRARY library;
			uintptr_t nFind = (uintptr_t)(*f);
			for( library = l.libraries; library; library = NextLink( library ) )
			{
				if( nFind == library->nLibrary )
				{
#ifdef _WIN32
					// should make sure noone has loaded a specific function.
					FreeLibrary ( library->library );
					UnlinkThing( library );
					ReleaseEx( library DBG_SRC );
#else
#endif
				}
			}
		}
	}
	{
		PFUNCTION function = (PFUNCTION)FindInBinaryTree( l.pFunctionTree, (uintptr_t)(*f) );
		PLIBRARY library;
		if( function &&
			 !(--function->references) )
		{
			UnlinkThing( function );
			lprintf( "Should remove the node from the tree here... but it crashes intermittantly. (tree list is corrupted)" );
			//RemoveLastFoundNode( l.pFunctionTree );
			library = function->library;
			if( !library->functions )
			{
#ifdef _WIN32
 //-V595
				FreeLibrary( library->library );
#else
				dlclose( library->library );
#endif
				UnlinkThing( library );
				ReleaseEx( library DBG_SRC );
			}
			ReleaseEx( function DBG_SRC );
			*f = NULL;
		}
		else
		{
			lprintf( "function was not found - or ref count = %" _32f " (5566 means no function)", function?function->references:5566 );
		}
	}
	return FALSE;
}
//-------------------------------------------------------------------------
#if !defined( __ANDROID__ ) && !defined( __ARM__ )
SYSTEM_PROC( PTHREAD, SpawnProcess )( CTEXTSTR filename, POINTER args )
{
	uintptr_t (CPROC *newmain)( PTHREAD pThread );
	newmain = (uintptr_t(CPROC*)(PTHREAD))LoadFunction( filename, "main" );
	if( newmain )
	{
		// hmm... suppose I should even thread through my own little header here
		// then when the thread exits I can get a positive acknowledgement?
		return ThreadTo( newmain, (uintptr_t)args );
	}
	return NULL;
}
#endif
//---------------------------------------------------------------------------
TEXTSTR GetArgsString( PCTEXTSTR pArgs )
{
	static TEXTCHAR args[256];
	int len = 0, n;
	args[0] = 0;
	// arg[0] should be the same as program name...
	for( n = 1; pArgs && pArgs[n]; n++ )
	{
		int space = (StrChr( pArgs[n], ' ' )!=NULL);
		len += tnprintf( args + len, sizeof( args ) - len * sizeof( TEXTCHAR ), "%s%s%s%s"
							, n>1?" ":""
							, space?"\"":""
							, pArgs[n]
							, space?"\"":""
							);
	}
	return args;
}
CTEXTSTR GetProgramName( void )
{
#if defined( __EMSCRIPTEN__ )
 // needs GetModuleName(NULL)
	return "WASM Application";
#elif defined( __ANDROID__ )
	return program_name;
#else
	if( !local_systemlib || !l.filename )
	{
		SystemInit();
		if( !l.filename )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.filename;
#endif
}
CTEXTSTR GetProgramPath( void )
{
#if defined( __EMSCRIPTEN__ )
	return "/";
#elif defined( __ANDROID__ )
	return program_path;
#else
	if( !local_systemlib || l.load_path )
	{
		SystemInit();
		if( !l.load_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.load_path;
#endif
}
CTEXTSTR GetInstallPath( void )
{
#if defined( __EMSCRIPTEN__ )
	return TARGET_INSTALL_PREFIX;
#elif defined( __ANDROID__ )
	return TARGET_INSTALL_PREFIX;
#else
	if( !local_systemlib || l.install_path )
	{
		SystemInit();
		if( !l.install_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.install_path;
#endif
}
CTEXTSTR GetLibraryPath( void )
{
#if defined( __EMSCRIPTEN__ )
	return "/";
#elif defined( __ANDROID__ )
	return library_path;
#else
	if( !local_systemlib || l.library_path )
	{
		SystemInit();
		if( !l.library_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.library_path;
#endif
}
CTEXTSTR GetStartupPath( void )
{
#if defined( __EMSCRIPTEN__ )
	return "/";
#elif defined( __ANDROID__ )
	return working_path;
#else
	if( !local_systemlib || l.work_path )
	{
		SystemInit();
		if( !l.work_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.work_path;
#endif
}
LOGICAL IsSystemShuttingDown( void )
{
#ifdef WIN32
	static HANDLE h = INVALID_HANDLE_VALUE;
	if( h == INVALID_HANDLE_VALUE )
		h = CreateEvent( NULL, TRUE, FALSE, "Windows Is Shutting Down" );
	if( h != INVALID_HANDLE_VALUE )
		if( WaitForSingleObject( h, 0 ) == WAIT_OBJECT_0 )
			return TRUE;
#endif
	return FALSE;
}
void SetExternalLoadLibrary( LOGICAL (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalLoadLibrary = f;
}
void SetExternalFindProgram( char * (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalFindProgram = f;
}
void SetProgramName( CTEXTSTR filename )
{
	SystemInit();
	l.filename = filename;
}
DeclareThreadVar LOGICAL disallow_spawn;
LOGICAL sack_system_allow_spawn( void ) {
	if( ( *local_systemlib ).flags.shutdown )
		return FALSE;
	return !disallow_spawn;
}
void sack_system_disallow_spawn( void ) {
	disallow_spawn = TRUE;
}
#undef Seek
SACK_SYSTEM_NAMESPACE_END
#define NO_UNICODE_C
#define TASK_INFO_DEFINED
#ifndef __NO_IDLE__
#endif
#ifdef __LINUX__
#include <poll.h>
#include <pty.h>
extern char **environ;
#endif
//--------------------------------------------------------------------------
SACK_SYSTEM_NAMESPACE
typedef struct task_info_tag TASK_INFO;
//--------------------------------------------------------------------------
#ifdef WIN32
static int DumpErrorEx( DBG_VOIDPASS )
#define DumpError() DumpErrorEx( DBG_VOIDSRC )
{
	//const int err = GetLastError();
	//_xlprintf( LOG_NOISE+1 DBG_RELAY)( "Failed create process:%d", err );
	return 0;
}
#endif
//--------------------------------------------------------------------------
extern uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread );
#ifdef _WIN32
static uintptr_t CPROC HandleTaskOutput(PTHREAD thread )
{
	struct taskOutputStruct* taskParams = (struct taskOutputStruct*)GetThreadParam( thread );
  // (PTASK_INFO)GetThreadParam( thread );
	PTASK_INFO task = taskParams->task;
	if( task )
	{
		Hold( task );
		if( taskParams->stdErr )
			task->pOutputThread2 = thread;
		else
			task->pOutputThread = thread;
		// read input from task, montiro close and dispatch TaskEnd Notification also.
		{
			PHANDLEINFO phi = taskParams->stdErr?&task->hStdErr:&task->hStdOut;
			PTEXT pInput = SegCreate( 4096 );
			int lastloop;
			size_t offset = 0;
			lastloop = FALSE;
			do
			{
				DWORD dwRead;
				DWORD dwAvail;
				if( task->flags.log_input )
					lprintf( "Go to read task's stdout." );
				offset = 0;
				while( 1 ) {
					BOOL readSuccess = ReadFile( phi->handle
						, GetText( pInput ) + offset, (DWORD)( GetTextSize( pInput ) - ( 1 + offset ) )
						, &dwRead, NULL );
					DWORD dwError = ( !readSuccess ) ? GetLastError() : 0;
					if( readSuccess || dwError == ERROR_BROKEN_PIPE )
					{
						offset += dwRead;
						if( dwError != ERROR_BROKEN_PIPE ) {
							if( offset < 4095 ) {
								Relinquish();
								if( PeekNamedPipe( phi->handle, NULL, 0, NULL, &dwAvail, NULL ) ) {
									if( dwAvail ) {
										if( task->flags.log_input )
											lprintf( "More data became available: %d", dwAvail );
										continue;
									}
								}
							}
						} else if( !dwRead ) {
							lastloop = 1;
							break;
						}
						if( task->flags.log_input )
							lprintf( "got read on task's stdout: %d %d", taskParams->stdErr, dwRead );
						//lprintf( "result %d", dwRead );
						GetText( pInput )[offset] = 0;
						pInput->data.size = offset;
						offset = 0;
						//LogBinary( GetText( pInput ), GetTextSize( pInput ) );
						if( taskParams->stdErr ) {
							if( task->OutputEvent2 )
								task->OutputEvent2( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
							else if( task->OutputEvent )
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
						} else {
							if( task->OutputEvent )
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
						}
						pInput->data.size = 4096;
						if( dwError == ERROR_BROKEN_PIPE )
							break;
					} else {
						DWORD dwError = GetLastError();
						offset = 0;
						//lprintf( "Thread Read was 0? %d %d", taskParams->stdErr, dwError );
						if( ( dwError == ERROR_BROKEN_PIPE
							|| dwError == ERROR_OPERATION_ABORTED )
							&& task->flags.process_ended ) {
							lastloop = TRUE;
							break;
						}
					}
				}
				//allow a minor time for output to be gathered before sending
				// partial gathers...
			}
			while( !lastloop );
			LineRelease( pInput );
			//lprintf( "Clearing thread handle (done)" );
			phi->hThread = 0;
			phi->handle = INVALID_HANDLE_VALUE;
			if( taskParams->stdErr ) {
				task->pOutputThread2 = NULL;
				task->OutputEvent2 = NULL;
			} else {
				task->pOutputThread = NULL;
				task->OutputEvent = NULL;
			}
			Release( task );
			//WakeAThread( phi->pdp->common.Owner );
			return 0xdead;
		}
	}
	return 0;
}
#endif
#ifdef __LINUX__
static uintptr_t CPROC HandleTaskOutput( PTHREAD thread ) {
	struct taskOutputStruct* taskParams = (struct taskOutputStruct*)GetThreadParam( thread );
  // (PTASK_INFO)GetThreadParam( thread );
	PTASK_INFO task = taskParams->task;
	if( task ) {
		Hold( task );
		if( taskParams->stdErr )
			task->pOutputThread2 = thread;
		else
			task->pOutputThread = thread;
		// read input from task, montiro close and dispatch TaskEnd Notification also.
		{
			PHANDLEINFO phi = taskParams->stdErr ? &task->hStdErr : &task->hStdOut;
			PTEXT pInput = SegCreate( 4096 );
			int lastloop;
			lastloop = FALSE;
			do {
				int32_t dwRead;
				{
					if( task->flags.log_input )
						lprintf( "Go to read task's %s.", taskParams->stdErr?"stderr":"stdout" );
					dwRead = read( phi->handle
						, GetText( pInput )
						, GetTextSize( pInput ) - 1 );
					if( !dwRead || (dwRead < 0) ) {
						const int err = errno;
						if( err == EIO ){
							lastloop = 1;
							break;
						}
#  ifdef _DEBUG
						//lprintf( "Ending system thread because of broke pipe! %d", errno );
#  endif
						lprintf( "%d read = pipe failure. %d", dwRead, err );
						break;
					}
					if( task->flags.log_input )
						lprintf( "got read on task's stdout: %d %d", taskParams->stdErr, dwRead );
					if( task->flags.bSentIoTerminator ) {
						if( dwRead > 1 )
							dwRead--;
						else {
							if( task->flags.log_input )
								lprintf( "Finished, no more data, task has ended; no need for once more around" );
							lastloop = 1;
 // we're done; task ended, and we got an io terminator on XP
							break;
						}
					}
					//lprintf( "result %d", dwRead );
					if( dwRead < 4096 ) {
						GetText( pInput )[dwRead] = 0;
						pInput->data.size = dwRead;
						//LogBinary( GetText( pInput ), GetTextSize( pInput ) );
						if( taskParams->stdErr ) {
							if( task->OutputEvent2 )
								task->OutputEvent2( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
							else if( task->OutputEvent )
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
						} else {
							if( task->OutputEvent )
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
						}
						pInput->data.size = 4096;
					}
				}
			//allow a minor time for output to be gathered before sending
			// partial gathers...
			} while( !lastloop );
			LineRelease( pInput );
			if( phi->handle > 0 && !(task->spawn_flags & LPP_OPTION_INTERACTIVE ) ) {
				close( phi->handle );
				phi->handle = -1;
			}
			//if( phi->handle == task->hStdIn.handle )
			//	task->hStdIn.handle = -1;
			if( taskParams->stdErr ) {
				task->pOutputThread2 = NULL;
 // this is no longer a valid thing - shutdown output pipe
				task->OutputEvent2 = NULL;
			} else {
				task->pOutputThread = NULL;
 // this is no longer a valid thing - shutdown output pipe
				task->OutputEvent = NULL;
			}
			Release( task );
			//WakeAThread( phi->pdp->common.Owner );
			return 0xdead;
		}
	}
return 0;
}
#endif
//--------------------------------------------------------------------------
static int FixHandles( PTASK_INFO task )
{
#ifdef WIN32
	if( task->pi.hProcess )
		CloseHandle( task->pi.hProcess );
	task->pi.hProcess = 0;
	if( task->pi.hThread )
		CloseHandle( task->pi.hThread );
	task->pi.hThread = 0;
#endif
 // must return 0 so expression continues
	return 0;
}
//--------------------------------------------------------------------------
void ResumeProgram( PTASK_INFO task )
{
#ifdef WIN32
	//DWORD WINAPI ResumeThread(  _In_ HANDLE hThread);
	ResumeThread( task->pi.hThread );
#endif
}
uintptr_t GetProgramAddress( PTASK_INFO task ) {
#ifdef WIN32
	/*
	BOOL WINAPI GetThreadContext(
  _In_	 HANDLE    hThread,
  _Inout_ LPCONTEXT lpContext
  );
  */
	uintptr_t memstart;
	CONTEXT ctx;
#ifdef __64__
	WOW64_CONTEXT ctx64;
	ctx64.ContextFlags = CONTEXT_INTEGER;
	Wow64GetThreadContext( task->pi.hThread, &ctx64 );
	memstart = ctx64.Ebx;
	ctx.ContextFlags = CONTEXT_INTEGER;
	GetThreadContext( task->pi.hThread, &ctx );
	//memstart = ctx.Ebx;
	return memstart;
#else
	GetThreadContext( task->pi.hThread, &ctx );
	memstart = ctx.Ebx;
	return memstart;
#endif
#else
	lprintf( "non-windows system; cannot find program address... yet" );
	return 0;
#endif
}
#if 0
void LoadReadExe( PTASK_INFO task, uintptr_t base )
   //-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	//POINTER source_memory = block;
	{
// = (PIMAGE_DOS_HEADER)source_memory;
		IMAGE_DOS_HEADER source_dos_header;
// = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		PIMAGE_NT_HEADERS source_nt_header;
		SIZE_T nRead;
		ReadProcessMemory( task->pi.hProcess, (void*)base, (void*)&source_dos_header, sizeof( source_dos_header ), &nRead );
		LogBinary((uint8_t*) &source_dos_header, sizeof( source_dos_header ));
		if( source_dos_header.e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return ;
		}
/*
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
			dwSize += (BLOCK_SIZE*2)-1; // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize &= ~(BLOCK_SIZE-1); // mask off the low bits; floor result to block boundary
			return (POINTER)Seek( source_memory, dwSize );
			}
		*/
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
extern HANDLE GetImpersonationToken( void );
#endif
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															  , int flags
															  , TaskOutput OutputHandler
															  , TaskEnd EndNotice
															  , uintptr_t psv
																DBG_PASS
															  ){
   return LaunchPeerProgram_v2( program, path, args, flags, OutputHandler, OutputHandler, EndNotice, psv, NULL DBG_RELAY );
}
#ifdef _WIN32
static wchar_t* ConvertEnvironment( char* env ) {
	int avail_chars = 256;
	int used_chars = 0;
	wchar_t* buffer = NewArray( wchar_t, avail_chars );
	char* value = env;
	while( value[0] ) {
		int valLen = 0;
		wchar_t* tmp = CharWConvert( value );
		int len = 0;
		for( len = 0; tmp[len]; len++ )
			;
		len++;
		for( valLen = 0; value[valLen]; valLen++ )
			;
		valLen++;
		while( ( used_chars + len ) >= avail_chars ) {
			avail_chars *= 2;
			buffer = (wchar_t*)Reallocate( buffer, sizeof( wchar_t ) * avail_chars );
		}
		MemCpy( buffer + used_chars, tmp, sizeof( wchar_t ) * len );
		Deallocate( wchar_t*, tmp );
		value += valLen;
	}
	return buffer;
}
static void convertStartupInfo( LPSTARTUPINFOA sia, LPSTARTUPINFOW siw ) {
	siw->lpReserved = NULL;
	siw->lpDesktop = CharWConvert( sia->lpDesktop );
	siw->lpTitle = CharWConvert( sia->lpTitle );
	siw->dwX = sia->dwX;
	siw->dwY = sia->dwY;
	siw->dwXSize = sia->dwXSize;
	siw->dwYSize = sia->dwYSize;
	siw->dwXCountChars = sia->dwXCountChars;
	siw->dwYCountChars = sia->dwYCountChars;
	siw->dwFillAttribute = sia->dwFillAttribute;
	siw->dwFlags = sia->dwFlags;
	siw->wShowWindow = sia->wShowWindow;
	siw->cbReserved2 = sia->cbReserved2;
	siw->lpReserved2 = sia->lpReserved2;
	siw->hStdInput = sia->hStdInput;
	siw->hStdOutput = sia->hStdOutput;
	siw->hStdError = sia->hStdError;
}
static BOOL _CreateProcess(
	LPCSTR lpApplicationName,
	LPSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCSTR lpCurrentDirectory,
	LPSTARTUPINFOA lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
) {
	wchar_t* wAppName = lpApplicationName?CharWConvert( lpApplicationName ):NULL;
	wchar_t* wCmdLine = lpCommandLine ? CharWConvert( lpCommandLine ) : NULL;
	wchar_t* wWorkDir = lpCurrentDirectory ? CharWConvert( lpCurrentDirectory ) : NULL;
	wchar_t* envBlock = lpEnvironment?ConvertEnvironment((char*)lpEnvironment):NULL;
	DWORD dwLastError;
	STARTUPINFOW si;
	si.cb = sizeof( si );
	convertStartupInfo( lpStartupInfo, &si );
	BOOL status = CreateProcessW( wAppName, wCmdLine
		, lpProcessAttributes, lpThreadAttributes
		, bInheritHandles, dwCreationFlags
		, lpEnvironment, wWorkDir, &si, lpProcessInformation );
	dwLastError = GetLastError();
	if( si.lpDesktop ) Deallocate( LPWSTR, si.lpDesktop );
	if( si.lpTitle ) Deallocate( LPWSTR, si.lpTitle );
	if( wAppName ) Deallocate( wchar_t*, wAppName );
	if( wCmdLine ) Deallocate( wchar_t*, wCmdLine );
	if( wWorkDir ) Deallocate( wchar_t*, wWorkDir );
	if( envBlock ) Deallocate( wchar_t*, envBlock );
	SetLastError( dwLastError );
	return status;
}
#endif
SYSTEM_PROC( PTASK_INFO, MonitorTaskEx )( int pid, int flags, TaskEnd EndNotice, uintptr_t psv DBG_PASS ) {
	PTASK_INFO task = NULL;
	task            = (PTASK_INFO)AllocateEx( sizeof( TASK_INFO ) DBG_RELAY );
	MemSet( task, 0, sizeof( TASK_INFO ) );
	task->spawn_flags          = 0;
#if defined(WIN32)
	task->launch_flags         = 0;
#endif
	task->flags.useCtrlBreak   = ( flags & LPP_OPTION_USE_CONTROL_BREAK ) ? 1 : 0;
	task->flags.useEventSignal = ( flags & LPP_OPTION_USE_SIGNAL ) ? 1 : 0;
	task->psvEnd           = psv;
	task->flags.runas_root = ( flags & LPP_OPTION_ELEVATE ) != 0;
	task->EndNotice        = EndNotice;
#ifdef WIN32
	task->pi.hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, pid );
	//lprintf( "Newly monitored process: %08x", task->pi.hProcess );
	if( task->pi.hProcess )
		ThreadTo( WaitForTaskEnd, (uintptr_t)task );
	else if( EndNotice ) {
		EndNotice( psv, NULL );
		Deallocate( PTASK_INFO, task );
		task = NULL;
	}
#elif defined( __LINUX__ )
	task->pid = pid;
	ThreadTo( WaitForTaskEnd, (uintptr_t)task );
#endif
	return task;
}
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// No way at all to know if the program works or fails.
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgram_v2 )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															  , int flags
															  , TaskOutput OutputHandler
															  , TaskOutput OutputHandler2
															  , TaskEnd EndNotice
															  , uintptr_t psv
															  , PLIST list
																DBG_PASS
															  )
{
	PTASK_INFO task = NULL;
	if( !sack_system_allow_spawn() ) return NULL;
// = ExpandPath( program );
	TEXTSTR expanded_path;
	TEXTSTR expanded_working_path = path ? ExpandPath( path ) : NULL;
	PLIST oldStrings = NULL;
	if( path ) {
		path = ExpandPath( path );
		if( IsAbsolutePath( program ) ) {
			expanded_path = ExpandPath( program );
		}
		else {
			//PVARTEXT pvtPath;
			//pvtPath = VarTextCreate();
			//if( path[0] == '.' && path[1] == 0 )
			//	vtprintf( pvtPath, "%s", program );
			//else
			//	vtprintf( pvtPath, "%s" "/" "%s", path, program );
// GetText( VarTextPeek( pvtPath ) ) );
			expanded_path = ExpandPath( program );
			//VarTextDestroy( &pvtPath );
		}
	} else {
		path = ExpandPath( "." );
		expanded_path = ExpandPath( program );
	}
	if( program && program[0] )
	{
#ifdef WIN32
		int launch_flags = ( ( flags & LPP_OPTION_NEW_CONSOLE ) ? CREATE_NEW_CONSOLE : 0 )
		                 | ( ( flags & LPP_OPTION_DETACH ) ? DETACHED_PROCESS : 0 )
		                 | ( ( flags & LPP_OPTION_NEW_GROUP ) ? CREATE_NEW_PROCESS_GROUP : 0 )
		                 | ( ( flags & LPP_OPTION_SUSPEND ) ? CREATE_SUSPENDED : 0 )
		                 | ( ( flags & LPP_OPTION_NO_WINDOW ) ? CREATE_NO_WINDOW : 0 )
			;
		PVARTEXT pvt = VarTextCreateEx( DBG_VOIDRELAY );
		PTEXT cmdline;
		TEXTSTR new_path;
		PTEXT final_cmdline;
		LOGICAL needs_quotes;
		//int first = TRUE;
		int success = 0;
		int shellExec = 0;
		if( path )
			Deallocate( CTEXTSTR, path );
		{
			INDEX idx;
			struct environmentValue* val;
			LIST_FORALL( list, idx, struct environmentValue*, val ) {
				const char *oldVal = OSALOT_GetEnvironmentVariable( val->field );
				if( oldVal ) oldVal = StrDup( oldVal );
				SetLink( &oldStrings, idx, oldVal );
				OSALOT_SetEnvironmentVariable( val->field, val->value );
			}
		}
		//TEXTCHAR saved_path[256];
		task = (PTASK_INFO)AllocateEx( sizeof( TASK_INFO ) DBG_RELAY );
		MemSet( task, 0, sizeof( TASK_INFO ) );
		task->spawn_flags = flags;
		task->launch_flags = launch_flags;
		task->flags.useCtrlBreak = ( flags & LPP_OPTION_USE_CONTROL_BREAK ) ? 1 : 0;
		task->flags.useEventSignal = ( flags & LPP_OPTION_USE_SIGNAL ) ? 1 : 0;
		//task->flags.noKillOnExit = ( flags & LPP_OPTION_NO_KILL_ON_EXIT ) ? 1 : 0;
		{
			CTEXTSTR nameStart = StrRChr( (CTEXTSTR)program, '/' );
			CTEXTSTR nameEnd = StrRChr( (CTEXTSTR)program, '.' );
			if( !nameStart ) {
				nameStart = StrRChr( (CTEXTSTR)program, '\\' );
				if( !nameStart ) nameStart = program;
				else nameStart++;
			} else nameStart++;
			if( !nameEnd ) nameEnd = nameStart + StrLen( nameStart );
			snprintf( task->name, 256, "%.*s", (int)(nameEnd-nameStart), nameStart );
			//lprintf( "Set Spawned Task Name to : %s", task->name );
		}
		task->psvEnd = psv;
		task->flags.runas_root = (flags & LPP_OPTION_ELEVATE) != 0;
		task->EndNotice = EndNotice;
		if( l.ExternalFindProgram ) {
			new_path = l.ExternalFindProgram( expanded_path );
			if( new_path ) {
				Release( expanded_path );
				expanded_path = new_path;
			}
		}
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( "%s[%s]", path, expanded_working_path );
#endif
		if( StrCmp( path, "." ) == 0 )
		{
			path = NULL;
			Release( expanded_working_path );
			expanded_working_path = NULL;
		}
		if( expanded_path && StrChr( expanded_path, ' ' ) )
			needs_quotes = TRUE;
		else
			needs_quotes = FALSE;
		if( needs_quotes )
			vtprintf( pvt,  "\"" );
		vtprintf( pvt, "%s", expanded_path );
		if( needs_quotes )
			vtprintf( pvt, "\"" );
		{
			PTEXT tmpText = VarTextPeek( pvt );
			int i;
			int len = (int)GetTextSize( tmpText );
			char* tmp = GetText( tmpText );
			for( i = 0; i < len; i++, tmp++ ) {
				if( tmp[0] == '/' ) tmp[0] = '\\';
			}
		}
		if( flags & LPP_OPTION_FIRST_ARG_IS_ARG )
			;
		else
		{
// arg[0] is passed with linux programs, and implied with windows.
			if( args && args[0] )
				args++;
		}
		while( args && args[0] )
		{
			if( args[0][0] == 0 )
				vtprintf( pvt, " \"\"" );
			else if( StrChr( args[0], ' ' ) )
				vtprintf( pvt, " \"%s\"", args[0] );
			else
				vtprintf( pvt, " %s", args[0] );
			//first = FALSE;
			args++;
		}
		cmdline = VarTextGet( pvt );
		vtprintf( pvt, "cmd.exe /c %s", GetText( cmdline ) );
		final_cmdline = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		MemSet( &task->si, 0, sizeof( STARTUPINFO ) );
		task->si.cb = sizeof( STARTUPINFO );
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( "quotes?%s path [%s] program [%s]  [cmd.exe (%s)]", needs_quotes?"yes":"no", expanded_working_path, expanded_path, GetText( final_cmdline ) );
#endif
		/*
		if( path )
		{
			GetCurrentPath( saved_path, sizeof( saved_path ) );
			SetCurrentPath( path );
		}
		*/
		task->OutputEvent = OutputHandler;
		task->OutputEvent2 = OutputHandler2;
		if( OutputHandler || OutputHandler2 )
		{
			SECURITY_ATTRIBUTES sa;
			//lprintf( "setting IO handles." );
			sa.bInheritHandle = TRUE;
			sa.lpSecurityDescriptor = NULL;
			sa.nLength = sizeof( sa );
			if( OutputHandler )
				CreatePipe( &task->hReadOut, &task->hWriteOut, &sa, 0 );
			if( OutputHandler2 )
				CreatePipe( &task->hReadErr, &task->hWriteErr, &sa, 0 );
			CreatePipe( &task->hReadIn, &task->hWriteIn, &sa, 0 );
			task->si.hStdInput = task->hReadIn;
			if( OutputHandler2 )
				task->si.hStdError = task->hWriteErr;
			if( OutputHandler )
				task->si.hStdOutput = task->hWriteOut;
			if( OutputHandler && !OutputHandler2 ) {
 // if this is not set, then stderr gets inherited.
				task->si.hStdError = task->hWriteOut;
			}
			task->si.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		else
		{
			//lprintf( "Not setting IO handles." );
			task->si.dwFlags |= STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		{
			if( flags & LPP_OPTION_IMPERSONATE_EXPLORER )
			{
				HANDLE hExplorer = GetImpersonationToken();
 //program
				if( ( CreateProcessAsUser( hExplorer, NULL
												 , GetText( cmdline )
												 , NULL, NULL, TRUE
												 , launch_flags | CREATE_NEW_PROCESS_GROUP
												 , NULL
												 , expanded_working_path
												 , &task->si
												 , &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
												, GetText( cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
 // GetText( cmdline )
												, NULL
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, "cmd.exe"
												, GetText( final_cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() )
				  )
				{
					success = 1;
				}
				CloseHandle( hExplorer );
			}
			else
			{
				//lprintf( "Using launch flags; %s %08x", task->name, launch_flags );
				if( ( (!task->flags.runas_root) && ( _CreateProcess( program
										, GetText( cmdline )
										, NULL, NULL, TRUE
										, launch_flags
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError()) ) ||
 //program
					((!task->flags.runas_root) && (_CreateProcess( NULL
										 , GetText( cmdline )
										 , NULL, NULL, TRUE
										 , launch_flags
										 , NULL
										 , expanded_working_path
										 , &task->si
										 , &task->pi ) || FixHandles(task) || DumpError()) ) ||
					((!task->flags.runas_root) && (_CreateProcess( program
 // GetText( cmdline )
										, NULL
										, NULL, NULL, TRUE
										, launch_flags
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError()) ) ||
					( (shellExec=1),TryShellExecute( task, expanded_working_path, program, cmdline ) ) ||
//"cmd.exe"
					( (shellExec=0),_CreateProcess( NULL
										, GetText( final_cmdline )
										, NULL, NULL, TRUE
										, launch_flags
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
				   0
				  )
				{
					success = 1;
				}
			}
			if( success )
			{
				//CloseHandle( task->hReadIn );
				//CloseHandle( task->hWriteOut );
#ifdef _DEBUG
				//xlprintf(LOG_NOISE)( "Success running %s[%s] in %s (%p): %d", program, GetText( cmdline ), expanded_working_path, task->pi.hProcess, GetLastError() );
#endif
				if( !shellExec && ( OutputHandler || OutputHandler2 ) )
				{
					task->hStdIn.handle	  = task->hWriteIn;
					task->hStdIn.pLine	  = NULL;
					//task->hStdIn.pdp		 = pdp;
					task->hStdIn.hThread  = 0;
					task->hStdIn.bNextNew = TRUE;
					if( task->OutputEvent ) {
						task->hStdOut.handle   = task->hReadOut;
						task->hStdOut.pLine	   = NULL;
						//task->hStdOut.pdp		  = pdp;
						task->hStdOut.bNextNew = TRUE;
						task->args1.task       = task;
						task->args1.stdErr     = FALSE;
						task->hStdOut.hThread  = ThreadTo( HandleTaskOutput, (uintptr_t)&task->args1 );
					}
					if( task->OutputEvent2 )
					{
						task->hStdErr.handle   = task->hReadErr;
						task->hStdErr.pLine	   = NULL;
						//task->hStdOut.pdp		  = pdp;
						task->hStdErr.bNextNew = TRUE;
						task->args2.task       = task;
						task->args2.stdErr     = TRUE;
						task->hStdErr.hThread  = ThreadTo( HandleTaskOutput, (uintptr_t)&task->args2 );
					}
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
				else
				{
					if( shellExec ) {
						// shell exec doesn't get any of this specified... it doesn't use any of it.
						if( OutputHandler2 ) {
							CloseHandle( task->hWriteErr );
							CloseHandle( task->hReadErr );
							task->hReadErr = task->hWriteErr = INVALID_HANDLE_VALUE;
						}
						if( OutputHandler ) {
							CloseHandle( task->hWriteOut );
							CloseHandle( task->hReadOut );
							task->hReadOut = task->hWriteOut = INVALID_HANDLE_VALUE;
						}
						CloseHandle( task->hWriteIn );
						CloseHandle( task->hReadIn );
						task->hReadIn = task->hWriteIn = INVALID_HANDLE_VALUE;
					}
					//task->hThread =
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
				// close my side of the pipes...
				if( task->hWriteOut != INVALID_HANDLE_VALUE ) {
					CloseHandle( task->hWriteOut );
					task->hWriteOut = INVALID_HANDLE_VALUE;
				}
				if( task->hWriteErr != INVALID_HANDLE_VALUE ) {
					CloseHandle( task->hWriteErr );
					task->hWriteErr = INVALID_HANDLE_VALUE;
				}
				if( task->hReadIn != INVALID_HANDLE_VALUE ) {
					CloseHandle( task->hReadIn );
					task->hReadIn = INVALID_HANDLE_VALUE;
				}
			}
			else
			{
				xlprintf(LOG_NOISE)( "Failed to run %s[%s]: %d", program, GetText( cmdline ), GetLastError() );
				if( task->hWriteIn    != INVALID_HANDLE_VALUE ) CloseHandle( task->hWriteIn );
				if( task->hReadIn     != INVALID_HANDLE_VALUE ) CloseHandle( task->hReadIn );
				if( task->hWriteOut   != INVALID_HANDLE_VALUE ) CloseHandle( task->hWriteOut );
				if( task->hReadOut    != INVALID_HANDLE_VALUE ) CloseHandle( task->hReadOut );
				if( task->pi.hProcess != INVALID_HANDLE_VALUE ) CloseHandle( task->pi.hProcess );
				if( task->pi.hThread  != INVALID_HANDLE_VALUE ) CloseHandle( task->pi.hThread );
				Release( task );
				task = NULL;
			}
		}
		LineRelease( cmdline );
		LineRelease( final_cmdline );
		goto reset_env;
#endif
#ifdef __LINUX__
		{
			pid_t newpid;
			//TEXTCHAR saved_path[256];
			task = (PTASK_INFO)Allocate( sizeof( TASK_INFO ) );
			MemSet( task, 0, sizeof( TASK_INFO ) );
			//task->flags.log_input = TRUE;
			task->spawn_flags = flags;
			task->psvEnd = psv;
			task->EndNotice = EndNotice;
			task->OutputEvent = OutputHandler;
			task->OutputEvent2 = OutputHandler2;
			task->args1.task       = task;
			task->args1.stdErr     = FALSE;
			task->args2.task       = task;
			task->args2.stdErr     = TRUE;
			task->pty              = -1;
			if( OutputHandler )
			{
				if( !(flags & LPP_OPTION_INTERACTIVE ) ) {
 // pipe failed
					if( pipe(task->hStdIn.pair) < 0 ) {
						Release( task );
						task = NULL;
						goto reset_env;
					}
					task->hStdIn.handle = task->hStdIn.pair[1];
					if( pipe(task->hStdOut.pair) < 0 ) {
						close( task->hStdIn.pair[0] );
						close( task->hStdIn.pair[1] );
						Release( task );
						task = NULL;
						goto reset_env;
					}
					task->hStdOut.handle = task->hStdOut.pair[0];
					if( OutputHandler2 ) {
						if( pipe(task->hStdErr.pair) < 0 ) {
							close( task->hStdIn.pair[0] );
							close( task->hStdIn.pair[1] );
							close( task->hStdOut.pair[0] );
							close( task->hStdOut.pair[1] );
							Release( task );
							task = NULL;
							goto reset_env;
						}
						task->hStdErr.handle = task->hStdErr.pair[0];
					} else
						task->hStdErr.handle =task->hStdOut.pair[0];
				}
			}
			// always have to thread to taskend so waitpid can clean zombies.
			ThreadTo( WaitForTaskEnd, (uintptr_t)task );
			int waitPipe[2];
			pipe(waitPipe);
			if( ( !( flags & LPP_OPTION_INTERACTIVE ) )
			    ? !( newpid = fork() )
			    : !( newpid = forkpty( &task->pty, NULL, NULL, NULL ) ) )
			{
				{
					INDEX idx;
					struct environmentValue* val;
					LIST_FORALL( list, idx, struct environmentValue*, val ) {
						//lprintf( "Waited until in the fork to set environment variable %s=%s", val->field, val->value );
						if( !val->value )
							unsetenv( val->field );
						else
							setenv( val->field, val->value, TRUE );
					}
				}
				// after fork; check that args has a space for
				// the program name to get filled into.
				// this memory doesn't leak; it's squashed by exec.
				if( flags & LPP_OPTION_FIRST_ARG_IS_ARG ) {
					char ** newArgs;
					int n;
					if( args )
						for( n = 0; args[n]; n++ );
					else n = 0;
					newArgs = NewArray( char *, n + 2 );
					if( args ) {
						for( n = 0; args[n]; n++ ) {
							newArgs[n + 1] = (char*)args[n];
						}
						newArgs[n + 1] = (char*)args[n];
					} else {
						newArgs[1] = NULL;
					}
					newArgs[0] = (char*)program;
					args = (PCTEXTSTR)newArgs;
				}
				if( expanded_working_path ) {
					chdir( expanded_working_path );
					//lprintf( "Change directory(in child): %s", expanded_working_path );
					//Release( expanded_working_path );
				}
				// keep a copy of program name so main thread can continue - which may be fast enough
				// to release the program name before the child gets to it.
				char *_program = CStrDup( program );
				// in case exec fails, we need to
				// drop any registered exit procs...
				if( !(flags & LPP_OPTION_INTERACTIVE) ) {
					//close( task->hStdIn.pair[1] );
					//close( task->hStdOut.pair[0] );
					//close( task->hStdErr.pair[0] );
					if( OutputHandler ) {
						dup2( task->hStdIn.pair[0], 0 );
						dup2( task->hStdOut.pair[1], 1 );
					}
					if( OutputHandler || OutputHandler2 )
						dup2( task->hStdErr.pair[1], 2 );
				}
				// mark the child as started...
				write( waitPipe[1], "", 1 );
				close( waitPipe[0] );
				close( waitPipe[1] );
				DispelDeadstart();
				execve( _program, (char *const*)args, environ );
				//lprintf( "Direct execute failed... trying along path..." );
				if( _program[0] != '/' )
				{
					char *tmp = strdup( getenv( "PATH" ) );
					char *tok;
					for( tok = strtok( tmp, ":" ); tok; tok = strtok( NULL, ":" ) )
					{
						char fullname[256];
						snprintf( fullname, sizeof( fullname ), "%s/%s", tok, _program );
						if( l.flags.bLogExec )
							lprintf( "program:[%s]", fullname );
						((char**)args)[0] = fullname;
						execve( fullname, (char*const*)args, environ );
						if( l.flags.bLogExec )
							lprintf( "exec in PATH failed - and this is ALLL bad... %s %d", fullname, errno );
					}
					Release( tmp );
				}
				if( l.flags.bLogExec )
					lprintf( "exec failed - and this is ALLL bad... %s %d", _program, errno );
				if( !(flags & LPP_OPTION_INTERACTIVE ) ) {
					if( OutputHandler ) {
						close( task->hStdIn.pair[0] );
						close( task->hStdOut.pair[1] );
						if( OutputHandler2 )
							close( task->hStdErr.pair[1] );
					}
				}
				//close( task->hWriteErr );
				close( 0 );
				close( 1 );
				close( 2 );
				//DebugBreak();
				// well as long as this runs before
				// the other all will be well...
				task = NULL;
				// shit - what can I do now?!
 // just in case exec fails... need to fault this.
				exit(0);
			}
			else
			{
				if( flags & LPP_OPTION_INTERACTIVE ) {
					// otherwise these are set earlier, when the pipe()'s
					// are created, and before the fork().
					task->hStdIn.handle = task->pty;
					task->hStdOut.handle = task->pty;
					task->hStdErr.handle = task->pty;
				}else {
					if( OutputHandler ) {
						close( task->hStdIn.pair[0] );
						close( task->hStdOut.pair[1] );
					}
					if( OutputHandler2 )
						close( task->hStdErr.pair[1] );
				}
				Release( (POINTER)path );
			}
			char buf;
			int rc = read( waitPipe[0], &buf, 1 );
			close( waitPipe[0] );
			close( waitPipe[1] );
			if( OutputHandler )
				ThreadTo( HandleTaskOutput, (uintptr_t)&task->args1 );
 // only if it was opened as a separate handle...
			if( OutputHandler2 ) {
				ThreadTo( HandleTaskOutput, (uintptr_t)&task->args2 );
			}
			task->pid = newpid;
		}
#endif
	}
reset_env:
	if( expanded_working_path )
		Release( expanded_working_path );
	Release( expanded_path );
	if( oldStrings )
	{
		INDEX idx;
		struct environmentValue* val;
		LIST_FORALL( list, idx, struct environmentValue*, val ) {
			const char *oldVal = (const char*)GetLink( &oldStrings, idx );
			OSALOT_SetEnvironmentVariable( val->field, oldVal );
			if( oldVal ) Deallocate( const char *, oldVal );
		}
		DeleteList( &oldStrings );
	}
	return task;
}
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															 , TaskOutput OutputHandler
															 , TaskEnd EndNotice
															 , uintptr_t psv
                                                DBG_PASS
															  )
{
	return LaunchPeerProgramExx( program, path, args, LPP_OPTION_DO_NOT_HIDE, OutputHandler, EndNotice, psv DBG_RELAY );
}
//------------- System() ---------- simplest form of launch process (with otuput handler, and pprintf support )
struct task_end_notice
{
	PTHREAD thread;
	LOGICAL ended;
	uintptr_t psv_output;
	TaskOutput output_handler;
};
static void CPROC SystemTaskEnd( uintptr_t psvUser, PTASK_INFO task )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->ended = TRUE;
	WakeThread( end_data->thread );
}
static void CPROC SystemOutputHandler( uintptr_t psvUser, PTASK_INFO Task, CTEXTSTR buffer, size_t len )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->output_handler( end_data->psv_output, Task, buffer, len );
}
ATEXIT( SystemAutoShutdownTasks )
{
	// this just ends commands run by SystemEx()...
	INDEX idx;
	PTASK_INFO task;
	if( local_systemlib ) {
		( *local_systemlib ).flags.shutdown = TRUE;
		LIST_FORALL( (*local_systemlib).system_tasks, idx, PTASK_INFO, task )
				TerminateProgram( task );
	}
}
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
															  , TaskOutput OutputHandler
															  , uintptr_t psv
																DBG_PASS
											)
{
	TEXTCHAR *command_line_tmp = StrDup( command_line );
	struct task_end_notice end_notice;
	PTASK_INFO result;
	int argc;
	TEXTSTR *argv;
	end_notice.ended = FALSE;
	end_notice.thread = MakeThread();
	end_notice.psv_output = psv;
	end_notice.output_handler = OutputHandler;
	ParseIntoArgs( command_line_tmp, &argc, &argv );
	Release( command_line_tmp );
	result = LaunchPeerProgramExx( argv[0], NULL, (PCTEXTSTR)argv, 0, OutputHandler?SystemOutputHandler:NULL, SystemTaskEnd, (uintptr_t)&end_notice DBG_RELAY );
	if( result )
	{
		AddLink( &(*local_systemlib).system_tasks, result );
		// we'll get woken when it ends, might as well be infinite.
		while( !end_notice.ended )
		{
#ifndef __NO_IDLE__
			if( !Idle( ) )
				WakeableSleep( 10000 );
			else
				WakeableSleep( 10 );
#else
			WakeableSleep( 25 );
#endif
		}
		DeleteLink( &(*local_systemlib).system_tasks, result );
	}
	{
		POINTER tmp = (POINTER)argv;
		while( argv[0] )
		{
			Release( (POINTER)argv[0] );
			argv++;
		}
		Release( tmp );
	}
	return result;
}
//----------------------- Utility to send to launched task's stdin ----------------------------
int vpprintf( PTASK_INFO task, CTEXTSTR format, va_list args )
{
	size_t written = 0;
	PVARTEXT pvt = VarTextCreate();
	PTEXT output;
	vvtprintf( pvt, format, args );
	output = VarTextGet( pvt );
	if( !task->flags.process_signaled_end )
	{
#ifdef _WIN32
		DWORD dwWritten;
#endif
		//lprintf( "Allowing write to process pipe..." );
		{
			PTEXT seg = output;
			while( seg )
			{
#ifdef _WIN32
				//LogBinary( GetText( seg )
				//			, GetTextSize( seg ) );
					WriteFile( task->hStdIn.handle
					          , GetText( seg )
					          , (DWORD)GetTextSize( seg )
					          , &dwWritten
					          , NULL );
					written += dwWritten;
#else
				{
					struct pollfd pfd = { task->hStdIn.handle, POLLHUP|POLLERR, 0 };
					if( poll( &pfd, 1, 0 ) &&
						 pfd.revents & POLLERR )
					{
						//Log( "Pipe has no readers..." );
						break;
					}
					//LogBinary( (uint8_t*)GetText( seg ), GetTextSize( seg ) );
					written = write( task->hStdIn.handle
					               , GetText( seg )
					               , GetTextSize( seg ) );
				}
#endif
				seg = NEXTLINE(seg);
			}
		}
		LineRelease( output );
	}
	else
	{
		//lprintf( "Task has ended, write  aborted." );
	}
	VarTextDestroy( &pvt );
	return written;
}
//----------------------- Utility to send to launched task's stdin ----------------------------
size_t task_send( PTASK_INFO task, const uint8_t*buffer, size_t buflen )
{
	size_t written = 0;
	if( !task->flags.process_signaled_end )
	{
		//lprintf( "Allowing write to process pipe..." );
		//LogBinary( (uint8_t*)buffer, buflen );
#ifdef _WIN32
		DWORD dwWritten;
		//LogBinary( GetText( seg )
		//			, GetTextSize( seg ) );
		WriteFile( task->hStdIn.handle
				, buffer
				, (DWORD)buflen
				, &dwWritten
				, NULL );
		written = dwWritten;
#else
		struct pollfd pfd = { task->hStdIn.handle, POLLHUP|POLLERR, 0 };
		if( poll( &pfd, 1, 0 ) &&
				pfd.revents & POLLERR )
		{
			//Log( "Pipe has no readers..." );
		} else {
			written = write( task->hStdIn.handle
					, buffer
					, buflen );
			//flush( task->hStdIn.handle );
		}
#endif
	}
	else
	{
		//lprintf( "Task has ended, write  aborted." );
	}
	return written;
}
int pprintf( PTASK_INFO task, CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vpprintf( task, format, args );
}
#ifdef __LINUX__
int GetTaskPTY( PTASK_INFO task ){
	return task->pty;
}
#endif
SACK_SYSTEM_NAMESPACE_END
//-------------------------------------------------------------------------
#ifndef SYSTEM_SOURCE
#define SYSTEM_SOURCE
#endif
SACK_SYSTEM_NAMESPACE
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR const* lpCmdLine, int *pArgc, TEXTCHAR ***pArgv )
{
	TEXTCHAR const* args = lpCmdLine;
	TEXTCHAR const* p;
	TEXTCHAR **pp;
	//TEXTCHAR argc; // result variable, count is a temp counter...
 // result variable, pp is a temp pointer
	TEXTCHAR **argv;
	TEXTCHAR quote = 0;
	int escape = 0;
	int count = 0;
	int lastchar;
 // auto continue spaces...
	lastchar = ' ';
	//lprintf( "Got args: %s", args );
	p = args;
	while( p && p[0] )
	{
		//lprintf( "check character %c %c", lastchar, p[0] );
		if( escape ) {
			if( p[0] == '\"' || p[0] == '\'' ) {
				escape = 0;
				count++;
			}
			else {
				escape = 0;
				count += 2;
			}
		}
		else if( p[0] == '\\' ) {
			escape = 1;
			count++;
		}
		else if( quote )
		{
			if( p[0] == quote )
			{
				count++;
				quote = 0;
				lastchar = ' ';
			}
		}
		else
		{
			if( p[0] == '\"' || p[0] == '\'' )
				quote = p[0];
			else
			{
 // and there's a space
				if( lastchar != ' ' && p[0] == ' ' )
				{
					count++;
				}
				else if( lastchar == ' ' && p[0] != ' ' )
				{
				}
			}
			lastchar = p[0] ;
		}
		p++;
	}
	if( quote )
 // complete this argument
		count++;
	else if( p != args )
		count++;
	if( count )
	{
		TEXTCHAR const* start;
 // auto continue spaces...
		lastchar = ' ';
		//lprintf( "Array is %d (+2?)", count );
		pp = argv = NewArray( TEXTCHAR*, count + 2 );
		//argc = count - 2;
		p = args;
		quote = 0;
		count = 0;
		//pp[count++] = StrDup( pTask->pTask ); // setup arg to equal program (needed for linux stuff)
		start = NULL;
		while( p[0] )
		{
			//lprintf( "check character %c %c", lastchar, p[0] );
			if( escape ) {
				escape = 0;
			}
			else if( p[0] == '\\' ) {
				escape = 1;
			}
			else if( quote )
			{
				if( !escape ) {
					if( !start )
						start = p;
					if( p[0] == quote )
					{
						pp[count++] = DupCStrLen( start, p - start );
						quote = 0;
						start = NULL;
						lastchar = ' ';
					}
				}
			}
			else
			{
				if( !escape ) {
					if( p[0] == '\"' || p[0] == '\'' )
						quote = p[0];
					else
					{
 // and there's a space
						if( lastchar != ' ' && p[0] == ' ' )
						{
							pp[count++] = DupCStrLen( start, p - start );
							start = NULL;
						}
						else if( lastchar == ' ' && p[0] != ' ' )
						{
							if( !start )
								start = p;
						}
					}
					lastchar = p[0] ;
				}
			}
			p++;
		}
		//lprintf( "Setting arg %d to %s", count, start );
		if( start )
			pp[count++] = StrDup( start );
		pp[count] = NULL;
		if( pArgc )
			(*pArgc) = count;
		if( pArgv )
			(*pArgv) = argv;
	}
	else
	{
		if( pArgc )
			(*pArgc) = 0;
		if( pArgv )
		{
			(*pArgv) = NewArray( TEXTCHAR*, 1 );
			(*pArgv)[0] = NULL;
		}
	}
}
SACK_SYSTEM_NAMESPACE_END
#ifndef __LINUX__
#include <objbase.h>
#ifdef __cplusplus
namespace sack { namespace system{
#endif
void InitCo( void )
{
	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
}
#ifdef __cplusplus
}
}
#endif
#endif
#define NO_UNICODE_C
#define PROCREG_SOURCE
#ifdef __ANDROID__
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
#  endif
#endif
//#define DEBUG_GLOBAL_REGISTRATION
#define REGISTRY_STRUCTURE_DEFINED
//#define PROCREG_SOURCE
// include this first so we can have the namespace...
#undef REGISTRY_STRUCTURE_DEFINED
#ifndef REGISTRY_STRUCTURE_DEFINED
#define REGISTRY_STRUCTURE_DEFINED
#ifdef __LINUX__
// pid_t for service process registrations...
#endif
PROCREG_NAMESPACE
//typedef struct tree_def_tag *PCLASSROOT;
//typedef void (CPROC *PROCEDURE)(void);
enum proc_types {
	ARG_FLOAT
					, ARG_DOUBLE
					, ARG_CHAR
					, ARG_SHORT
					, ARG_LONG
					, ARG_LONGLONG
					, ARG_UCHAR
					, ARG_USHORT
					, ARG_ULONG
					, ARG_ULONGLONG
					, ARG_PTRFLOAT
					, ARG_PTRDOUBLE
					, ARG_PTRCHAR
					, ARG_PTRSHORT
					, ARG_PTRLONG
					, ARG_PTRLONGLONG
					, ARG_PTRUCHAR
					, ARG_PTRUSHORT
					, ARG_PTRULONG
					, ARG_PTRULONGLONG
               , ARG_PTRSTRING
};
#if 0
typedef struct proc_param_tag {
	enum proc_types type;
   int count;
//1>c:\work\sack\src\procreglib\registry.h(42) : warning C4200: nonstandard extension used : zero-sized array in struct/union
//1>        Cannot generate copy-ctor or copy-assignment operator when UDT contains a zero-sized array`
   char name[];
} PROC_PARAM;
#endif
typedef struct proc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	PROCEDURE proc;
} PROCDEF, *PPROCDEF;
#ifdef __cplusplus_cli
typedef struct stdproc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	STDPROCEDURE proc;
} STDPROCDEF, *PSTDPROCDEF;
#endif
#define MAGIC_TREE_NUMBER 0x20040525
#define IS_TREE_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_TREE_NUMBER )
#define MAGIC_LIST_NUMBER 0x20040911
#define IS_LIST_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_LIST_NUMBER )
typedef struct tree_def_tag
{
////////
// this and "/blah/blah/blah" look the same
// to an application.  Therefore a name is as good
// as text... internally a pointer to this structure
// when CTEXTSTR and PTREEDEF are received through a
// CTEXTSTR parameter, the distinction can be made by
// examinging the first 4 characters... however!
// the string passed must be at least 4 bytes of
   // real memory.
  // magic number 0x20040525
	uint32_t Magic;
	union {
 // any option can have a tree of suboptions?
		PTREEROOT Tree;
			// a list of things may serve as lightweight alternative
		PLIST List;
	};
   POINTER cursor;
   struct proc_name_tag *self;
} TREEDEF, *PTREEDEF;
typedef struct tree_def_tag const * PCTREEDEF;
#define MAXTREEDEFSPERSET 256
DeclareSet( TREEDEF );
typedef struct data_class_def_tag
{
   uintptr_t size;
   OpenCloseNotification Open;
   OpenCloseNotification Close;
   INDEX unique;
   TREEDEF instances;
} DATADEF, *PDATADEF;
typedef struct name_def_tag
{
	// a member can have a string and a number
   // associated with it.
   CTEXTSTR sValue;
   uintptr_t iValue;
} NAMEDEF, *PNAMEDEF;
#ifdef __LINUX__
typedef  struct service_tag {
	pid_t pid;
	uint32_t Msg;
	// paramters...
} SERVICE, *PSERVICE;
#endif
typedef struct proc_name_tag
{
	struct {
 // really only important when saving the tree
		BIT_FIELD bAlias: 1;
		// each and every node may reference a tree
		// if it does, then the tree will be non-NULL
 // else it's a proc leef...
		BIT_FIELD bTree : 1;
 // name value points at a name
		BIT_FIELD bValue : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bIntVal : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bStringVal : 1;
 // name points at a function
		BIT_FIELD bProc : 1;
  // this might be fun to register names across msgsvr's
		BIT_FIELD bService : 1;
 // data member defines data..
		BIT_FIELD bData : 1;
 // is a (__stdcall *) instead of a (CPROC *)
		BIT_FIELD bStdProc : 1;
	} flags;
	CTEXTSTR name;
	TREEDEF   tree;
	struct {
		NAMEDEF    name;
		PROCDEF    proc;
#ifdef __cplusplus_cli
		STDPROCDEF stdproc;
#endif
		DATADEF    data;
#ifdef __LINUX__
		SERVICE    service;
#endif
	}data;
	PTREEDEF parent;
} NAME, *PNAME;
#define MAXNAMESPERSET 256
DeclareSet( NAME );
#define NAMESPACE_SIZE (4096 - sizeof( uint32_t ) - 2 * sizeof( POINTER ))
typedef struct namespace_tag
{
	uint32_t nextname;
	TEXTCHAR buffer[NAMESPACE_SIZE];
	DeclareLink( struct namespace_tag );
} NAMESPACE, *PNAMESPACE;
PROCREG_NAMESPACE_END
#endif
PROCREG_NAMESPACE
// using lower level syslog bypasses some allocation requirements...
//#define lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf DBG_SRC ); }
	static struct procreg_local_private_tag {
		// don't use critical sections while registering.
		struct {
			BIT_FIELD enable_critical_sections : 1;
		} flags;
	} procreg_local_private_data;
struct tmp_namebuf
{
	TEXTCHAR *buffer;
	size_t length;
};
struct procreg_local_tag {
	struct {
		BIT_FIELD bInterfacesLoaded : 1;
		BIT_FIELD bIndexNameTable : 1;
		// if neither of the next two are set, then the statement can be processed; both are cleared at endif
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindEndif : 5;
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindElse : 1;
		//BIT_FIELD bIfSuccess : 1; // set if 'if' condition is true
		BIT_FIELD bTraceInterfaceLoading : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
 // having read the configuration file
		BIT_FIELD bReadConfiguration : 1;
	} flags;
	PTREEDEF Names;
	PTREEROOT NameIndex;
	PTREEROOT NameIndex_literal;
	PTREEDEFSET TreeNodes;
	PNAMESET NameSet;
	PNAMESPACE NameSpace;
	PLIST TransationSpaces;
 // open group ID
	int translations;
	TEXTCHAR *config_filename;
	FILE *file;
	CRITICALSECTION csName;
	uint32_t simple_lock;
	PLINKQUEUE tmp_names;
	int reference_count;
	PLIST global_spaces;
	//gcroot<System::IO::FileStream^> fs;
};
static CTEXTSTR config_filename;
#ifdef l
#   undef l
#endif
#ifdef __cplusplus
#  define procreg_local_data  procreg_local_data_pp
#endif
#define l (*procreg_local_data)
#ifdef __STATIC_GLOBALS__
static struct procreg_local_tag procreg_local_data__;
#endif
static struct procreg_local_tag *procreg_local_data;
static CTEXTSTR SaveName( CTEXTSTR name );
PTREEDEF GetClassTreeEx( PCTREEDEF root
										, PCTREEDEF name_class
										, PTREEDEF alias, LOGICAL bCreate );
#define GetClassTree( root, name_class ) GetClassTreeEx( root, name_class, NULL, TRUE )
//---------------------------------------------------------------------------
static int CPROC SavedNameCmpEx(CTEXTSTR dst, CTEXTSTR src, size_t srclen, LOGICAL case_sensitive )
{
	// NUL does not nessecarily terminate strings
	// instead slave off the length...
	 TEXTCHAR f,last;
 // one for length, one for nul
	size_t l1 = srclen;
 // one for length, one for nul
	size_t l2 = dst[-1] - 2;
	// case insensitive loop..
	//lprintf( "Compare %s(%d) vs %s[%p](%d)", src, l1, dst, dst, l2 );
	// interesting... first sort by length
	// and then by content?
	//if( l1 != l2 )
	 //  return l2-l1;
	do {
		if( (*src) == '\\' || (*src)=='/' )
		{
 // no more length .. should have gotten a matched length on dst...
			l1 = 0;
			break;
		}
		if( !case_sensitive ) {
			if( (( f = (TEXTCHAR)(*(dst++))) >= 'A') && (f <= 'Z') )
				f -= ('A' - 'a');
			if( (( last = (TEXTCHAR)(*(src++))) >= 'A') && (last <= 'Z') )
				last -= ('A' - 'a');
		} else {
			f = (TEXTCHAR)( *( dst++ ) );
			last = (TEXTCHAR)( *( src++ ) );
		}
		--l2;
		--l1;
	} while ( l2 && l1 && (f == last) );
	//lprintf( "Results to compare...%d,%d  %c,%c", l1, l2, f, last );
	// if up to the end of some portion of the strings matched...
	if( !f && !last )
	{
		return 0;
	}
	if( !l2 && !l1 )
	{
		return f-last;
	}
	if( f == last )
	{
		if( l2 && !l1 )
			return 1;
		if( l1 && !l2 )
			return -1;
	}
	return(f - last);
}
//---------------------------------------------------------------------------
static int CPROC SavedNameCmp(CTEXTSTR dst, CTEXTSTR src)
{
	//lprintf( "Compare names... (tree) %s,%s", dst, src );
	if( !src && !dst )
		return 0;
	if( !src ) {
		DebugBreak();
		return 1;
	}
	if( !dst && src )
		return -1;
	return SavedNameCmpEx( dst, src, src[-1]-2, FALSE );
}
//---------------------------------------------------------------------------
static int CPROC SavedNameCmpCS(CTEXTSTR dst, CTEXTSTR src)
{
	//lprintf( "Compare names... (tree) %s,%s", dst, src );
	if( !src && !dst )
		return 0;
	if( !src ) {
		DebugBreak();
		return 1;
	}
	if( !dst && src )
		return -1;
	return SavedNameCmpEx( dst, src, src[-1]-2, TRUE );
}
//---------------------------------------------------------------------------
static TEXTSTR StripName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	int escape = 0;
	if( !name )
	{
		buf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '\\' )
		{
			escape = 1;
		}
		else
		{
			// drop spaces...
			if( escape || ( name[0] > ' ' && name[0] < 127 ) )
			{
				*(buf++) = name[0];
			}
			escape = 0;
		}
		name++;
	}
	buf[0] = 0;
	return savebuf;
}
//---------------------------------------------------------------------------
static TEXTSTR GetFullName( CTEXTSTR name )
{
	int len;
	int out;
	int totlen = name[-1];
	TEXTSTR result;
	//for( len = 0; name[len] != 0 || name[len+1] != 0; len++ );
	result = NewArray( TEXTCHAR, totlen + 1);
	out = 0;
	for( len = 0; len < totlen; len++ )
		if( name[len] )
			result[out++] = name[len];
	result[out] = 0;
	return result;
}
//---------------------------------------------------------------------------
static CTEXTSTR DressName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	savebuf[0] = 2;
	buf++;
	if( !name )
	{
		savebuf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '/' || name[0] == '\\' )
			break;
		if( name[0] < ' ' || name[0] >= 127 )
		{
			savebuf[0]++;
			(*buf++) = '\\';
			savebuf[0]++;
			(*buf++) = name[0];
		}
		else
		{
			savebuf[0]++;
			(*buf++) = name[0];
		}
		name++;
	}
	buf[0] = 0;
	return savebuf + 1;
}
//---------------------------------------------------------------------------
static CTEXTSTR DoSaveNameEx( CTEXTSTR stripped, size_t len, LOGICAL case_sensitive DBG_PASS )
#define DoSaveName(a,b,c) DoSaveNameEx(a,b,c DBG_SRC )
{
	PNAMESPACE space = l.NameSpace;
	TEXTCHAR *p = NULL;
	// cannot save 0 length strings.
	if( !stripped || !stripped[0] || !len )
	{
		//lprintf( "zero length string passed" );
		return NULL;
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		EnterCriticalSec( &l.csName );
#else
		while( LockedExchange( &l.simple_lock, 1 ) )
			Relinquish();
#endif
	}
	if( l.flags.bIndexNameTable )
	{
		POINTER p;
		p = (POINTER)FindInBinaryTree( case_sensitive?l.NameIndex_literal:l.NameIndex, (uintptr_t)stripped );
		if( p )
		{
			// otherwise it will be single threaded?
			if( procreg_local_private_data.flags.enable_critical_sections )
			{
#if USE_CUSTOM_ALLOCER
				LeaveCriticalSec( &l.csName );
#else
				l.simple_lock = 0;
#endif
			}
			return ((CTEXTSTR)p);
		}
	}
	else
	{
		for( space = l.NameSpace; space; space = space->next )
		{
			p = space->buffer;
			while( p[0] && len )
			{
				//lprintf( "Compare %s(%d) vs %s(%d)", p+1, p[0], stripped,len );
				if( SavedNameCmpEx( p+1, stripped, len, case_sensitive ) == 0 )
				{
					// otherwise it will be single threaded?
					if( procreg_local_private_data.flags.enable_critical_sections )
					{
						l.simple_lock = 0;
						//LeaveCriticalSec( &l.csName );
					}
					return (CTEXTSTR)p+1;
				}
				p +=
#if defined( __ARM__ ) || defined( UNDER_CE ) || defined( __EMSCRIPTEN__ )
					(
#endif
					 p[0]
#if defined( __ARM__ ) || defined( UNDER_CE ) || defined( __EMSCRIPTEN__ )
					 +3 ) & 0xFC;
#endif
				;
			}
		}
	}
	for( space = l.NameSpace; space; space = space->next )
	{
		//lprintf( "Finding next name space free %p %p %p", l.NameSpace, space, space->next );
		if( ( space->nextname + len ) < ( NAMESPACE_SIZE - 3 ) )
		{
			p = NULL;
			break;
		}
	}
	if( !space || !p )
	{
		size_t alloclen;
		if( !space )
		{
			space = (PNAMESPACE)Allocate( sizeof( NAMESPACE ) );
			space->nextname = 0;
			//lprintf( "Adding new namespace %p", space );
			LinkThing( l.NameSpace, space );
		}
		MemCpy( p = space->buffer + space->nextname + 1, stripped,(uint32_t)(sizeof( TEXTCHAR)*(len + 1)) );
 // make sure we get a null terminator...
		p[len] = 0;
		// +2 1 for byte of len, 1 for nul at end.
		alloclen = (len + 2);
		space->buffer[space->nextname] = (TEXTCHAR)(alloclen);
		space->nextname += (uint32_t)alloclen;
		space->buffer[space->nextname] = 0;
#if defined( __ARM__ ) || defined( UNDER_CE ) || defined( __EMSCRIPTEN__ )
		space->nextname = ( space->nextname + 3 ) & 0xFFFFC;
		// +3&0xFC rounds to next full dword segment
		// arm requires this name be aligned on a dword boundry
		// because later code references this as a DWORD value.
#endif
		if( l.flags.bIndexNameTable )
		{
			AddBinaryNode( l.NameIndex, p, (uintptr_t)p );
			AddBinaryNode( l.NameIndex_literal, p, (uintptr_t)p );
		}
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		LeaveCriticalSec( &l.csName );
#else
		l.simple_lock = 0;
#endif
	}
	return (CTEXTSTR)p;
}
//---------------------------------------------------------------------------
static CTEXTSTR SaveName( CTEXTSTR name )
{
	if( name )
	{
		size_t len = StrLen( name );
		struct tmp_namebuf *tmp_namebuf = (struct tmp_namebuf*)DequeLink( &l.tmp_names );
		TEXTSTR stripped;
		size_t n;
		if( !tmp_namebuf )
		{
			tmp_namebuf = New( struct tmp_namebuf );
			tmp_namebuf->length = len + 2;
			tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
		}
		else
		{
			if( tmp_namebuf->length < ( len + 2 ) )
			{
				Release( tmp_namebuf->buffer );
				tmp_namebuf->length = len + 2;
				tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
			}
		}
		stripped = tmp_namebuf->buffer;
		stripped[0] = (TEXTCHAR)(len + 2);
		for( n = 0; n < len; n++ )
			if( name[n] == '\\' || name[n] == '/' )
			{
				len = n;
				break;
			}
 // allow +1 length for null after string; otherwise strncpy dropps the nul early
		StrCpyEx( stripped + 1, name, len + 1 );
		stripped[0] = (TEXTCHAR)(len + 2);
		{
			CTEXTSTR result = DoSaveName( stripped + 1, len, FALSE );
			EnqueLink( &l.tmp_names, tmp_namebuf );
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
CTEXTSTR SaveNameConcatN( CTEXTSTR name1, ... )
//#define SaveNameConcat(n1,n2) SaveNameConcatN( (n1),(n2),NULL )
{
	// space concat since that's eaten by strip...
	TEXTCHAR _stripbuffer[256];
	TEXTCHAR *stripbuffer = (_stripbuffer+1);
	size_t len = 0;
	CTEXTSTR namex;
	va_list args;
	va_start( args, name1 );
	for( namex = name1;
			 namex;
			 namex = va_arg( args, CTEXTSTR ) )
	{
		size_t newlen;
		// concat order for libraries is
		// args, return type, library, library_procname
		// this is appeneded to the key value FUNCTION
		//lprintf( "Concatting %s", namex );
		newlen = StrLen( StripName( stripbuffer + len, namex ) );
		//if( newlen )
		newlen++;
		len += newlen;
	}
	_stripbuffer[0] = (TEXTCHAR)(len + 2);
	// and add another - final part of string is \0\0
	//stripbuffer[len] = 0;
	//len++;
	return DoSaveName( stripbuffer, len, FALSE );
}
//---------------------------------------------------------------------------
CTEXTSTR SaveText( CTEXTSTR text )
{
	size_t len = StrLen( text );
	TEXTSTR stripped = NewArray( TEXTCHAR, len + 2 );
	CTEXTSTR result;
	StrCpyEx( stripped + 1, text, len + 1 );
	stripped[0] = (TEXTCHAR)(len + 2);
	result = DoSaveName( stripped + 1, len, FALSE);
	Release( stripped );
	return result;
}
//---------------------------------------------------------------------------
CTEXTSTR SaveTextCS( CTEXTSTR text )
{
	static uint32_t volatile lock;
	static char stripped[258];
#ifdef XCHG
	while( XCHG( &lock, 1 ) )
		Relinquish();
#else
	while( LockedExchange( &lock, 1 ) )
		Relinquish();
#endif
	size_t len = StrLen( text );
	//TEXTSTR stripped = NewArray( TEXTCHAR, len + 2 );
	CTEXTSTR result;
	StrCpyEx( stripped + 1, text, len + 1 );
	stripped[0] = (TEXTCHAR)(len + 2);
	result = DoSaveName( stripped + 1, len, TRUE);
	//Release( stripped );
	lock = 0;
	return result;
}
//---------------------------------------------------------------------------
static void CPROC KillName( CPOINTER user, uintptr_t key )
{
	PNAME name = (PNAME)user;
	if( name->tree.Tree )
	{
	}
	else if( name->flags.bValue )
	{
	}
	else if( name->flags.bProc )
	{
	}
	else if( name->flags.bData )
	{
	}
	//DeleteFromSet( NAME, l.TreeNodes, user );
}
//---------------------------------------------------------------------------
// p would be the global space, but it's also already set in it's correct spot
static void CPROC InitGlobalSpace( POINTER p, uintptr_t size )
{
	InitializeCriticalSec( &(*(struct procreg_local_tag*)p).csName );
	(*(struct procreg_local_tag*)p).config_filename = StrDup( config_filename );
	(*(struct procreg_local_tag*)p).Names = (PTREEDEF)GetFromSet( TREEDEF, &(*(struct procreg_local_tag*)p).TreeNodes );
	(*(struct procreg_local_tag*)p).Names->Magic = MAGIC_TREE_NUMBER;
	(*(struct procreg_local_tag*)p).Names->Tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	// enable name indexing.
	// if we have 500 names, 9 searches is much less than 250 avg
	(*(struct procreg_local_tag*)p).flags.bIndexNameTable = 1;
	(*(struct procreg_local_tag*)p).NameIndex = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	(*(struct procreg_local_tag*)p).NameIndex_literal = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmpCS, KillName );
	(*(struct procreg_local_tag*)p).reference_count++;
}
static void Init( void )
{
	// don't call this function, preserves the process line cache, just check the flag and simple skip any call.
	// use SAFE_INIT();
#ifndef __STATIC_GLOBALS__
#define SAFE_INIT() if( !procreg_local_data ) RegisterAndCreateGlobalWithInit( (POINTER*)&procreg_local_data, sizeof( *procreg_local_data ), "procreg_local_data", InitGlobalSpace )
	SAFE_INIT();
#else
	if( !procreg_local_data ) {
		procreg_local_data = &procreg_local_data__;
		InitGlobalSpace( procreg_local_data, sizeof( procreg_local_data[0] ) );
	}
#endif
}
#ifndef __NO_INTERFACE_SUPPORT__
static void ReadConfiguration( void );
#endif
//PRIORITY_UNLOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
//{
	// release other members too, kindly
	//Deallocate( struct procreg_local_tag*, procreg_local_data );
	//procreg_local_data = NULL;
//}
PRIORITY_PRELOAD( InitProcReg2, SYSLOG_PRELOAD_PRIORITY )
{
	// this has to be done after timer's init is done, which is SYSLOG_PRELOAD_PRIORITY-1
	procreg_local_private_data.flags.enable_critical_sections = 1;
}
PRIORITY_PRELOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
{
	Init();
#ifndef __NO_INTERFACE_SUPPORT__
#ifndef __NO_DEFAULT_INTERFACES__
	if( !l.flags.bReadConfiguration )
	{
		l.flags.bReadConfiguration = 1;
		SuspendDeadstart();
		ReadConfiguration();
		ResumeDeadstart();
	}
#endif
#endif
#ifndef __NO_OPTIONS__
	l.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( GetProgramName(), "SACK/Process Registry/Disable Memory Logging", 1, TRUE );
#else
	l.flags.bDisableMemoryLogging = 1;
#endif
}
//---------------------------------------------------------------------------
int GetClassPath( TEXTSTR out, size_t len, PCLASSROOT root )
{
	int ofs = 0;
	PLINKSTACK pls = CreateLinkStack();
	PTREEDEF current;
	PNAME name;
	for( current = (PTREEDEF)root; current && current->self; current = current->self->parent )
	{
		PushLink( &pls, current->self );
	}
	while( ( name = (PNAME)PopLink( &pls ) ) )
	{
		//pcr->
		ofs += tnprintf( out + ofs, len - ofs, "/%s", name->name );
	}
	DeleteLinkStack( &pls );
	return ofs;
}
//---------------------------------------------------------------------------
static PTREEDEF AddClassTree( PCTREEDEF class_root, TEXTCHAR *name, PTREEROOT root, int bAlias )
{
	if( root && class_root )
	{
 //Allocate( sizeof( NAME ) );
		PNAME classname = GetFromSet( NAME, &l.NameSet );
		//MemSet( classname, 0, sizeof( NAME ) );
		classname->flags.bAlias = bAlias;
		classname->name = SaveName( name );
		classname->tree.Magic = MAGIC_TREE_NUMBER;
		classname->tree.Tree = root;
		classname->tree.self = classname;
		classname->flags.bTree = TRUE;
		classname->parent = (PTREEDEF)class_root;
		//lprintf( "Adding class tree thing %p  %s", class_root->Tree, classname->name );
		if( !AddBinaryNode( class_root->Tree, classname, (uintptr_t)classname->name ) )
		{
			//Log( "For some reason could not add new class tree to tree!" );
			DeleteFromSet( NAME, l.NameSet, classname );
			return NULL;
		}
		return &classname->tree;
	}
	return NULL;
}
//---------------------------------------------------------------------------
static CTEXTSTR  my_pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//---------------------------------------------------------------------------
// if name_class is NULL then root is returned.
// if name_class is not NULL then if name_class references
// PTREEDEF structure, then name_class is returned.
// if root is NULL then it is set to l.nmaes... if this library has
// never been initialized it will return NULL.
// if name_class does not previously exist, then it is created.
// There is no protection for someone to constantly create large trees just
// by asking for them.
PTREEDEF GetClassTreeEx( PCTREEDEF root, PCTREEDEF _name_class, PTREEDEF alias, LOGICAL bCreate )
{
	PCTREEDEF class_root;
	if( !root )
	{
		Init();
		root = (PCTREEDEF)l.Names;
// fix root...
	}
	class_root = root;
	if(
#if defined( __ARM__ ) || defined( UNDER_CE ) || defined( __EMSCRIPTEN__ )
		// if its odd, it comes from the name space
		// (savename)
		(((uintptr_t)class_root)&0x3) ||
#endif
		(class_root->Magic != MAGIC_TREE_NUMBER) )
	{
		// if root name is passed as a NAME, then resolve it
		// assuming the root of all names as the root...
		class_root = GetClassTreeEx( l.Names, class_root, NULL, bCreate );
	}
	if( _name_class )
	{
		if(
#if defined( __ARM__ ) || defined( UNDER_CE ) || defined( __EMSCRIPTEN__ )
	  // if its odd, it comes from the name space
		// (savename)
			 !(((uintptr_t)_name_class)&0x3) &&
#endif
			(_name_class->Magic == MAGIC_TREE_NUMBER) )
		{
			return (PTREEDEF)_name_class;
		}
		else
		{
			size_t buflen = 0;
			//TEXTCHAR *original;
			TEXTCHAR *end, *start;
			CTEXTSTR name_class = (CTEXTSTR)_name_class;
			size_t len = StrLen( name_class ) + 1;
			PNAME new_root;
			int retry = 0;
			if( len > buflen )
			{
				buflen = len + 32;
			}
			start = (TEXTCHAR*)name_class;
			do
			{
				end = (TEXTCHAR*)my_pathchr( start );
				do
				{
					if( end == start )
					{
						start = start+1;
						end = (TEXTCHAR*)my_pathchr( start );
						continue;
					}
					if( !end || ((my_pathchr(end+1) - end) != 1) )
						break;
					end++;
				}
				while( 1 );
				do
				{
					{
						// dress name terminates on a '/'
						TEXTCHAR buf[256];
						//lprintf( "Finding a..." );
						new_root = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, start ) );
						//lprintf( "Found %p %s(%d)=%s", new_root, buf+1, buf[0], start );
					}
					if( !new_root )
					{
						if( !bCreate )
							return NULL;
						if( alias && !end )
						{
							// added name in this place name terminates on a '/'
							//lprintf( "name not found, adding...!end && alias" );
							class_root = AddClassTree( class_root
															 , start
															 , alias->Tree
															 , TRUE );
							((PTREEDEF)class_root)->self = alias->self;
						}
						else
						{
							PTREEDEF new_root;
							PTREEROOT tree;
							// added name in this place name terminates on a '/'
							// interesting note - while searching for
							// a member, branches are created.... should consider
							// perhaps offering an option to read for class root without creating
							// however it gives one an idea of what methods might be avaialable...
							//lprintf( "name not found, adding.. [%s] %s", start, class_root->self?class_root->self->name:"." );
							new_root = AddClassTree( class_root
															 , start
															 , tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES
																						 , (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp
																						 , KillName )
															 , FALSE
															 );
							if( !new_root )
							{
								// if this happens it was probably added while adding...
								DebugBreak();
								DestroyBinaryTree( tree );
								if( retry < 2 )
								{
									retry++;
									continue;
								}
#ifndef NO_LOGGING
								SystemLogFL( "Failed to register..." FILELINE_SRC );
								lprintf( "name not found, adding.. [%s] %s", start, class_root->self?class_root->self->name:"." );
#endif
								return NULL;
							}
							class_root = new_root;
						}
					}
					else
					{
						if( !end && alias )
						{
							if( !new_root->flags.bAlias ) {
								static int error_count;
								error_count++;
								// this orphans the prior tree; but probably results from requests for values that aren't present
								// and later are filled by an alias.
								if( error_count > 20 )
									lprintf( " Name %s exists, but we want it to be an alias, and it is not...(a LOT of this is bad) ", new_root->name );
								if( new_root->tree.Magic != MAGIC_TREE_NUMBER )
									lprintf( "Hell it's not even a tree!" );
							}
							new_root->flags.bAlias = 1;
							new_root->tree.Tree = alias->Tree;
							new_root->tree.self = alias->self;
						}
						class_root = &new_root->tree;
					}
					break;
				} while( 1 );
				if( end )
					start = end + 1;
				else
					break;
			}
			while( class_root && start[0] );
		}
	}
	return (PTREEDEF)class_root;
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( NULL, (PTREEDEF)name_class, NULL, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( (PTREEDEF)root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR name_class )
{
	if( !procreg_local_data ) return NULL;
	return (PCLASSROOT)GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class )
{
	return GetClassTreeEx( root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT name_class )
{
	return GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#endif
//---------------------------------------------------------------------------
int AddNode( PTREEDEF class_root, POINTER data, uintptr_t key )
{
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, (CTEXTSTR)key ) );
		if( oldname )
		{
			//lprintf( "Name already in the tree... %s", (CTEXTSTR)key );
			return FALSE;
		}
		else
		{
			//lprintf( "addnode? a data ndoe - create data structure" );
			if( !AddBinaryNode( class_root->Tree, data, key ) )
			{
				Log( "For some reason could not add new name to tree!" );
				return FALSE;
			}
		}
		return TRUE;
	}
	Log( "Nowhere to add the node..." );
	return FALSE;
}
//---------------------------------------------------------------------------
static int CPROC MyStrCmp( uintptr_t s1, uintptr_t s2 )
{
	//lprintf( "Compare (%s) vs (%s)", s1, s2 );
	return StrCaseCmp( (TEXTCHAR*)s1, (TEXTCHAR*)s2 );
}
//---------------------------------------------------------------------------
#undef RegisterFunctionExx
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													 , PCLASSROOT name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
													)
{
	if( root || name_class )
	{
//Allocate( sizeof( NAME ) );
		PNAME newname = GetFromSet( NAME, &l.NameSet );
		TEXTCHAR strippedargs[256];
		CTEXTSTR func_name = real_name?real_name:public_name;
		CTEXTSTR root_func_name = func_name;
		PTREEDEF class_root = (PTREEDEF)GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
		int tmp;
		MemSet( newname, 0, sizeof( NAME ) );
		newname->flags.bProc = 1;
		// this is kinda messed up...
		newname->name = SaveName( public_name );
		newname->data.proc.library = SaveName( library );
		newname->data.proc.procname = SaveName( real_name );
		//newname->data.proc.ret = SaveName( returntype );
		for( tmp = 0; func_name[tmp]; tmp++ )
			if( func_name[tmp] == '/' ||
				func_name[tmp] == '\\' )
			{
				func_name = func_name + tmp + 1;
				tmp = -1;
			}
		if( func_name != root_func_name )
		{
			size_t len;
			TEXTSTR new_root_func_name = NewArray( TEXTCHAR, len = ( func_name - root_func_name ) );
			StrCpyEx( new_root_func_name, root_func_name, len );
			new_root_func_name[len-1] = 0;
			//lprintf( "trimmed name would be %s  /   %s", new_root_func_name, func_name );
			class_root = GetClassTree( (PCTREEDEF)class_root, (PCTREEDEF)new_root_func_name );
			Release( new_root_func_name );
		}
		//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
		newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, args )
															  , returntype
															  , library?library:"_"
															  , func_name
															  , NULL
															  );
		newname->data.proc.proc = proc;
		if( class_root )
		{
			PNAME oldname;
			oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
			if( oldname )
			{
				if( !oldname->data.proc.proc )
				{
					// old branch location might have existed, but no value assigned...
					//lprintf( "overloading prior %p with %p and %p with %p"
					//		 , oldname->data.proc.proc, proc
					//		 , oldname->data.proc.name, newname->data.proc.name
					//		 );
					oldname->flags.bProc = 1;
					oldname->data.proc.proc = proc;
					oldname->data.proc.name = newname->data.proc.name;
					oldname->data.proc.library = newname->data.proc.library;
					oldname->data.proc.procname = newname->data.proc.procname;
					newname->data.proc.name = NULL;
				}
				else if( oldname->data.proc.proc == proc ) {
#ifdef _DEBUG
					CTEXTSTR file = GetRegisteredValue( (CTEXTSTR)&oldname->tree, "Source File" );
					int line = (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)&oldname->tree, "Source Line", TRUE );
					lprintf( "Duplicate function registration, it's the same address as before... %s(%d) %s(%d) %s %s", file, line, pFile, nLine, (char*)name_class, public_name );
#endif
				}else
				{
					TEXTSTR s1, s2;
#ifndef NO_LOGGING
					CTEXTSTR file = GetRegisteredValue( (CTEXTSTR)&oldname->tree, "Source File" );
					int line = (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)&oldname->tree, "Source Line", TRUE );
					_xlprintf( 2 DBG_RELAY)( "proc %s/%s regisry by %s of %s(%s) conflicts with %s(%d):%s(%s)..."
												  , (CTEXTSTR)name_class?(CTEXTSTR)name_class:"@"
												  , public_name?public_name:"@"
												  , newname->name
												  , s1 = GetFullName( newname->data.proc.name )
													//,library
												  , newname->data.proc.procname
												  , file
												  , line
												  , s2 = GetFullName( oldname->data.proc.name )
												  //,library
												  , oldname->data.proc.procname );
					DumpRegisteredNames();
					Release( s1 );
					Release( s2 );
					// perhaps it's same in a different library...
					Log( "All is not well - found same function name in tree with different address. (ignoring second) " );
#endif
				}
				DeleteFromSet( NAME, l.NameSet, newname );
				return TRUE;
			}
			else
			{
				if( !AddBinaryNode( class_root->Tree, (PCLASSROOT)newname, (uintptr_t)newname->name ) )
				{
					Log( "For some reason could not add new name to tree!" );
					DeleteFromSet( NAME, l.NameSet, newname );
					return FALSE;
				}
			}
			{
				//PTREEDEF root = GetClassRoot( newname );
				newname->parent = class_root;
				newname->tree.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
				newname->tree.Tree = CreateBinaryTreeExx( 0
																	 , (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
																	 , KillName );
#ifdef _DEBUG
				{
					CTEXTSTR name = pathrchr( pFile );
					// chop the trailing filename, removing path of filename.
					if( name )
						name++;
					else
						name = pFile;
					RegisterValue( (CTEXTSTR)&newname->tree, "Source File", name );
					RegisterIntValue( (CTEXTSTR)&newname->tree, "Source Line", nLine );
				}
#endif
			}
		}
		else
		{
			lprintf( "I'm relasing this name!?" );
			DeleteFromSet( NAME, l.NameSet, newname );
		}
		return 1;
	}
	return FALSE;
}
#ifdef __cplusplus
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													 , CTEXTSTR name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  )
{
	return RegisterFunctionExx( (PCLASSROOT)root, (PCLASSROOT)name_class, public_name, returntype
	                          , proc, args, library, real_name DBG_RELAY );
}
#endif
//---------------------------------------------------------------------------
#if 0
int ReleaseRegisteredFunctionEx( PCLASSROOT root, CTEXTSTR name_class
							 , CTEXTSTR public_name
							 )
{
	PTREEDEF class_root = GetClassTree( root, (PCLASSROOT)name_class );
	TEXTCHAR buf[256];
	PNAME node = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, public_name ) );
	if( node )
	{
		if( node->flags.bProc )
		{
			UnloadFunction( &node->data.proc.proc );
			//node->data.proc.proc = NULL;
			node->flags.bProc = 0;
			return 1;
		}
	}
	return 0;
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
														, CTEXTSTR name_class
														, CTEXTSTR public_name
														, CTEXTSTR returntype
														, CTEXTSTR library
														, CTEXTSTR name
														, CTEXTSTR args
														 DBG_PASS
														)
{
	//PROCEDURE proc = (PROCEDURE)LoadFunction( library, name );
	//if( proc )
	{
		return RegisterFunctionExx( root, (PCLASSROOT)name_class
		                          , public_name
		                          , returntype
		                          , NULL
		                          , args
		                          , library
		                          , name
		                          DBG_RELAY );
	}
   //return 0;
}
#undef RegisterProcedureEx
PROCREG_PROC( int, RegisterProcedureEx )( CTEXTSTR name_class
                                        , CTEXTSTR public_name
                                        , CTEXTSTR returntype
                                        , CTEXTSTR library
                                        , CTEXTSTR name
                                        , CTEXTSTR args
                                         DBG_PASS
                                        )
{
   return RegisterProcedureExx( NULL, name_class, public_name, returntype, library, name, args DBG_RELAY );
}
#ifndef __NO_INTERFACE_SUPPORT__
// used in dekware.
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
                                                    , CTEXTSTR parms
                                                    )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, NULL );
	PNAME oldname = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( oldname )
	{
		PROCEDURE proc = oldname->data.proc.proc;
		if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
		{
			proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
													, oldname->data.proc.procname );
			//lprintf( "Found a procedure %s=%p  (%p)", name, oldname, proc );
			// should compare whether the types match...
			if( !proc )
			{
				Log( "Failed to load function when requested from tree..." );
			}
			oldname->data.proc.proc = proc;
		}
		return oldname->data.proc.proc;
	}
	return NULL;
}
#endif
//---------------------------------------------------------------------------
// can use the return type and args to validate the correct
// type of routine is called...
// name is not the function name, but rather the public/common name...
// this name may optionally include a # remark detailing more information
// about the name... the comparison of this name is done up to the #
// and data after a # is checked only if both values have a sub-comment.
// library name is not checked.
// this routine may find more than 1 routine which matches the given
// criteria.  return type and args may be NULL indicating a care-less
// approach.
void DumpRegisteredNamesWork( PTREEDEF tree, int level );
#undef GetRegisteredProcedureExx
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
#define GetRegisteredProcedureExx GetRegisteredProcedureExxx
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)name_class, NULL, FALSE );
	if( class_root )
	{
		PNAME oldname;
		//TEXTCHAR buf[256];
		//lprintf( "Found class %s=%p for %s", name_class, class_root, name );
		//DumpRegisteredNamesWork( class_root, 5 );
		oldname = (PNAME)LocateInBinaryTree( class_root->Tree, (uintptr_t)name, NULL );
		//oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		if( oldname )
		{
#if 0
			PROCEDURE proc = oldname->data.proc.proc;
			if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
			{
				proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
														, oldname->data.proc.procname );
				//lprintf( "Found a procedure %s=%p  (%p)", name, oldname, proc );
				// should compare whether the types match...
				if( !proc )
				{
					Log( "Failed to load function when requested from tree..." );
				}
				oldname->data.proc.proc = proc;
			}
#endif
			return oldname->data.proc.proc;
		}
		//else
      //   lprintf( "Failed to find %s in the tree", buf );
	}
	//lprintf( "Failed to find the class root..." );
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, name_class, returntype, name, args );
}
#endif
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( (PCLASSROOT)l.Names, name_class, returntype, name, args );
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( l.Names, name_class, returntype, name, args );
}
#endif
//---------------------------------------------------------------------------
void DumpRegisteredNamesWork( PTREEDEF tree, int level )
{
	PNAME name;
	PVARTEXT pvt;
	PTEXT pText;
   POINTER data;
	int bLogging = 0;
#if 0
	if( level == 0 )
	{
		Init();
		lprintf( "Names %p  %p", l.Names, l.NameSpace );
	}
#endif
   if( l.flags.bDisableMemoryLogging )
		bLogging = SetAllocateLogging( FALSE );
   // at least save the create/destroy uselessness...
	if( !tree->Tree )
	{
		if( l.flags.bDisableMemoryLogging )
			SetAllocateLogging( bLogging );
		return;
	}
	pvt = VarTextCreateExx( 512, 1024 );
#if 0
	DumpTree( tree->Tree, NULL );
	lprintf( "Tree is %p %p", tree, tree->Tree );
#endif
	for( name = (PNAME)GetLeastNodeEx( tree->Tree, &data );
		  name;
		  name = (PNAME)GetGreaterNodeEx( tree->Tree, &data ) )
	{
		int n;
		for( n = 0; n < level; n++ )
			vtprintf( pvt, "   " );
		vtprintf( pvt, "%s", name->name );
		if( name->flags.bValue )
		{
			vtprintf( pvt, " = " );
			if( name->flags.bIntVal )
				vtprintf( pvt, "[%ld]", name->data.name.iValue );
			if( name->flags.bStringVal )
				vtprintf( pvt, "\"%s\"", name->data.name.sValue );
			if( name->flags.bProc )
            vtprintf( pvt, "*%p", name->data.proc.proc );
		}
		else if( name->flags.bProc )
		{
			CTEXTSTR p = name->data.proc.name;
			if( p )
			{
				size_t len = p[-1] - 2;
				vtprintf( pvt, " = " );
				while( len )
				{
					size_t tmp;
					vtprintf( pvt, "%s ", p );
					tmp = StrLen( p ) + 1;
					len-= tmp;
					p += tmp;
				}
				vtprintf( pvt, "*%p", name->data.proc.proc );
			}
		}
		pText = VarTextGet( pvt );
		xlprintf(LOG_INFO)( "%s", GetText( pText ) );
		LineRelease( pText );
		DumpRegisteredNamesWork( &name->tree, level + 1 );
	}
	VarTextDestroy( &pvt );
	if( l.flags.bDisableMemoryLogging )
		SetAllocateLogging( bLogging );
}
//---------------------------------------------------------------------------
struct browse_index
{
	PTREEDEF current_limbs;
	PTREEDEF current_branch;
};
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bTree;
}
int NewNameIsAlias( PCLASSROOT *data )
{
	struct browse_index *class_root = (struct browse_index*)(*data);
	PNAME name;
	name = (PNAME)GetCurrentNodeEx( class_root->current_branch->Tree, &class_root->current_branch->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
int NameIsAlias( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( name )
		return (PCLASSROOT)&name->tree;
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	*data =
		(PCLASSROOT)(class_root = (PTREEDEF)GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)classname, NULL, 0 ));
	if( class_root )
	{
		name = (PNAME)GetLeastNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( "Resulting first name: %s", name->name );
			return name->name;
		}
	}
	return NULL;
}
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, classname, data );
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, (CTEXTSTR)classname, data );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	if( class_root )
	{
		name = (PNAME)GetGreaterNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( "Resulting next name: %s", name->name );
			return name->name;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNames )( void )
{
	if( l.Names )
		DumpRegisteredNamesWork( l.Names, 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root )
{
	DumpRegisteredNamesWork( GetClassTreeEx( l.Names, (PCTREEDEF)root, NULL, TRUE ), 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, InvokeProcedure )( void )
{
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		//lprintf( "... existed? %p", oldname );
		if( oldname )
		{
 // it is now a value, okay?
			oldname->flags.bValue = 1;
			if( bIntVal )
			{
				oldname->flags.bIntVal = 1;
				oldname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				oldname->flags.bStringVal = 1;
				oldname->data.name.sValue = SaveName( value );
			}
		}
		else
		{
 //Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			//MemSet( newname, 0, sizeof( NAME ) );
			if( name )
				newname->name = SaveName( name );
			newname->flags.bValue = 1;
			newname->parent = class_root;
			if( bIntVal )
			{
				newname->flags.bIntVal = 1;
				newname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				newname->flags.bStringVal = 1;
 //StrDup( value );
				newname->data.name.sValue = SaveName( value );
			}
			//lprintf( "... adding %s (%s)", name, newname->name );
			if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
			{
				lprintf( "Failed to add name to tree...%s", name );
			}
		}
		return TRUE;
	}
	return FALSE;
}
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	Init();
	return RegisterValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value )
{
	return RegisterValueEx( name_class, name, FALSE, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueExx( root, name_class, name, TRUE, (CTEXTSTR)value );
}
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueEx( name_class, name, TRUE, (CTEXTSTR)value );
}
//---------------------------------------------------------------------------
int GetRegisteredStaticValue( PCLASSROOT root, CTEXTSTR name_class
									 , CTEXTSTR name
									 , CTEXTSTR *result
									 , int bIntVal )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	TEXTCHAR buf[256];
	PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
		{
			*((int*)result) = (int)oldname->data.name.iValue;
			return TRUE;
		}
		else if( oldname->flags.bStringVal )
		{
			(*result) = oldname->data.name.sValue;
			return TRUE;
		}
	}
	return FALSE;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	PTREEDEF class_root;
	TEXTCHAR buf[256];
	PNAME oldname;
	class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
			return (CTEXTSTR)oldname->data.name.iValue;
		else if( oldname->flags.bStringVal )
			return oldname->data.name.sValue;
	}
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	return GetRegisteredValueExx( (PCLASSROOT)root, name_class, name, bIntVal );
}
#endif
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	Init();
	return GetRegisteredValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal );
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name )
{
	return GetRegisteredValueEx( name_class, name, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueExx( root, name_class, name, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)original, NULL, TRUE );
	return (PCLASSROOT)GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)alias, class_root, TRUE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR alias )
{
	Init();
	return (PCLASSROOT)RegisterClassAliasEx( (PCLASSROOT)l.Names, original, alias );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
												 , CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)classname, NULL, TRUE );
	if( class_root )
	{
 //(PNAME)Allocate( sizeof( NAME ) );
		PNAME pName = GetFromSet( NAME, &l.NameSet );
		//MemSet( pName, 0, sizeof( NAME ) );
		pName->flags.bData = 1;
		pName->name = SaveName( name );
		pName->data.data.Open = Open;
		pName->data.data.Close = Close;
		pName->data.data.size = size;
		pName->data.data.instances.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
		pName->data.data.instances.Tree = CreateBinaryTreeExx( 0
														, (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
														, KillName );
		pName->parent = class_root;
		if( !AddNode( class_root, pName, (uintptr_t)pName->name ) )
		{
			DeleteFromSet( NAME, l.NameSet, pName );
 // NULL
			return 0;
		}
		return (uintptr_t)pName;
	}
 // NULL
	return 0;
}
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	Init();
	return RegisterDataTypeEx( (PCLASSROOT)l.Names, classname, name, size, Open, Close );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, MakeRegisteredDataTypeEx)( PCLASSROOT root
																 , CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename
																 , POINTER data
																 , uintptr_t datasize
																 )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( !pName )
			pName = (PNAME)RegisterDataTypeEx( root, classname, name, datasize, NULL, NULL );
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), "%s_%d", name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					// look up prior instance...
					if( !FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) )
					{
						AddBinaryNode( pDataDef->instances.Tree
										 , data
										 , (uintptr_t)instancename );
					}
					else
					{
						lprintf( "Suck. We just created one externally, and want to use that data, but it already exists." );
						DumpRegisteredNames();
						DebugBreak();
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
					}
					return (uintptr_t)data;
				}
			}
		}
		else
		{
			lprintf( "No such struct defined: %s", name );
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), "%s_%d", name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					POINTER p;
					// look up prior instance...
					if( !( p = (POINTER)FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) ) )
					{
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( "Allocating new struct data :%" _32f, pDataDef->size );
#endif
						p = Allocate( pDataDef->size + sizeof( PLIST ) );
						((PLIST*)p)[0] = NULL;
						p = (POINTER)( ((uintptr_t)p) + sizeof( PLIST ) );
						MemSet( p, 0, pDataDef->size );
						if( pDataDef->Open )
							pDataDef->Open( p, pDataDef->size );
						AddBinaryNode( pDataDef->instances.Tree
										 , p
										 , (uintptr_t)instancename );
					}
					else
					{
						// registered one, returned, needs to be offset for hold purposes.
						POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
						Hold( tmp_p );
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( "Resulting with previuosly created instance." );
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
#endif
					}
					return (uintptr_t)p;
				}
			}
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		else
		{
			lprintf( "No such struct defined:[%s]%s", classname, name );
		}
#endif
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename )
{
	Init();
	return CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, classname, name, instancename );
}
//---------------------------------------------------------------------------
typedef POINTER (CPROC *LOADPROC)( void );
typedef void	 (CPROC *UNLOADPROC)( POINTER );
//-----------------------------------------------------------------------
LOGICAL RegisterInterfaceEx( CTEXTSTR servicename, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS )
{
	//PARAM( args, TEXTCHAR*, servicename );
	//PARAM( args, TEXTCHAR*, library );
	//PARAM( args, TEXTCHAR*, load_proc_name );
	//PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( "system/interfaces" );
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, "POINTER", "load", "void" ) )
	{
		lprintf( "Service: %s has multiple definitions, using first registered."
				 , servicename );
		return FALSE;
	}
	//lprintf( "Registering library l:%p ul:%p", load, unload );
	{
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , "load"
								  , "POINTER"
								  , (PROCEDURE)load
								  , "(void)", NULL, NULL DBG_RELAY );
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , "unload"
								  , "void"
								  , (PROCEDURE)unload
								  , "(POINTER)", NULL, NULL DBG_RELAY );
	}
	return TRUE;
}
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
static uintptr_t CPROC HandleLibrary( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, library );
	PARAM( args, TEXTCHAR*, load_proc_name );
	PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( "system/interfaces" );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, "POINTER", "load", "void" ) )
	{
		lprintf( "Service: %s has multiple definitions, will use last first."
				 , servicename );
		return psv;
	}
	//lprintf( "Registering library %s function %s", library, load_proc_name );
	{
		RegisterProcedureExx( pcr
		                    , servicename
		                    , "load"
		                    , "POINTER"
		                    , library
		                    , load_proc_name
		                    , "void" DBG_SRC );
		RegisterProcedureExx( pcr
		                    , servicename
		                    , "unload"
		                    , "void"
		                    , library
		                    , unload_proc_name, "POINTER" DBG_SRC );
	}
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleAlias( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, originalname );
	TEXTCHAR fullservicename[256];
	TEXTCHAR fulloriginalname[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "alias %s=%s", servicename, originalname );
	tnprintf( fullservicename, sizeof( fullservicename), "system/interfaces/%s", servicename );
	tnprintf( fulloriginalname, sizeof( fulloriginalname), "system/interfaces/%s", originalname );
	RegisterClassAlias( fulloriginalname, fullservicename );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	LOGICAL tempPath = FALSE;
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( module[0] == '~' || module[0] == '@' || module[0] == '^' || module[0] == '*' ) {
		module = ExpandPath( module );
		tempPath = TRUE;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "load module %s", module );
	LoadFunction( module, NULL );
	if( tempPath )
		Deallocate( TEXTCHAR*, module );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandlePrivateModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "load private module %s", module );
	LoadPrivateFunction( module, NULL );
	return psv;
}
//-----------------------------------------------------------------------
static TEXTSTR SubstituteNameVars( CTEXTSTR name )
{
	PVARTEXT pvt = VarTextCreate();
	const TEXTCHAR *start = name;
	const TEXTCHAR *this_var = name;
	const TEXTCHAR *end;
	while( ( this_var = StrChr( start, '%' ) ) )
	{
		// allow specifying %% for a single %.
		// emit the stuff from start to the variable
		if( start < this_var )
			vtprintf( pvt, "%*.*s", this_var-start, this_var-start, start );
		if( this_var[1] == '%' )
		{
			VarTextAddCharacter( pvt, '%' );
			start = this_var + 2;
			continue;
		}
		end = StrChr( this_var + 1, '%' );
		if( end )
		{
			TEXTCHAR *tmpvar = NewArray( TEXTCHAR, end - this_var );
			CTEXTSTR envvar;
			tnprintf( tmpvar, end-this_var, "%*.*s", (int)(end-this_var-1), (int)(end-this_var-1), this_var + 1 );
			envvar = OSALOT_GetEnvironmentVariable( tmpvar );
			if( envvar )
				vtprintf( pvt, "%s", OSALOT_GetEnvironmentVariable( tmpvar ) );
			else
				lprintf( "failed to find environment variable '%s'", tmpvar );
			Release( tmpvar );
			start = end + 1;
		}
		else
			lprintf( "Bad framing on environment variable %%var%% syntax got [%s]", start );
	}
	if( start[0] )
		vtprintf( pvt, "%s", start );
	{
		TEXTSTR result = StrDup( GetText( VarTextPeek( pvt ) ) );
		VarTextDestroy( &pvt );
		return result;
	}
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModulePath( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTSTR, filepath );
	filepath = ExpandPath( filepath );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
# ifdef __LINUX__
	OSALOT_AppendEnvironmentVariable( "LD_LIBRARY_PATH", filepath );
# else
#  ifndef UNDER_CE
	OSALOT_AppendEnvironmentVariable( "PATH", filepath );
#  endif
# endif
	Release( filepath );
	return psv;
}
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename )
{
	if( l.config_filename )
		Release( l.config_filename );
	l.config_filename = StrDup( filename );
}
PROCREG_PROC( void, SetStaticInterfaceConfigFile )( CTEXTSTR filename ) {
	config_filename = filename;
}
static uintptr_t CPROC SetDefaultDirectory( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, path );
	SetCurrentPath( path );
#endif
	return psv;
}
static uintptr_t CPROC SetOptionDefault( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' )
	{
		if( l.flags.bTraceInterfaceLoading )
			lprintf( "Default Option %s / [%s] = [%s}", GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_GetProfileStringEx( GetProgramName(), key, value, buf, sizeof( buf ), TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( "Default Option [%s]/[%s]/[%s] = [%s}", key, optpath, optname, value );
		SACK_GetPrivateProfileStringEx( optpath, optname, value, buf, sizeof( buf ), key, TRUE );
		Release( optname );
		Release( optpath );
	}
#endif
	return psv;
}
static uintptr_t CPROC SetOptionSet( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	size_t valueLen = value?strlen( value ):0;
	TEXTCHAR *buf = (TEXTCHAR*)malloc( valueLen + 2 );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' ) {
		if( l.flags.bTraceInterfaceLoading )
			lprintf( "Set Option %s / [%s] = [%s}", GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_GetProfileStringEx( GetProgramName(), key, value, buf, valueLen+2, TRUE );
		if( memcmp( buf, value, valueLen ) )
			SACK_WriteProfileStringEx( GetProgramName(), key, value, NULL, TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( "Set Option [%s]/[%s]/[%s] = [%s}", key, optpath, optname, value );
		SACK_GetProfileStringEx( optpath, key, value, buf, valueLen + 2, TRUE );
		if( memcmp( buf, value, valueLen ) )
			SACK_WritePrivateProfileStringEx( optpath, optname, value, NULL, TRUE );
		Release( optname );
		Release( optpath );
	}
	free( buf );
#endif
	return psv;
}
static uintptr_t CPROC TestOption( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	SACK_GetProfileStringEx( GetProgramName(), key, "", buf, sizeof( buf ), TRUE );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( " is [%s] == [%s]  buf = [%s]", key, value, buf );
	if( buf[0] == 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	else if( StrCaseCmp( buf, value ) != 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "seek(findendif, findelse) = %d %d", l.flags.bFindEndif, l.flags.bFindElse );
#endif
	return psv;
}
static uintptr_t CPROC EndTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "found endif..." );
	if(l.flags.bFindEndif)
	{
		l.flags.bFindEndif--;
		l.flags.bFindElse = 0;
	}
	return psv;
}
static uintptr_t CPROC ElseTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "found else..." );
	if(l.flags.bFindElse)
	{
		l.flags.bFindElse = 0;
		l.flags.bFindEndif = 0;
	}
	else
		l.flags.bFindEndif++;
	return psv;
}
static uintptr_t CPROC SetTrace( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, yesno );
	l.flags.bTraceInterfaceLoading = yesno;
	return psv;
}
static uintptr_t CPROC IncludeAdditional( uintptr_t psv, arg_list args )
{
	//int skipResume = 0;
	PARAM( args, CTEXTSTR, path );
	TEXTSTR old_configname = l.config_filename;
	l.config_filename = ExpandPath( path );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( "include:%s from %s", l.config_filename, old_configname );
	SuspendDeadstart();
	ReadConfiguration();
	ResumeDeadstart();
	Release( l.config_filename );
	l.config_filename = old_configname;
	return psv;
}
static uintptr_t CPROC SetProducerName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_producer( name );
	return psv;
}
static uintptr_t CPROC SetApplicationName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_application( name );
	return psv;
}
#endif
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
void ReadConfiguration( void )
{
	if( !l.flags.bInterfacesLoaded )
	{
		PCONFIG_HANDLER pch;
		pch = CreateConfigurationHandler();
		AddConfigurationMethod( pch, "Producer=%m", SetProducerName );
		AddConfigurationMethod( pch, "Application=%m", SetApplicationName );
		AddConfigurationMethod( pch, "enable trace=%b", SetTrace );
		AddConfigurationMethod( pch, "option default %m=%m", SetOptionDefault );
		AddConfigurationMethod( pch, "option set %m=%m", SetOptionSet );
		AddConfigurationMethod( pch, "default option %m=%m", SetOptionDefault );
		AddConfigurationMethod( pch, "set option %m=%m", SetOptionSet );
		AddConfigurationMethod( pch, "start directory \"%m\"", SetDefaultDirectory );
		AddConfigurationMethod( pch, "include \"%m\"", IncludeAdditional );
		AddConfigurationMethod( pch, "if %m==%m", TestOption );
		AddConfigurationMethod( pch, "endif", EndTestOption );
		AddConfigurationMethod( pch, "else", ElseTestOption );
		AddConfigurationMethod( pch, "service=%w library=%w load=%w unload=%w", HandleLibrary );
		AddConfigurationMethod( pch, "alias service '%m' = '%m'", HandleAlias );
		AddConfigurationMethod( pch, "alias service %w %w", HandleAlias );
		AddConfigurationMethod( pch, "module %w", HandleModule );
		AddConfigurationMethod( pch, "pmodule %w", HandlePrivateModule );
		AddConfigurationMethod( pch, "modulepath %m", HandleModulePath );
		{
			CTEXTSTR filepath
#ifdef __ANDROID__
				= ".";
#else
				= NULL;
#endif
			size_t pathlen;
			PLIST loadnames = NULL;
			TEXTSTR loadname;
			TEXTSTR path_loadname = NULL;
			size_t len;
			INDEX idx;
			int success = FALSE;
			if( l.config_filename )
			{
				success = ProcessConfigurationFile( pch, l.config_filename, 0 );
				if( !success )
					lprintf( "Failed to open custom interface configuration file:%s", l.config_filename );
				return;
			}
			if( !success )
			{
				CTEXTSTR dot;
				CTEXTSTR tmpdot;
				dot = GetProgramName();
				tmpdot = pathrchr( dot );
				if( tmpdot ) dot = tmpdot + 1;
/*StrLen( "interface.conf" )*/
				loadname = NewArray( TEXTCHAR, len = StrLen( dot ) + 14 + 3);
				tnprintf( loadname, len, "%s.%s", dot, "interface.conf" );
				success = ProcessConfigurationFile( pch, loadname, 0 );
				while( !success && dot )
				{
					AddLink( &loadnames, loadname );
					dot = StrChr( dot + 1, '.' );
					if( dot )
					{
						loadname = NewArray( TEXTCHAR, len );
						tnprintf( loadname, len, "%s.%s", dot+1, "interface.conf" );
						success = ProcessConfigurationFile( pch, loadname, 0 );
						if( !success )
							AddLink( &loadnames, loadname );
					}
				}
			}
			if( !success )
			{
				success = ProcessConfigurationFile( pch, "interface.conf", 0 );
			}
			if( !success )
			{
				INDEX max_count = GetLinkCount( loadnames );
				if( !filepath )
					filepath = ExpandPath( "@/../share/SACK/conf" );
				pathlen = StrLen( filepath );
				//printf( "Configuration path? %s\n", filepath );
				LIST_FORALL( loadnames, idx, TEXTSTR, loadname ) {
					if( idx >= max_count ) break;
					path_loadname = NewArray( TEXTCHAR, len = pathlen + SizeOfMemBlock( loadname ) );
					AddLink( &loadnames, path_loadname );
					tnprintf( path_loadname, len, "%s/%s", filepath, loadname );
					success = ProcessConfigurationFile( pch, path_loadname, 0 );
					if( success ) printf( "Configuration path? %s\n", path_loadname );
					if( success ) break;
				}
			}
			if( !success )
			{
				if( !path_loadname ) path_loadname = NewArray( TEXTCHAR, len = strlen(filepath) + 13 + 1 );
				tnprintf( path_loadname, len, "%s/%s", filepath, "interface.conf" );
				success = ProcessConfigurationFile( pch, path_loadname, 0 );
				if( success ) printf( "Configuration path? %s\n", path_loadname );
			}
			if( !success )
			{
				//lprintf( "Failed to open interface configuration file:%s - assuming it will never exist, and aborting trying this again"
				//		 , l.config_filename?l.config_filename:"interface.conf" );
			}
			LIST_FORALL( loadnames, idx, TEXTSTR, loadname ) {
				if( loadname )
					Deallocate( TEXTSTR, loadname );
			}
#ifndef __ANDROID__
			if( filepath ) Deallocate( CTEXTSTR, filepath );
#endif
			DeleteListEx( &loadnames DBG_SRC );
		}
		DestroyConfigurationHandler( pch );
		//at this point... we should probably NOT
		// dump this information, a vast amount of information may occur.
		// consider impelmenting enumerators and allowing browsing
		//DumpRegisteredNames();
		// if we failed, probably noone will notice, and nooone will
		// get the clue that we need to have an interface.conf
		// for this to preload extra libraries that the program may be
		// requesting.
		l.flags.bInterfacesLoaded = 1;
	}
	//else
	//	lprintf( "already loaded." );
}
#endif
//-----------------------------------------------------------------------
POINTER GetInterfaceExx( CTEXTSTR pServiceName, LOGICAL ReadConfig DBG_PASS ) {
	return GetInterface_v4( pServiceName, ReadConfig, FALSE DBG_RELAY );
}
POINTER GetInterface_v4( CTEXTSTR pServiceName, LOGICAL ReadConfig, int quietFail DBG_PASS )
{
	TEXTCHAR interface_name[256];
	POINTER (CPROC *load)( void );
#ifndef __NO_INTERFACE_SUPPORT__
	static int reading_configuration;
#endif
	// this might be the first clean chance to run deadstarts
	// for ill behaved platforms that have forgotten to do this.
	if( !IsRootDeadstartStarted() )
	{
		InvokeDeadstart();
	}
#ifndef __NO_INTERFACE_SUPPORT__
	if( ReadConfig && !reading_configuration )
	{
		reading_configuration = 1;
		SuspendDeadstart();
		ReadConfiguration();
		ResumeDeadstart();
		reading_configuration = 0;
	}
#endif
	//lprintf( "Load interface [%s]", pServiceName );
	if( pServiceName )
	{
		tnprintf( interface_name, sizeof( interface_name ), "system/interfaces/%s", pServiceName );
		load = GetRegisteredProcedure( (PCLASSROOT)interface_name, POINTER, load, (void) );
		//lprintf( "GetInterface for %s is %p", pServiceName, load );
		if( load )
		{
			POINTER p = load();
			//lprintf( "And the laod proc resulted %p", p );
 //load();
			return p;
		}
#ifdef _DEBUG
		else if( !quietFail )
		{
			if( l.flags.bInterfacesLoaded )
			{
				if( !GetRegisteredValueExx( (PCLASSROOT)interface_name, NULL, "Logged", 1 ) )
				{
					_lprintf(DBG_RELAY)( "Did not find load procedure for:[%s] (dumping names from /system/interface/* so you can see what might be available)", interface_name );
					DumpRegisteredNamesFrom(GetClassRoot("system/interfaces"));
					RegisterValueExx( (PCLASSROOT)interface_name, NULL, "Logged", 1, (CTEXTSTR)1 );
				}
			}
		}
#endif
	}
	return NULL;
}
#undef GetInterfaceEx
POINTER GetInterfaceEx( CTEXTSTR pServiceName, LOGICAL ReadConfig )
{
	return GetInterfaceExx( pServiceName, ReadConfig DBG_SRC );
}
POINTER GetInterfaceDbg( CTEXTSTR pServiceName DBG_PASS )
{
	POINTER result = GetInterfaceExx( pServiceName, FALSE DBG_RELAY );
	if( !result )
	{
		// don't force the issue too much
		if( l.flags.bReadConfiguration )
			result = GetInterfaceExx( pServiceName, TRUE DBG_RELAY );
	}
	return result;
}
#if 0
#undef GetInterface
PUBLIC( POINTER, GetInterface )( CTEXTSTR pServiceName )
{
	return GetInterfaceDbg( pServiceName DBG_SRC );
}
#endif
//-----------------------------------------------------------------------
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_drop )
{
	TEXTCHAR interfacename[256];
	void (CPROC *unload)( POINTER );
	tnprintf( interfacename, sizeof(interfacename), "system/interfaces/%s", pServiceName );
	unload = GetRegisteredProcedure( (PCLASSROOT)interfacename, void, unload, (POINTER) );
	if( unload )
		unload( interface_drop );
}
//-----------------------------------------------------------------------
PRIORITY_ATEXIT( CloseGlobalRegions, ATEXIT_PRIORITY_SHAREMEM + 1 )
{
	PLIST *global_reference;
	INDEX idx;
	return;
	l.reference_count--;
	if( !l.reference_count )
		LIST_FORALL( l.global_spaces, idx, PLIST*, global_reference )
		{
			INDEX idx2;
			POINTER *ppGlobal;
			SetAllocateLogging( 0 );
			// hold the global reference once more, and then just release
			Hold( global_reference );
			LIST_FORALL( global_reference[0], idx2, POINTER *, ppGlobal )
			{
				// increment count here for number of Releases to do.
				(*ppGlobal) = NULL;
				Release( global_reference );
			}
			DeleteList( global_reference );
			// Release all times; number of holds should match number above...
			// safety check it?
			Release( global_reference );
		}
}
void RegisterAndCreateGlobalWithInit( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Open)(POINTER,uintptr_t) )
{
	POINTER *ppGlobalMain;
	POINTER p;
	if( ppGlobal == (POINTER*)&procreg_local_data )
	{
		uintptr_t size = global_size + sizeof( PLIST );
		uint32_t created;
		TEXTCHAR spacename[32];
		if( procreg_local_data != NULL )
		{
			// if local already has something, just return.
			return;
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		lprintf( "Opening space..." );
#endif
#ifdef UNICODE
#define _S "ls"
#else
#define _S "s"
#endif
#ifdef WIN32
		tnprintf( spacename, sizeof( spacename ), "%s:%08lX", name, GetCurrentProcessId() );
#else
		tnprintf( spacename, sizeof( spacename ), "%" _S ":%08X", name, getpid() );
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
		{
			wchar_t buf[32];
			strcpy( (char*)buf, "abcdefghijklmn" );
			swprintf( buf, 32, L"%s", L"some_name" );
			{
				char tmpmsg[256];
				int chars;
				int ofs= 0;
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%02x ", ((char*)buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
								ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (name)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (spacename)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			}
		}
#  endif
#endif
		// hmm application only shared space?
		// how do I get that to happen?
#if defined( __NO_MMAP__ )
		(*ppGlobal) = malloc( size );
		created = 1;
#else
		(*ppGlobal) = OpenSpaceExx( spacename, NULL, 0, &size, &created );
#endif
		(*ppGlobal) = (POINTER*)( (uintptr_t)(*ppGlobal) + sizeof( PLIST ) );
		// I myself must have a global space, which is kept sepearte from named spaces
		// but then... blah
		if( created )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( "(specific procreg global)clearing memory:%s(%p)", spacename, (*ppGlobal ) );
#endif
			MemSet( (*ppGlobal), 0, global_size );
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				global_references[0] = NULL;
				AddLink( global_references, ppGlobal );
			}
			if( Open )
				Open( (*ppGlobal), global_size );
			p = (POINTER)MakeRegisteredDataTypeEx( NULL, "system/global data", name, name, (*ppGlobal), global_size );
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( "(specific procreg global)using memory untouched:%s(%p)", spacename, (*ppGlobal ) );
#endif
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				AddLink( global_references, ppGlobal );
			}
		}
		// result is the same as the pointer input...
		return;
	}
	if( ppGlobal && !(*ppGlobal) )
	{
		Init();
		// RTLD_DEFAULT
		ppGlobalMain = &p;
		p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, "system/global data", name, name );
		if( !p )
		{
			RegisterDataType( "system/global data", name, global_size
								 , Open
								 , NULL );
			p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, "system/global data", name, name );
			if( !p )
				ppGlobalMain = NULL;
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( "Registered and created by registered type. %p", p );
#endif
			{
				// only need each space once in this list; when it's created.
				POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
				AddLink( &l.global_spaces, tmp_p );
			}
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( "Found our shared region by asking politely for it! *********************" );
#endif
		}
		if( !ppGlobalMain )
		{
			lprintf( "None found in main... no way to mark for a peer..." );
			exit(0);
		}
		if( ppGlobalMain && *ppGlobalMain )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( "Resulting with a global space to use... %p", (*ppGlobalMain) );
#endif
			(*ppGlobal) = (*ppGlobalMain);
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( PLIST ) );
				AddLink( global_references, ppGlobal );
			}
		}
		else
		{
			lprintf( "Failure to get global_procreg_data block." );
			exit(0);
		}
	}
	else
	{
		// thing is already apparently initizliaed.. don't do this.
		ppGlobalMain = NULL;
	}
}
void RegisterAndCreateGlobal( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name )
{
	RegisterAndCreateGlobalWithInit( ppGlobal, global_size, name, NULL );
}
#ifdef __cplusplus_cli
using namespace System;
public ref class ProcReg
{
	static ProcReg()
	{
		InvokeDeadstart();
	}
	int Register( System::String^ name_class, String^ proc, STDPROCEDURE Delegate )
	{
		if( name_class )
		{
//Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			TEXTCHAR strippedargs[256];
			pin_ptr<const WCHAR> tmp2 = PtrToStringChars(name_class);
			CTEXTSTR __name_class = DupWideToText( tmp2 );
			pin_ptr<const WCHAR> tmp = PtrToStringChars(proc);
			CTEXTSTR real_name = DupWideToText( tmp );
			PTREEDEF class_root = (PTREEDEF)GetClassTree( NULL, (PTREEDEF)__name_class );
			MemSet( newname, 0, sizeof( NAME ) );
			newname->flags.bStdProc = 1;
			// this is kinda messed up...
			newname->name = SaveName( real_name );
			//newname->data.stdproc.library = SaveName( library );
			newname->data.stdproc.procname = SaveName( real_name );
			//newname->data.proc.ret = SaveName( returntype );
			//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
			newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, "(*)" )
 //returntype
																  , ""
 // library
																  , ""
																  , real_name
																  , NULL
																  );
			newname->data.stdproc.proc = Delegate;
			if( class_root )
			{
				PNAME oldname;
				oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
				if( oldname )
				{
					if( oldname->data.stdproc.proc == Delegate )
						lprintf( "And fortunatly it's the same address... all is well: %s", newname->name );
					else
					{
						xlprintf( 2 )( "proc %s/%s regisry by %s of %s(%s) conflicts with %s(%s)..."
													  , (CTEXTSTR)__name_class?(CTEXTSTR)__name_class:"@"
													  , real_name
													  , newname->name
													  , newname->data.proc.name
														//,library
													  , newname->data.proc.procname
													  , oldname->data.proc.name
													  //,library
													  , oldname->data.proc.procname );
						// perhaps it's same in a different library...
						Log( "All is not well - found same function name in tree with different address. (ignoring second) " );
						//DebugBreak();
						//DumpRegisteredNames();
					}
					return TRUE;
				}
				else
				{
					newname->parent = class_root;
					if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
					{
						Log( "For some reason could not add new name to tree!" );
						DeleteFromSet( NAME, l.NameSet, newname );
					}
				}
			}
			else
			{
				lprintf( "I'm relasing this name!?" );
				DeleteFromSet( NAME, l.NameSet, newname );
			}
			return 1;
		}
	}
};
#endif
PROCREG_NAMESPACE_END
#undef l
/*
 BLOCKINDEX BAT[BLOCKS_PER_BAT] // link of next blocks; 0 if free, FFFFFFFF if end of file block
 uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
 // (1+BLOCKS_PER_BAT) * BLOCK_SIZE total...
 BAT[0] = first directory cluster; array of struct directory_entry
 BAT[1] = name space; directory offsets land in a block referenced by this chain
 */
#define SACK_VFS_SOURCE
#if 1
 // tolower on linux
/* Salty Random Generator is a random bitstream generator. It
   generates blobs
   of randomness, and provides an interface to get a number of
   bits from 1 to N of the random stream.                      */
#ifdef SALTY_RANDOM_GENERATOR_SOURCE
#define SRG_EXPORT EXPORT_METHOD
#else
/* Defines export method for SaltyRandomGenerator functions. */
#define SRG_EXPORT IMPORT_METHOD
#endif
//
// struct random_context *entropy = CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
// uses sha1
SRG_EXPORT struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a larger salt generator... (sha2-512)
SRG_EXPORT struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a sha2-256
SRG_EXPORT struct random_context *SRG_CreateEntropy2_256( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy3( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a sha3-512 (keccak)
SRG_EXPORT struct random_context *SRG_CreateEntropy3( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy4( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a K12-32768
SRG_EXPORT struct random_context *SRG_CreateEntropy4( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user );
// Destroya  context.  Pass the address of your 'struct random_context *entropy;   ... SRG_DestroyEntropy( &entropy );
SRG_EXPORT void SRG_DestroyEntropy( struct random_context **ppEntropy );
// get a large number of bits of entropy from the random_context
// buffer needs to be an integral number of 32 bit elements....
SRG_EXPORT void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits );
// get a number of bits of entropy from the
// if get_signed is not 0, the result will be sign extended if the last bit is set
//  (coded on little endian; tests for if ( result & ( 1 << bits - 1 ) ) then sign extend
SRG_EXPORT int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed );
// get a single bit.
SRG_EXPORT uint32_t SRG_GetBit( struct random_context *ctx );
// opportunity to reset an entropy generator back to initial condition
// next call to getentropy will be the same as the first call after create.
SRG_EXPORT void SRG_ResetEntropy( struct random_context *ctx );
// After SRG_ResetEntropy(), this takes the existing entropy
// already in the random_context and seeds the entropy generator
// with this existing digest;  GetEntropy/GetEntropyBuffer do this
// internally; but for user control, this is separated from just
// ResetEntropy().
//   SRG_ResetEntropy(ctx);   // reset entropy generator to empty.
//   SRG_StreamEntropy(ctx);  // continue from last ending
//   SRG_FeedEntropy(ctx, /*buffer*/ ); // mix in some more entropy
//
SRG_EXPORT void SRG_StreamEntropy( struct random_context *ctx );
// Manually load some salt into the next enropy buffer to e retreived.
// sets up to add the next salt into the buffer.
SRG_EXPORT void SRG_FeedEntropy( struct random_context *ctx, const uint8_t *salt, size_t salt_size );
// Flush the current entropy feed to internal entropy feed
// and initialize with previous feed.
SRG_EXPORT void SRG_StepEntropy( struct random_context* ctx );
// reset the state of the random context entirely. (?)
SRG_EXPORT void SRG_Reset( struct random_context* ctx );
// restore the random contxt from the external holder specified
// {
//    POINTER save_context;
//    SRG_SaveState( ctx, &save_context );  // will allocate space for the context
//    SRG_RestoreState( ctx, save_context ); // context should previously be saved
// }
SRG_EXPORT void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder );
// save the random context in an external buffer holder.
// external buffer holder needs to be initialized to NULL.
// {
//    POINTER save_context = NULL;
//    SRG_SaveState( ctx, &save_context );
// }
SRG_EXPORT void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder, size_t *dataSize );
//
// Randeom Hash generators.  Returns a 256 bit hash in a base 64 string.
// internally seeded by clocks
// Are thread safe; current thread pool is 32 before having to wait
//
// return a unique ID using SHA2_512
SRG_EXPORT char * SRG_ID_Generator( void );
// return a unique ID using SHA2_256
SRG_EXPORT char *SRG_ID_Generator_256( void );
// return a unique ID using SHA3-keccak-512
SRG_EXPORT char *SRG_ID_Generator3( void );
// return a unique ID using K12-32768
SRG_EXPORT char *SRG_ID_Generator4( void );
// return a short unique ID using K12-32768
SRG_EXPORT char *SRG_ID_ShortGenerator4( void );
//------------------------------------------------------------------------
//   crypt_util.c extra simple routines - kinda like 'passwd'
//
// usage
/// { uint8_t* buf; size_t buflen; SRG_DecryptData( <resultfrom encrypt>, &buf, &buflen ); }
//  buffer result must be released by user
SRG_EXPORT void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars );
SRG_EXPORT void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars );
// text result must release by user
SRG_EXPORT TEXTSTR SRG_DecryptString( CTEXTSTR local_password );
// encrypt a block of binary data to another binary buffer
SRG_EXPORT void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size );
// text result must release by user
SRG_EXPORT TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen );
// text result must release by user
// calls EncrytpData with buffer and string length + 1 to include the null for decryption.
SRG_EXPORT TEXTCHAR * SRG_EncryptString( CTEXTSTR buffer );
// Simplified encyprtion wrapper around OpenSSL/LibreSSL EVP AES-256-CBC, uses key as IV also.
// result is length; address of pointer to cyphertext is filled in with an Allocated buffer.
// Limitation of 4G-byte encryption.
// automaically adds padding as required.
SRG_EXPORT int SRG_AES_decrypt( uint8_t *ciphertext, int ciphertext_len, uint8_t *key, uint8_t **plaintext );
// Simplified encyprtion wrapper around OpenSSL/LibreSSL EVP AES-256-CBC, uses key as IV also.
// result is length; address of pointer to cyphertext is filled in with an Allocated buffer.
// Limitation of 4G-byte encryption.
// automaically adds padding as required.
SRG_EXPORT size_t SRG_AES_encrypt( uint8_t *plaintext, size_t plaintext_len, uint8_t *key, uint8_t **ciphertext );
// xor-sub-wipe-sub encryption.
// encrypts objBuf of objBufLen using (keyBuf+tick)
// pointers refrenced passed to outBuf and outBufLen are filled in with the result
// Will automatically add 4 bytes and pad up to 8
SRG_EXPORT void SRG_XSWS_encryptData( uint8_t *objBuf, size_t objBufLen
	, uint64_t tick, const uint8_t *keyBuf, size_t keyBufLen
	, uint8_t **outBuf, size_t *outBufLen
);
// xor-sub-wipe-sub decryption.
// decrypts objBuf of objBufLen using (keyBuf+tick)
// pointers refrenced passed to outBuf and outBufLen are filled in with the result
//
SRG_EXPORT void SRG_XSWS_decryptData( uint8_t *objBuf, size_t objBufLen
	, uint64_t tick, const uint8_t *keyBuf, size_t keyBufLen
	, uint8_t **outBuf, size_t *outBufLen
);
//--------------------------------------------------------------
// block_shuffle.c
//
// Utilities to shuffle 2D data.
//
//  This can use a small swap block to tile over a larger 2D area
//
//  shuffles a matrix of bytes
//  1D operation is available by setting either height to 1
//  (arrays are 'wide' before they are 'high')
/*
{
	struct block_shuffle_key *key = BlockShuffle_CreateKey( SRG_CreateEntropy( NULL, 0 ), 8, 8 );
	uint8_t input_bytes[8][18];
	uint8_t encoded_bytes[8][8];
	uint8_t output_bytes[8][36];
	BlockShuffle_SetDataBlock( key, input, 2, 2, 15, 3, sizeof( input_bytes[0] )
		encoded, 0, 0, sizeof( encoded_bytes[0] ) );
	BlockShuffle_GetDataBlock( key, encoded, 2, 2, 15, 3, sizeof( encoded_bytes[0] )
		output_bytes, 0, 0, sizeof( input_bytes[0] ) );
}
{
	struct block_shuffle_key *BlockShuffle_CreateKey( SRG_CreateEntropy( NULL, 0 ), 8, 8 );
	uint8_t input_bytes[8][18];
	uint8_t encoded_bytes[8][8];
	uint8_t output_bytes[8][36];
}
*/
// API subjet to CHANGE!
// creates a swap-matrix of width by height matrix.  Could be a linear
// swap width (or height) is 1
SRG_EXPORT struct block_shuffle_key *BlockShuffle_CreateKey( struct random_context *ctx, size_t width, size_t height );
// do substitution within a range of data
SRG_EXPORT void BlockShuffle_SetDataBlock( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, int y, size_t w, size_t h, size_t output_stride
	, uint8_t* input, int ofs_x, int ofs_y, size_t input_stride );
// do linear substitution over a range
SRG_EXPORT void BlockShuffle_SetData( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, size_t w
	, uint8_t* input, int ofs_x );
// reverse subsittuion within a range of data
SRG_EXPORT void BlockShuffle_GetDataBlock( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, int y, size_t w, size_t h, size_t encrypted_stride
	, uint8_t* output, int ofs_x, int ofs_y, size_t stride );
// reverse linear substituion over a range.
SRG_EXPORT void BlockShuffle_GetData( struct block_shuffle_key *key
	, uint8_t* encrypted, size_t x, size_t w
	, uint8_t* output, size_t ofs_x );
// Allocate a byte shuffler.
// This transformation creates a unique mapping of byteA to byteB.
// The SubByte and BusByte operations may be performed in either order
// but the complimentary function is required to decode the buffer.
//  (A->B) mapping with SubByte is different from (A->B) mapping with BusByte
// Bus(A) != Sub(A)  but  Bus(Sub(A)) == Sub(Bus(A)) == A
SRG_EXPORT struct byte_shuffle_key *BlockShuffle_ByteShuffler( struct random_context *ctx );
// Releases any resource sassociated with_byte shuffler_key.
void BlockShuffle_DropByteShuffler( struct byte_shuffle_key *key );
// BlockSHuffle_SubBytes and BLockShuffle_BusBytes are reflective routines.
//  They read bytes from 'bytes' and otuput to 'out_bytes'
//  in-place operation (bytes == out_bytes) is posssible.
// SubBytes swaps A->B
SRG_EXPORT void BlockShuffle_SubBytes( struct byte_shuffle_key *key
	, uint8_t *bytes, uint8_t *out_bytes, size_t byteCount );
// swap a single byte; can be in-place.
SRG_EXPORT void BlockShuffle_SubByte( struct byte_shuffle_key *key
	, uint8_t *bytes, uint8_t *out_bytes );
// BlockSHuffle_SubBytes and BlockShuffle_BusBytes are reflective routines.
//  They read bytes from 'bytes' and otuput to 'out_bytes'
//  in-place operation (bytes == out_bytes) is posssible.
// BusBytes swaps B->A
SRG_EXPORT void BlockShuffle_BusBytes( struct byte_shuffle_key *key, uint8_t *bytes
	, uint8_t *out_bytes, size_t byteCount );
// swap a single byte; can be in-place.
SRG_EXPORT void BlockShuffle_BusByte( struct byte_shuffle_key *key
	, uint8_t *bytes, uint8_t *out_bytes );
/* Provides Sack Virtual Filesystem interfaces. */
#ifndef SACK_VFS_DEFINED
/* Header multiple inclusion protection symbol. */
#define SACK_VFS_DEFINED
#ifdef SACK_VFS_STATIC
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC
#  else
#    define SACK_VFS_PROC extern
#  endif
#else
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC EXPORT_METHOD
#  else
#    define SACK_VFS_PROC IMPORT_METHOD
#  endif
#endif
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _SACK_VFS_NAMESPACE  namespace SACK_VFS {
/* Define the ending symbol for file system namespace. */
#define _SACK_VFS_NAMESPACE_END }
#else
#define _SACK_VFS_NAMESPACE
#define _SACK_VFS_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define SACK_VFS_NAMESPACE_END _SACK_VFS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define SACK_VFS_NAMESPACE SACK_NAMESPACE _SACK_VFS_NAMESPACE
#ifdef __cplusplus
namespace sack {
	/* Virtual File System interface/module. */
	namespace SACK_VFS {
#endif
#if !defined( VIRTUAL_OBJECT_STORE ) && !defined( FILE_BASED_VFS )
struct sack_vfs_volume;
struct sack_vfs_file;
struct sack_vfs_find_info;
// if the option to auto mount a file system is used, this is the
// name of the 'file system interface'  ( sack_get_filesystem_interface( SACK_VFS_FILESYSTEM_NAME ) )
#define SACK_VFS_FILESYSTEM_NAME "sack_shmem"
// open a volume at the specified pathname.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// same as load_cyrypt_volume with userkey and devkey NULL.
SACK_VFS_PROC struct sack_vfs_volume * sack_vfs_load_volume( CTEXTSTR filepath );
// open a volume at the specified pathname.  Use the specified keys to encrypt it.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// if the keys are NULL same as load_volume.
SACK_VFS_PROC struct sack_vfs_volume * sack_vfs_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// pass some memory and a memory length of the memory to use as a volume.
// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
// the space is opened as readonly; write accesses/expanding operations will fail.
SACK_VFS_PROC struct sack_vfs_volume * sack_vfs_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// close a volume; release all resources; any open files will keep the volume open.
// when the final file closes the volume will complete closing.
SACK_VFS_PROC void            sack_vfs_unload_volume( struct sack_vfs_volume * vol );
// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
// things to be stored in.
SACK_VFS_PROC void            sack_vfs_shrink_volume( struct sack_vfs_volume * vol );
// remove encryption from volume.
SACK_VFS_PROC LOGICAL         sack_vfs_decrypt_volume( struct sack_vfs_volume *vol );
// change the key applied to a volume.
SACK_VFS_PROC LOGICAL         sack_vfs_encrypt_volume( struct sack_vfs_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
// create a signature of current directory of volume.
// can be used to validate content.  Returns 256 character hex string.
SACK_VFS_PROC const char *    sack_vfs_get_signature( struct sack_vfs_volume *vol );
// pass an offset from memory start and the memory start...
// computes the distance, uses that to generate a signature
// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
SACK_VFS_PROC const uint8_t * sack_vfs_get_signature2( POINTER disk, POINTER diskReal );
// ---------- Operations on files in volumes ------------------
// open a file, creates if does not exist.
SACK_VFS_PROC struct sack_vfs_file * sack_vfs_openfile( struct sack_vfs_volume *vol, CTEXTSTR filename );
// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
SACK_VFS_PROC int sack_vfs_exists( struct sack_vfs_volume *vol, const char * file );
// close a file.
SACK_VFS_PROC int sack_vfs_close( struct sack_vfs_file *file );
// get the current File Position Index (FPI).
SACK_VFS_PROC size_t sack_vfs_tell( struct sack_vfs_file *file );
// get the length of the file
SACK_VFS_PROC size_t sack_vfs_size( struct sack_vfs_file *file );
// set the current File Position Index (FPI).
SACK_VFS_PROC size_t sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence );
// write starting at the current FPI.
SACK_VFS_PROC size_t sack_vfs_write( struct sack_vfs_file *file, const void * data, size_t length );
// read starting at the current FPI.
SACK_VFS_PROC size_t sack_vfs_read( struct sack_vfs_file *file, void * data, size_t length );
// sets the file length to the current FPI.
SACK_VFS_PROC size_t sack_vfs_truncate( struct sack_vfs_file *file );
// psv should be struct sack_vfs_volume *vol;
// delete a filename.  Clear the space it was occupying.
SACK_VFS_PROC int sack_vfs_unlink_file( struct sack_vfs_volume *vol, const char * filename );
// rename a file within the filesystem; if the target name exists, it is deleted.  If the target file is also open, it will be prevented from deletion; and duplicate filenames will end up exising(?)
SACK_VFS_PROC LOGICAL sack_vfs_rename( uintptr_t psvInstance, const char *original, const char *newname );
// -----------  directory interface commands. ----------------------
// returns find_info which is then used in subsequent commands.
SACK_VFS_PROC struct sack_vfs_find_info * sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask );
// reset find_info to the first directory entry.  returns 0 if no entry.
SACK_VFS_PROC int sack_vfs_find_first( struct sack_vfs_find_info *info );
// closes a find cursor; returns 0.
SACK_VFS_PROC int sack_vfs_find_close( struct sack_vfs_find_info *info );
// move to the next entry returns 0 if no entry.
SACK_VFS_PROC int sack_vfs_find_next( struct sack_vfs_find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC char * sack_vfs_find_get_name( struct sack_vfs_find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC size_t   sack_vfs_find_get_size ( struct sack_vfs_find_info *info );
SACK_VFS_PROC uint64_t sack_vfs_find_get_ctime( struct sack_vfs_find_info *info );
SACK_VFS_PROC uint64_t sack_vfs_find_get_wtime( struct sack_vfs_find_info *info );
#endif
#ifdef __cplusplus
/* virtual file system using file system IO instead of memory mapped IO */
namespace fs {
#endif
	struct sack_vfs_fs_volume;
	struct sack_vfs_fs_file;
	struct sack_vfs_fs_find_info;
	// open a volume at the specified pathname.
	// if the volume does not exist, will create it.
	// if the volume does exist, a quick validity check is made on it, and then the result is opened
	// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
	// same as load_cyrypt_volume with userkey and devkey NULL.
	SACK_VFS_PROC struct sack_vfs_fs_volume * sack_vfs_fs_load_volume( CTEXTSTR filepath );
	// open a volume at the specified pathname.  Use the specified keys to encrypt it.
	// if the volume does not exist, will create it.
	// if the volume does exist, a quick validity check is made on it, and then the result is opened
	// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
	// if the keys are NULL same as load_volume.
	SACK_VFS_PROC struct sack_vfs_fs_volume * sack_vfs_fs_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
	// pass some memory and a memory length of the memory to use as a volume.
	// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
	// the space is opened as readonly; write accesses/expanding operations will fail.
	SACK_VFS_PROC struct sack_vfs_fs_volume * sack_vfs_fs_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
	// close a volume; release all resources; any open files will keep the volume open.
	// when the final file closes the volume will complete closing.
	SACK_VFS_PROC void            sack_vfs_fs_unload_volume( struct sack_vfs_fs_volume * vol );
	// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
	// things to be stored in.
	SACK_VFS_PROC void            sack_vfs_fs_shrink_volume( struct sack_vfs_fs_volume * vol );
	// remove encryption from volume.
	SACK_VFS_PROC LOGICAL         sack_vfs_fs_decrypt_volume( struct sack_vfs_fs_volume *vol );
	// change the key applied to a volume.
	SACK_VFS_PROC LOGICAL         sack_vfs_fs_encrypt_volume( struct sack_vfs_fs_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
	// create a signature of current directory of volume.
	// can be used to validate content.  Returns 256 character hex string.
	SACK_VFS_PROC const char *    sack_vfs_fs_get_signature( struct sack_vfs_fs_volume *vol );
	// pass an offset from memory start and the memory start...
	// computes the distance, uses that to generate a signature
	// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
	SACK_VFS_PROC const uint8_t * sack_vfs_fs_get_signature2( POINTER disk, POINTER diskReal );
	// ---------- Operations on files in volumes ------------------
	// open a file, creates if does not exist.
	SACK_VFS_PROC struct sack_vfs_fs_file * sack_vfs_fs_openfile( struct sack_vfs_fs_volume *vol, CTEXTSTR filename );
	// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
	SACK_VFS_PROC int sack_vfs_fs_exists( struct sack_vfs_fs_volume *vol, const char * file );
	// close a file.
	SACK_VFS_PROC int sack_vfs_fs_close( struct sack_vfs_fs_file *file );
	// get the current File Position Index (FPI).
	SACK_VFS_PROC size_t sack_vfs_fs_tell( struct sack_vfs_fs_file *file );
	// get the length of the file
	SACK_VFS_PROC size_t sack_vfs_fs_size( struct sack_vfs_fs_file *file );
	// set the current File Position Index (FPI).
	SACK_VFS_PROC size_t sack_vfs_fs_seek( struct sack_vfs_fs_file *file, size_t pos, int whence );
	// write starting at the current FPI.
	SACK_VFS_PROC size_t sack_vfs_fs_write( struct sack_vfs_fs_file *file, const void * data, size_t length );
	// read starting at the current FPI.
	SACK_VFS_PROC size_t sack_vfs_fs_read( struct sack_vfs_fs_file *file, void * data, size_t length );
	// sets the file length to the current FPI.
	SACK_VFS_PROC size_t sack_vfs_fs_truncate( struct sack_vfs_fs_file *file );
	// psv should be struct sack_vfs_fs_volume *vol;
	// delete a filename.  Clear the space it was occupying.
	SACK_VFS_PROC int sack_vfs_fs_unlink_file( struct sack_vfs_fs_volume *vol, const char * filename );
	// rename a file within the filesystem; if the target name exists, it is deleted.  If the target file is also open, it will be prevented from deletion; and duplicate filenames will end up exising(?)
	SACK_VFS_PROC LOGICAL sack_vfs_fs_rename( uintptr_t psvInstance, const char *original, const char *newname );
	// -----------  directory interface commands. ----------------------
	// returns find_info which is then used in subsequent commands.
	SACK_VFS_PROC struct sack_vfs_fs_find_info * sack_vfs_fs_find_create_cursor( uintptr_t psvInst, const char *base, const char *mask );
	// reset find_info to the first directory entry.  returns 0 if no entry.
	SACK_VFS_PROC int sack_vfs_fs_find_first( struct sack_vfs_fs_find_info *info );
	// closes a find cursor; returns 0.
	SACK_VFS_PROC int sack_vfs_fs_find_close( struct sack_vfs_fs_find_info *info );
	// move to the next entry returns 0 if no entry.
	SACK_VFS_PROC int sack_vfs_fs_find_next( struct sack_vfs_fs_find_info *info );
	// get file information for the file at the current cursor position...
	SACK_VFS_PROC char * sack_vfs_fs_find_get_name( struct sack_vfs_fs_find_info *info );
	// get file information for the file at the current cursor position...
	SACK_VFS_PROC size_t sack_vfs_fs_find_get_size( struct sack_vfs_fs_find_info *info );
#ifdef __cplusplus
}
#endif
#ifdef __cplusplus
/* Object storage system, uses a optimized hash map to index unique identifiers and data associated with them.
Timeline exists, Multi-versioning support possible using the same file and different timestamps with associated data.
*/
namespace objStore {
#endif
	struct sack_vfs_os_volume;
	struct sack_vfs_os_file;
	struct sack_vfs_os_find_info;
	struct sack_vfs_os_time_cursor;
	/* thse should probably be moved to sack_vfs_os.h being file system specific extensions. */
	enum sack_object_store_file_system_file_ioctl_ops {
  // psvInstance should be a file handle pass (char*, size_t length )
		SOSFSFIO_PROVIDE_SEALANT,
 // test if file has been tampered, is is still sealed. pass (address of int)
		SOSFSFIO_TAMPERED,
 // get the resulting storage ID.  (Move ID creation into low level driver)
		SOSFSFIO_STORE_OBJECT,
 // set key required to read this record.
		SOSFSFIO_PROVIDE_READKEY,
		//SFSIO_GET_OBJECT_ID, // get the resulting storage ID.  (Move ID creation into low level driver)
 // creates an index for this record.
		SOSFSFIO_CREATE_INDEX,
 // remove an index (by name)
		SOSFSFIO_DESTROY_INDEX,
		SOSFSFIO_ADD_INDEX_ITEM,
		SOSFSFIO_REMOVE_INDEX_ITEM,
		SOSFSFIO_ADD_REFERENCE,
		SOSFSFIO_REMOVE_REFERENCE,
		SOSFSFIO_ADD_REFERENCE_BY,
		SOSFSFIO_REMOVE_REFERENCE_BY,
 // set file preferred block size intead of automatic
		SOSFSFIO_SET_BLOCKSIZE,
 // set the last updated time of a file
		SOSFSFIO_SET_TIME,
 // get the list of all times associated with a file
		SOSFSFIO_GET_TIMES,
 // get the last(current) time of the file
		SOSFSFIO_GET_TIME,
	};
	enum sack_object_store_file_system_system_ioctl_ops {
 // get the resulting storage ID.  (Move ID creation into low level driver)
		SOSFSSIO_STORE_OBJECT,
		SOSFSSIO_PATCH_OBJECT,
		SOSFSSIO_LOAD_OBJECT,
		SOSFSSIO_OPEN_VERSION,
		SOSFSSIO_NEW_VERSION,
		SOSFSSIO_OPEN_TIMELINE,
		SOSFSSIO_READ_TIMELINE,
		//SFSIO_GET_OBJECT_ID, // get the resulting storage ID.  (Move ID creation into low level driver)
	};
// returns a pointer to and array of buffers.
// the last pointer in the list is NULL.
// each pointer in the list points to a structure containing a pointer to the data and the length of the data
#define sack_vfs_os_ioctl_load_decrypt_object( vol, objId,objIdLen, seal,seallen )                            ((struct {uint8_t*, size_t}*)sack_fs_ioctl( vol, SOSFSSIO_LOAD_OBJECT, objId, objIdLen, seal, seallen ))
// returns a pointer to and array of buffers.
// the last pointer in the list is NULL.
// each pointer in the list points to a structure containing a pointer to the data and the length of the data
#define sack_vfs_os_ioctl_load_object( vol, objId,objIdLen )                                                  ((struct {uint8_t*, size_t}*)sack_fs_ioctl( vol, SOSFSSIO_LOAD_OBJECT, objId, objIdLen ))
// unsealed store/update(patch)
// returns TRUE/FALSE. true if the object already exists, or was successfully written.
// store object data, get a unique ID for the data.
// {
//     char data[] = "some data";
//     char result[44];
//     sack_vfs_os_ioctl_store_rw_object( vol, data, sizeof( data ), result, 44 );
// }
#define sack_vfs_os_ioctl_store_rw_object( vol, obj,objlen, result, resultlen )                                 sack_fs_ioctl( vol, SOSFSSIO_STORE_OBJECT, FALSE, obj, objlen, NULL, 0, NULL, 0, NULL, 0, result, resultlen )
// re-write an object with new content using old ID.
// returns TRUE/FALSE. true if the patch already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char oldResult[] = "AAAAAAAAAAAAAAAAAAAAAAAA"; // ID from previous store result
//     char result[44];
//     sack_vfs_os_ioctl_patch_rw_object( vol, oldResult, sizeof( oldReult-1 ), data, sizeof( data ), result, 44 );
// }
#define sack_vfs_os_ioctl_patch_rw_object( vol, objId,objIdLen, obj,objlen )                                     sack_fs_ioctl( vol, SOSFSSIO_PATCH_OBJECT, FALSE, objId, objIdLen, NULL, 0, obj, objlen, NULL, 0, NULL, 0 )
// sealed store and patch
// store a unencrypted, sealed object using specified sealant
// store data to a new sealed block.  Also encrypt the data
// returns TRUE/FALSE. true if the object already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char result[44];
//     sack_vfs_os_ioctl_store_crypt_object( vol, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_store_crypt_owned_object( vol, obj,objlen, seal,seallen, readkey,readkeylen, result, resultlen )                 sack_fs_ioctl( vol, SOSFSSIO_STORE_OBJECT, TRUE,TRUE,  obj, objlen, NULL, 0, seal, seallen, readkey,readkeylen, result, resultlen )
// store data to a new sealed block.  Also encrypt the data
// returns TRUE/FALSE. true if the object already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char result[44];
//     sack_vfs_os_ioctl_store_crypt_object( vol, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_store_crypt_sealed_object( vol, obj,objlen, seal,seallen, readkey,readkeylen, result, resultlen )                 sack_fs_ioctl( vol, SOSFSSIO_STORE_OBJECT, TRUE,FALSE,  obj, objlen, NULL, 0, seal, seallen, readkey,readkeylen, result, resultlen )
// store patch to an existing sealed block.  (Writes never change existing data), also encrypt the data
// returns TRUE/FALSE. true if the patch already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char oldResult[] = "AAAAAAAAAAAAAAAAAAAAAAAA"; // ID from previous store result
//     char result[44];
//     sack_vfs_os_ioctl_patch_crypt_object( vol, oldResult, sizeof( oldResult )-1, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_patch_crypt_owned_object( vol, objId,objIdLen, obj,objlen, seal,seallen, readkey,readkeylen, result, resultlen ) sack_fs_ioctl( vol, SOSFSSIO_PATCH_OBJECT, TRUE, TRUE, objId, objIdLen, authId, authIdLen, obj, objlen, seal, seallen, readkey,readkeylen, result, resultlen )
// store patch to an existing sealed block.  (Writes never change existing data), also encrypt the data
// returns TRUE/FALSE. true if the patch already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char oldResult[] = "AAAAAAAAAAAAAAAAAAAAAAAA"; // ID from previous store result
//     char result[44];
//     sack_vfs_os_ioctl_patch_crypt_object( vol, oldResult, sizeof( oldResult )-1, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_patch_crypt_sealed_object( vol, objId,objIdLen, obj,objlen, seal,seallen, result, resultlen ) sack_fs_ioctl( vol, SOSFSSIO_PATCH_OBJECT, TRUE, FALSE, objId, objIdLen, authId, authIdLen, obj, objlen, seal, seallen, result, resultlen )
// store data to a new sealed block.  Data is publically readable.
// returns TRUE/FALSE. true if the object already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char result[44];
//     sack_vfs_os_ioctl_store_owned_object( vol, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_store_owned_object( vol, obj,objlen, seal,seallen, result, resultlen )                 sack_fs_ioctl( vol, SOSFSSIO_STORE_OBJECT, FALSE, TRUE, obj, objlen, NULL, 0, seal, seallen, NULL, 0, result, resultlen )
// store data to a new sealed block.  Data is publically readable.
// returns TRUE/FALSE. true if the object already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char result[44];
//     sack_vfs_os_ioctl_store_sealed_object( vol, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_store_sealed_object( vol, obj,objlen, seal,seallen, result, resultlen )                 sack_fs_ioctl( vol, SOSFSSIO_STORE_OBJECT, FALSE, FALSE, obj, objlen, NULL, 0, seal, seallen, NULL, 0, result, resultlen )
// store patch to an existing sealed block.  (Writes never change existing data).  Data is publically readable.
// returns TRUE/FALSE. true if the patch already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char oldResult[] = "AAAAAAAAAAAAAAAAAAAAAAAA"; // ID from previous store result
//     char result[44];
//     sack_vfs_os_ioctl_patch_object( vol, oldResult, sizeof( oldResult )-1, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_patch_owned_object( vol, objId,objIdLen, obj,objlen, seal,seallen, result, resultlen ) sack_fs_ioctl( vol, SOSFSSIO_PATCH_OBJECT, FALSE, TRUE, objId, objIdLen, authId, authIdLen, obj, objlen, seal, seallen, result, resultlen )
// store patch to an existing sealed block.  (Writes never change existing data).  Data is publically readable.
// returns TRUE/FALSE. true if the patch already exists, or was successfully written.
// {
//     char data[] = "some data";
//     char seal[] = "BBBBBBBBBBBBBBBBBBBBBBBB"; // Some sealant bsea64
//     char oldResult[] = "AAAAAAAAAAAAAAAAAAAAAAAA"; // ID from previous store result
//     char result[44];
//     sack_vfs_os_ioctl_patch_object( vol, oldResult, sizeof( oldResult )-1, data, sizeof( data ), seal, sizeof( seal ), result, 44 );
// }
#define sack_vfs_os_ioctl_patch_sealed_object( vol, objId,objIdLen, obj,objlen, seal,seallen, result, resultlen ) sack_fs_ioctl( vol, SOSFSSIO_PATCH_OBJECT, FALSE, FALSE, objId, objIdLen, authId, authIdLen, obj, objlen, seal, seallen, result, resultlen )
#define sack_vfs_os_ioctl_create_index( file, indexName ) sack_vfs_os_file_ioctl( file, SOSFSFIO_CREATE_INDEX, indexName )
#define sack_vfs_os_ioctl_get_times( file, timeArray,tzArray,timeCount ) sack_vfs_os_file_ioctl( file, SOSFSFIO_GET_TIMES, timeArray,tzArray,timeCount )
// get the last write timeline index of a file
//     sack_vfs_os_ioctl_get_time( file )
#define sack_vfs_os_ioctl_get_time( file ) sack_vfs_os_file_ioctl( file, SOSFSFIO_GET_TIME )
#define sack_vfs_os_ioctl_set_time( file, timestamp,tz )            sack_vfs_os_file_ioctl( file, SOSFSFIO_SETTIME, timestamp,tz )
// open a volume at the specified pathname.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// same as load_cyrypt_volume with userkey and devkey NULL.
SACK_VFS_PROC struct sack_vfs_os_volume * sack_vfs_os_load_volume( CTEXTSTR filepath, struct file_system_mounted_interface* mount );
/*
    polish volume cleans up some of the dirty sectors.  It starts a background thread that
	waits a short time of no dirty updates. (flush, but polish <-> dirty )
 */
SACK_VFS_PROC void sack_vfs_os_polish_volume( struct sack_vfs_os_volume* vol );
SACK_VFS_PROC void sack_vfs_os_flush_volume( struct sack_vfs_os_volume* vol, LOGICAL unload );
// open a volume at the specified pathname.  Use the specified keys to encrypt it.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// if the keys are NULL same as load_volume.
SACK_VFS_PROC struct sack_vfs_os_volume * sack_vfs_os_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey, struct file_system_mounted_interface* mount );
// diagnostics can use this open; flags may control whether the journal is processed automatically on open.
// this flag can be used to disable journal replay.
#define SACK_VFS_LOAD_FLAG_NO_REPLAY 1
SACK_VFS_PROC struct sack_vfs_os_volume* sack_vfs_os_load_volume_v2( int flags, CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey, struct file_system_mounted_interface* mount );
// pass some memory and a memory length of the memory to use as a volume.
// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
// the space is opened as readonly; write accesses/expanding operations will fail.
SACK_VFS_PROC struct sack_vfs_os_volume * sack_vfs_os_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// close a volume; release all resources; any open files will keep the volume open.
// when the final file closes the volume will complete closing.
SACK_VFS_PROC void            sack_vfs_os_unload_volume( struct sack_vfs_os_volume * vol );
// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
// things to be stored in.
SACK_VFS_PROC void            sack_vfs_os_shrink_volume( struct sack_vfs_os_volume * vol );
// remove encryption from volume.
SACK_VFS_PROC LOGICAL         sack_vfs_os_decrypt_volume( struct sack_vfs_os_volume *vol );
// change the key applied to a volume.
SACK_VFS_PROC LOGICAL         sack_vfs_os_encrypt_volume( struct sack_vfs_os_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
// create a signature of current directory of volume.
// can be used to validate content.  Returns 256 character hex string.
SACK_VFS_PROC const char *    sack_vfs_os_get_signature( struct sack_vfs_os_volume *vol );
// pass an offset from memory start and the memory start...
// computes the distance, uses that to generate a signature
// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
SACK_VFS_PROC const uint8_t * sack_vfs_os_get_signature2( POINTER disk, POINTER diskReal );
// extra file system operations, not in the normal API definition set.
SACK_VFS_PROC uintptr_t sack_vfs_os_system_ioctl( struct sack_vfs_os_volume* psvInstance, uintptr_t opCode, ... );
// ---------- Operations on files in volumes ------------------
// open a file, creates if does not exist.
SACK_VFS_PROC struct sack_vfs_os_file * sack_vfs_os_openfile( struct sack_vfs_os_volume *vol, CTEXTSTR filename );
// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
SACK_VFS_PROC int sack_vfs_os_exists( struct sack_vfs_os_volume *vol, const char * file );
// extra operations, not in the normal API definition set.
SACK_VFS_PROC uintptr_t sack_vfs_os_file_ioctl( struct sack_vfs_os_file *file, uintptr_t opCode, ... );
// close a file.
SACK_VFS_PROC int sack_vfs_os_close( struct sack_vfs_os_file *file );
// get the current File Position Index (FPI).
SACK_VFS_PROC size_t sack_vfs_os_tell( struct sack_vfs_os_file *file );
// get the length of the file
SACK_VFS_PROC size_t sack_vfs_os_size( struct sack_vfs_os_file *file );
// set the current File Position Index (FPI).
SACK_VFS_PROC size_t sack_vfs_os_seek( struct sack_vfs_os_file *file, size_t pos, int whence );
// write starting at the current FPI.
SACK_VFS_PROC size_t sack_vfs_os_write( struct sack_vfs_os_file *file, const void * data, size_t length );
// read starting at the current FPI.
SACK_VFS_PROC size_t sack_vfs_os_read( struct sack_vfs_os_file *file, void * data, size_t length );
// sets the file length to the current FPI.
SACK_VFS_PROC size_t sack_vfs_os_truncate( struct sack_vfs_os_file *file );
// psv should be struct sack_vfs_os_volume *vol;
// delete a filename.  Clear the space it was occupying.
SACK_VFS_PROC int sack_vfs_os_unlink_file( struct sack_vfs_os_volume *vol, const char * filename );
// rename a file within the filesystem; if the target name exists, it is deleted.  If the target file is also open, it will be prevented from deletion; and duplicate filenames will end up exising(?)
SACK_VFS_PROC LOGICAL sack_vfs_os_rename( uintptr_t psvInstance, const char *original, const char *newname );
// -----------  directory interface commands. ----------------------
// returns find_info which is then used in subsequent commands.
SACK_VFS_PROC struct sack_vfs_os_find_info * sack_vfs_os_find_create_cursor( uintptr_t psvInst, const char *base, const char *mask );
// reset find_info to the first directory entry.  returns 0 if no entry.
SACK_VFS_PROC int sack_vfs_os_find_first( struct sack_vfs_os_find_info *info );
// closes a find cursor; returns 0.
SACK_VFS_PROC int sack_vfs_os_find_close( struct sack_vfs_os_find_info *info );
// move to the next entry returns 0 if no entry.
SACK_VFS_PROC int sack_vfs_os_find_next( struct sack_vfs_os_find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC char * sack_vfs_os_find_get_name( struct sack_vfs_os_find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC size_t sack_vfs_os_find_get_size( struct sack_vfs_os_find_info *info );
// get times for the object in storage.
SACK_VFS_PROC LOGICAL sack_vfs_os_get_times( struct sack_vfs_os_file* file, uint64_t** timeArray, int8_t**tzArray, size_t* timeCount );
// set last time for object in storage. (overwrites current tick used to update on write)
SACK_VFS_PROC LOGICAL sack_vfs_os_set_time( struct sack_vfs_os_file* file, uint64_t time, int8_t tz );
SACK_VFS_PROC struct sack_vfs_os_time_cursor* sack_vfs_os_get_time_cursor( struct sack_vfs_os_volume* vol );
SACK_VFS_PROC LOGICAL sack_vfs_os_read_time_cursor( struct sack_vfs_os_time_cursor* cursor, int step, uint64_t time_, uint64_t* entry, const char** filename, uint64_t* result_timestamp, int8_t* result_tz, const char** buffer, size_t* size );
// force disabling any further writes to the volue; for unit-testing journal recovery.
SACK_VFS_PROC LOGICAL sack_vfs_os_halt( struct sack_vfs_os_volume* volume );
// generate a report about the internal structure of the volue...
// journal parameters, timeline length?  File Entries?
SACK_VFS_PROC LOGICAL sack_vfs_os_analyze( struct sack_vfs_os_volume* volume );
#ifdef __cplusplus
}
#endif
//DOM-IGNORE-BEGIN
#if defined USE_VFS_FS_INTERFACE
#define sack_vfs_volume sack_vfs_fs_volume
#define sack_vfs_file sack_vfs_fs_file
#define sack_vfs_load_volume  sack_vfs_fs_load_volume
#define sack_vfs_load_crypt_volume  sack_vfs_fs_load_crypt_volume
#define sack_vfs_use_crypt_volume  sack_vfs_fs_use_crypt_volume
#define sack_vfs_unload_volume  sack_vfs_fs_unload_volume
#define sack_vfs_shrink_volume  sack_vfs_fs_shrink_volume
#define sack_vfs_decrypt_volume  sack_vfs_fs_decrypt_volume
#define sack_vfs_encrypt_volume  sack_vfs_fs_encrypt_volume
#define sack_vfs_get_signature  sack_vfs_fs_get_signature
#define sack_vfs_get_signature2  sack_vfs_fs_get_signature2
#define sack_vfs_openfile  sack_vfs_fs_openfile
#define sack_vfs_exists  sack_vfs_fs_exists
#define sack_vfs_close  sack_vfs_fs_close
#define sack_vfs_tell  sack_vfs_fs_tell
#define sack_vfs_size  sack_vfs_fs_size
#define sack_vfs_seek  sack_vfs_fs_seek
#define sack_vfs_write  sack_vfs_fs_write
#define sack_vfs_read  sack_vfs_fs_read
#define sack_vfs_truncate  sack_vfs_fs_truncate
#define sack_vfs_unlink_file  sack_vfs_fs_unlink_file
#define sack_vfs_rename  sack_vfs_fs_rename
#define sack_vfs_find_create_cursor  sack_vfs_fs_find_create_cursor
#define sack_vfs_find_first  sack_vfs_fs_find_first
#define sack_vfs_find_close  sack_vfs_fs_find_close
#define sack_vfs_find_next  sack_vfs_fs_find_next
#define sack_vfs_find_get_name  sack_vfs_fs_find_get_name
#define sack_vfs_find_get_size  sack_vfs_fs_find_get_size
#define sack_vfs_find_get_cdate  sack_vfs_fs_find_get_cdate
#define sack_vfs_find_get_wdate  sack_vfs_fs_find_get_wdate
#endif
#if defined USE_VFS_OS_INTERFACE
#define sack_vfs_volume sack_vfs_os_volume
#define sack_vfs_file sack_vfs_os_file
#define sack_vfs_load_volume(a)  sack_vfs_os_load_volume(a,NULL)
#define sack_vfs_load_crypt_volume(a,b,c,d)  sack_vfs_os_load_crypt_volume(a,b,c,d,NULL)
#define sack_vfs_use_crypt_volume  sack_vfs_os_use_crypt_volume
#define sack_vfs_unload_volume  sack_vfs_os_unload_volume
#define sack_vfs_shrink_volume  sack_vfs_os_shrink_volume
#define sack_vfs_decrypt_volume  sack_vfs_os_decrypt_volume
#define sack_vfs_encrypt_volume  sack_vfs_os_encrypt_volume
#define sack_vfs_get_signature  sack_vfs_os_get_signature
#define sack_vfs_get_signature2  sack_vfs_os_get_signature2
#define sack_vfs_openfile  sack_vfs_os_openfile
#define sack_vfs_exists  sack_vfs_os_exists
#define sack_vfs_close  sack_vfs_os_close
#define sack_vfs_tell  sack_vfs_os_tell
#define sack_vfs_size  sack_vfs_os_size
#define sack_vfs_seek  sack_vfs_os_seek
#define sack_vfs_write  sack_vfs_os_write
#define sack_vfs_read  sack_vfs_os_read
#define sack_vfs_truncate  sack_vfs_os_truncate
#define sack_vfs_unlink_file  sack_vfs_os_unlink_file
#define sack_vfs_rename  sack_vfs_os_rename
#define sack_vfs_find_create_cursor  sack_vfs_os_find_create_cursor
#define sack_vfs_find_first  sack_vfs_os_find_first
#define sack_vfs_find_close  sack_vfs_os_find_close
#define sack_vfs_find_next  sack_vfs_os_find_next
#define sack_vfs_find_get_name  sack_vfs_os_find_get_name
#define sack_vfs_find_get_size  sack_vfs_os_find_get_size
#define sack_vfs_find_get_cdate  sack_vfs_os_find_get_cdate
#define sack_vfs_find_get_wdate  sack_vfs_os_find_get_wdate
#endif
//DOM-IGNORE-END
#if defined( __cplusplus )
 //SACK_VFS_NAMESPACE_END
} }
using namespace sack::SACK_VFS;
using namespace sack::SACK_VFS::fs;
using namespace sack::SACK_VFS::objStore;
#endif
#endif
#else
#  include <sack.h>
 // tolower on linux
//#include <filesys.h>
//#include <procreg.h>
//#include <salty_generator.h>
//#include <sack_vfs.h>
//#include <sqlgetoption.h>
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#  pragma warning( disable: 26451 )
#endif
SACK_VFS_NAMESPACE
//#define PARANOID_INIT
//#define DEBUG_TRACE_LOG
#ifdef DEBUG_TRACE_LOG
#define LoG( a,... ) lprintf( a,##__VA_ARGS__ )
#else
#define LoG( a,... )
#endif
// more verbose logging...
//#define DEBUG_BLOCK_TRACKING
//#define DEBUG_NAME_POSITION_SEEK
//#define DEBUG_VERBOSE_CHAIN_FOLLOW
//#define DEBUG_BAT_UPDATES
#ifdef DEBUG_BAT_UPDATES
#define LoGB( a,... ) lprintf( a,##__VA_ARGS__ )
#else
#define LoGB( a,... )
#endif
#define MMAP_BASED_VFS
#ifndef _MSC_VER
#endif
/**************
  VFS_VERSION
     used to track migration of keys and keying methods.
  0x100 = version 1; SHORTKEY_LENGTH = 16
 **************/
#define VFS_VERSION     0x100
// 12 bits = 1 << 12 = 4096
#define BLOCK_SIZE_BITS 12
// BLOCKINDEX is either 4 or 8 bytes... sizeof( size_t )...
// all constants though should compile out to a single value... and just for grins went to 16 bit size_t and 0 shift... or 1 byte
#define BLOCK_BAT_SHIFT (BLOCK_SIZE_BITS-(sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_INDEX_SHIFT ((sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_BYTE_SHIFT (BLOCK_SIZE_BITS)
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
#define BLOCK_SMALL_SIZE     256
#define DIR_BLOCK_SIZE_BITS   12
#define DIR_BLOCK_SIZE      (1<<DIR_BLOCK_SIZE_BITS)
#define BAT_BLOCK_SIZE      4096
#define NAME_BLOCK_SIZE     4096
#define KEY_SIZE            1024
#define TIME_BLOCK_SIZE     4096
#define ROLLBACK_BLOCK_SIZE 4096
#define FILE_NAME_MAXLEN    4096
#define BLOCK_MASK (BLOCK_SIZE-1)
#ifdef VIRTUAL_OBJECT_STORE
// if the block index & BAT_BLOCK_MASK, is a data block
// all BATs are 4096
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT)-1)
#  define BLOCK_SECTOR_MASK BLOCKS_PER_BAT
#else
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT))
#  define BLOCK_SECTOR_MASK (BLOCKS_PER_BAT-1)
#endif
#define BAT_BLOCK_MASK ( ( BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT ) - 1)
#define BLOCKS_PER_SECTOR (1+BLOCKS_PER_BAT)
// per-sector perumation; needs to be a power of 2 (in bytes)
#define SHORTKEY_LENGTH 16
#ifndef VFS_DISK_DATATYPE
#  define VFS_DISK_DATATYPE size_t
#endif
 // BLOCK_SIZE blocks...
typedef VFS_DISK_DATATYPE BLOCKINDEX;
 // file position type
typedef VFS_DISK_DATATYPE FPI;
/* BEFORE DEF */
#undef BC
#ifdef VIRTUAL_OBJECT_STORE
/* THIS DEFINES SACK_VFS_OS_VOLUME */
#  define BC(n) BLOCK_CACHE_VOS_##n
#    ifdef sack_vfs_volume
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_os
#    define directory_entry directory_entry_os
#    define sack_vfs_disk sack_vfs_disk_os
#    define sack_vfs_diskSection sack_vfs_diskSection_os
#    define directory_hash_lookup_block directory_hash_lookup_block_os
#    define sack_vfs_volume sack_vfs_os_volume
#    define sack_vfs_file sack_vfs_os_file
#   ifdef __cplusplus
namespace objStore {
#   endif
#elif defined FILE_BASED_VFS
#  define BC(n) BLOCK_CACHE_FS_##n
#    ifdef block_cache_entries
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_fs
#    define directory_entry directory_entry_fs
#    define sack_vfs_disk sack_vfs_disk_fs
#    define sack_vfs_diskSection sack_vfs_diskSection_fs
#    define directory_hash_lookup_block directory_hash_lookup_block_fs
/* THIS DEFINES SACK_VS_VOLUME */
#    define sack_vfs_volume sack_vfs_fs_volume
#    define sack_vfs_file sack_vfs_fs_file
#   ifdef __cplusplus
namespace fs {
#   endif
#else
#  define BC(n) BLOCK_CACHE_##n
#endif
/* AFTER DEF */
enum block_cache_entries
{
	BC( ZERO )
	, BC( DIRECTORY ) = 0
#ifdef VIRTUAL_OBJECT_STORE
	, BC( DIRECTORY_LAST ) = BC( DIRECTORY ) + 64
#endif
	, BC( NAMES )
	, BC( NAMES_LAST ) = BC( NAMES ) + 16
	, BC( BAT )
#ifdef VIRTUAL_OBJECT_STORE
	// keep a few tables for cache (file system too?)
	, BC( BAT_LAST ) = BC( BAT ) + 16
#endif
	, BC(DATAKEY)
	, BC(FILE)
	, BC(FILE_LAST) = BC(FILE) + 32
#ifdef VIRTUAL_OBJECT_STORE
	, BC( TIMELINE )
	, BC( TIMELINE_LAST ) = BC( TIMELINE ) + 48
#endif
#if defined( VIRTUAL_OBJECT_STORE )
	// really shouldn't need more than one of these...
	// record
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// replay
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// 1 - target disk sector
	, BC( ROLLBACK )
	, BC( ROLLBACK_LAST ) = BC( ROLLBACK ) + 6
#endif
#if defined( VIRTUAL_OBJECT_STORE ) && defined( DEBUG_VALIDATE_TREE )
	// debug timeline, keep a mirror for comparisons, when links were lost, etc...
	// can be factored out at some point.
	, BC( TIMELINE_RO )
	, BC( TIMELINE_RO_LAST ) = BC( TIMELINE_RO ) + 48
#endif
	, BC(COUNT)
};
// could effecitvely be fewer than this
// 82 dirents * 512 byte names = 40000
#define DIRENT_NAME_OFFSET_OFFSET             0x0001FFFF
// (sealant length / 4)  (mulitply by 4 to get real length)
#define DIRENT_NAME_OFFSET_FLAG_SEALANT       0x003E0000
#define DIRENT_NAME_OFFSET_FLAG_SEALANT_SHIFT 17
#define DIRENT_NAME_OFFSET_FLAG_OWNED         0x00400000
#define DIRENT_NAME_OFFSET_FLAG_READ_KEYED    0x00800000
// unused flag; previous indicated versioning.
#define DIRENT_NAME_OFFSET_UNUSED_0         0x01000000
#define DIRENT_NAME_OFFSET_VERSION_SHIFT      25
#define DIRENT_NAME_OFFSET_VERSIONS           0x1E000000
#define DIRENT_NAME_OFFSET_UNUSED             0xFE000000
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct directory_entry
{
  // name offset from beginning of disk
	FPI name_offset;
  // first block of data of the file
	BLOCKINDEX first_block;
  // how big the file is
	VFS_DISK_DATATYPE filesize;
#ifdef VIRTUAL_OBJECT_STORE
  // when the file was created/last written
	uint64_t timelineEntry;
#endif
} PACKED;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#undef VFS_DIRECTORY_ENTRIES
#ifdef VIRTUAL_OBJECT_STORE
// subtract name has index
// subtrace name index
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE - ( 2*sizeof(BLOCKINDEX) + 256*sizeof(BLOCKINDEX)) ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#else
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#endif
/*
struct sack_vfs_diskSection
{
	// BAT is at 0 of every BLOCK_SIZE blocks (4097 total)
	// &BAT[0] == itself....
	// BAT[0] == first directory entry (actually next entry; first is always here)
	// BAT[1] == first name entry (actually next name block; first is known as here)
	// bat[BLOCK_SIZE] == NEXT_BAT[0]; NEXT_BAT = BAT + BLOCK_SIZE + 1024*BLOCK_SIZE;
	// bat[8192] == ... ( 0 + ( BLOCK_SIZE + BLOCKS_PER_BAT*BLOCK_SIZE ) * N >> 12 )
	BLOCKINDEX BAT[BLOCKS_PER_BAT];
	//struct directory_entry directory[BLOCK_SIZE/sizeof( struct directory_entry)]; // 256
	//char  names[BLOCK_SIZE/sizeof(char)];
	uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
};
struct sack_vfs_disk {
	struct sack_vfs_diskSection firstBlock;
	struct sack_vfs_diskSection blocks[];
};
*/
#undef SMUDGECACHE
#undef CLEANCACHE
#ifdef DEBUG_SECTOR_DIRT
#define SMUDGECACHE(vol,n) {	 lprintf( "set dirty on %d %d %d", n, vol->segment[n], vol->bufferFPI[n]);	 vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 lprintf( "reset dirty on %d", n);	 RESETFLAG( vol->dirty, n ); }
#else
#define SMUDGECACHE(vol,n) {    vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 RESETFLAG( vol->dirty, n ); }
#endif
#ifndef ROLLBACK_JOURNAL_DEFINED
#define ROLLBACK_JOURNAL_DEFINED
static int const seglock_mask_size = 4;
struct sack_vfs_os_BAT_info {
	FPI sectorStart;
	FPI sectorEnd;
	BLOCKINDEX blockStart;
	int size;
};
struct vfs_os_rollback_journal {
	struct sack_vfs_os_file* rollback_file;
	struct sack_vfs_os_file* rollback_journal_file;
	struct sack_vfs_os_file* rollback_small_journal_file;
	PDATALIST pdlPendingRecord;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	PDATALIST pdlJournaled;
 // sectors that are in rollback already
	BLOCKINDEX *pJournaled;
 // how long pJournaled is used
	int journalLength;
 // max length of pJournaled
	int journalAvail;
};
#ifdef small
#  undef small
#endif
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct vfs_os_rollback_entry {
	BLOCKINDEX fileBlock;
	struct {
		uint64_t small : 1;
  // block was full of 0's
		uint64_t zero : 1;
	} flags;
	// block size is retrievable when the block is reloadeded to write
// PACKED entries[1];
};
PREFIX_PACKED struct vfs_os_rollback_header {
	struct {
		uint64_t dirty : 1;
		uint64_t processing : 1;
	} flags;
  // where the blocks are tracked.
	BLOCKINDEX journal;
 // where small blocks are tracked
	BLOCKINDEX small_journal;
	BLOCKINDEX unused_rollbackLength;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	BLOCKINDEX nextEntry;
  // align entries on 4096 boundaries
	uint64_t   Filler1;
	// where this is tracked.
	struct vfs_os_rollback_entry  entries[1];
}PACKED ;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#endif
struct sack_vfs_volume {
	const char * volname;
#ifdef FILE_BASED_VFS
	FILE *file;
	struct file_system_mounted_interface *mount;
#else
	struct sack_vfs_disk *disk;
 // disk might be offset from diskReal because it's a .exe attached.
	struct sack_vfs_disk *diskReal;
#endif
	//uint32_t dirents;  // constant 0
	//uint32_t nameents; // constant 1
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BC(COUNT)];
// associated with usekey[n]
	BLOCKINDEX segment[BC(COUNT)];
#ifdef VIRTUAL_OBJECT_STORE
	struct vfs_volume_flags {
		BIT_FIELD skipRollbackProcessing : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD halted : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD versioned : 1;
	}flags;
	struct vfs_os_rollback_journal journal;
	BLOCKINDEX lastBlock;
	PDATALIST pdl_BAT_information;
	PLIST pending_rollback;
	//PDATASTACK pdsCTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
	//PDATASTACK pdsWTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
 // timeline root
	struct storageTimeline *timeline;
	enum block_cache_entries timelineCache;
 // timeline root key
	struct storageTimeline *timelineKey;
	struct sack_vfs_os_file *timeline_file;
	struct sack_vfs_os_file* timeline_index_file;
	//struct storageTimelineCursor *timeline_cache;
  // segment is locked into cache.
	MASKSET_( seglock, BC( COUNT ), 4 );
	unsigned int sector_size[BC( COUNT )];
#endif
	uint8_t fileCacheAge[BC(FILE_LAST) - BC(FILE)];
#ifdef VIRTUAL_OBJECT_STORE
	uint8_t dirHashCacheAge[BC(DIRECTORY_LAST) - BC(DIRECTORY)];
	uint8_t batHashCacheAge[BC(BAT_LAST) - BC(BAT)];
	uint8_t timelineCacheAge[BC( TIMELINE_LAST ) - BC( TIMELINE )];
	uint8_t rollbackCacheAge[BC( ROLLBACK_LAST ) - BC( ROLLBACK )];
#endif
	uint8_t nameCacheAge[BC(NAMES_LAST) - BC(NAMES)];
	struct random_context *entropy;
  // root of all cached key buffers
	uint8_t* key;
#ifdef FILE_BASED_VFS
  // root of all cached key buffers
	uint8_t* oldkey;
#endif
#ifndef VIRTUAL_OBJECT_STORE
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
 // composite key
	uint8_t* usekey[BC( COUNT )];
#endif
  // signature of executable attached as header
	uint8_t* sigkey;
  // signature of executable attached as header
	uint8_t* sigsalt;
	size_t sigkeyLength;
#  ifdef FILE_BASED_VFS
  // root buffer space of all cache blocks
	uint8_t* key_buffer;
 // data cache blocks
	uint8_t* usekey_buffer[BC(COUNT)];
 // duplicate copy of original sector data
	uint8_t* usekey_buffer_clean[BC(COUNT)];
	PTHREAD flusher;
	volatile LOGICAL flushing;
	PVARTEXT pvtDeleteBuffer;
#ifdef DEBUG_CACHE_FAULTS
	int cacheRequests[10];
	int cacheFaults[10];
#endif
	FLAGSET( dirty, BC(COUNT) );
	FLAGSET( _dirty, BC( COUNT ) );
	FPI bufferFPI[BC(COUNT)];
#  endif
	BLOCKINDEX lastBatBlock;
	PDATALIST pdlFreeBlocks;
#ifdef VIRTUAL_OBJECT_STORE
	BLOCKINDEX lastBatSmallBlock;
	PDATALIST pdlFreeSmallBlocks;
#endif
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	volatile uint32_t lock;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	THREAD_ID locked_thread;
#endif
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
};
#if !defined( VIRTUAL_OBJECT_STORE )
struct sack_vfs_file
{
 // which volume this is in
	struct sack_vfs_volume *vol;
	struct directory_entry dirent_key;
	FPI fpi;
	BLOCKINDEX _first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
	BLOCKINDEX *blockChain;
	BLOCKINDEX blockChainAvail;
	BLOCKINDEX blockChainLength;
#  ifdef FILE_BASED_VFS
  // where to write the directory entry update to
	FPI entry_fpi;
#    ifdef VIRTUAL_OBJECT_STORE
	enum block_cache_entries cache;
	struct memoryTimelineNode *timeline;
	uint8_t *seal;
	uint8_t *sealant;
	uint8_t *readKey;
	uint16_t readKeyLen;
	uint8_t sealantLen;
 // boolean, on read, validates seal.  Defaults to FALSE.
	uint8_t sealed;
	char *filename;
#    endif
  // has file size within
	struct directory_entry _entry;
  // has file size within
	struct directory_entry *entry;
#  else
  // has file size within
	struct directory_entry *entry;
#  endif
};
#endif
#  undef TSEEK
#  undef BTSEEK
#  ifdef VIRTUAL_OBJECT_STORE
#    define TSEEK(type,v,o,s,c) ((type)vfs_os_SEEK(v,o,s,&c))
#    define BTSEEK(type,v,o,s,c) ((type)vfs_os_BSEEK(v,o,s,&c))
#  elif defined FILE_BASED_VFS
#    define TSEEK(type,v,o,c) ((type)vfs_fs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_fs_BSEEK(v,o,&c))
#  else
#    define TSEEK(type,v,o,c) ((type)vfs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_BSEEK(v,o,&c))
#  endif
#if defined( __GNUC__ ) && !defined( _WIN32 )
#define HIDDEN __attribute__ ((visibility ("hidden")))
#else
#define HIDDEN
#endif
#if !defined( VIRTUAL_OBJECT_STORE ) && !defined( FILE_BASED_VFS )
  uintptr_t vfs_SEEK( struct sack_vfs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_BSEEK( struct sack_vfs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( VIRTUAL_OBJECT_STORE )
  uintptr_t vfs_os_SEEK( struct sack_vfs_os_volume* vol, FPI offset, int size, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_os_BSEEK( struct sack_vfs_os_volume* vol, BLOCKINDEX block, int size, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( FILE_BASED_VFS )
  uintptr_t vfs_fs_SEEK( struct sack_vfs_fs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_fs_BSEEK( struct sack_vfs_fs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#endif
#if defined( VIRTUAL_OBJECT_STORE ) || defined( FILE_BASED_VFS )
#   ifdef __cplusplus
}
using namespace sack::SACK_VFS;
#   endif
#  endif
static struct {
	struct directory_entry zero_entkey;
	uint8_t zerokey[BLOCK_SIZE];
} l;
#define EOFBLOCK  (~(BLOCKINDEX)0)
#define EOBBLOCK  ((BLOCKINDEX)1)
#define EODMARK   (1)
#define GFB_INIT_NONE   0
#define GFB_INIT_DIRENT 1
#define GFB_INIT_NAMES  2
static BLOCKINDEX GetFreeBlock( struct sack_vfs_volume *vol, int init );
static struct directory_entry * VFSScanDirectory( struct sack_vfs_volume *vol, const char * filename, struct directory_entry *dirkey, int path_match );
static char mytolower( int c ) {	if( c == '\\' ) return '/'; return tolower( c ); }
static int  PathCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && ( (s1[0]=='/'&&s2[0]=='\\')||(s1[0]=='\\'&&s2[0]=='/')||
									 (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0])) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
// read the byte from namespace at offset; decrypt byte in-register
// compare against the filename bytes.
static int MaskStrCmp( struct sack_vfs_volume *vol, CTEXTSTR filename, FPI name_offset, int path_match ) {
	if( vol->key ) {
		int c;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] ) )
			  && filename[0] ) {
			int del = mytolower(filename[0]) - mytolower(c);
			if( ( filename[0] == '/' && c == '\\' )
			    || ( filename[0] == '\\' && c == '/' ) )
				del = 0;
			if( del ) return del;
			filename++;
			name_offset++;
			if( path_match && !filename[0] ) {
				c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] );
				if( c == '/' || c == '\\' ) return 0;
			}
		}
		// c will be 0 or filename will be 0...
		if( path_match ) return 1;
		return filename[0] - c;
	} else {
		//LoG( "doesn't volume always have a key?" );
		if( path_match ) {
			size_t l;
			int r = PathCaseCmpEx( filename, (CTEXTSTR)(((uint8_t*)vol->disk) + name_offset), l = strlen( filename ) );
			if( !r )
				if( ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '/' || ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '\\' )
					return 0;
				else
					return 1;
			return r;
		}
		else
			return PathCaseCmpEx( filename, (CTEXTSTR)(((uint8_t*)vol->disk) + name_offset), strlen(filename) );
	}
}
#ifdef DEBUG_TRACE_LOG
static void MaskStrCpy( char *output, size_t outlen, struct sack_vfs_volume *vol, FPI name_offset ) {
	if( vol->key ) {
		int c;
		FPI name_start = name_offset;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] ) ) ) {
			if( ( name_offset - name_start ) < outlen )
				output[name_offset-name_start] = c;
			name_offset++;
		}
		if( ( name_offset - name_start ) < outlen )
			output[name_offset-name_start] = 0;
		else
			output[outlen-1] = 0;
	} else {
		//LoG( "doesn't volume always have a key?" );
		StrCpyEx( output, (const char *)(((uint8_t*)vol->disk) + name_offset), outlen );
	}
}
#endif
static void ExtendBlockChain( struct sack_vfs_file *file ) {
	FPI newSize = ( file->blockChainAvail ) * 2 + 1;
	file->blockChain = (BLOCKINDEX*)Reallocate( file->blockChain, (size_t)(newSize * sizeof( BLOCKINDEX )) );
#ifdef _DEBUG
	// debug
	memset( file->blockChain + file->blockChainAvail, 0, (newSize - file->blockChainAvail ) * sizeof(BLOCKINDEX) );
#endif
	file->blockChainAvail = newSize;
}
static void SetBlockChain( struct sack_vfs_file *file, FPI fpi, BLOCKINDEX newBlock ) {
	FPI fileBlock = fpi >> BLOCK_SIZE_BITS;
#ifdef _DEBUG
	if( !newBlock ) DebugBreak();
#endif
	while( (fileBlock) >= file->blockChainAvail ) {
		ExtendBlockChain( file );
	}
	if( fileBlock >= file->blockChainLength )
		file->blockChainLength = (fileBlock + 1);
	//_lprintf(DBG_RELAY)( "setting %d to %d", (int)fileBlock, (int)newBlock );
	if( file->blockChain[fileBlock] ) {
		if( file->blockChain[fileBlock] == newBlock ) {
			return;
		}
	}
	file->blockChain[fileBlock] = newBlock;
}
static enum block_cache_entries UpdateSegmentKey( struct sack_vfs_volume *vol, enum block_cache_entries cache_idx, BLOCKINDEX segment )
{
	if( !vol->key ) {
		vol->segment[cache_idx] = segment;
		return cache_idx;
	}
	if( cache_idx == BC(FILE) ) {
		int n, m;
		int nLeast;
		//uint8_t next = 0;
		for( n = 0; n < (BC(FILE_LAST) - BC(FILE)); n++ ) {
			if( vol->segment[cache_idx + n] == segment ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BC(FILE_LAST) - BC(FILE)); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] > vol->fileCacheAge[n] )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = m;
				break;
			}
			if( !vol->fileCacheAge[n] ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BC(FILE_LAST) - BC(FILE)); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] >( n + 1 ) )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = n + 1;
				break;
			}
			if( vol->fileCacheAge[n] == 1 ) nLeast = n;
		}
		if( n == (BC(FILE_LAST) - BC(FILE)) ) {
			for( n = 0; n < (BC(FILE_LAST) - BC(FILE)); n++ ) {
				vol->fileCacheAge[n]--;
			}
			vol->fileCacheAge[nLeast] = (BC(FILE_LAST) - BC(FILE));
			cache_idx = (enum block_cache_entries)(BC(FILE) + nLeast);
		}
	}
	vol->segment[cache_idx] = segment;
	if( vol->segment[cache_idx] == vol->_segment[cache_idx] )
		return cache_idx;
	SRG_ResetEntropy( vol->entropy );
	vol->_segment[cache_idx] = vol->segment[cache_idx];
  // so we know which 'segment[idx]' to use.
	vol->curseg = cache_idx;
	SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->segkey, SHORTKEY_LENGTH * 8 );
	{
		int n;
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[cache_idx];
		uint64_t* volkey = (uint64_t*)vol->key;
		uint64_t* segkey = (uint64_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey += 2;
			volkey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[cache_idx];
		uint32_t* volkey = (uint32_t*)vol->key;
		uint32_t* segkey = (uint32_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey[2] = volkey[2] ^ (segkey[2]);
			usekey[3] = volkey[3] ^ (segkey[3]);
			usekey += 4;
			volkey += 4;
		}
#endif
	}
	return cache_idx;
}
static LOGICAL ValidateBAT( struct sack_vfs_volume *vol ) {
	BLOCKINDEX first_slab = 0;
	BLOCKINDEX slab = (BLOCKINDEX)(vol->dwSize / ( BLOCK_SIZE ));
	BLOCKINDEX last_block = ( slab * BLOCKS_PER_BAT ) / BLOCKS_PER_SECTOR;
	BLOCKINDEX n;
	BLOCKINDEX sector;
	BLOCKINDEX sector_b = (BLOCKINDEX)-1;
	FLAGSETTYPE *usedSectors;
	if( vol->dwSize & 0xfFF ) {
		lprintf( "Volume is setup to fail with an odd number of bytes total : %d %08" _size_f, (int)(vol->dwSize & 0xFFF), vol->dwSize );
	}
	size_t size;
	usedSectors = NewArray( FLAGSETTYPE, size= (2+(vol->dwSize / BLOCK_SIZE)/(CHAR_BIT*sizeof(FLAGSETTYPE) )) );
	MemSet( usedSectors, 0, size * sizeof( FLAGSETTYPE ) );
	//if( vol->key )
	{
		for( sector = 0, n = first_slab; n < slab; n += BLOCKS_PER_SECTOR, sector++ ) {
			size_t m;
			BLOCKINDEX *BAT;
			BLOCKINDEX *blockKey;
			BLOCKINDEX *BAT_;
			BLOCKINDEX *blockKey_;
			BLOCKINDEX *checkBAT;
			BLOCKINDEX *checkBlockKey;
			BAT_      = BAT      = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE);
			UpdateSegmentKey( vol, BC(BAT), n + 1 );
			// have to update the key first... it might not be pointing at the right thing.
			blockKey_ = blockKey = ((BLOCKINDEX*)vol->usekey[BC( BAT )]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ )
			{
				BLOCKINDEX block = BAT[0] ^ blockKey[0];
				BLOCKINDEX blockIndex = (sector*BLOCKS_PER_BAT) + m;
				BAT++; blockKey++;
				if( block == EOBBLOCK ) {
					LoGB( "Bat Length was %d is now: %d (really %d)", vol->lastBatBlock, n+m, (sector*BLOCKS_PER_BAT)+m );
					vol->lastBatBlock = (BLOCKINDEX)((sector*BLOCKS_PER_BAT) + m);
					break;
				}
				if( block )
					if( !TESTFLAG( usedSectors, blockIndex ) ) {
						if( block == EOFBLOCK )
							SETFLAG( usedSectors, blockIndex );
						else {
							//BLOCKINDEX chainLen = 0;
							//enum block_cache_entries cache = BC( FILE );
							BLOCKINDEX nextBlock = block;
							BLOCKINDEX nextBlock_;
							SETFLAG( usedSectors, blockIndex );
							LoG( "ValidateBAT: following chain of blocks from block %d", blockIndex );
							while( nextBlock != EOFBLOCK ) {
								BLOCKINDEX b;
								BLOCKINDEX nn;
								if( nextBlock == EOBBLOCK ) {
									lprintf( "File chains hould not have EOB block in it." );
									DebugBreak();
								}
								if( !nextBlock ) {
									lprintf( "Empty space should never be in a file chain." );
									DebugBreak();
								}
								if( nextBlock >= last_block ) {
									Release( usedSectors );
									return FALSE;
								}
								b = nextBlock / (BLOCKS_PER_BAT);
								nn = nextBlock & (BLOCKS_PER_BAT - 1);
								if( !TESTFLAG( usedSectors, nextBlock ) ) {
									nextBlock_ = nextBlock;
									SETFLAG( usedSectors, nextBlock );
									if( b != sector ) {
										checkBAT = (BLOCKINDEX*)(((uint8_t*)vol->disk) + (b)* BLOCKS_PER_SECTOR*BLOCK_SIZE);
										checkBlockKey = ((BLOCKINDEX*)vol->usekey[BC( DATAKEY )]);
										if( b != sector_b ) {
											UpdateSegmentKey( vol, BC( DATAKEY ), ((b)* BLOCKS_PER_SECTOR) + 1 );
											sector_b = b;
										}
									}
									else {
										checkBAT = BAT_;
										checkBlockKey = blockKey_;
									}
									nextBlock = checkBAT[nn] ^ checkBlockKey[nn];
									if( !nextBlock ) {
										lprintf( "FELL OFF OF FILE CHAIN INTO EMPTY SPACE (0)! (find file and delete it?)" );
										LogBinary( (uint8_t*)usedSectors, size * sizeof( FLAGSETTYPE ) );
										DebugBreak();
										break;
									}
#ifdef DEBUG_VERBOSE_CHAIN_FOLLOW
									LoG( "Next block in chain to follow: %d %p", nextBlock, checkBAT );
#endif
								}
								else {
									if( nextBlock < ((sector*BLOCKS_PER_BAT) + m) ) {
										// this is actually ok... we just iterated over the tail part of the file.
										break;
									}
									BAT[-1] = EOFBLOCK ^ blockKey[-1];
									//return FALSE;
#ifdef _MSC_VER
#pragma warning( disable: 6001 )
#endif
									// this was something.
									// the warning _nextblock will have always been set in this state, it's
									// not uninitialized.
									lprintf( "THIS IS BAD - cross-linked files; or otherwise %d  %d", (int)nextBlock, (int)nextBlock_ );
#ifdef _MSC_VER
#pragma warning( default: 6001 )
#endif
									LogBinary( (uint8_t*)usedSectors, size * sizeof( FLAGSETTYPE ) );
									DebugBreak();
								}
								//chainLen++;
							}
						}
					}
					else {
						// block was already found in a previous file chain.
					}
				if( block == EOFBLOCK ) continue;
				if( block >= last_block ) return FALSE;
				//if( initial )
					if( block == 0 ) {
 // use as a temp variable....
						vol->lastBatBlock = (BLOCKINDEX)(sector*BLOCKS_PER_BAT + m);
						LoGB( "SET LAST BLOCK AVAIL: %d", (int)vol->lastBatBlock );
						AddDataItem( &vol->pdlFreeBlocks, &vol->lastBatBlock );
					}
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	Release( usedSectors );
	if( !VFSScanDirectory( vol, NULL, NULL, 0 ) ) return FALSE;
	return TRUE;
}
//-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
static POINTER GetExtraData( POINTER block )
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	POINTER source_memory = block;
	{
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)source_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
 // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize += (BLOCK_SIZE*2)-1;
 // mask off the low bits; floor result to block boundary
			dwSize &= ~(BLOCK_SIZE-1);
			return (POINTER)Seek( source_memory, dwSize );
		}
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
static void AddSalt2( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct datatype { void* start; size_t length; } *data = (struct datatype*)psv;
	(*salt_size) = data->length;
	(*salt) = (POINTER)data->start;
	// only need to make one pass of it....
	data->length = 0;
	data->start = NULL;
}
const uint8_t *sack_vfs_get_signature2( POINTER disk, POINTER diskReal ) {
	if( disk != diskReal ) {
		static uint8_t usekey[BLOCK_SIZE];
		static struct random_context *entropy;
		static struct datatype { void* start; size_t length; } data;
		data.start = diskReal;
		data.length = ((uintptr_t)disk - (uintptr_t)diskReal) - BLOCK_SIZE;
		if( !entropy ) entropy = SRG_CreateEntropy2( AddSalt2, (uintptr_t)&data );
		SRG_ResetEntropy( entropy );
		SRG_GetEntropyBuffer( entropy, (uint32_t*)usekey, BLOCK_SIZE*CHAR_BIT );
		return usekey;
	}
	return NULL;
}
// add some space to the volume....
static LOGICAL ExpandVolume( struct sack_vfs_volume *vol ) {
	LOGICAL created;
	//LOGICAL path_checked = FALSE;
	struct sack_vfs_disk* new_disk;
	BLOCKINDEX oldsize = (BLOCKINDEX)vol->dwSize;
	if( vol->read_only ) return TRUE;
	if( !vol->dwSize ) {
		{
			char *tmp = StrDup( vol->volname );
			char *dir = (char*)pathrchr( tmp );
			if( dir ) {
				dir[0] = 0;
				if( !IsPath( tmp ) ) MakePath( tmp );
			}
			Deallocate( char*, tmp );
		}
		new_disk = (struct sack_vfs_disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
		if( new_disk && vol->dwSize ) {
			if( vol->dwSize & BLOCK_MASK ) {
				size_t oldSize = vol->dwSize;
				lprintf( "DISK IS A BAD SIZE... trying to fix!" );
				Release( new_disk );
				vol->dwSize = (vol->dwSize + BLOCK_SIZE) & ~BLOCK_MASK;
				new_disk = (struct sack_vfs_disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
				if( !(vol->dwSize & BLOCK_MASK) ) {
					MemSet( ((uint8_t*)new_disk) + oldSize, 0, vol->dwSize - oldSize );
					lprintf( "DISK SHOULD BE OK now" );
				}
				else {
					DebugBreak();
				}
			}
			CloseSpace( vol->diskReal );
			vol->diskReal = new_disk;
#ifdef WIN32
			// elf has a different signature to check for .so extended data...
			struct sack_vfs_disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct sack_vfs_disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					if( ( ( (uintptr_t)actual_disk - (uintptr_t)new_disk ) < vol->dwSize ) ) {
						//lprintf( "Size to check %zd", (uintptr_t)actual_disk - (uintptr_t)new_disk );
						const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
						//LogBinary( sig, BLOCK_SIZE / 2 );
						if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE/2 ) ) {
							lprintf( "Signature failed comparison; the core has changed since it was attached." );
							CloseSpace( vol->diskReal );
							vol->diskReal = NULL;
							vol->dwSize = 0;
							return FALSE;
						}
						{
							char* check_sig = (char*)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE / 2 );
							int ofs;
							for( ofs = 0; ofs < BLOCK_SIZE / 2; ofs++ ) if( check_sig[0] ) break; else check_sig++;
							if( ofs < ( BLOCK_SIZE / 2 ) ){
								const uint8_t* sig = sack_vfs_get_signature2( (POINTER)( (uintptr_t)actual_disk + vol->dwSize - ((uintptr_t)actual_disk - (uintptr_t)new_disk)), actual_disk );
								if( memcmp( sig, (POINTER)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE/2 ), BLOCK_SIZE / 2 ) ){
									lprintf( "Payload signature failed." );
									CloseSpace( vol->diskReal );
									vol->diskReal = NULL;
									vol->dwSize = 0;
									return FALSE;
								}
							}
						}
						vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
						new_disk = actual_disk;
					} else {
						lprintf( "Signature failed comparison; the core is not attached to anything." );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
				}
			}
#endif
			vol->disk = new_disk;
			if( created && vol->disk == vol->diskReal ) {
				enum block_cache_entries cache = BC(DIRECTORY);
				//struct directory_entry *next_entries =
					BTSEEK( struct directory_entry *, vol, 0, cache );
				struct directory_entry *entkey = (vol->key) ? ((struct directory_entry *)vol->usekey[cache]) : &l.zero_entkey;
				// initialize directory list.
				((struct directory_entry*)(((uintptr_t)vol->disk) + BLOCK_SIZE))->first_block = EODMARK ^ entkey->first_block;
				// initialize first BAT block.
				cache = BC(BAT);
				TSEEK( BLOCKINDEX*, vol, 0, cache );
				((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[cache])[0];
			}
			return TRUE;
		}
		else {
			// really this is bad anyway.
			if( new_disk )
 // zero size result?, but with memory
				created = 1;
			else
				vol->dwSize = 0;
		}
	}
	if( oldsize ) CloseSpace( vol->diskReal );
	vol->dwSize += ((uintptr_t)vol->disk - (uintptr_t)vol->diskReal);
	// a BAT plus the sectors it references... ( BLOCKS_PER_BAT + 1 ) * BLOCK_SIZE
	vol->dwSize += BLOCKS_PER_SECTOR*BLOCK_SIZE;
	new_disk = (struct sack_vfs_disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
	if( !new_disk ) {
		DebugBreak();
	}
	LoG( "created expanded volume: %p from %p size:%" _size_f, new_disk, vol->disk, vol->dwSize );
	if( new_disk && new_disk != vol->disk ) {
		INDEX idx;
		struct sack_vfs_file *file;
		CloseSpace( vol->diskReal );
		vol->diskReal = new_disk;
#ifdef WIN32
		// elf has a different signature to check for .so extended data...
		{
			struct sack_vfs_disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct sack_vfs_disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
					if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE/2 ) ) {
						lprintf( "Signature failed comparison; the core has changed since it was attached" );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
					{
						char* check_sig = (char*)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE / 2 );
						int ofs;
						for( ofs = 0; ofs < BLOCK_SIZE / 2; ofs++ ) if( check_sig[0] ) break; else check_sig++;
						if( ofs < ( BLOCK_SIZE / 2 ) ){
							const uint8_t* sig = sack_vfs_get_signature2( (POINTER)( (uintptr_t)actual_disk + vol->dwSize - ( (uintptr_t)actual_disk - (uintptr_t)new_disk ) ), actual_disk );
							if( memcmp( sig, (POINTER)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE / 2 ), BLOCK_SIZE / 2 ) ){
								lprintf( "Payload signature failed." );
								CloseSpace( vol->diskReal );
								vol->diskReal = NULL;
								vol->dwSize = 0;
								return FALSE;
							}
						}
					}
					vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
					new_disk = actual_disk;
				}
			}
		}
#endif
		LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file ) {
			file->entry = (struct directory_entry*)((uintptr_t)file->entry - (uintptr_t)vol->disk + (uintptr_t)new_disk);
		}
		vol->disk = new_disk;
	}
	if( vol->key ) {
		BLOCKINDEX first_slab = oldsize / ( BLOCK_SIZE );
		BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
		BLOCKINDEX n;
		for( n = first_slab; n < slab; n++  ) {
			//vol->segment[BC(BAT)] = n + 1;
			if( ( n % (BLOCKS_PER_SECTOR) ) == 0 )	 UpdateSegmentKey( vol, BC(BAT), n + 1 );
#ifdef PARANOID_INIT
			else SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->usekey[BC(BAT)], BLOCK_SIZE * 8 );
#else
			else continue;
#endif
			//memcpy( ((uint8_t*)vol->disk) + n * BLOCK_SIZE, vol->usekey[BC(BAT)], BLOCK_SIZE );
			((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BC(BAT)])[0];
			memset( ((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))+1, 0, BLOCK_SIZE - sizeof( BLOCKINDEX ) );
		}
	}
	else if( !oldsize )  {
		memset( vol->disk, 0, vol->dwSize );
	} else if( oldsize )  {
		memset( ((uint8_t*)vol->disk) + oldsize, 0, (size_t)(vol->dwSize - oldsize) );
	}
	if( !oldsize ) {
		// can't recover dirents and nameents dynamically; so just assume
		// use the GetFreeBlock because it will update encypted
		//vol->disk->BAT[0] = EOFBLOCK;  // allocate 1 directory entry block
		//vol->disk->BAT[1] = EOFBLOCK;  // allocate 1 name block
		if( created && vol->disk == vol->diskReal ) {
			UpdateSegmentKey( vol, BC(BAT), 1 );
			((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BC(BAT)])[0];
		}
		/* vol->dirents = */
GetFreeBlock( vol, GFB_INIT_DIRENT );
		/* vol->nameents = */
GetFreeBlock( vol, GFB_INIT_NAMES );
	}
	return TRUE;
}
// shared with fuse module
uintptr_t vfs_SEEK( struct sack_vfs_volume *vol, FPI offset, enum block_cache_entries *cache_index ) {
	while( offset >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( offset / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + (uintptr_t)offset;
}
// shared with fuse module
uintptr_t vfs_BSEEK( struct sack_vfs_volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) {
	BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_BAT_SHIFT ) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + ( block & (BLOCKS_PER_BAT-1) ) * BLOCK_SIZE;
	while( b >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( b / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			if( (cache_index[0] == BC(FILE))
				&& (seg < 3) ) {
				lprintf( "CRITICAL FAILURE, SEEK OUT OF DISK %d", (int)seg );
#ifdef __clang__
				__builtin_trap();
#else
				( *(int*)0 ) = 0;
#endif
			}
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + (uintptr_t)b;
}
static BLOCKINDEX GetFreeBlock( struct sack_vfs_volume *vol, int init )
{
	size_t n;
	BLOCKINDEX b = 0;
	enum block_cache_entries cache = BC(BAT);
	// don't need to init to 0 anymore.
// = TSEEK( BLOCKINDEX*, vol, 0, cache );
	BLOCKINDEX *current_BAT;
	BLOCKINDEX *blockKey;
	BLOCKINDEX check_val;
	BLOCKINDEX result;
	if( vol->pdlFreeBlocks->Cnt ) {
		BLOCKINDEX newblock = ((BLOCKINDEX*)GetDataItem( &vol->pdlFreeBlocks, vol->pdlFreeBlocks->Cnt - 1 ))[0];
		LoGB( "Got free block from existin tracked blocks:%d", newblock );
		check_val = 0;
		b = newblock / BLOCKS_PER_BAT;
		n = newblock % BLOCKS_PER_BAT;
		vol->pdlFreeBlocks->Cnt--;
	}
	else {
		check_val = EOBBLOCK;
		b = vol->lastBatBlock / BLOCKS_PER_BAT;
		n = vol->lastBatBlock % BLOCKS_PER_BAT;
	}
#ifdef DEBUG_BLOCK_TRACKING
	LoG( "(should be 0(free in-bat) or 1(end of tracked)) check, start, b, n %d %d %d %d", (int)check_val, (int) vol->lastBatBlock, (int)b, (int)n );
#endif
	current_BAT = TSEEK( BLOCKINDEX*, vol, b*BLOCKS_PER_SECTOR*BLOCK_SIZE, cache ) + n;
	blockKey = ((BLOCKINDEX*)vol->usekey[cache]) + n;
	result = b * BLOCKS_PER_BAT + n;
	if( !current_BAT ) return 0;
	current_BAT[0] = EOFBLOCK ^ blockKey[0];
	LoGB( "Write to BAT: EOF at %d  %d", (int)n, result );
	if( (check_val == EOBBLOCK) ) {
		if( n < (BLOCKS_PER_BAT - 1) ) {
			current_BAT[1] = EOBBLOCK ^ blockKey[1];
			LoGB( "Write to BAT: EOB at %d  %d", (int)n+1, result + 1 );
			vol->lastBatBlock++;
		}
		else {
			cache = BC( BAT );
			LoG( "Expanding disk Here, get next block block.");
			current_BAT = TSEEK( BLOCKINDEX*, vol, (b + 1) * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[cache]);
			current_BAT[0] = EOBBLOCK ^ blockKey[0];
			LoGB( "Write to BAT: EOF at %d  %d", (int)0, (b+1) * BLOCKS_PER_BAT );
			vol->lastBatBlock = (b + 1) * BLOCKS_PER_BAT;
			//lprintf( "Set last block....%d", (int)vol->lastBatBlock );
		}
	}
	if( init ) {
		enum block_cache_entries cache;
		if( init == GFB_INIT_DIRENT )
			cache = BC( DIRECTORY );
		else if( init == GFB_INIT_NAMES )
			cache = BC( NAMES );
		else
			cache = BC( FILE );
		while( ((b * BLOCKS_PER_SECTOR +n) * BLOCK_SIZE) > vol->dwSize ) {
			LoG( "looping to get a size %d", ((vol->segment[cache] - 1)*BLOCK_SIZE) );
			if( !ExpandVolume( vol ) ) return 0;
		}
		if( init == GFB_INIT_DIRENT ) {
			uint8_t* dirsec = (uint8_t*)vfs_BSEEK( vol, result, &cache );
			((struct directory_entry*)dirsec)->first_block = EODMARK ^ ((struct directory_entry*)vol->usekey[cache])->first_block;
			//((struct directory_entry*)(((uint8_t*)vol->disk) + (vol->segment[cache] - 1) * BLOCK_SIZE))[0].first_block = EODMARK ^ ((struct directory_entry*)vol->usekey[cache])->first_block;
		}
		else if( init == GFB_INIT_NAMES ) {
			uint8_t* namesec = (uint8_t*)vfs_BSEEK( vol, result, &cache );
			((char*)namesec)[0] = ((char*)vol->usekey[cache])[0];
			//((char*)(((uint8_t*)vol->disk) + (vol->segment[cache] - 1) * BLOCK_SIZE))[0] = ((char*)vol->usekey[cache])[0];
		}
		//else
		//	memcpy( ((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE, vol->usekey[cache], BLOCK_SIZE );
	}
	//lprintf( "Return block:%d   %d  %d", (int)(b*BLOCKS_PER_BAT + n), (int)b, (int)n );
	return result;
}
static BLOCKINDEX vfs_GetNextBlock( struct sack_vfs_volume *vol, BLOCKINDEX block, int init, LOGICAL expand ) {
	BLOCKINDEX sector = block / BLOCKS_PER_BAT;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX *, vol, sector * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	BLOCKINDEX seg;
	BLOCKINDEX check_val;
 // if this passes, later ones will also.
	if( !this_BAT ) return 0;
	seg = ( ((uintptr_t)this_BAT - (uintptr_t)vol->disk) / BLOCK_SIZE ) + 1;
	if( seg != vol->segment[cache] ) {
		//vol->segment[BC(BAT)] = seg;
		UpdateSegmentKey( vol, cache, seg );
	}
	check_val = (this_BAT[block & (BLOCKS_PER_BAT - 1)]) ^ ((BLOCKINDEX*)vol->usekey[cache])[block & (BLOCKS_PER_BAT-1)];
	if( check_val == EOBBLOCK ) {
		lprintf( "the file itself should never get a EOBBLOCK in it. %d  %d", (int)block, (int)sector );
#ifdef __clang__
		__builtin_trap();
#else
		( *(int*)0 ) = 0;
#endif
		// the file itself should never get a EOBBLOCK in it.
		//(this_BAT[block & (BLOCKS_PER_BAT-1)]) = EOFBLOCK^((BLOCKINDEX*)vol->usekey[BC(BAT)])[block & (BLOCKS_PER_BAT-1)];
		//(this_BAT[1+block & (BLOCKS_PER_BAT-1)]) = EOBBLOCK^((BLOCKINDEX*)vol->usekey[BC(BAT)])[1+block & (BLOCKS_PER_BAT-1)];
	}
	if( check_val == EOFBLOCK ) {
		if( expand ) {
			BLOCKINDEX key;
			check_val = GetFreeBlock( vol, init );
			// free block might have expanded...
			cache = BC( BAT );
			this_BAT = TSEEK( BLOCKINDEX*, vol, sector * ( BLOCKS_PER_SECTOR*BLOCK_SIZE ), cache );
			key = ((BLOCKINDEX*)vol->usekey[cache])[block & (BLOCKS_PER_BAT - 1)];
			if( !this_BAT ) return 0;
#ifdef _DEBUG
			if( !block && init != GFB_INIT_DIRENT ) DebugBreak();
#endif
			// segment could already be set from the GetFreeBlock...
			this_BAT[block & (BLOCKS_PER_BAT-1)] = check_val ^ key;
			LoGB( "Write to BAT: Chain %d at %d  %d  %p", check_val, (int)(block&(BLOCKS_PER_BAT-1)), block, this_BAT );
		}
	}
	return check_val;
}
static void AddSalt( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct sack_vfs_volume *vol = (struct sack_vfs_volume *)psv;
	if( vol->sigsalt ) {
		(*salt_size) = vol->sigkeyLength;
		(*salt) = (POINTER)vol->sigsalt;
		vol->sigsalt = NULL;
	}
	else if( vol->datakey ) {
		(*salt_size) = BLOCK_SIZE;
		(*salt) = (POINTER)vol->datakey;
		vol->datakey = NULL;
	}
	else if( vol->userkey ) {
		(*salt_size) = StrLen( vol->userkey );
		(*salt) = (POINTER)vol->userkey;
		vol->userkey = NULL;
	}
	else if( vol->devkey ) {
		(*salt_size) = StrLen( vol->devkey );
		(*salt) = (POINTER)vol->devkey;
		vol->devkey = NULL;
	}
	else if( vol->segment[vol->curseg] ) {
		BLOCKINDEX sector = vol->segment[vol->curseg];
		switch( vol->clusterKeyVersion ) {
		case 0:
			( *salt_size ) = sizeof( vol->segment[vol->curseg] );
			( *salt ) = &vol->segment[vol->curseg];
			break;
		case 1:
			memcpy( vol->tmpSalt, vol->key, 16 );
			vol->tmpSalt[sector & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[0];
			vol->tmpSalt[( sector >> 4 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[1];
			vol->tmpSalt[( sector >> 8 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[2];
			vol->tmpSalt[( sector >> 12 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[3];
			( (BLOCKINDEX*)vol->tmpSalt )[0] ^= sector;
			( (BLOCKINDEX*)vol->tmpSalt )[1] ^= sector;
// sizeof( vol->segment[vol->curseg] );
			( *salt_size ) = 12;
			( *salt ) = vol->tmpSalt;
			break;
		}
	}
	else
		(*salt_size) = 0;
}
static void AssignKey( struct sack_vfs_volume *vol, const char *key1, const char *key2 )
{
	vol->userkey = key1;
	vol->devkey = key2;
	if( key1 || key2 )
	{
		uintptr_t size = BLOCK_SIZE + BLOCK_SIZE * BC(COUNT) + BLOCK_SIZE + SHORTKEY_LENGTH;
		int n;
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		else
			SRG_ResetEntropy( vol->entropy );
		vol->key = (uint8_t*)OpenSpace( NULL, NULL, &size );
		for( n = 0; n < BC(COUNT); n++ ) {
			vol->usekey[n] = vol->key + (n + 1) * BLOCK_SIZE;
			vol->segment[n] = 0;
		}
		vol->segkey = vol->key + BLOCK_SIZE * (BC(COUNT) + 1);
		vol->sigkey = vol->key + BLOCK_SIZE * (BC(COUNT) + 1) + SHORTKEY_LENGTH;
		vol->curseg = BC(DIRECTORY);
		vol->segment[BC(DIRECTORY)] = 0;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->key, BLOCK_SIZE * 8 );
	}
	else {
		int n;
		for( n = 0; n < BC(COUNT); n++ )
			vol->usekey[n] = l.zerokey;
		vol->segkey = l.zerokey;
		vol->sigkey = l.zerokey;
		vol->key = NULL;
	}
}
struct sack_vfs_volume *sack_vfs_load_volume( const char * filepath )
{
	struct sack_vfs_volume *vol = New( struct sack_vfs_volume );
	memset( vol, 0, sizeof( struct sack_vfs_volume ) );
	vol->pdlFreeBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->volname = SaveText( filepath );
	AssignKey( vol, NULL, NULL );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { Deallocate( struct sack_vfs_volume*, vol ); return NULL; }
	return vol;
}
struct sack_vfs_volume *sack_vfs_load_crypt_volume( const char * filepath, uintptr_t version, const char * userkey, const char * devkey ) {
	struct sack_vfs_volume *vol = New( struct sack_vfs_volume );
	MemSet( vol, 0, sizeof( struct sack_vfs_volume ) );
	if( !version ) version = 2;
	vol->pdlFreeBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->clusterKeyVersion = version - 1;
	vol->volname = SaveText( filepath );
	vol->userkey = userkey;
	vol->devkey = devkey;
	AssignKey( vol, userkey, devkey );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol ); return NULL; }
	return vol;
}
struct sack_vfs_volume *sack_vfs_use_crypt_volume( POINTER memory, size_t sz, uintptr_t version, const char * userkey, const char * devkey ) {
	struct sack_vfs_volume *vol = New( struct sack_vfs_volume );
	MemSet( vol, 0, sizeof( struct sack_vfs_volume ) );
	vol->read_only = 1;
	AssignKey( vol, userkey, devkey );
	if( !version ) version = 2;
	vol->pdlFreeBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->clusterKeyVersion = version - 1;
	vol->external_memory = TRUE;
	vol->diskReal = (struct sack_vfs_disk*)memory;
	vol->dwSize = sz;
#ifdef WIN32
	// elf has a different signature to check for .so extended data...
	struct sack_vfs_disk *actual_disk;
	if( ((char*)memory)[0] == 'M' && ((char*)memory)[1] == 'Z' ) {
		actual_disk = (struct sack_vfs_disk*)GetExtraData( memory );
		if( actual_disk ) {
			if( ( ( (uintptr_t)actual_disk - (uintptr_t)memory ) < vol->dwSize ) ) {
				const uint8_t *sig = sack_vfs_get_signature2( (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), memory );
				if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE/2 ) ) {
					lprintf( "Signature failed comparison; the core has changed since it was attached" );
					vol->diskReal = NULL;
					vol->dwSize = 0;
					sack_vfs_unload_volume( vol );
					return FALSE;
				}
				{
					char* check_sig = (char*)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE / 2 );
					int ofs;
					for( ofs = 0; ofs < BLOCK_SIZE / 2; ofs++ ) if( check_sig[0] ) break; else check_sig++;
					if( ofs < ( BLOCK_SIZE / 2 ) ){
						const uint8_t* sig = sack_vfs_get_signature2( (POINTER)( (uintptr_t)actual_disk + vol->dwSize - ( (uintptr_t)actual_disk - (uintptr_t)memory ) ), actual_disk );
						if( memcmp( sig, (POINTER)( ( (uintptr_t)actual_disk ) - BLOCK_SIZE / 2 ), BLOCK_SIZE / 2 ) ){
							lprintf( "Payload signature failed." );
							vol->diskReal = NULL;
							vol->dwSize = 0;
							return FALSE;
						}
					}
				}
				vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)memory);
				memory = (POINTER)actual_disk;
			} else {
				// not enough length to have a volume.
				vol->diskReal = NULL;
				vol->disk = NULL;
				vol->dwSize = 0;
				sack_vfs_unload_volume( vol );
				return NULL;
			}
		}
	}
#endif
	vol->disk = (struct sack_vfs_disk*)memory;
	if( !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol );  return NULL; }
	return vol;
}
void sack_vfs_unload_volume( struct sack_vfs_volume * vol ) {
	INDEX idx;
	struct sack_vfs_file *file;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file )
		break;
	if( file ) {
		vol->closed = TRUE;
		return;
	}
	DeleteListEx( &vol->files DBG_SRC );
	DeleteDataList( &vol->pdlFreeBlocks );
	if( !vol->external_memory )	CloseSpace( vol->diskReal );
	if( vol->key ) {
		Deallocate( uint8_t*, vol->key );
		SRG_DestroyEntropy( &vol->entropy );
	}
	Deallocate( struct sack_vfs_volume*, vol );
}
void sack_vfs_shrink_volume( struct sack_vfs_volume * vol ) {
	size_t n;
	BLOCKINDEX b = 0;
	//int found_free; // this block has free data; should be last BAT?
	BLOCKINDEX last_block = 0;
	BLOCKINDEX last_bat = 0;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
 // expand failed, tseek failed in response, so don't do anything
	if( !current_BAT ) return;
	do {
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = (BLOCKINDEX*)vol->usekey[cache];
		for( n = 0; n < BLOCKS_PER_BAT; n++ ) {
			check_val = *(current_BAT++);
			if( vol->key )	check_val ^= *(blockKey++);
			if( check_val ) {
				last_bat = b;
				last_block = n;
			}
		}
		b++;
		if( b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) < vol->dwSize ) {
			current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
		} else
			break;
	}while( 1 );
	CloseSpace( vol->diskReal );
	SetFileLength( vol->volname,
			((uintptr_t)vol->disk - (uintptr_t)vol->diskReal) +
			(size_t)(last_bat * BLOCKS_PER_SECTOR * BLOCK_SIZE + ( last_block + 1 + 1 )* BLOCK_SIZE) );
	// setting 0 size will cause expand to do an initial open instead of expanding
	vol->diskReal = NULL;
	vol->dwSize = 0;
}
static void mask_block( struct sack_vfs_volume *vol, size_t n ) {
	BLOCKINDEX b = ( 1 + (n >> BLOCK_INDEX_SHIFT) * (BLOCKS_PER_SECTOR) + (n & (BLOCKS_PER_BAT - 1)));
	UpdateSegmentKey( vol, BC(DATAKEY), b + 1 );
	{
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[BC(DATAKEY)];
		uint64_t* block = (uint64_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block += 2; usekey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[BC(DATAKEY)];
		uint32_t* block = (uint32_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block[2] = block[2] ^ usekey[2];
			block[3] = block[3] ^ usekey[3];
			block += 4; usekey += 4;
		}
#endif
	}
}
LOGICAL sack_vfs_decrypt_volume( struct sack_vfs_volume *vol )
{
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume is already decrypted, cannot remove key
	if( !vol->key ) { vol->lock = 0; return FALSE; }
	{
		enum block_cache_entries cache = BC(BAT);
		size_t n;
		BLOCKINDEX slab = vol->dwSize / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[cache]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				block[0] ^= blockKey[0];
				if( block[0] == EOBBLOCK ) break;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block++;
				blockKey++;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	AssignKey( vol, NULL, NULL );
	vol->lock = 0;
	return TRUE;
}
LOGICAL sack_vfs_encrypt_volume( struct sack_vfs_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 ) {
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume already has a key, cannot apply new key
	if( vol->key ) { vol->lock = 0; return FALSE; }
	if( !version ) version = 2;
	vol->clusterKeyVersion = version-1;
	AssignKey( vol, key1, key2 );
	{
		int done;
		size_t n;
		enum block_cache_entries cache = BC(BAT);
		BLOCKINDEX slab = (vol->dwSize + (BLOCKS_PER_SECTOR*BLOCK_SIZE-1)) / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		done = 0;
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[cache]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) done = TRUE;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block[0] ^= blockKey[0];
				if( done ) break;
				block++;
				blockKey++;
			}
			if( done ) break;
		}
	}
	vol->lock = 0;
	return TRUE;
}
const char *sack_vfs_get_signature( struct sack_vfs_volume *vol ) {
	static char signature[257];
	static const char *output = "0123456789ABCDEF";
	if( !vol )
		return NULL;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	{
		static BLOCKINDEX datakey[BLOCKS_PER_BAT];
		uint8_t* usekey = vol->key?vol->usekey[BC(DATAKEY)]:l.zerokey;
		signature[256] = 0;
		memset( datakey, 0, sizeof( datakey ) );
		{
			{
				size_t n;
				BLOCKINDEX this_dir_block = 0;
				BLOCKINDEX next_dir_block;
				BLOCKINDEX *next_entries;
				do {
					enum block_cache_entries cache = BC(DATAKEY);
					next_entries = BTSEEK( BLOCKINDEX *, vol, this_dir_block, cache );
					for( n = 0; n < BLOCKS_PER_BAT; n++ )
						datakey[n] ^= next_entries[n] ^ ((BLOCKINDEX*)(((uint8_t*)usekey)))[n];
					next_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, FALSE );
#ifdef _DEBUG
					if( this_dir_block == next_dir_block )
						DebugBreak();
					if( next_dir_block == 0 )
						DebugBreak();
#endif
					this_dir_block = next_dir_block;
				}
				while( next_dir_block != EOFBLOCK );
			}
		}
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		SRG_ResetEntropy( vol->entropy );
		vol->curseg = BC(DIRECTORY);
		vol->segment[vol->curseg] = 0;
		vol->datakey = (const char *)datakey;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)usekey, 128 * 8 );
		{
			int n;
			for( n = 0; n < 128; n++ ) {
				signature[n*2] = output[( usekey[n] >> 4 ) & 0xF];
				signature[n*2+1] = output[usekey[n] & 0xF];
			}
		}
	}
	vol->lock = 0;
	return signature;
}
struct directory_entry * VFSScanDirectory( struct sack_vfs_volume *vol, const char * filename, struct directory_entry *dirkey, int path_match ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	BLOCKINDEX next_dir_block;
	struct directory_entry *next_entries;
	if( filename && filename[0] == '.' && filename[1] == '/' ) filename += 2;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			BLOCKINDEX bi;
			enum block_cache_entries name_cache = BC(NAMES);
			struct directory_entry *entkey = ( vol->key)?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			//const char * testname;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
 // done.
			if( filename && !name_ofs )	return NULL;
			//LoG( "%d name_ofs = %" _size_f "(%" _size_f ") block = %d  vs %s"
			//   , n, name_ofs
			//   , next_entries[n].name_offset ^ entkey->name_offset
			//   , next_entries[n].first_block ^ entkey->first_block
			//   , filename );
			bi = next_entries[n].first_block ^ entkey->first_block;
			// if file is deleted; don't check it's name.
			if( !bi ) continue;
			// if file is end of directory, done sanning.
 // done.
			if( bi == EODMARK ) return filename?NULL:((struct directory_entry*)1);
			if( name_ofs > vol->dwSize ) { return NULL; }
			//testname =
			if( filename ) {
 // have to do the seek to the name block otherwise it might not be loaded.
				TSEEK( const char *, vol, name_ofs, name_cache );
				if( MaskStrCmp( vol, filename, name_ofs, path_match ) == 0 ) {
					if( dirkey ) dirkey[0] = (*entkey);
					LoG( "return found entry: %p (%" _size_f ":%" _size_f ") %s", next_entries + n, name_ofs, next_entries[n].first_block ^ dirkey->first_block, filename );
					return next_entries + n;
				}
			}
		}
		next_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
		LoG( "this_dir_block was and will be:%d %d", this_dir_block, next_dir_block );
#ifdef _DEBUG
		if( this_dir_block == next_dir_block ) DebugBreak();
  // should have a last-entry before no more blocks....
		if( next_dir_block == 0 ) { DebugBreak(); return NULL; }
#endif
		this_dir_block = next_dir_block;
	}
	while( 1 );
}
// this results in an absolute disk position
static FPI SaveFileName( struct sack_vfs_volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_name_block = 1;
	while( 1 ) {
		enum block_cache_entries cache = BC(NAMES);
		TEXTSTR names = BTSEEK( TEXTSTR, vol, this_name_block, cache );
		unsigned char *name = (unsigned char*)names;
		while( name < ( (unsigned char*)names + BLOCK_SIZE ) ) {
			int c = name[0];
			if( vol->key ) c = c ^ vol->usekey[BC(NAMES)][name-(unsigned char*)names];
			if( !c ) {
				size_t namelen;
				if( ( namelen = StrLen( filename ) ) < (size_t)( ( (unsigned char*)names + BLOCK_SIZE ) - name ) ) {
					LoG( "using unused entry for new file...%" _size_f "  %" _size_f " %s", this_name_block, (uintptr_t)name - (uintptr_t)names, filename );
					if( vol->key ) {
						for( n = 0; n < namelen + 1; n++ )
							name[n] = filename[n] ^ vol->usekey[BC(NAMES)][n + (name-(unsigned char*)names)];
						if( (namelen + 1) < (size_t)(((unsigned char*)names + BLOCK_SIZE) - name) )
							name[n] = vol->usekey[BC(NAMES)][n + (name - (unsigned char*)names)];
					} else
						memcpy( name, filename, ( namelen + 1 ) );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			}
			else
				if( MaskStrCmp( vol, filename, name - (unsigned char*)vol->disk, 0 ) == 0 ) {
					LoG( "using existing entry for new file...%s", filename );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			if( vol->key ) {
				while( ( name[0] ^ vol->usekey[BC(NAMES)][name-(unsigned char*)names] ) ) name++;
				name++;
			} else
				name = name + StrLen( (const char*)name ) + 1;
#ifdef DEBUG_NAME_POSITION_SEEK
			LoG( "new position is %" _size_f "  %" _size_f, this_name_block, (uintptr_t)name - (uintptr_t)names );
#endif
		}
		this_name_block = vfs_GetNextBlock( vol, this_name_block, GFB_INIT_NAMES, TRUE );
		LoG( "Need a new(next) name block.... %zd" , this_name_block );
	}
}
static struct directory_entry * GetNewDirectory( struct sack_vfs_volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	struct directory_entry *next_entries;
	LOGICAL moveMark = FALSE;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( vol->key )?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			struct directory_entry *ent = next_entries + n;
			FPI name_ofs = ent->name_offset ^ entkey->name_offset;
			BLOCKINDEX first_blk = ent->first_block ^ entkey->first_block;
			// not name_offset (end of list) or not first_block(free entry) use this entry
			if( name_ofs && (first_blk > 1) )  continue;
			if( first_blk == EODMARK ) moveMark = TRUE;
			name_ofs = SaveFileName( vol, filename ) ^ entkey->name_offset;
			first_blk = GetFreeBlock( vol, FALSE ) ^ entkey->first_block;
			// get free block might have expanded and moved the disk; reseek and get ent address
			next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
			ent = next_entries + n;
			ent->filesize = entkey->filesize;
			ent->name_offset = name_ofs;
			ent->first_block = first_blk;
			if( n < (VFS_DIRECTORY_ENTRIES - 1) ) {
				if( moveMark ) {
					struct directory_entry *enttmp = next_entries + (n + 1);
					enttmp->first_block = EODMARK ^ entkey[1].first_block;
				}
			} else {
				// otherwise pre-init the next directory sector
				this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
			}
			return ent;
		}
		this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
	}
	while( 1 );
}
struct sack_vfs_file * CPROC sack_vfs_openfile( struct sack_vfs_volume *vol, const char * filename ) {
	struct sack_vfs_file *file = New( struct sack_vfs_file );
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( filename[0] == '.' && filename[1] == '/' ) filename += 2;
	LoG( "sack_vfs open %s = %p on %s", filename, file, vol->volname );
	file->entry = VFSScanDirectory( vol, filename, &file->dirent_key, 0 );
	if( !file->entry ) {
		if( vol->read_only ) { LoG( "Fail open: readonly" ); vol->lock = 0; Deallocate( struct sack_vfs_file *, file ); return NULL; }
		else file->entry = GetNewDirectory( vol, filename );
	}
	if( vol->key )
		memcpy( &file->dirent_key, vol->usekey[BC(DIRECTORY)] + ( (uintptr_t)file->entry & BLOCK_MASK ), sizeof( struct directory_entry ) );
	else
		memset( &file->dirent_key, 0, sizeof( struct directory_entry ) );
	file->vol = vol;
	file->fpi = 0;
	file->delete_on_close = 0;
	file->_first_block = file->block = file->entry->first_block ^ file->dirent_key.first_block;
	LoG( "open file start file block is %d", (int)file->block );
	file->blockChain = NULL;
	file->blockChainAvail = 0;
	file->blockChainLength = 0;
	SetBlockChain( file, 0, file->block );
	AddLink( &vol->files, file );
	vol->lock = 0;
	return file;
}
static struct sack_vfs_file * CPROC sack_vfs_open( uintptr_t psvInstance, const char * filename, const char *opts ) {
	return sack_vfs_openfile( (struct sack_vfs_volume*)psvInstance, filename );
}
int CPROC sack_vfs_exists( struct sack_vfs_volume *vol, const char * file ) {
	struct directory_entry entkey;
	struct directory_entry *ent;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( file[0] == '.' && file[1] == '/' ) file += 2;
	ent = VFSScanDirectory( vol, file, &entkey, 0 );
	//lprintf( "sack_vfs exists %s %s", ent?"ya":"no", file );
	vol->lock = 0;
	if( ent ) return TRUE;
	return FALSE;
}
size_t CPROC sack_vfs_tell( struct sack_vfs_file *file ) { return (size_t)file->fpi; }
size_t CPROC sack_vfs_size( struct sack_vfs_file *file ) { return (size_t)(file->entry->filesize ^ file->dirent_key.filesize); }
size_t CPROC sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence )
{
	FPI old_fpi = file->fpi;
	BLOCKINDEX b;
	if( whence == SEEK_SET ) file->fpi = pos;
	if( whence == SEEK_CUR ) file->fpi += pos;
	if( whence == SEEK_END ) file->fpi = ( file->entry->filesize  ^ file->dirent_key.filesize ) + pos;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( file->vol->locked_thread && file->vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	if( (file->fpi >> BLOCK_SIZE_BITS) < file->blockChainLength ) {
		enum block_cache_entries cache = BC( FILE );
		file->block = file->blockChain[file->fpi >> BLOCK_SIZE_BITS];
#ifdef DEBUG_BLOCK_TRACKING
		LoG( "(_seek)File block set to %d from block chain", (int)file->block );
#endif
#ifdef _DEBUG
		if( !file->block )DebugBreak();
#endif
		//LoG( "file block is %d", (int)file->block );
		vfs_BSEEK( file->vol, file->block, &cache );
		file->vol->lock = 0;
		return (size_t)file->fpi;
	}
	else {
		file->block = b = file->blockChain[file->blockChainLength - 1];
#ifdef DEBUG_BLOCK_TRACKING
		LoG( "Need more blocks after end of file.... %d", file->block );
#endif
		old_fpi = ( file->blockChainLength - 1 ) * BLOCK_SIZE;
	}
	{
		if( ( file->fpi & ( ~BLOCK_MASK ) ) >= ( old_fpi & ( ~BLOCK_MASK ) ) ) {
			do {
				if( ( file->fpi & ( ~BLOCK_MASK ) ) == ( old_fpi & ( ~BLOCK_MASK ) ) ) {
					file->block = b;
					file->vol->lock = 0;
					LoG( "-- file block is finally %d", (int)b );
					return (size_t)file->fpi;
				}
				b = vfs_GetNextBlock( file->vol, b, FALSE, TRUE );
#ifdef DEBUG_BLOCK_TRACKING
				LoG( "-- file block will be %d   %d  %d", (int)b, (int)file->fpi, (int)(old_fpi) );
#endif
// the actual old FPI already had a block (input file->block), new FPI gets this block.
				old_fpi += BLOCK_SIZE;
				SetBlockChain( file, old_fpi, b );
				//SetBlockChain( file, old_fpi, file->block );
			} while( 1 );
		}
	}
	{
		size_t n = (size_t)(file->blockChainLength - 1);
#ifdef _DEBUG
		if( n & 0x80000000 ) DebugBreak();
#endif
		while( n * BLOCK_SIZE < ( pos & ~BLOCK_MASK ) ) {
			b = vfs_GetNextBlock( file->vol, b, FALSE, TRUE );
			n++;
		}
		file->block = b;
		LoG( "++ file block is %d", (int)file->block );
		SetBlockChain( file, file->fpi, file->block );
	}
	file->vol->lock = 0;
	return (size_t)file->fpi;
}
static void MaskBlock( struct sack_vfs_volume *vol, uint8_t* usekey, uint8_t* block, BLOCKINDEX block_ofs, size_t ofs, const char *data, size_t length ) {
	size_t n;
	block += block_ofs;
	usekey += ofs;
	if( vol->key )
		for( n = 0; n < length; n++ ) (*block++) = (*data++) ^ (*usekey++);
	else {
		for( n = 0; n < length; n++, block++, data++ ) block[0] = data[0];
		//memcpy( block, data, length );
	}
}
size_t CPROC sack_vfs_write( struct sack_vfs_file *file, const void * data_, size_t length ) {
	const char* data = (const char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( file->vol->locked_thread && file->vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	LoG( "Write to file %p %" _size_f "  @%" _size_f, file, length, file->fpi );
	if( ofs ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE - ofs;
			written += BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			if( !file->block )
				DebugBreak();
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			if( !file->block ) {
				lprintf( "File is corrupt");
				file->vol->lock = 0;
				return written;
			}
 // in case the block needs to be allocated/expanded.
			block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
			LoG( "file block is %d", (int)file->block );
			SetBlockChain( file, file->fpi, file->block );
			length -= BLOCK_SIZE - ofs;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length )
	{
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE;
			written += BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			if( !file->block )
				DebugBreak();
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			if( !file->block ) {
				lprintf( "File is corrupt");
				file->vol->lock = 0;
				return written;
			}
			LoG( "File block was %d", file->block );
 // in case the block needs to be allocated/expanded.
			block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
#ifdef _DEBUG
			if( !file->block ) DebugBreak();
#endif
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) ) {
				SetBlockChain( file, file->fpi, file->block );
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			}
			LoG( "(write,block) file block is %d", (int)file->block );
			length -= BLOCK_SIZE;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
size_t CPROC sack_vfs_read( struct sack_vfs_file *file, void * data_, size_t length ) {
	char* data = (char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( file->vol->locked_thread && file->vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < ( file->fpi + length ) ) {
		if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < file->fpi )
			length = 0;
		else
			length = (size_t)( file->entry->filesize  ^ file->dirent_key.filesize ) - (size_t)file->fpi;
	}
	if( !length ) {  file->vol->lock = 0; return 0; }
	if( ofs ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), BLOCK_SIZE - ofs );
			written += BLOCK_SIZE - ofs;
			data += BLOCK_SIZE - ofs;
			length -= BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			if( !file->block ) {
				lprintf( "File is corrupt");
				file->vol->lock = 0;
				return written;
			}
 // in case the block needs to be allocated/expanded.
			block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
			LoG( "file block is %d", (int)file->block );
			SetBlockChain( file, file->fpi, file->block );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, BLOCK_SIZE - ofs );
			written += BLOCK_SIZE;
			data += BLOCK_SIZE;
			length -= BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			if( !file->block ) {
				lprintf( "File is corrupt");
				file->vol->lock = 0;
				return written;
			}
 // in case the block needs to be allocated/expanded.
			block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
			LoG( "file block is %d", (int)file->block );
			SetBlockChain( file, file->fpi, file->block );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
static void sack_vfs_unlink_file_entry( struct sack_vfs_volume *vol, struct directory_entry *entry, struct directory_entry *entkey, BLOCKINDEX first_block, LOGICAL deleted ) {
	BLOCKINDEX block, _block;
	struct sack_vfs_file *file_found = NULL;
	struct sack_vfs_file *file;
	INDEX idx;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file ) {
		if( file->_first_block == ( entry->first_block ^ entkey->first_block ) ) {
			file_found = file;
			file->delete_on_close = TRUE;
		}
	}
	if( !deleted ) {
 // zero the block... keep the name.
		entry->first_block = entkey->first_block;
	}
	if( !file_found ) {
// entry->first_block ^ entkey->first_block;
		_block = block = first_block;
		LoG( "(marking physical deleted (again?)) entry starts at %d", block );
		// wipe out file chain BAT
		do {
			enum block_cache_entries cache = BC(BAT);
			BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_BAT_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
			BLOCKINDEX _thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[cache])[_block & (BLOCKS_PER_BAT-1)]:0;
			uint8_t* blockData = (uint8_t*)vfs_BSEEK( vol, block, &cache );
			//LoG( "Clearing file datablock...%p", (uintptr_t)blockData - (uintptr_t)vol->disk );
			memset( blockData, 0, BLOCK_SIZE );
			block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
			LoGB( "Write to BAT: 0 at %d  %d  %p (STORE FREE too)", (int)(_block&(BLOCKS_PER_BAT - 1)), _block, this_BAT );
			AddDataItem( &vol->pdlFreeBlocks, &_block );
			_block = block;
		} while( block != EOFBLOCK );
	}
}
static void shrinkBAT( struct sack_vfs_file *file ) {
	struct sack_vfs_volume *vol = file->vol;
	struct directory_entry *entry = file->entry;
	struct directory_entry *entkey = &file->dirent_key;
	BLOCKINDEX block, _block;
	size_t bsize = 0;
	_block = block = entry->first_block ^ entkey->first_block;
	do {
		enum block_cache_entries cache = BC(BAT);
		enum block_cache_entries data_cache = BC(DATAKEY);
		BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_BAT_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
		BLOCKINDEX _thiskey;
		_thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[cache])[_block & (BLOCKS_PER_BAT-1)]:0;
		block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
		if( bsize > (entry->filesize ^ entkey->filesize) ) {
			uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
			//LoG( "clearing a datablock after a file..." );
			memset( blockData, 0, BLOCK_SIZE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
		} else {
			bsize++;
			if( bsize > (entry->filesize ^ entkey->filesize) ) {
				uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
				//LoG( "clearing a partial datablock after a file..., %d, %d", BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)), ( entry->filesize & (BLOCK_SIZE-1)) );
				memset( blockData + ( entry->filesize & (BLOCK_SIZE-1)), 0, BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)) );
				this_BAT[_block & (BLOCKS_PER_BAT-1)] = ~_thiskey;
			}
		}
		_block = block;
	} while( block != EOFBLOCK );
}
size_t CPROC sack_vfs_truncate( struct sack_vfs_file *file ) { file->entry->filesize = file->fpi ^ file->dirent_key.filesize; shrinkBAT( file ); return (size_t)file->fpi; }
int CPROC sack_vfs_close( struct sack_vfs_file *file ) {
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( file->vol->locked_thread && file->vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
#ifdef DEBUG_TRACE_LOG
	{
		enum block_cache_entries cache = BC(NAMES);
		static char fname[256];
		FPI name_ofs = file->entry->name_offset ^ file->dirent_key.name_offset;
 // have to do the seek to the name block otherwise it might not be loaded.
		TSEEK( const char *, file->vol, name_ofs, cache );
		MaskStrCpy( fname, sizeof( fname ), file->vol, name_ofs );
		LoG( "close file:%s(%p)", fname, file );
	}
#endif
	DeleteLink( &file->vol->files, file );
	if( file->delete_on_close ) sack_vfs_unlink_file_entry( file->vol, file->entry, &file->dirent_key, file->_first_block, TRUE );
	file->vol->lock = 0;
	//ValidateBAT( file->vol );
	if( file->vol->closed ) sack_vfs_unload_volume( file->vol );
	Deallocate( struct sack_vfs_file *, file );
	return 0;
}
int CPROC sack_vfs_unlink_file( struct sack_vfs_volume *vol, const char * filename ) {
	int result = 0;
	struct directory_entry entkey;
	struct directory_entry *entry;
	if( !vol ) return 0;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	LoG( "unlink file:%s", filename );
	if( ( entry  = VFSScanDirectory( vol, filename, &entkey, 0 ) ) ) {
		sack_vfs_unlink_file_entry( vol, entry, &entkey, entry->first_block ^ entkey.first_block, FALSE );
		result = 1;
	}
	vol->lock = 0;
	return result;
}
	/* noop */
int CPROC sack_vfs_flush( struct sack_vfs_file *file ) {	return 0; }
static LOGICAL CPROC sack_vfs_need_copy_write( void ) {	return FALSE; }
struct sack_vfs_find_info {
	BLOCKINDEX this_dir_block;
	char filename[BLOCK_SIZE];
	struct sack_vfs_volume *vol;
	CTEXTSTR base;
	size_t base_len;
	size_t filenamelen;
	VFS_DISK_DATATYPE filesize;
	CTEXTSTR mask;
	size_t thisent;
};
struct sack_vfs_find_info * CPROC sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask )
{
	struct sack_vfs_find_info *info = New( struct sack_vfs_find_info );
	info->base = base;
	info->base_len = StrLen( base );
	info->mask = mask;
	info->vol = (struct sack_vfs_volume *)psvInst;
	return info;
}
static int iterate_find( struct sack_vfs_find_info *info ) {
	struct directory_entry *next_entries;
	size_t n;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		enum block_cache_entries name_cache = BC(NAMES);
		next_entries = BTSEEK( struct directory_entry *, info->vol, info->this_dir_block, cache );
		for( n = info->thisent; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( info->vol->key)?((struct directory_entry *)info->vol->usekey[cache])+n:&l.zero_entkey;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
			if( !name_ofs )
				return 0;
			// if file is deleted; don't check it's name.
			if( !(next_entries[n].first_block ^ entkey->first_block ) )
				continue;
			if( (next_entries[n].first_block ^ entkey->first_block ) == EODMARK )
 // end of directory.
				return 0;
			info->filesize = next_entries[n].filesize ^ entkey->filesize;
			if( (name_ofs) > info->vol->dwSize ) {
				LoG( "corrupted volume." );
				return 0;
			}
			TSEEK( const char *, info->vol, name_ofs, name_cache );
			if( info->vol->key ) {
				int c;
				info->filenamelen = 0;
				while( ( c = ( ((uint8_t*)info->vol->disk)[name_ofs] ^ info->vol->usekey[name_cache][name_ofs&BLOCK_MASK] ) ) ) {
					info->filename[info->filenamelen++] = c;
					name_ofs++;
				}
				info->filename[info->filenamelen]	 = c;
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			} else {
				StrCpy( info->filename, (const char *)(((uint8_t*)info->vol->disk) + name_ofs) );
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			}
			info->thisent = n + 1;
			return 1;
		}
 // new block, set new starting index.
		info->thisent = 0;
		info->this_dir_block = vfs_GetNextBlock( info->vol, info->this_dir_block, FALSE, FALSE );
	}
	while( info->this_dir_block != EOFBLOCK );
	return 0;
}
int CPROC sack_vfs_find_first( struct sack_vfs_find_info *info ) {
	info->this_dir_block = 0;
	info->thisent = 0;
	return iterate_find( info );
}
int CPROC sack_vfs_find_close( struct sack_vfs_find_info *info ) { Deallocate( struct sack_vfs_find_info*, info ); return 0; }
int CPROC sack_vfs_find_next( struct sack_vfs_find_info *info ) { return iterate_find( info ); }
char * CPROC sack_vfs_find_get_name( struct sack_vfs_find_info *info ) { return ((struct sack_vfs_find_info*)info)->filename; }
size_t CPROC sack_vfs_find_get_size( struct sack_vfs_find_info *info ) { return (size_t)((struct sack_vfs_find_info*)info)->filesize; }
LOGICAL CPROC sack_vfs_find_is_directory( struct sack_vfs_find_info *cursor ) { return FALSE; }
LOGICAL CPROC sack_vfs_is_directory( uintptr_t psvInstance, const char *path ) {
	if( path[0] == '.' && path[1] == 0 ) return TRUE;
	{
		struct sack_vfs_volume *vol = (struct sack_vfs_volume *)psvInstance;
		if( VFSScanDirectory( vol, path, NULL, 1 ) ) {
			return TRUE;
		}
	}
	return FALSE;
}
uint64_t CPROC sack_vfs_find_get_ctime( struct sack_vfs_find_info *info ) { return (size_t)0; }
uint64_t CPROC sack_vfs_find_get_wtime( struct sack_vfs_find_info *info ) { return (size_t)0; }
LOGICAL CPROC sack_vfs_rename( uintptr_t psvInstance, const char *original, const char *newname ) {
	struct sack_vfs_volume *vol = (struct sack_vfs_volume *)psvInstance;
	// fail if the names are the same.
	if( strcmp( original, newname ) == 0 )
		return FALSE;
	if( vol ) {
		struct directory_entry entkey;
		struct directory_entry *entry;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
		while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
		while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
		if( ( entry  = VFSScanDirectory( vol, original, &entkey, 0 ) ) ) {
			struct directory_entry new_entkey;
			struct directory_entry *new_entry;
			if( (new_entry = VFSScanDirectory( vol, newname, &new_entkey, 0 )) ) {
				vol->lock = 0;
				sack_vfs_unlink_file( vol, newname );
#ifdef VFS_IMPLEMENT_FILE_LOCKING
				while( vol->locked_thread && vol->locked_thread != GetThisThreadID() ) Relinquish();
#endif
				while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
			}
			entry->name_offset = SaveFileName( vol, newname ) ^ entkey.name_offset;
			vol->lock = 0;
			return TRUE;
		}
		vol->lock = 0;
	}
	return FALSE;
}
#ifdef VFS_IMPLEMENT_FILE_LOCKING
int CPROC sack_vfs_file_lock( struct sack_vfs_file* file, int disposition ) {
	while( LockedExchange64( &file->vol->locked_thread, GetThisThreadID() ) ) Relinquish();
	return 1;
}
int CPROC sack_vfs_file_unlock( struct sack_vfs_file* file, int disposition ) {
	file->vol->locked_thread = 0;
	return 1;
}
#endif
static struct file_system_interface sack_vfs_fsi = {
                                                     (void*(CPROC*)(uintptr_t,const char *, const char*))sack_vfs_open
                                                   , (int(CPROC*)(void*))sack_vfs_close
                                                   , (size_t(CPROC*)(void*,void*,size_t))sack_vfs_read
                                                   , (size_t(CPROC*)(void*,const void*,size_t))sack_vfs_write
                                                   , (size_t(CPROC*)(void*,size_t,int))sack_vfs_seek
                                                   , (void(CPROC*)(void*))sack_vfs_truncate
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_unlink_file
                                                   , (size_t(CPROC*)(void*))sack_vfs_size
                                                   , (size_t(CPROC*)(void*))sack_vfs_tell
                                                   , (int(CPROC*)(void*))sack_vfs_flush
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_exists
                                                   , sack_vfs_need_copy_write
                                                   , (struct find_cursor*(CPROC*)(uintptr_t,const char *,const char *))             sack_vfs_find_create_cursor
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_first
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_close
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_next
                                                   , (char*(CPROC*)(struct find_cursor*))           sack_vfs_find_get_name
                                                   , (size_t(CPROC*)(struct find_cursor*))          sack_vfs_find_get_size
                                                   , (LOGICAL(CPROC*)(struct find_cursor *))        sack_vfs_find_is_directory
                                                   , sack_vfs_is_directory
                                                   , sack_vfs_rename
	, (uintptr_t( CPROC* )(uintptr_t, uintptr_t, va_list))NULL
	, (uintptr_t( CPROC* )(uintptr_t, uintptr_t, va_list))NULL
	, (uint64_t( CPROC* )(struct find_cursor* cursor))sack_vfs_find_get_ctime
	, (uint64_t( CPROC* )(struct find_cursor* cursor))sack_vfs_find_get_wtime
	 //int (CPROC* _mkdir)(uintptr_t psvInstance, const char*);
	, NULL
 //int (CPROC* _rmdir)(uintptr_t psvInstance, const char*);
	, NULL
 //(int(CPROC*)(void*))sack_vfs_file_lock
	, NULL
 //(int(CPROC*)(void*))sack_vfs_file_unlock
	, NULL
};
PRIORITY_PRELOAD( Sack_VFS_Register, VIRTUAL_FILESYSTEM_PRELOAD_PRIORITY )
{
#ifdef ALT_VFS_NAME
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME ".runner"
#else
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME
#endif
	sack_register_filesystem_interface( DEFAULT_VFS_NAME, &sack_vfs_fsi );
}
PRIORITY_PRELOAD( Sack_VFS_RegisterDefaultFilesystem, SQL_PRELOAD_PRIORITY + 1 ) {
	if( SACK_GetProfileInt( GetProgramName(), "SACK/VFS/Mount VFS", 0 ) ) {
		struct sack_vfs_volume *vol;
		TEXTCHAR volfile[256];
		TEXTSTR tmp;
		SACK_GetProfileString( GetProgramName(), "SACK/VFS/File", "*/../assets.svfs", volfile, 256 );
		tmp = ExpandPath( volfile );
		vol = sack_vfs_load_volume( tmp );
		Deallocate( TEXTSTR, tmp );
		sack_mount_filesystem( "sack_shmem", sack_get_filesystem_interface( DEFAULT_VFS_NAME )
		                     , 900, (uintptr_t)vol, TRUE );
	}
}
SACK_VFS_NAMESPACE_END
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#  pragma warning( default: 26451 )
#endif
/*
 BLOCKINDEX BAT[BLOCKS_PER_BAT] // link of next blocks; 0 if free, FFFFFFFF if end of file block
 uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
 // (1+BLOCKS_PER_BAT) * BLOCK_SIZE total...
 BAT[0] = first directory cluster; array of struct directory_entry
 BAT[1] = name space; directory offsets land in a block referenced by this chain
 */
#define SACK_VFS_SOURCE
//#define USE_STDIO
#if 1
 // tolower on linux
#ifndef USE_STDIO
#endif
#else
 // tolower on linux
//#include <filesys.h>
//#include <procreg.h>
//#include <salty_generator.h>
//#include <sack_vfs.h>
//#include <sqlgetoption.h>
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#pragma warning( disable: 26451 )
#endif
#ifdef USE_STDIO
#define sack_fopen(a,b,c)     fopen(b,c)
#define sack_fseek(a,b,c)     fseek(a,(long)b,c)
#define sack_fclose(a)        fclose(a)
#define sack_fread(a,b,c,d)   fread(a,b,c,d)
#define sack_fwrite(a,b,c,d)  fwrite(a,b,c,d)
#define sack_ftell(a)         ftell(a)
#ifdef __cplusplus
namespace sack {
	namespace filesys {
#endif
		// pathops.c
		extern LOGICAL  CPROC  IsPath( CTEXTSTR path );
		extern  int CPROC  MakePath( CTEXTSTR path );
		extern CTEXTSTR CPROC pathrchr( CTEXTSTR path );
		extern CTEXTSTR CPROC pathchr( CTEXTSTR path );
#ifdef __cplusplus
	}
}
using namespace sack::filesys;
#endif
#endif
SACK_VFS_NAMESPACE
#define FILE_BASED_VFS
#ifndef _MSC_VER
#endif
/**************
  VFS_VERSION
     used to track migration of keys and keying methods.
  0x100 = version 1; SHORTKEY_LENGTH = 16
 **************/
#define VFS_VERSION     0x100
// 12 bits = 1 << 12 = 4096
#define BLOCK_SIZE_BITS 12
// BLOCKINDEX is either 4 or 8 bytes... sizeof( size_t )...
// all constants though should compile out to a single value... and just for grins went to 16 bit size_t and 0 shift... or 1 byte
#define BLOCK_BAT_SHIFT (BLOCK_SIZE_BITS-(sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_INDEX_SHIFT ((sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_BYTE_SHIFT (BLOCK_SIZE_BITS)
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
#define BLOCK_SMALL_SIZE     256
#define DIR_BLOCK_SIZE_BITS   12
#define DIR_BLOCK_SIZE      (1<<DIR_BLOCK_SIZE_BITS)
#define BAT_BLOCK_SIZE      4096
#define NAME_BLOCK_SIZE     4096
#define KEY_SIZE            1024
#define TIME_BLOCK_SIZE     4096
#define ROLLBACK_BLOCK_SIZE 4096
#define FILE_NAME_MAXLEN    4096
#define BLOCK_MASK (BLOCK_SIZE-1)
#ifdef VIRTUAL_OBJECT_STORE
// if the block index & BAT_BLOCK_MASK, is a data block
// all BATs are 4096
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT)-1)
#  define BLOCK_SECTOR_MASK BLOCKS_PER_BAT
#else
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT))
#  define BLOCK_SECTOR_MASK (BLOCKS_PER_BAT-1)
#endif
#define BAT_BLOCK_MASK ( ( BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT ) - 1)
#define BLOCKS_PER_SECTOR (1+BLOCKS_PER_BAT)
// per-sector perumation; needs to be a power of 2 (in bytes)
#define SHORTKEY_LENGTH 16
#ifndef VFS_DISK_DATATYPE
#  define VFS_DISK_DATATYPE size_t
#endif
 // BLOCK_SIZE blocks...
typedef VFS_DISK_DATATYPE BLOCKINDEX;
 // file position type
typedef VFS_DISK_DATATYPE FPI;
/* BEFORE DEF */
#undef BC
#ifdef VIRTUAL_OBJECT_STORE
/* THIS DEFINES SACK_VFS_OS_VOLUME */
#  define BC(n) BLOCK_CACHE_VOS_##n
#    ifdef sack_vfs_volume
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_os
#    define directory_entry directory_entry_os
#    define sack_vfs_disk sack_vfs_disk_os
#    define sack_vfs_diskSection sack_vfs_diskSection_os
#    define directory_hash_lookup_block directory_hash_lookup_block_os
#    define sack_vfs_volume sack_vfs_os_volume
#    define sack_vfs_file sack_vfs_os_file
#   ifdef __cplusplus
namespace objStore {
#   endif
#elif defined FILE_BASED_VFS
#  define BC(n) BLOCK_CACHE_FS_##n
#    ifdef block_cache_entries
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_fs
#    define directory_entry directory_entry_fs
#    define sack_vfs_disk sack_vfs_disk_fs
#    define sack_vfs_diskSection sack_vfs_diskSection_fs
#    define directory_hash_lookup_block directory_hash_lookup_block_fs
/* THIS DEFINES SACK_VS_VOLUME */
#    define sack_vfs_volume sack_vfs_fs_volume
#    define sack_vfs_file sack_vfs_fs_file
#   ifdef __cplusplus
namespace fs {
#   endif
#else
#  define BC(n) BLOCK_CACHE_##n
#endif
/* AFTER DEF */
enum block_cache_entries
{
	BC( ZERO )
	, BC( DIRECTORY ) = 0
#ifdef VIRTUAL_OBJECT_STORE
	, BC( DIRECTORY_LAST ) = BC( DIRECTORY ) + 64
#endif
	, BC( NAMES )
	, BC( NAMES_LAST ) = BC( NAMES ) + 16
	, BC( BAT )
#ifdef VIRTUAL_OBJECT_STORE
	// keep a few tables for cache (file system too?)
	, BC( BAT_LAST ) = BC( BAT ) + 16
#endif
	, BC(DATAKEY)
	, BC(FILE)
	, BC(FILE_LAST) = BC(FILE) + 32
#ifdef VIRTUAL_OBJECT_STORE
	, BC( TIMELINE )
	, BC( TIMELINE_LAST ) = BC( TIMELINE ) + 48
#endif
#if defined( VIRTUAL_OBJECT_STORE )
	// really shouldn't need more than one of these...
	// record
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// replay
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// 1 - target disk sector
	, BC( ROLLBACK )
	, BC( ROLLBACK_LAST ) = BC( ROLLBACK ) + 6
#endif
#if defined( VIRTUAL_OBJECT_STORE ) && defined( DEBUG_VALIDATE_TREE )
	// debug timeline, keep a mirror for comparisons, when links were lost, etc...
	// can be factored out at some point.
	, BC( TIMELINE_RO )
	, BC( TIMELINE_RO_LAST ) = BC( TIMELINE_RO ) + 48
#endif
	, BC(COUNT)
};
// could effecitvely be fewer than this
// 82 dirents * 512 byte names = 40000
#define DIRENT_NAME_OFFSET_OFFSET             0x0001FFFF
// (sealant length / 4)  (mulitply by 4 to get real length)
#define DIRENT_NAME_OFFSET_FLAG_SEALANT       0x003E0000
#define DIRENT_NAME_OFFSET_FLAG_SEALANT_SHIFT 17
#define DIRENT_NAME_OFFSET_FLAG_OWNED         0x00400000
#define DIRENT_NAME_OFFSET_FLAG_READ_KEYED    0x00800000
// unused flag; previous indicated versioning.
#define DIRENT_NAME_OFFSET_UNUSED_0         0x01000000
#define DIRENT_NAME_OFFSET_VERSION_SHIFT      25
#define DIRENT_NAME_OFFSET_VERSIONS           0x1E000000
#define DIRENT_NAME_OFFSET_UNUSED             0xFE000000
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct directory_entry
{
  // name offset from beginning of disk
	FPI name_offset;
  // first block of data of the file
	BLOCKINDEX first_block;
  // how big the file is
	VFS_DISK_DATATYPE filesize;
#ifdef VIRTUAL_OBJECT_STORE
  // when the file was created/last written
	uint64_t timelineEntry;
#endif
} PACKED;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#undef VFS_DIRECTORY_ENTRIES
#ifdef VIRTUAL_OBJECT_STORE
// subtract name has index
// subtrace name index
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE - ( 2*sizeof(BLOCKINDEX) + 256*sizeof(BLOCKINDEX)) ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#else
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#endif
/*
struct sack_vfs_diskSection
{
	// BAT is at 0 of every BLOCK_SIZE blocks (4097 total)
	// &BAT[0] == itself....
	// BAT[0] == first directory entry (actually next entry; first is always here)
	// BAT[1] == first name entry (actually next name block; first is known as here)
	// bat[BLOCK_SIZE] == NEXT_BAT[0]; NEXT_BAT = BAT + BLOCK_SIZE + 1024*BLOCK_SIZE;
	// bat[8192] == ... ( 0 + ( BLOCK_SIZE + BLOCKS_PER_BAT*BLOCK_SIZE ) * N >> 12 )
	BLOCKINDEX BAT[BLOCKS_PER_BAT];
	//struct directory_entry directory[BLOCK_SIZE/sizeof( struct directory_entry)]; // 256
	//char  names[BLOCK_SIZE/sizeof(char)];
	uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
};
struct sack_vfs_disk {
	struct sack_vfs_diskSection firstBlock;
	struct sack_vfs_diskSection blocks[];
};
*/
#undef SMUDGECACHE
#undef CLEANCACHE
#ifdef DEBUG_SECTOR_DIRT
#define SMUDGECACHE(vol,n) {	 lprintf( "set dirty on %d %d %d", n, vol->segment[n], vol->bufferFPI[n]);	 vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 lprintf( "reset dirty on %d", n);	 RESETFLAG( vol->dirty, n ); }
#else
#define SMUDGECACHE(vol,n) {    vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 RESETFLAG( vol->dirty, n ); }
#endif
#ifndef ROLLBACK_JOURNAL_DEFINED
#define ROLLBACK_JOURNAL_DEFINED
static int const seglock_mask_size = 4;
struct sack_vfs_os_BAT_info {
	FPI sectorStart;
	FPI sectorEnd;
	BLOCKINDEX blockStart;
	int size;
};
struct vfs_os_rollback_journal {
	struct sack_vfs_os_file* rollback_file;
	struct sack_vfs_os_file* rollback_journal_file;
	struct sack_vfs_os_file* rollback_small_journal_file;
	PDATALIST pdlPendingRecord;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	PDATALIST pdlJournaled;
 // sectors that are in rollback already
	BLOCKINDEX *pJournaled;
 // how long pJournaled is used
	int journalLength;
 // max length of pJournaled
	int journalAvail;
};
#ifdef small
#  undef small
#endif
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct vfs_os_rollback_entry {
	BLOCKINDEX fileBlock;
	struct {
		uint64_t small : 1;
  // block was full of 0's
		uint64_t zero : 1;
	} flags;
	// block size is retrievable when the block is reloadeded to write
// PACKED entries[1];
};
PREFIX_PACKED struct vfs_os_rollback_header {
	struct {
		uint64_t dirty : 1;
		uint64_t processing : 1;
	} flags;
  // where the blocks are tracked.
	BLOCKINDEX journal;
 // where small blocks are tracked
	BLOCKINDEX small_journal;
	BLOCKINDEX unused_rollbackLength;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	BLOCKINDEX nextEntry;
  // align entries on 4096 boundaries
	uint64_t   Filler1;
	// where this is tracked.
	struct vfs_os_rollback_entry  entries[1];
}PACKED ;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#endif
struct sack_vfs_volume {
	const char * volname;
#ifdef FILE_BASED_VFS
	FILE *file;
	struct file_system_mounted_interface *mount;
#else
	struct sack_vfs_disk *disk;
 // disk might be offset from diskReal because it's a .exe attached.
	struct sack_vfs_disk *diskReal;
#endif
	//uint32_t dirents;  // constant 0
	//uint32_t nameents; // constant 1
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BC(COUNT)];
// associated with usekey[n]
	BLOCKINDEX segment[BC(COUNT)];
#ifdef VIRTUAL_OBJECT_STORE
	struct vfs_volume_flags {
		BIT_FIELD skipRollbackProcessing : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD halted : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD versioned : 1;
	}flags;
	struct vfs_os_rollback_journal journal;
	BLOCKINDEX lastBlock;
	PDATALIST pdl_BAT_information;
	PLIST pending_rollback;
	//PDATASTACK pdsCTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
	//PDATASTACK pdsWTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
 // timeline root
	struct storageTimeline *timeline;
	enum block_cache_entries timelineCache;
 // timeline root key
	struct storageTimeline *timelineKey;
	struct sack_vfs_os_file *timeline_file;
	struct sack_vfs_os_file* timeline_index_file;
	//struct storageTimelineCursor *timeline_cache;
  // segment is locked into cache.
	MASKSET_( seglock, BC( COUNT ), 4 );
	unsigned int sector_size[BC( COUNT )];
#endif
	uint8_t fileCacheAge[BC(FILE_LAST) - BC(FILE)];
#ifdef VIRTUAL_OBJECT_STORE
	uint8_t dirHashCacheAge[BC(DIRECTORY_LAST) - BC(DIRECTORY)];
	uint8_t batHashCacheAge[BC(BAT_LAST) - BC(BAT)];
	uint8_t timelineCacheAge[BC( TIMELINE_LAST ) - BC( TIMELINE )];
	uint8_t rollbackCacheAge[BC( ROLLBACK_LAST ) - BC( ROLLBACK )];
#endif
	uint8_t nameCacheAge[BC(NAMES_LAST) - BC(NAMES)];
	struct random_context *entropy;
  // root of all cached key buffers
	uint8_t* key;
#ifdef FILE_BASED_VFS
  // root of all cached key buffers
	uint8_t* oldkey;
#endif
#ifndef VIRTUAL_OBJECT_STORE
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
 // composite key
	uint8_t* usekey[BC( COUNT )];
#endif
  // signature of executable attached as header
	uint8_t* sigkey;
  // signature of executable attached as header
	uint8_t* sigsalt;
	size_t sigkeyLength;
#  ifdef FILE_BASED_VFS
  // root buffer space of all cache blocks
	uint8_t* key_buffer;
 // data cache blocks
	uint8_t* usekey_buffer[BC(COUNT)];
 // duplicate copy of original sector data
	uint8_t* usekey_buffer_clean[BC(COUNT)];
	PTHREAD flusher;
	volatile LOGICAL flushing;
	PVARTEXT pvtDeleteBuffer;
#ifdef DEBUG_CACHE_FAULTS
	int cacheRequests[10];
	int cacheFaults[10];
#endif
	FLAGSET( dirty, BC(COUNT) );
	FLAGSET( _dirty, BC( COUNT ) );
	FPI bufferFPI[BC(COUNT)];
#  endif
	BLOCKINDEX lastBatBlock;
	PDATALIST pdlFreeBlocks;
#ifdef VIRTUAL_OBJECT_STORE
	BLOCKINDEX lastBatSmallBlock;
	PDATALIST pdlFreeSmallBlocks;
#endif
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	volatile uint32_t lock;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	THREAD_ID locked_thread;
#endif
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
};
#if !defined( VIRTUAL_OBJECT_STORE )
struct sack_vfs_file
{
 // which volume this is in
	struct sack_vfs_volume *vol;
	struct directory_entry dirent_key;
	FPI fpi;
	BLOCKINDEX _first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
	BLOCKINDEX *blockChain;
	BLOCKINDEX blockChainAvail;
	BLOCKINDEX blockChainLength;
#  ifdef FILE_BASED_VFS
  // where to write the directory entry update to
	FPI entry_fpi;
#    ifdef VIRTUAL_OBJECT_STORE
	enum block_cache_entries cache;
	struct memoryTimelineNode *timeline;
	uint8_t *seal;
	uint8_t *sealant;
	uint8_t *readKey;
	uint16_t readKeyLen;
	uint8_t sealantLen;
 // boolean, on read, validates seal.  Defaults to FALSE.
	uint8_t sealed;
	char *filename;
#    endif
  // has file size within
	struct directory_entry _entry;
  // has file size within
	struct directory_entry *entry;
#  else
  // has file size within
	struct directory_entry *entry;
#  endif
};
#endif
#  undef TSEEK
#  undef BTSEEK
#  ifdef VIRTUAL_OBJECT_STORE
#    define TSEEK(type,v,o,s,c) ((type)vfs_os_SEEK(v,o,s,&c))
#    define BTSEEK(type,v,o,s,c) ((type)vfs_os_BSEEK(v,o,s,&c))
#  elif defined FILE_BASED_VFS
#    define TSEEK(type,v,o,c) ((type)vfs_fs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_fs_BSEEK(v,o,&c))
#  else
#    define TSEEK(type,v,o,c) ((type)vfs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_BSEEK(v,o,&c))
#  endif
#if defined( __GNUC__ ) && !defined( _WIN32 )
#define HIDDEN __attribute__ ((visibility ("hidden")))
#else
#define HIDDEN
#endif
#if !defined( VIRTUAL_OBJECT_STORE ) && !defined( FILE_BASED_VFS )
  uintptr_t vfs_SEEK( struct sack_vfs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_BSEEK( struct sack_vfs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( VIRTUAL_OBJECT_STORE )
  uintptr_t vfs_os_SEEK( struct sack_vfs_os_volume* vol, FPI offset, int size, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_os_BSEEK( struct sack_vfs_os_volume* vol, BLOCKINDEX block, int size, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( FILE_BASED_VFS )
  uintptr_t vfs_fs_SEEK( struct sack_vfs_fs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_fs_BSEEK( struct sack_vfs_fs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#endif
#if defined( VIRTUAL_OBJECT_STORE ) || defined( FILE_BASED_VFS )
#   ifdef __cplusplus
}
using namespace sack::SACK_VFS;
#   endif
#  endif
#ifdef __cplusplus
namespace fs {
#endif
//#define PARANOID_INIT
//#define DEBUG_TRACE_LOG
#ifdef DEBUG_TRACE_LOG
#define LoG( a,... ) lprintf( a,##__VA_ARGS__ )
#else
#define LoG( a,... )
#endif
#undef TSEEK
#define TSEEK(type,v,o,c) ((type)vfs_fs_SEEK(v,o,&c))
#undef BTSEEK
#define BTSEEK(type,v,o,c) ((type)vfs_fs_BSEEK(v,o,&c))
#define l vfs_fs_local
static struct {
	struct directory_entry zero_entkey;
	uint8_t zerokey[BLOCK_SIZE];
} l;
#define EOFBLOCK  (~(BLOCKINDEX)0)
#define EOBBLOCK  ((BLOCKINDEX)1)
#define EODMARK   (1)
#define GFB_INIT_NONE   0
#define GFB_INIT_DIRENT 1
#define GFB_INIT_NAMES  2
static BLOCKINDEX _fs_GetFreeBlock( struct sack_vfs_fs_volume *vol, int init );
static LOGICAL _fs_ScanDirectory( struct sack_vfs_fs_volume *vol, const char * filename, FPI *dirFPI, struct directory_entry *dirent, struct directory_entry *dirkey, int path_match );
static char _fs_mytolower( int c ) {	if( c == '\\' ) return '/'; return tolower( c ); }
static int  _fs_PathCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && ( (s1[0]=='/'&&s2[0]=='\\')||(s1[0]=='\\'&&s2[0]=='/')||
									 (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0])) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
// read the byte from namespace at offset; decrypt byte in-register
// compare against the filename bytes.
static int _fs_MaskStrCmp( struct sack_vfs_fs_volume *vol, CTEXTSTR filename, FPI name_offset, int path_match ) {
	const char *dirname = (const char*)(vol->usekey_buffer[BC(NAMES)] + (name_offset&BLOCK_MASK));
	if( vol->key ) {
		int c;
		while(  ( c = (dirname[name_offset] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] ) )
			  && filename[0] ) {
			int del = _fs_mytolower(filename[0]) - _fs_mytolower(c);
			if( del ) return del;
			filename++;
			name_offset++;
			if( path_match && !filename[0] ) {
				c = (dirname[name_offset] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] );
				if( c == '/' || c == '\\' ) return 0;
			}
		}
		// c will be 0 or filename will be 0...
		if( path_match ) return 1;
		return filename[0] - c;
	} else {
		//LoG( "doesn't volume always have a key?" );
		if( path_match ) {
			size_t l;
			int r = _fs_PathCaseCmpEx( filename, dirname + name_offset, l = strlen( filename ) );
			if( !r )
				if( (dirname + name_offset)[l] == '/' || (dirname + name_offset)[l] == '\\' )
					return 0;
				else
					return 1;
			return r;
		}
		else
			return _fs_PathCaseCmpEx( filename, dirname, strlen(filename) );
	}
}
#ifdef DEBUG_TRACE_LOG
static void _fs_MaskStrCpy( char *output, size_t outlen, struct sack_vfs_fs_volume *vol, FPI name_offset ) {
	if( vol->key ) {
		int c;
		FPI name_start = name_offset;
		while(  ( c = ( vol->usekey_buffer[BC(NAMES)][name_offset&BLOCK_MASK] ^ vol->usekey[BC(NAMES)][name_offset&BLOCK_MASK] ) ) ) {
			if( ( name_offset - name_start ) < outlen )
				output[name_offset-name_start] = c;
			name_offset++;
		}
		if( ( name_offset - name_start ) < outlen )
			output[name_offset-name_start] = 0;
		else
			output[outlen-1] = 0;
	} else {
		//LoG( "doesn't volume always have a key?" );
		StrCpyEx( output, (const char *)(vol->usekey[BC(NAMES)] + (name_offset & BLOCK_MASK )), outlen );
	}
}
#endif
#ifdef _MSC_VER
// this is about nLeast being uninitialized.  If nLeast is used
// its value will have been set; otherwise it will not be used.
#pragma warning( disable: 6001 )
#endif
static int _fs_updateCacheAge( struct sack_vfs_fs_volume *vol, enum block_cache_entries *cache_idx, BLOCKINDEX segment, uint8_t *age, int ageLength ) {
	int n, m;
	int nLeast;
	for( n = 0; n < (ageLength); n++ ) {
		if( vol->segment[cache_idx[0] + n] == segment ) {
			cache_idx[0] = (enum block_cache_entries)((cache_idx[0])+n);
			for( m = 0; m < (ageLength); m++ ) {
				if( !age[m] ) break;
				if( age[m] > age[n] )
					age[m]--;
			}
			age[n] = m;
			break;
		}
		if( !age[n] ) {
			cache_idx[0] = (enum block_cache_entries)((cache_idx[0])+n);
			for( m = 0; m < (ageLength); m++ ) {
				if( !age[m] ) break;
				if( age[m] > ( n + 1 ) )
					age[m]--;
			}
			age[n] = n + 1;
			break;
		}
		if( age[n] == 1 ) nLeast = n;
	}
	if( n == (ageLength) ) {
		for( n = 0; n < (ageLength); n++ ) {
			age[n]--;
		}
		age[nLeast] = (ageLength);
		return (enum block_cache_entries)(nLeast);
	}
	return (enum block_cache_entries)(n);
}
#ifdef _MSC_VER
#pragma warning( default: 6001 )
#endif
static enum block_cache_entries _fs_UpdateSegmentKey( struct sack_vfs_fs_volume *vol, enum block_cache_entries cache_idx, BLOCKINDEX segment )
{
	if( !vol->key ) {
		vol->segment[cache_idx] = segment;
		return cache_idx;
	}
	if( cache_idx == BC(FILE) ) {
		_fs_updateCacheAge( vol, &cache_idx, segment, vol->fileCacheAge, (BC(FILE_LAST) - BC(FILE)) );
	}
	else if( cache_idx == BC(NAMES) ) {
		_fs_updateCacheAge( vol, &cache_idx, segment, vol->nameCacheAge, (BC(NAMES_LAST) - BC(NAMES)) );
	}
	vol->segment[cache_idx] = segment;
	if( vol->segment[cache_idx] == vol->_segment[cache_idx] )
		return cache_idx;
	SRG_ResetEntropy( vol->entropy );
	vol->_segment[cache_idx] = vol->segment[cache_idx];
  // so we know which 'segment[idx]' to use.
	vol->curseg = cache_idx;
	SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->segkey, SHORTKEY_LENGTH * 8 );
	{
		int n;
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[cache_idx];
		uint64_t* volkey = (uint64_t*)vol->key;
		uint64_t* segkey = (uint64_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey += 2;
			volkey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[cache_idx];
		uint32_t* volkey = (uint32_t*)vol->key;
		uint32_t* segkey = (uint32_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey[2] = volkey[2] ^ (segkey[2]);
			usekey[3] = volkey[3] ^ (segkey[3]);
			usekey += 4;
			volkey += 4;
		}
#endif
	}
	return cache_idx;
}
static LOGICAL _fs_ValidateBAT( struct sack_vfs_fs_volume *vol ) {
	BLOCKINDEX first_slab = 0;
	BLOCKINDEX slab = (BLOCKINDEX)(vol->dwSize / ( BLOCK_SIZE ));
	BLOCKINDEX last_block = ( slab * BLOCKS_PER_BAT ) / BLOCKS_PER_SECTOR;
	BLOCKINDEX n;
	enum block_cache_entries cache = BC(BAT);
	if( vol->key ) {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT;
			BLOCKINDEX *blockKey;
			BAT = TSEEK( BLOCKINDEX*, vol, n * BLOCK_SIZE, cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BC(BAT)]);
			_fs_UpdateSegmentKey( vol, BC(BAT), n + 1 );
			for( m = 0; m < BLOCKS_PER_BAT; m++ )
			{
				BLOCKINDEX block = BAT[0] ^ blockKey[0];
				BAT++; blockKey++;
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	} else {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT = TSEEK( BLOCKINDEX*, vol, n * BLOCK_SIZE, cache );
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				BLOCKINDEX block = BAT[m];
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	if( !_fs_ScanDirectory( vol, NULL, NULL, NULL, NULL, 0 ) ) return FALSE;
	return TRUE;
}
//-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
#if 0
static POINTER _fs_GetExtraData( POINTER block )
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	POINTER source_memory = block;
	{
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)source_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
 // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize += (BLOCK_SIZE*2)-1;
 // mask off the low bits; floor result to block boundary
			dwSize &= ~(BLOCK_SIZE-1);
			return (POINTER)Seek( source_memory, dwSize );
		}
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
#endif
static void _fs_AddSalt2( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct datatype { void* start; size_t length; } *data = (struct datatype*)psv;
	(*salt_size) = data->length;
	(*salt) = (POINTER)data->start;
	// only need to make one pass of it....
	data->length = 0;
	data->start = NULL;
}
const uint8_t *sack_vfs_fs_get_signature2( POINTER disk, POINTER diskReal ) {
	if( disk != diskReal ) {
		static uint8_t usekey[BLOCK_SIZE];
		static struct random_context *entropy;
		static struct datatype { void* start; size_t length; } data;
		data.start = diskReal;
		data.length = ((uintptr_t)disk - (uintptr_t)diskReal) - BLOCK_SIZE;
		if( !entropy ) entropy = SRG_CreateEntropy2( _fs_AddSalt2, (uintptr_t)&data );
		SRG_ResetEntropy( entropy );
		SRG_GetEntropyBuffer( entropy, (uint32_t*)usekey, BLOCK_SIZE*CHAR_BIT );
		return usekey;
	}
	return NULL;
}
// add some space to the volume....
static LOGICAL _fs_ExpandVolume( struct sack_vfs_fs_volume *vol ) {
	LOGICAL created = FALSE;
	//LOGICAL path_checked = FALSE;
	//size_t oldsize = vol->dwSize;
	if( vol->file && vol->read_only ) return TRUE;
	if( !vol->file ) {
		{
			char *tmp = StrDup( vol->volname );
			char *dir = (char*)pathrchr( tmp );
			if( dir ) {
				dir[0] = 0;
				if( !IsPath( tmp ) ) MakePath( tmp );
			}
			Deallocate( char*, tmp );
		}
		vol->file = sack_fopen( 0, vol->volname, "rb+" );
		if( !vol->file ) {
			created = TRUE;
			vol->file = sack_fopen( 0, vol->volname, "wb+" );
		}
		sack_fseek( vol->file, 0, SEEK_END );
		vol->dwSize = sack_ftell( vol->file );
		sack_fseek( vol->file, 0, SEEK_SET );
	}
	//vol->dwSize += ((uintptr_t)vol->disk - (uintptr_t)vol->diskReal);
	// a BAT plus the sectors it references... ( BLOCKS_PER_BAT + 1 ) * BLOCK_SIZE
	vol->dwSize += BLOCKS_PER_SECTOR*BLOCK_SIZE;
	LoG( "created expanded volume: %p from %p size:%" _size_f, vol->file, BLOCKS_PER_SECTOR*BLOCK_SIZE, vol->dwSize );
	// can't recover dirents and nameents dynamically; so just assume
	// use the _fs_GetFreeBlock because it will update encypted
	//vol->disk->BAT[0] = EOFBLOCK;  // allocate 1 directory entry block
	//vol->disk->BAT[1] = EOFBLOCK;  // allocate 1 name block
	if( created ) {
		_fs_UpdateSegmentKey( vol, BC(BAT), 1 );
		((BLOCKINDEX*)vol->usekey_buffer[BC(BAT)])[0]
			= EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BC(BAT)])[0];
		SETFLAG( vol->dirty, BC(BAT) );
		sack_fseek( vol->file, 0, SEEK_SET );
		sack_fwrite( vol->usekey_buffer[BC(BAT)], 1, BLOCK_SIZE, vol->file );
		/* vol->dirents = */
_fs_GetFreeBlock( vol, GFB_INIT_DIRENT );
		/* vol->nameents = */
_fs_GetFreeBlock( vol, GFB_INIT_NAMES );
	}
	return TRUE;
}
// shared with fuse module
uintptr_t vfs_fs_SEEK( struct sack_vfs_fs_volume *vol, FPI offset, enum block_cache_entries *cache_index ) {
	while( offset >= vol->dwSize ) if( !_fs_ExpandVolume( vol ) ) return 0;
	{
		BLOCKINDEX seg = (offset / BLOCK_SIZE) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			vol->segment[cache_index[0]] = seg;
			if( TESTFLAG( vol->dirty, cache_index[0] ) ) {
				sack_fseek( vol->file, (size_t)vol->bufferFPI[cache_index[0]], SEEK_SET );
				sack_fwrite( vol->usekey_buffer[cache_index[0]], 1, BLOCK_SIZE, vol->file );
				RESETFLAG( vol->dirty, cache_index[0] );
			}
			cache_index[0] = _fs_UpdateSegmentKey( vol, cache_index[0], seg );
			sack_fseek( vol->file, (size_t)(offset & ~BLOCK_MASK), SEEK_SET );
			if( !sack_fread( vol->usekey_buffer[cache_index[0]], 1, BLOCK_SIZE, vol->file ) )
				memset( vol->usekey_buffer[cache_index[0]], 0, BLOCK_SIZE );
		}
		vol->bufferFPI[cache_index[0]] = offset & ~BLOCK_MASK;
		sack_fseek( vol->file, (size_t)(offset & ~BLOCK_MASK), SEEK_SET );
		return ((uintptr_t)vol->usekey_buffer[cache_index[0]]) + (offset&BLOCK_MASK);
	}
}
// shared with fuse module
uintptr_t vfs_fs_BSEEK( struct sack_vfs_fs_volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) {
	BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_INDEX_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + ( block & (BLOCKS_PER_BAT-1) ) * BLOCK_SIZE;
	while( b >= vol->dwSize ) if( !_fs_ExpandVolume( vol ) ) return 0;
	{
		BLOCKINDEX seg = ( b / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			vol->segment[cache_index[0]] = seg;
			if( TESTFLAG( vol->dirty, cache_index[0] ) ) {
				sack_fseek( vol->file, (size_t)vol->bufferFPI[cache_index[0]], SEEK_SET );
				sack_fwrite( vol->usekey_buffer[cache_index[0]], 1, BLOCK_SIZE, vol->file );
				RESETFLAG( vol->dirty, cache_index[0] );
			}
			cache_index[0] = _fs_UpdateSegmentKey( vol, cache_index[0], seg );
			sack_fseek( vol->file, (size_t)(b & ~BLOCK_MASK), SEEK_SET );
			if( !sack_fread( vol->usekey_buffer[cache_index[0]], 1, BLOCK_SIZE, vol->file ) )
				memset( vol->usekey_buffer[cache_index[0]], 0, BLOCK_SIZE );
		}
		vol->bufferFPI[cache_index[0]] = b & ~BLOCK_MASK;
		sack_fseek( vol->file, (size_t)(b & ~BLOCK_MASK), SEEK_SET );
		return ((uintptr_t)vol->usekey_buffer[cache_index[0]]) + (b&BLOCK_MASK);
	}
}
static BLOCKINDEX _fs_GetFreeBlock( struct sack_vfs_fs_volume *vol, int init )
{
	size_t n;
	int b = 0;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
	//FPI start_POS = sack_ftell( vol->file );
	//BLOCKINDEX *start_BAT = current_BAT;
	if( !current_BAT ) return 0;
	do
	{
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = ((BLOCKINDEX*)vol->usekey[BC(BAT)]);
		for( n = 0; n < BLOCKS_PER_BAT; n++ )
		{
			check_val = current_BAT[0] ^ blockKey[0];
			if( !check_val || (check_val == 1) )
			{
				// mark it as claimed; will be enf of file marker...
				// adn thsi result will overwrite previous EOF.
				current_BAT[0] = EOFBLOCK ^ blockKey[0];
				if( init )
				{
					enum block_cache_entries cache;
					cache = _fs_UpdateSegmentKey( vol, BC(FILE), b * (BLOCKS_PER_SECTOR)+n + 1 + 1 );
					while( ((vol->segment[cache]-1)*BLOCK_SIZE) > vol->dwSize ){
						LoG( "looping to get a size %d", ((vol->segment[cache]-1)*BLOCK_SIZE) );
						if( !_fs_ExpandVolume( vol ) ) return 0;
					}
					if( init == GFB_INIT_DIRENT ) {
						memset( vol->usekey_buffer[BC(DIRECTORY)], 0, BLOCK_SIZE );
						((struct directory_entry*)(vol->usekey_buffer[BC(DIRECTORY)]))[0].first_block = EODMARK ^ ((struct directory_entry*)vol->usekey[cache])->first_block;
						LoG( "Initialize Dirent block, make sure disk exists behind target block" );
						sack_fseek( vol->file, (size_t)(vol->segment[cache] - 1) * BLOCK_SIZE, SEEK_SET );
						sack_fwrite( vol->usekey_buffer[BC(DIRECTORY)], 1, BLOCK_SIZE, vol->file );
					}
					else if( init == GFB_INIT_NAMES ) {
						memset( vol->usekey_buffer[BC(NAMES)], 0, BLOCK_SIZE );
						((char*)(vol->usekey_buffer[BC(NAMES)]))[0] = ((char*)vol->usekey[cache])[0];
						LoG( "Initialize name block, make sure disk exists behind target block" );
						sack_fseek( vol->file, (size_t)(vol->segment[cache] - 1) * BLOCK_SIZE, SEEK_SET );
						sack_fwrite( vol->usekey_buffer[BC(NAMES)], 1, BLOCK_SIZE, vol->file );
					}
					//else
					//	memcpy( ((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE, vol->usekey[cache], BLOCK_SIZE );
				}
				SETFLAG( vol->dirty, cache );
				if( (check_val == EOBBLOCK) )
					if( n < (BLOCKS_PER_BAT - 1) ) {
						LoG( "Write EOB to %d", b * BLOCKS_PER_BAT +n + 1 );
						current_BAT[1] = EOBBLOCK ^ blockKey[1];
					}
					else {
						// have to write what is there now, seek will read new block in...
						current_BAT = TSEEK( BLOCKINDEX*, vol, (b + 1) * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
						blockKey = ((BLOCKINDEX*)vol->usekey[BC(BAT)]);
						LoG( "Write EOB to %d", b * BLOCKS_PER_BAT + n );
						current_BAT[0] = EOBBLOCK ^ blockKey[0];
						SETFLAG( vol->dirty, cache );
					}
				LoG( "Return new block:%d", b * BLOCKS_PER_BAT + n );
				return b * BLOCKS_PER_BAT + n;
			}
			current_BAT++;
			blockKey++;
		}
		b++;
		current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
		//start_POS = sack_ftell( vol->file );
	}while( 1 );
}
static BLOCKINDEX vfs_fs_GetNextBlock( struct sack_vfs_fs_volume *vol, BLOCKINDEX block, int init, LOGICAL expand ) {
	BLOCKINDEX sector = block >> BLOCK_INDEX_SHIFT;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX *, vol, sector * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	BLOCKINDEX check_val;
 // if this passes, later ones will also.
	if( !this_BAT ) return 0;
	check_val = (this_BAT[block & (BLOCKS_PER_BAT - 1)]) ^ ((BLOCKINDEX*)vol->usekey[cache])[block & (BLOCKS_PER_BAT-1)];
	if( check_val == EOBBLOCK ) {
		LoG( "This adds a new block becuase after %d is %d", block, check_val );
		(this_BAT[block & (BLOCKS_PER_BAT-1)]) = EOFBLOCK^((BLOCKINDEX*)vol->usekey[BC(BAT)])[block & (BLOCKS_PER_BAT-1)];
		(this_BAT[1+block & (BLOCKS_PER_BAT-1)]) = EOBBLOCK^((BLOCKINDEX*)vol->usekey[BC(BAT)])[1+block & (BLOCKS_PER_BAT-1)];
	}
	else
		LoG( "Block after %d is %d", block, check_val );
	if( check_val == EOFBLOCK || check_val == EOBBLOCK ) {
 /*stupid triglyphs*/
		LoG( "(DOUBLE UPDATE?" "?) This adds a new block becuase after %d is %d", block, check_val );
		if( expand ) {
			BLOCKINDEX key = vol->key?((BLOCKINDEX*)vol->usekey[BC(BAT)])[block & (BLOCKS_PER_BAT-1)]:0;
			check_val = _fs_GetFreeBlock( vol, init );
			// free block might have expanded...
			this_BAT = TSEEK( BLOCKINDEX*, vol, sector * ( BLOCKS_PER_SECTOR*BLOCK_SIZE ), cache );
			if( !this_BAT ) return 0;
			// segment could already be set from the _fs_GetFreeBlock...
			this_BAT[block & (BLOCKS_PER_BAT-1)] = check_val ^ key;
			fwrite( this_BAT, 1, BLOCK_SIZE, vol->file );
		}
	}
	return check_val;
}
static void _fs_AddSalt( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct sack_vfs_fs_volume *vol = (struct sack_vfs_fs_volume *)psv;
	if( vol->sigsalt ) {
		(*salt_size) = vol->sigkeyLength;
		(*salt) = (POINTER)vol->sigsalt;
		vol->sigsalt = NULL;
	}
	else if( vol->datakey ) {
		(*salt_size) = BLOCK_SIZE;
		(*salt) = (POINTER)vol->datakey;
		vol->datakey = NULL;
	}
	else if( vol->userkey ) {
		(*salt_size) = StrLen( vol->userkey );
		(*salt) = (POINTER)vol->userkey;
		vol->userkey = NULL;
	}
	else if( vol->devkey ) {
		(*salt_size) = StrLen( vol->devkey );
		(*salt) = (POINTER)vol->devkey;
		vol->devkey = NULL;
	}
	else if( vol->segment[vol->curseg] ) {
		BLOCKINDEX sector = vol->segment[vol->curseg];
		switch( vol->clusterKeyVersion ) {
		case 0:
			( *salt_size ) = sizeof( vol->segment[vol->curseg] );
			( *salt ) = &vol->segment[vol->curseg];
			break;
		case 1:
			memcpy( vol->tmpSalt, vol->key, 16 );
			vol->tmpSalt[sector & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[0];
			vol->tmpSalt[( sector >> 4 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[1];
			vol->tmpSalt[( sector >> 8 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[2];
			vol->tmpSalt[( sector >> 12 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[3];
			( (BLOCKINDEX*)vol->tmpSalt )[0] ^= sector;
			( (BLOCKINDEX*)vol->tmpSalt )[1] ^= sector;
// sizeof( vol->segment[vol->curseg] );
			( *salt_size ) = 12;
			( *salt ) = vol->tmpSalt;
			break;
		}
	}
	else
		(*salt_size) = 0;
}
static void _fs_AssignKey( struct sack_vfs_fs_volume *vol, const char *key1, const char *key2 )
{
	uintptr_t size = BLOCK_SIZE + BLOCK_SIZE * BC(COUNT) + BLOCK_SIZE + SHORTKEY_LENGTH;
	if( !vol->key_buffer ) {
		int n;
		vol->key_buffer = NewArray( uint8_t, size );
		memset( vol->key_buffer, 0, size );
		for( n = 0; n < BC(COUNT); n++ ) {
			vol->usekey_buffer[n] = vol->key_buffer + (n + 1) * BLOCK_SIZE;
		}
	}
	vol->userkey = key1;
	vol->devkey = key2;
	if( key1 || key2 )
	{
		int n;
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( _fs_AddSalt, (uintptr_t)vol );
		else
			SRG_ResetEntropy( vol->entropy );
		vol->key = NewArray( uint8_t, size );
		for( n = 0; n < BC(COUNT); n++ ) {
			vol->usekey[n] = vol->key + (n + 1) * BLOCK_SIZE;
			vol->segment[n] = 0;
		}
		vol->segkey = vol->key + BLOCK_SIZE * (BC(COUNT) + 1);
		vol->sigkey = vol->key + BLOCK_SIZE * (BC(COUNT) + 1) + SHORTKEY_LENGTH;
		vol->curseg = BC(DIRECTORY);
		vol->segment[BC(DIRECTORY)] = 0;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->key, BLOCK_SIZE * 8 );
	}
	else {
		int n;
		for( n = 0; n < BC(COUNT); n++ )
			vol->usekey[n] = l.zerokey;
		vol->segkey = l.zerokey;
		vol->sigkey = l.zerokey;
		vol->key = NULL;
	}
}
struct sack_vfs_fs_volume *sack_vfs_fs_load_volume( const char * filepath )
{
	struct sack_vfs_fs_volume *vol = New( struct sack_vfs_fs_volume );
	memset( vol, 0, sizeof( struct sack_vfs_fs_volume ) );
	vol->volname = strdup( filepath );
	_fs_AssignKey( vol, NULL, NULL );
	if( !_fs_ExpandVolume( vol ) || !_fs_ValidateBAT( vol ) ) { Deallocate( struct sack_vfs_fs_volume*, vol ); return NULL; }
	return vol;
}
struct sack_vfs_fs_volume *sack_vfs_fs_load_crypt_volume( const char * filepath, uintptr_t version, const char * userkey, const char * devkey ) {
	struct sack_vfs_fs_volume *vol = New( struct sack_vfs_fs_volume );
	MemSet( vol, 0, sizeof( struct sack_vfs_fs_volume ) );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->volname = strdup( filepath );
	vol->userkey = userkey;
	vol->devkey = devkey;
	_fs_AssignKey( vol, userkey, devkey );
	if( !_fs_ExpandVolume( vol ) || !_fs_ValidateBAT( vol ) ) { sack_vfs_fs_unload_volume( vol ); return NULL; }
	return vol;
}
#if 0
struct sack_vfs_fs_volume *sack_vfs_fs_use_crypt_volume( POINTER memory, size_t sz, uintptr_t version, const char * userkey, const char * devkey ) {
	struct sack_vfs_fs_volume *vol = New( struct sack_vfs_fs_volume );
	MemSet( vol, 0, sizeof( struct sack_vfs_fs_volume ) );
	vol->read_only = 1;
	_fs_AssignKey( vol, userkey, devkey );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->external_memory = TRUE;
	vol->diskReal = (struct sack_vfs_disk*)memory;
	vol->dwSize = sz;
#ifdef WIN32
	// elf has a different signature to check for .so extended data...
	struct sack_vfs_disk *actual_disk;
	if( ((char*)memory)[0] == 'M' && ((char*)memory)[1] == 'Z' ) {
		actual_disk = (struct sack_vfs_disk*)GetExtraData( memory );
		if( actual_disk ) {
			if( ( ( (uintptr_t)actual_disk - (uintptr_t)memory ) < vol->dwSize ) ) {
				const uint8_t *sig = sack_vfs_fs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), memory );
				if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
					lprintf( "Signature failed comparison; the core has changed since it was attached" );
					vol->diskReal = NULL;
					vol->dwSize = 0;
					sack_vfs_fs_unload_volume( vol );
					return FALSE;
				}
				vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)memory);
				memory = (POINTER)actual_disk;
			} else {
				lprintf( "Signature failed comparison; the core is not attached to anything." );
				vol->diskReal = NULL;
				vol->disk = NULL;
				vol->dwSize = 0;
				sack_vfs_fs_unload_volume( vol );
				return NULL;
			}
		}
	}
#endif
	vol->disk = (struct sack_vfs_disk*)memory;
	if( !_fs_ValidateBAT( vol ) ) { sack_vfs_fs_unload_volume( vol );  return NULL; }
	return vol;
}
#endif
void sack_vfs_fs_unload_volume( struct sack_vfs_fs_volume * vol ) {
	INDEX idx;
	struct sack_vfs_fs_file *file;
	LIST_FORALL( vol->files, idx, struct sack_vfs_fs_file *, file )
		break;
	if( file ) {
		vol->closed = TRUE;
		return;
	}
	strdup_free( (char*)vol->volname );
	DeleteListEx( &vol->files DBG_SRC );
	sack_fclose( vol->file );
	//if( !vol->external_memory )	CloseSpace( vol->diskReal );
	if( vol->key ) {
		Deallocate( uint8_t*, vol->key );
		SRG_DestroyEntropy( &vol->entropy );
	}
	Deallocate( uint8_t*, vol->key_buffer );
	Deallocate( struct sack_vfs_fs_volume*, vol );
}
void sack_vfs_fs_shrink_volume( struct sack_vfs_fs_volume * vol ) {
	size_t n;
	unsigned int b = 0;
	//int found_free; // this block has free data; should be last BAT?
	//BLOCKINDEX last_block = 0;
	//unsigned int last_bat = 0;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
 // expand failed, tseek failed in response, so don't do anything
	if( !current_BAT ) return;
	do {
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = (BLOCKINDEX*)vol->usekey[BC(BAT)];
		for( n = 0; n < BLOCKS_PER_BAT; n++ ) {
			check_val = *(current_BAT++);
			if( vol->key )	check_val ^= *(blockKey++);
			if( check_val ) {
				//last_bat = b;
				//last_block = n;
			}
		}
		b++;
		if( b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) < vol->dwSize ) {
			current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
		} else
			break;
	}while( 1 );
	sack_fclose( vol->file );
	vol->file = NULL;
	/*
	SetFileLength( vol->volname,
			last_bat * BLOCKS_PER_SECTOR * BLOCK_SIZE + ( last_block + 1 + 1 )* BLOCK_SIZE );
	*/
	// setting 0 size will cause expand to do an initial open instead of expanding
	vol->dwSize = 0;
}
static void _fs_mask_block( struct sack_vfs_fs_volume *vol, size_t n ) {
	BLOCKINDEX b = ( 1 + (n >> BLOCK_INDEX_SHIFT) * (BLOCKS_PER_SECTOR) + (n & (BLOCKS_PER_BAT - 1)));
	_fs_UpdateSegmentKey( vol, BC(DATAKEY), b + 1 );
	{
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[BC(DATAKEY)];
		uint64_t* block = (uint64_t*)vol->usekey_buffer[BC( DATAKEY )];
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block += 2; usekey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[BC(DATAKEY)];
		uint32_t* block = (uint32_t*)vol->usekey_buffer[BC(DATAKEY)];
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block[2] = block[2] ^ usekey[2];
			block[3] = block[3] ^ usekey[3];
			block += 4; usekey += 4;
		}
#endif
	}
}
LOGICAL sack_vfs_fs_decrypt_volume( struct sack_vfs_fs_volume *vol )
{
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume is already decrypted, cannot remove key
	if( !vol->key ) { vol->lock = 0; return FALSE; }
	{
		enum block_cache_entries cache = BC(BAT);
		size_t n;
		BLOCKINDEX slab = vol->dwSize / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BC(BAT)]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				block[0] ^= blockKey[0];
				if( block[0] == EOBBLOCK ) break;
				else if( block[0] ) _fs_mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block++;
				blockKey++;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	_fs_AssignKey( vol, NULL, NULL );
	vol->lock = 0;
	return TRUE;
}
LOGICAL sack_vfs_fs_encrypt_volume( struct sack_vfs_fs_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 ) {
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume already has a key, cannot apply new key
	if( vol->key ) { vol->lock = 0; return FALSE; }
	if( !version ) version = 2;
	vol->clusterKeyVersion = version-1;
	_fs_AssignKey( vol, key1, key2 );
	{
		int done;
		size_t n;
		enum block_cache_entries cache = BC(BAT);
		BLOCKINDEX slab = (vol->dwSize + (BLOCKS_PER_SECTOR*BLOCK_SIZE-1)) / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		done = 0;
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BC(BAT)]);
			//vol->segment[BC(BAT)] = n + 1;
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) done = TRUE;
				else if( block[0] ) _fs_mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block[0] ^= blockKey[0];
				if( done ) break;
				block++;
				blockKey++;
			}
			if( done ) break;
		}
	}
	vol->lock = 0;
	return TRUE;
}
const char *sack_vfs_fs_get_signature( struct sack_vfs_fs_volume *vol ) {
	static char signature[257];
	static const char *output = "0123456789ABCDEF";
	if( !vol )
		return NULL;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	{
		static BLOCKINDEX datakey[BLOCKS_PER_BAT];
		uint8_t* usekey = vol->key?vol->usekey[BC(DATAKEY)]:l.zerokey;
		signature[256] = 0;
		memset( datakey, 0, sizeof( datakey ) );
		{
			{
				size_t n;
				BLOCKINDEX this_dir_block = 0;
				BLOCKINDEX next_dir_block;
				BLOCKINDEX *next_entries;
				do {
					enum block_cache_entries cache = BC(DATAKEY);
					next_entries = BTSEEK( BLOCKINDEX *, vol, this_dir_block, cache );
					for( n = 0; n < BLOCKS_PER_BAT; n++ )
						datakey[n] ^= next_entries[n] ^ ((BLOCKINDEX*)(((uint8_t*)usekey)))[n];
					next_dir_block = vfs_fs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, FALSE );
					if( this_dir_block == next_dir_block )
						DebugBreak();
					if( next_dir_block == 0 )
						DebugBreak();
					this_dir_block = next_dir_block;
				}
				while( next_dir_block != EOFBLOCK );
			}
		}
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( _fs_AddSalt, (uintptr_t)vol );
		SRG_ResetEntropy( vol->entropy );
		vol->curseg = BC(DIRECTORY);
		vol->segment[vol->curseg] = 0;
		vol->datakey = (const char *)datakey;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)usekey, 128 * 8 );
		{
			int n;
			for( n = 0; n < 128; n++ ) {
				signature[n*2] = output[( usekey[n] >> 4 ) & 0xF];
				signature[n*2+1] = output[usekey[n] & 0xF];
			}
		}
	}
	vol->lock = 0;
	return signature;
}
LOGICAL _fs_ScanDirectory( struct sack_vfs_fs_volume *vol, const char * filename, FPI *dirFPI, struct directory_entry *dirent, struct directory_entry *dirkey, int path_match ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	BLOCKINDEX next_dir_block;
	struct directory_entry *next_entries;
	if( filename && filename[0] == '.' && filename[1] == '/' ) filename += 2;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			BLOCKINDEX bi;
			struct directory_entry *entkey = ( vol->key)?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			struct directory_entry *entry = ((struct directory_entry *)vol->usekey_buffer[cache]) + n;
			//const char * testname;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
 // done.
			if( filename && !name_ofs )	return FALSE;
			LoG( "%d ch:%d addr:%p name_ofs = %" _size_f "(%" _size_f ") block = %d  vs %s"
			   , n, cache, next_entries + n , name_ofs
			   , next_entries[n].name_offset ^ entkey->name_offset
			   , next_entries[n].first_block ^ entkey->first_block
			   , filename );
			bi = next_entries[n].first_block ^ entkey->first_block;
			// if file is deleted; don't check it's name.
			if( !bi ) continue;
			// if file is end of directory, done sanning.
 // done.
			if( bi == EODMARK ) return filename?FALSE:(2);
			if( name_ofs > vol->dwSize ) { return FALSE; }
			//testname =
			if( filename ) {
#if defined( DEBUG_TRACE_LOG )
				enum block_cache_entries name_cache = BC(NAMES);
 // have to do the seek to the name block otherwise it might not be loaded.
				const char *names = TSEEK( const char *, vol, name_ofs, name_cache );
				LoG( "this name: %s", names );
#endif
				if( _fs_MaskStrCmp( vol, filename, name_ofs, path_match ) == 0 ) {
					if( dirkey ) {
						dirkey[0] = (*entkey);
						if( dirent ) {
							if( dirFPI )
								dirFPI[0] = vol->segment[cache] * BLOCK_SIZE
								          + ( n * sizeof( struct directory_entry ) );
							dirent->first_block = entry->first_block;
							dirent->name_offset = entry->name_offset;
							dirent->filesize = entry->filesize;
						}
					}
					LoG( "return found entry: %p (%" _size_f ":%" _size_f ") %s", next_entries + n, name_ofs, next_entries[n].first_block ^ dirkey->first_block, filename );
					return TRUE;
				}
			}
		}
		next_dir_block = vfs_fs_GetNextBlock( vol, this_dir_block, FALSE, TRUE );
#ifdef _DEBUG
		if( this_dir_block == next_dir_block ) DebugBreak();
#endif
  // should have a last-entry before no more blocks....
		if( next_dir_block == 0 ) { DebugBreak(); return FALSE; }
		this_dir_block = next_dir_block;
	}
	while( 1 );
}
// this results in an absolute disk position
static FPI _fs_SaveFileName( struct sack_vfs_fs_volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_name_block = 1;
	while( 1 ) {
		enum block_cache_entries cache = BC(NAMES);
		TEXTSTR names = BTSEEK( TEXTSTR, vol, this_name_block, cache );
		unsigned char *name = (unsigned char*)names;
		while( name < ( (unsigned char*)names + BLOCK_SIZE ) ) {
			int c = name[0];
			if( vol->key ) c = c ^ vol->usekey[cache][(uintptr_t)name-(uintptr_t)names];
			if( !c ) {
				size_t namelen;
				if( ( namelen = StrLen( filename ) ) < (size_t)( ( (unsigned char*)names + BLOCK_SIZE ) - name ) ) {
					LoG( "using unused entry for new file...%" _size_f "  %" _size_f " %s", this_name_block, (uintptr_t)name - (uintptr_t)names, filename );
					if( vol->key ) {
						for( n = 0; n < namelen + 1; n++ )
							name[n] = filename[n] ^ vol->usekey[cache][n + (name-(unsigned char*)names)];
						if( (namelen + 1) < (size_t)(((unsigned char*)names + BLOCK_SIZE) - name) )
							name[n] = vol->usekey[cache][n + (name - (unsigned char*)names)];
					} else
						memcpy( name, filename, ( namelen + 1 ) );
					sack_fwrite( vol->usekey_buffer[cache], 1, BLOCK_SIZE, vol->file );
					return ((uintptr_t)name) - ((uintptr_t)names) + vol->bufferFPI[cache];
				}
			}
			else
				if( _fs_MaskStrCmp( vol, filename, (uintptr_t)name - (uintptr_t)names, 0 ) == 0 ) {
					LoG( "using existing entry for new file...%s", filename );
					return ((uintptr_t)name) - ((uintptr_t)names) + vol->bufferFPI[cache];
				}
			if( vol->key ) {
				while( ( name[0] ^ vol->usekey[cache][name-(unsigned char*)names] ) ) name++;
				name++;
			} else
				name = name + StrLen( (const char*)name ) + 1;
			//LoG( "new position is %" _size_f "  %" _size_f, this_name_block, (uintptr_t)name - (uintptr_t)names );
		}
		this_name_block = vfs_fs_GetNextBlock( vol, this_name_block, GFB_INIT_DIRENT, TRUE );
		LoG( "Need a new directory block....", this_name_block );
	}
}
static struct directory_entry * _fs_GetNewDirectory( struct sack_vfs_fs_volume *vol, const char * filename, FPI *entFPI, struct directory_entry *dirent, struct directory_entry *_entkey ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	struct directory_entry *next_entries;
	LOGICAL moveMark = FALSE;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		FPI dirblockFPI;
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		dirblockFPI = sack_ftell( vol->file );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( vol->key )?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			struct directory_entry *ent = next_entries + n;
			FPI name_ofs = ent->name_offset ^ entkey->name_offset;
			BLOCKINDEX first_blk = ent->first_block ^ entkey->first_block;
			// not name_offset (end of list) or not first_block(free entry) use this entry
			if( name_ofs && (first_blk > 1) )  continue;
			if( first_blk == EODMARK ) moveMark = TRUE;
			name_ofs = _fs_SaveFileName( vol, filename ) ^ entkey->name_offset;
			first_blk = _fs_GetFreeBlock( vol, FALSE ) ^ entkey->first_block;
			//ent = next_entries + n;
			_entkey[0] = entkey[0];
			entFPI[0] = dirblockFPI + n * sizeof( struct directory_entry );
			dirent->filesize = ent->filesize = entkey->filesize;
			dirent->name_offset = ent->name_offset = name_ofs;
			dirent->first_block = ent->first_block = first_blk;
			sack_fseek( vol->file, (size_t)entFPI[0], SEEK_SET );
			sack_fwrite( dirent, 1, sizeof( *dirent ), vol->file );
			if( n < (VFS_DIRECTORY_ENTRIES - 1) ) {
				if( moveMark ) {
					struct directory_entry *enttmp = next_entries + (n + 1);
					enttmp->first_block = EODMARK ^ entkey[1].first_block;
					sack_fseek( vol->file, (size_t)(entFPI[0] + sizeof( struct directory_entry )), SEEK_SET );
					sack_fwrite( enttmp, 1, sizeof( *dirent ), vol->file );
				}
			} else {
				// otherwise pre-init the next directory sector
				this_dir_block = vfs_fs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
			}
			return dirent;
		}
		this_dir_block = vfs_fs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
	}
	while( 1 );
}
struct sack_vfs_fs_file * CPROC sack_vfs_fs_openfile( struct sack_vfs_fs_volume *vol, const char * filename ) {
	struct sack_vfs_fs_file *file = New( struct sack_vfs_fs_file );
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( filename[0] == '.' && filename[1] == '/' ) filename += 2;
	LoG( "sack_vfs open %s = %p on %s", filename, file, vol->volname );
	file->entry = &file->_entry;
	if( !_fs_ScanDirectory( vol, filename, &file->entry_fpi, &file->_entry, &file->dirent_key, 0 ) ) {
		if( vol->read_only ) { LoG( "Fail open: readonly" ); vol->lock = 0; Deallocate( struct sack_vfs_fs_file *, file ); return NULL; }
		else _fs_GetNewDirectory( vol, filename, &file->entry_fpi, file->entry, &file->dirent_key );
	}
	file->vol = vol;
	file->fpi = 0;
	file->delete_on_close = 0;
	file->_first_block = file->block = file->entry->first_block ^ file->dirent_key.first_block;
	AddLink( &vol->files, file );
	vol->lock = 0;
	return file;
}
static struct sack_vfs_fs_file * CPROC sack_vfs_fs_open( uintptr_t psvInstance, const char * filename, const char *opts ) {
	return sack_vfs_fs_openfile( (struct sack_vfs_fs_volume*)psvInstance, filename );
}
int CPROC sack_vfs_fs_exists( struct sack_vfs_fs_volume *vol, const char * file ) {
	LOGICAL result;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( file[0] == '.' && file[1] == '/' ) file += 2;
	result = _fs_ScanDirectory( vol, file, NULL, NULL, NULL, 0 );
	vol->lock = 0;
	return result;
}
size_t CPROC sack_vfs_fs_tell( struct sack_vfs_fs_file *file ) { return (size_t)file->fpi; }
size_t CPROC sack_vfs_fs_size( struct sack_vfs_fs_file *file ) { return (size_t)(file->entry->filesize ^ file->dirent_key.filesize); }
size_t CPROC sack_vfs_fs_seek( struct sack_vfs_fs_file *file, size_t pos, int whence )
{
	FPI old_fpi = file->fpi;
	if( whence == SEEK_SET ) file->fpi = pos;
	if( whence == SEEK_CUR ) file->fpi += pos;
	if( whence == SEEK_END ) file->fpi = ( file->entry->filesize  ^ file->dirent_key.filesize ) + pos;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	{
		if( ( file->fpi & ( ~BLOCK_MASK ) ) >= ( old_fpi & ( ~BLOCK_MASK ) ) ) {
			do {
				if( ( file->fpi & ( ~BLOCK_MASK ) ) == ( old_fpi & ( ~BLOCK_MASK ) ) ) {
					file->vol->lock = 0;
					return (size_t)file->fpi;
				}
				file->block = vfs_fs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
				old_fpi += BLOCK_SIZE;
			} while( 1 );
		}
	}
	{
		size_t n = 0;
		BLOCKINDEX b = file->_first_block;
		while( n * BLOCK_SIZE < ( pos & ~BLOCK_MASK ) ) {
			b = vfs_fs_GetNextBlock( file->vol, b, FALSE, TRUE );
			n++;
		}
		file->block = b;
	}
	file->vol->lock = 0;
	return (size_t)file->fpi;
}
static void _fs_MaskBlock( struct sack_vfs_fs_volume *vol, uint8_t* usekey, uint8_t* block, BLOCKINDEX block_ofs, size_t ofs, const char *data, size_t length ) {
	size_t n;
	block += block_ofs;
	usekey += ofs;
	if( vol->key )
		for( n = 0; n < length; n++ ) (*block++) = (*data++) ^ (*usekey++);
	else
		memcpy( block, data, length );
}
size_t CPROC sack_vfs_fs_write( struct sack_vfs_fs_file *file, const void * data_, size_t length ) {
	const char* data = (const char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	LOGICAL updated = FALSE;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	LoG( "Write to file %p %" _size_f "  @%" _size_f, file, length, ofs );
	if( ofs ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_fs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, BLOCK_SIZE - ofs );
			sack_fwrite( block + ofs, BLOCK_SIZE - ofs, 1, file->vol->file );
			data += BLOCK_SIZE - ofs;
			written += BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			if( file->fpi > (file->entry->filesize ^ file->dirent_key.filesize) ) {
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
				updated = TRUE;
			}
			file->block = vfs_fs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE - ofs;
		} else {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, length );
			sack_fwrite( file->vol->usekey_buffer[cache] + ofs, BLOCK_SIZE - ofs, 1, file->vol->file );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > (file->entry->filesize ^ file->dirent_key.filesize) ) {
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
				updated = TRUE;
			}
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length )
	{
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_fs_BSEEK( file->vol, file->block, &cache );
		if( file->block < 2 ) DebugBreak();
		if( length >= BLOCK_SIZE ) {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, BLOCK_SIZE );
			sack_fwrite( block, 1, BLOCK_SIZE, file->vol->file );
			data += BLOCK_SIZE;
			written += BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			if( file->fpi > (file->entry->filesize ^ file->dirent_key.filesize) ) {
				updated = TRUE;
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			}
			file->block = vfs_fs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE;
		} else {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, length );
			sack_fwrite( block, 1, BLOCK_SIZE, file->vol->file );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > (file->entry->filesize ^ file->dirent_key.filesize) ) {
				updated = TRUE;
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			}
			length = 0;
		}
	}
	if( updated ) {
		sack_fseek( file->vol->file, (size_t)file->entry_fpi, SEEK_SET );
		sack_fwrite( file->entry, 1, sizeof( *file->entry ), file->vol->file );
	}
	file->vol->lock = 0;
	LoG( "Data to write, return %d.", written );
	return written;
}
size_t CPROC sack_vfs_fs_read( struct sack_vfs_fs_file *file, void * data_, size_t length ) {
	char* data = (char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	LoG( "Read to file %p %" _size_f "  @%" _size_f, file, length, ofs );
	if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < ( file->fpi + length ) ) {
		if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < file->fpi )
			length = 0;
		else
			length = (size_t)(( file->entry->filesize  ^ file->dirent_key.filesize ) - file->fpi);
	}
	if( !length ) { errno = file->vol->lock = 0; LoG( "No Data to write..." );  return 0; }
	if( ofs ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_fs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), BLOCK_SIZE - ofs );
			written += BLOCK_SIZE - ofs;
			data += BLOCK_SIZE - ofs;
			length -= BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			file->block = vfs_fs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_fs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, BLOCK_SIZE - ofs );
			written += BLOCK_SIZE;
			data += BLOCK_SIZE;
			length -= BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			file->block = vfs_fs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			_fs_MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	file->vol->lock = 0;
	LoG( "Data read, return %d.", written );
	return written;
}
static void sack_vfs_fs_unlink_file_entry( struct sack_vfs_fs_volume *vol, FPI entFPI, struct directory_entry *entry, struct directory_entry *entkey, BLOCKINDEX first_block, LOGICAL deleted ) {
	BLOCKINDEX block, _block;
	struct sack_vfs_fs_file *file_found = NULL;
	struct sack_vfs_fs_file *file;
	INDEX idx;
	LoG( "Files?%d", vol->files->Cnt );
	LIST_FORALL( vol->files, idx, struct sack_vfs_fs_file *, file ) {
		LoG( "FILE CHECK: %d  %d", idx, file->_first_block );
		if( file->_first_block == first_block ) {
			file_found = file;
			file->delete_on_close = TRUE;
			LoG( "File is still open, mark to delete on close..." );
		}
	}
	if( !deleted ) {
		// delete the file entry now; this disk entry may be reused immediately.
		entry->first_block = entkey->first_block;
		LoG( "Release directory entry (zero first block of file) %d", entry->first_block );
		{
			enum block_cache_entries cache = BC( DIRECTORY );
			struct directory_entry* entkey = (vol->key) ? ((struct directory_entry*)vol->usekey[cache] + (entFPI&BLOCK_MASK)) : &l.zero_entkey;
			struct directory_entry* entry = ((struct directory_entry*)(vol->usekey_buffer[cache] + (entFPI & BLOCK_MASK)));
			LoG( "Entry was: %p %d %d", entry, cache, entry->first_block );
			entry->first_block = entkey->first_block;
		}
		sack_fseek( vol->file, (size_t)entFPI, SEEK_SET );
		sack_fwrite( entry, 1, sizeof( *entry ), vol->file );
	}
	if( !file_found ) {
// entry->first_block ^ entkey->first_block;
		_block = block = first_block;
		LoG( "(marking physical deleted (again?)) entry starts at %d", block );
		// wipe out file chain BAT
		do {
			enum block_cache_entries cache = BC(BAT);
			enum block_cache_entries fileCache = BC(DATAKEY);
			BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_INDEX_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
			BLOCKINDEX _thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[cache])[_block & (BLOCKS_PER_BAT-1)]:0;
			//BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_INDEX_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + (block & (BLOCKS_PER_BAT - 1)) * BLOCK_SIZE;
			uint8_t* blockData = (uint8_t*)vfs_fs_BSEEK( vol, block, &fileCache );
			LoG( "Clearing file datablock...%p", (uintptr_t)block*BLOCK_SIZE );
			memset( blockData, 0, BLOCK_SIZE );
			// after seek, block was read, and file position updated.
			sack_fwrite( blockData, 1, BLOCK_SIZE, vol->file );
			block = vfs_fs_GetNextBlock( vol, block, FALSE, FALSE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
			_block = block;
		} while( block != EOFBLOCK );
	}
}
static void _fs_shrinkBAT( struct sack_vfs_fs_file *file ) {
	struct sack_vfs_fs_volume *vol = file->vol;
	BLOCKINDEX block, _block;
	size_t bsize = 0;
	_block = block = file->entry->first_block ^ file->dirent_key.first_block;
	do {
		enum block_cache_entries cache = BC(BAT);
		enum block_cache_entries data_cache = BC(DATAKEY);
		BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_INDEX_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
		BLOCKINDEX _thiskey;
		_thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[cache])[_block & (BLOCKS_PER_BAT-1)]:0;
		block = vfs_fs_GetNextBlock( vol, block, FALSE, FALSE );
		if( bsize > (file->entry->filesize ^ file->dirent_key.filesize) ) {
			uint8_t* blockData = (uint8_t*)vfs_fs_BSEEK( file->vol, _block, &data_cache );
			//LoG( "clearing a datablock after a file..." );
			memset( blockData, 0, BLOCK_SIZE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
		} else {
			bsize++;
			if( bsize > (file->entry->filesize ^ file->dirent_key.filesize) ) {
				uint8_t* blockData = (uint8_t*)vfs_fs_BSEEK( file->vol, _block, &data_cache );
				//LoG( "clearing a partial datablock after a file..., %d, %d", BLOCK_SIZE-(file->entry->filesize & (BLOCK_SIZE-1)), ( file->entry->filesize & (BLOCK_SIZE-1)) );
				memset( blockData + (file->entry->filesize & (BLOCK_SIZE-1)), 0, BLOCK_SIZE-(file->entry->filesize & (BLOCK_SIZE-1)) );
				this_BAT[_block & (BLOCKS_PER_BAT-1)] = ~_thiskey;
			}
		}
		_block = block;
	} while( block != EOFBLOCK );
}
size_t CPROC sack_vfs_fs_truncate( struct sack_vfs_fs_file *file ) { file->entry->filesize = file->fpi ^ file->dirent_key.filesize; _fs_shrinkBAT( file ); return (size_t)file->fpi; }
int CPROC sack_vfs_fs_close( struct sack_vfs_fs_file *file ) {
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
#ifdef DEBUG_TRACE_LOG
	{
		enum block_cache_entries cache = BC(NAMES);
		static char fname[256];
		FPI name_ofs = file->entry->name_offset ^ file->dirent_key.name_offset;
 // have to do the seek to the name block otherwise it might not be loaded.
		TSEEK( const char *, file->vol, name_ofs, cache );
		_fs_MaskStrCpy( fname, sizeof( fname ), file->vol, name_ofs );
		LoG( "close file:%s(%p)", fname, file );
	}
#endif
	DeleteLink( &file->vol->files, file );
	if( file->delete_on_close ) sack_vfs_fs_unlink_file_entry( file->vol, file->entry_fpi, file->entry, &file->dirent_key, file->_first_block, TRUE );
	file->vol->lock = 0;
	if( file->vol->closed ) sack_vfs_fs_unload_volume( file->vol );
	Deallocate( struct sack_vfs_fs_file *, file );
	return 0;
}
int CPROC sack_vfs_fs_unlink_file( struct sack_vfs_fs_volume *vol, const char * filename ) {
	int result = 0;
	struct directory_entry entkey;
	struct directory_entry entry;
	FPI entFPI;
	if( !vol ) return 0;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	LoG( "unlink file:%s", filename );
	if( _fs_ScanDirectory( vol, filename, &entFPI, &entry, &entkey, 0 ) ) {
		sack_vfs_fs_unlink_file_entry( vol, entFPI, &entry, &entkey, entry.first_block ^ entkey.first_block, FALSE );
		result = 1;
	}
	vol->lock = 0;
	return result;
}
	/* noop */
int CPROC sack_vfs_fs_flush( struct sack_vfs_fs_file *file ) {	return 0; }
static LOGICAL CPROC sack_vfs_fs_need_copy_write( void ) {	return FALSE; }
struct sack_vfs_fs_find_info {
	BLOCKINDEX this_dir_block;
	char filename[BLOCK_SIZE];
	struct sack_vfs_fs_volume *vol;
	CTEXTSTR base;
	size_t base_len;
	size_t filenamelen;
	size_t filesize;
	CTEXTSTR mask;
	size_t thisent;
};
struct sack_vfs_fs_find_info * CPROC sack_vfs_fs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask )
{
	struct sack_vfs_fs_find_info *info = New( struct sack_vfs_fs_find_info );
	info->base = base;
	info->base_len = StrLen( base );
	info->mask = mask;
	info->vol = (struct sack_vfs_fs_volume *)psvInst;
	return (struct sack_vfs_fs_find_info*)info;
}
static int _fs_iterate_find( struct sack_vfs_fs_find_info* cinfo ) {
	struct sack_vfs_fs_find_info *info = (struct sack_vfs_fs_find_info*)cinfo;
	struct directory_entry *next_entries;
	size_t n;
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		enum block_cache_entries name_cache = BC(NAMES);
		next_entries = BTSEEK( struct directory_entry *, info->vol, info->this_dir_block, cache );
		for( n = info->thisent; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( info->vol->key)?((struct directory_entry *)info->vol->usekey[cache])+n:&l.zero_entkey;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
			const char *filename;
			if( !name_ofs )
				return 0;
			// if file is deleted; don't check it's name.
			if( !(next_entries[n].first_block ^ entkey->first_block ) )
				continue;
			if( (next_entries[n].first_block ^ entkey->first_block ) == EODMARK )
 // end of directory.
				return 0;
			info->filesize = (size_t)(next_entries[n].filesize ^ entkey->filesize);
			if( (name_ofs) > info->vol->dwSize ) {
				LoG( "corrupted volume." );
				return 0;
			}
			filename = TSEEK( const char *, info->vol, name_ofs, name_cache );
			if( info->vol->key ) {
				int c;
				info->filenamelen = 0;
				while( ( c = ( ((uint8_t*)filename)[0] ^ info->vol->usekey[name_cache][name_ofs&BLOCK_MASK] ) ) ) {
					info->filename[info->filenamelen++] = c;
					filename++;
					name_ofs++;
				}
				info->filename[info->filenamelen]	 = c;
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			} else {
				StrCpy( info->filename, filename );
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			}
			info->thisent = n + 1;
			return 1;
		}
 // new block, set new starting index.
		info->thisent = 0;
		info->this_dir_block = vfs_fs_GetNextBlock( info->vol, info->this_dir_block, FALSE, FALSE );
	}
	while( info->this_dir_block != EOFBLOCK );
	return 0;
}
int CPROC sack_vfs_fs_find_first( struct sack_vfs_fs_find_info *cinfo ) {
	struct sack_vfs_fs_find_info *info = (struct sack_vfs_fs_find_info*)cinfo;
	info->this_dir_block = 0;
	info->thisent = 0;
	return _fs_iterate_find( info );
}
int CPROC sack_vfs_fs_find_close( struct sack_vfs_fs_find_info *info ) { Deallocate( struct sack_vfs_fs_find_info*, info ); return 0; }
int CPROC sack_vfs_fs_find_next( struct sack_vfs_fs_find_info *info ) { return _fs_iterate_find( (struct sack_vfs_fs_find_info*)info ); }
char * CPROC sack_vfs_fs_find_get_name( struct sack_vfs_fs_find_info *info ) { return ((struct sack_vfs_fs_find_info*)info)->filename; }
size_t CPROC sack_vfs_fs_find_get_size( struct sack_vfs_fs_find_info *info ) { return ((struct sack_vfs_fs_find_info*)info)->filesize; }
LOGICAL CPROC sack_vfs_fs_find_is_directory( struct sack_vfs_fs_find_info *cursor ) { return FALSE; }
LOGICAL CPROC sack_vfs_fs_is_directory( uintptr_t psvInstance, const char *path ) {
	if( path[0] == '.' && path[1] == 0 ) return TRUE;
	{
		struct sack_vfs_fs_volume *vol = (struct sack_vfs_fs_volume *)psvInstance;
		if( _fs_ScanDirectory( vol, path, NULL, NULL, NULL, 1 ) ) {
			return TRUE;
		}
	}
	return FALSE;
}
uint64_t  CPROC sack_vfs_fs_find_get_ctime( struct sack_vfs_fs_find_info *info ) { return (size_t)0; }
uint64_t  CPROC sack_vfs_fs_find_get_wtime( struct sack_vfs_fs_find_info *info ) { return (size_t)0; }
LOGICAL CPROC sack_vfs_fs_rename( uintptr_t psvInstance, const char *original, const char *newname ) {
	struct sack_vfs_fs_volume *vol = (struct sack_vfs_fs_volume *)psvInstance;
	// fail if the names are the same.
	if( strcmp( original, newname ) == 0 )
		return FALSE;
	if( vol ) {
		struct directory_entry entkey;
		struct directory_entry entry;
		FPI entFPI;
		while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
		if( ( _fs_ScanDirectory( vol, original, &entFPI, &entry, &entkey, 0 ) ) ) {
			struct directory_entry new_entkey;
			struct directory_entry new_entry;
			if( (_fs_ScanDirectory( vol, newname, &entFPI, &new_entry, &new_entkey, 0 )) ) {
				vol->lock = 0;
				sack_vfs_fs_unlink_file( vol, newname );
				while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
			}
			entry.name_offset = _fs_SaveFileName( vol, newname ) ^ entkey.name_offset;
			sack_fseek( vol->file, (size_t)entFPI, SEEK_SET );
			sack_fwrite( &entry, 1, sizeof( entry ), vol->file );
			vol->lock = 0;
			return TRUE;
		}
		vol->lock = 0;
	}
	return FALSE;
}
#ifndef USE_STDIO
static struct file_system_interface sack_vfs_fs_fsi = {
                                                     (void*(CPROC*)(uintptr_t,const char *, const char*))sack_vfs_fs_open
                                                   , (int(CPROC*)(void*))sack_vfs_fs_close
                                                   , (size_t(CPROC*)(void*,void*,size_t))sack_vfs_fs_read
                                                   , (size_t(CPROC*)(void*,const void*,size_t))sack_vfs_fs_write
                                                   , (size_t(CPROC*)(void*,size_t,int))sack_vfs_fs_seek
                                                   , (void(CPROC*)(void*))sack_vfs_fs_truncate
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_fs_unlink_file
                                                   , (size_t(CPROC*)(void*))sack_vfs_fs_size
                                                   , (size_t(CPROC*)(void*))sack_vfs_fs_tell
                                                   , (int(CPROC*)(void*))sack_vfs_fs_flush
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_fs_exists
                                                   , sack_vfs_fs_need_copy_write
                                                   , (struct find_cursor*(CPROC*)(uintptr_t,const char *,const char *))             sack_vfs_fs_find_create_cursor
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_fs_find_first
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_fs_find_close
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_fs_find_next
                                                   , (char*(CPROC*)(struct find_cursor*))           sack_vfs_fs_find_get_name
                                                   , (size_t(CPROC*)(struct find_cursor*))          sack_vfs_fs_find_get_size
                                                   , (LOGICAL(CPROC*)(struct find_cursor*))         sack_vfs_fs_find_is_directory
                                                   , sack_vfs_fs_is_directory
                                                   , sack_vfs_fs_rename
	, (uintptr_t( CPROC* )(uintptr_t, uintptr_t, va_list))NULL
	, (uintptr_t( CPROC* )(uintptr_t, uintptr_t, va_list))NULL
	, (uint64_t( CPROC* )(struct find_cursor* cursor))sack_vfs_fs_find_get_ctime
	, (uint64_t( CPROC* )(struct find_cursor* cursor))sack_vfs_fs_find_get_wtime
};
PRIORITY_PRELOAD( Sack_VFS_FS_Register, CONFIG_SCRIPT_PRELOAD_PRIORITY - 2 )
{
#undef DEFAULT_VFS_NAME
#ifdef ALT_VFS_NAME
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME ".runner"
#else
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME "-fs"
#endif
	sack_register_filesystem_interface( DEFAULT_VFS_NAME, &sack_vfs_fs_fsi );
}
PRIORITY_PRELOAD( Sack_VFS_FS_RegisterDefaultFilesystem, SQL_PRELOAD_PRIORITY + 1 ) {
	if( SACK_GetProfileInt( GetProgramName(), "SACK/VFS/Mount FS VFS", 0 ) ) {
		struct sack_vfs_fs_volume *vol;
		TEXTCHAR volfile[256];
		TEXTSTR tmp;
		SACK_GetProfileString( GetProgramName(), "SACK/VFS/FS File", "*/../assets.sfs", volfile, 256 );
		tmp = ExpandPath( volfile );
		vol = sack_vfs_fs_load_volume( tmp );
		Deallocate( TEXTSTR, tmp );
		sack_mount_filesystem( "sack_shmem-fs", sack_get_filesystem_interface( DEFAULT_VFS_NAME )
		                     , 900, (uintptr_t)vol, TRUE );
	}
}
#endif
#ifdef __cplusplus
}
#endif
#ifdef USE_STDIO
#  undef sack_fopen
#  undef sack_fseek
#  undef sack_fclose
#  undef sack_fread
#  undef sack_fwrite
#  undef sack_ftell
#endif
SACK_VFS_NAMESPACE_END
#undef l
#undef FILE_BASED_VFS
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#pragma warning( default: 26451 )
#endif
#if !defined( SACK_AMALGAMATE ) || defined( __cplusplus )
/*
	FILE Data has extra fields stored with the data.
	   File Data - Directory entry filesize
	   references - a reference to a blockchain that contains the references to this object.
	        In the reference data block is FPI which is the directory entry ( converted directories? )
	   Sealant - length stored in NAME_OFFSET field of directory entry
	   patches - a sealed object has the ability to be modified with other signed and sealed patches.
			 A reference to the patch FileData is stored for each patch object.
			 (The patch object has a unique object identifier?  Or does it only exist for this object?)
*/
/*
 BLOCKINDEX BAT[BLOCKS_PER_BAT] // link of next blocks; 0 if free, FFFFFFFF if end of file block, FFFFFFFE end of BAT
 // (1+BLOCKS_PER_BAT) * BLOCK_SIZE total...
 BAT[0] = first directory cluster; array of struct directory_entry
 BAT[1] = name space; directory offsets land in a block referenced by this chain
 */
#define SACK_VFS_SOURCE
#define SACK_VFS_OS_SOURCE
#define SKIP_LIGHT_ENCRYPTION(n)
#define VFS_OS_PARANOID_TRUNCATE
// this is a badly named debug symbol;
// it is the LAST debugging of delete logging/checking...
//#define DEBUG_DELETE_LAST
//#define USE_STDIO
#if 1
 // tolower on linux
#ifndef USE_STDIO
#endif
/* JSOX Parser
   Parses JSOX (github.com/d3x0r/jsox)
   This function is meant for a simple utility to just take a
   known completed packet, and get the values from it. There may
   be mulitple top level values, although the JSON standard will
   only supply a single object or array as the first value.
   jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1,
   &amp;pdlMessage );
   \Example :
   <code>
   // call to parse a message... and iterate through each value
   {
     PDATALIST pdlMessage;
     LOGICAL gotMessage;
     if( jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1, &amp;pdlMessage ) )
     {
       int index;
       struct jsox_value_container *value;
       DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value )
       {
          // for each value in the result.... the first layer will
          // always be just one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
		  // then for each value-\>contains (as a datalist like above),
          // process each of those values.
       }
       jsox_dispose_mesage( &amp;pdlMessage );
     }
   }
   </code>
   This is a streaming setup, where a data block can be added, and
   the stream of objects can be returned from it....
   \Example 2:
   <code lang="c++">
   // allocate a parser to keep track of the parsing state... struct jsox_parse_state *parser = jsox_begin_parse();
   // at some point later, add some data to it... jsox_parse_add_data( parser, "utf8-data", sizeof( "utf8-data" ) - 1 );
   // and then get any objects that have been parsed from the stream so far...
   {
     PDATALIST pdlMessage;
     pdlMessage = jsox_parse_get_data( parser );
     if( pdlMessage )
     {
       int index;
       struct jsox_value_container *value;
       DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value )
       {
         // for each value in the result.... the first layer will
         // always be just
         // one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
         // then for each value-\>contains (as a datalist like above), process each of those values.
       }
       jsox_dispose_mesage( &amp;pdlMessage );
       jsox_parse_add_data( parser, NULL, 0 );
       // trigger parsing next message.
     }
   }
   </code>                                                                                                                                                                                                                    */
#ifndef JSOX_PARSER_HEADER_INCLUDED
#define JSOX_PARSER_HEADER_INCLUDED
// include types to get namespace, and, well PDATALIST types
#ifdef __cplusplus
namespace sack { namespace network {
	/* <combinewith jsox_parser.h>
	   \ \                         */
	namespace jsox {
#endif
#ifdef JSOX_PARSER_SOURCE
#  define JSOX_PARSER_PROC(type,name) EXPORT_METHOD type name
#else
#  define JSOX_PARSER_PROC(type,name) IMPORT_METHOD type name
#endif
enum jsox_value_types {
	JSOX_VALUE_UNDEFINED = -1
	, JSOX_VALUE_UNSET = 0
 //= 1 no data
	, JSOX_VALUE_NULL
 //= 2 no data
	, JSOX_VALUE_TRUE
 //= 3 no data
	, JSOX_VALUE_FALSE
 //= 4 string
	, JSOX_VALUE_STRING
 //= 5 string + result_d | result_n
	, JSOX_VALUE_NUMBER
 //= 6 contains
	, JSOX_VALUE_OBJECT
 //= 7 contains
	, JSOX_VALUE_ARRAY
	// up to here is supported in JSON
 //= 8 no data
	, JSOX_VALUE_NEG_NAN
 //= 9 no data
	, JSOX_VALUE_NAN
 //= 10 no data
	, JSOX_VALUE_NEG_INFINITY
 //= 11 no data
	, JSOX_VALUE_INFINITY
  // = 12 comes in as a number, string is data.
	, JSOX_VALUE_DATE
 // = 13 string data, needs bigint library to process...
	, JSOX_VALUE_BIGINT
 // = 14 no data; used in [,,,] as place holder of empty
	, JSOX_VALUE_EMPTY
  // = 15 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY
  // = 14 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY_MAX = JSOX_VALUE_TYPED_ARRAY +12
};
struct jsox_value_container {
  // name of this value (if it's contained in an object)
	char * name;
	size_t nameLen;
 // value from above indiciating the type of this value
	enum jsox_value_types value_type;
   // the string value of this value (strings and number types only)
	char *string;
	size_t stringLen;
  // boolean whether to use result_n or result_d
	int float_result;
	union {
		double result_d;
		int64_t result_n;
		//struct json_value_container *nextToken;
	};
  // list of struct json_value_container that this contains.
	PDATALIST contains;
  // acutal source datalist(?)
	PDATALIST *_contains;
  // if VALUE_OBJECT or VALUE_TYPED_ARRAY; this may be non NULL indicating what the class name is.
	char *className;
	size_t classNameLen;
};
// allocates a JSOX parsing context and is prepared to begin parsing data.
JSOX_PARSER_PROC( struct jsox_parse_state *, jsox_begin_parse )(void);
// clear state; after an error state, this can allow reusing a state.
JSOX_PARSER_PROC( void, jsox_parse_clear_state )( struct jsox_parse_state *state );
// get actual allocated root for a value... allows holding that.
JSOX_PARSER_PROC( const char *, jsox_get_parse_buffer )(struct jsox_parse_state *pState, const char *buf);
// destroy current parse state.
JSOX_PARSER_PROC( void, jsox_parse_dispose_state )(struct jsox_parse_state **ppState);
// return >0 when a completed value/object is available.
// after returning >0, call json_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns 0, then ther is no further object
// to retrieve.  If this return -1 there was an error, and use jsox_parse_get_error() to
// retrieve the error text.
JSOX_PARSER_PROC( int, jsox_parse_add_data )(struct jsox_parse_state *context
	, const char * msg
	, size_t msglen
	);
JSOX_PARSER_PROC( PTEXT, jsox_parse_get_error )(struct jsox_parse_state *state);
JSOX_PARSER_PROC( PDATALIST, jsox_parse_get_data )(struct jsox_parse_state *context);
// single all-in-one parsing of an input buffer.
JSOX_PARSER_PROC( LOGICAL, jsox_parse_message )(const char * msg
	, size_t msglen
	, PDATALIST *msg_data_out
	);
// release all resources of a message from jsox_parse_message or jsox_parse_get_data
JSOX_PARSER_PROC( void, jsox_dispose_message )(PDATALIST *msg_data);
JSOX_PARSER_PROC( struct jsox_parse_state *, jsox_get_messge_parser )(void);
JSOX_PARSER_PROC( char *, jsox_escape_string_length )(const char *string, size_t len, size_t *outlen);
JSOX_PARSER_PROC( char *, jsox_escape_string )(const char *string);
/*
	jsox_get_pared_value()
	takes a parsed message data list as a parameer, and a path.
	A message may have been parsed into multiple parts.  This
	early version will return just the first value in the datalist.
	If there is an optional `path` specified, then that is used to
	step through the JSOX parsed structure to get deeper values.
	Path is specified as a list of fieldnames and array index numbers.
	optional separator characters may be used between members '.', ' ', '/' and '\'.
	Separator characters may be repeated or mixed with other seaprators and are all
	considered a single separation.
	optional bracket characters around an array index may be used     [0]    is often as good as 0.
	Some example paths
		messages[0]from
		messages.0.from
		messages [0] from
		messages [0] lines[0]
	{ messages : [ // array of messages
	    { from : "someone", lines: [ "lines","of","message"] }
	  ]
	}
	jsox_get_parsed_value() returns a value from a PDATALIST
	jsox_get_parsed_object_value() and jsox_get_parsed_array_value() :  returns a value from a value member.
*/
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_value )(PDATALIST pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_object_value )(struct jsox_value_container *pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
JSOX_PARSER_PROC( struct jsox_value_container *, jsox_get_parsed_array_value )(struct jsox_value_container * pdlMessage, const char *path
	, void( *callback )(uintptr_t psv, struct jsox_value_container *val), uintptr_t psv
	);
#ifdef __cplusplus
//SACK_NAMESPACE_END
} } }
using namespace sack::network::jsox;
#endif
#endif
#else
 // tolower on linux
//#include <filesys.h>
//#include <procreg.h>
//#include <salty_generator.h>
//#include <sack_vfs.h>
//#include <sqlgetoption.h>
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#  pragma warning( disable: 26451 )
#endif
#ifdef USE_STDIO
#define sack_fopen(a,b,c)     fopen(b,c)
#define sack_fseek(a,b,c)     fseek(a,(long)b,c)
#define sack_fclose(a)        fclose(a)
#define sack_fread(a,b,c,d)   fread(a,b,c,d)
#define sack_fwrite(a,b,c,d)  fwrite(a,b,c,d)
#define sack_ftell(a)         ftell(a)
#undef StrDup
#define StrDup(a)             strdup(a)
#define free(a)               Deallocate( POINTER, a )
#ifdef __cplusplus
namespace sack {
	namespace filesys {
#endif
		// filesyslib/pathops.c
		extern LOGICAL  CPROC  IsPath( CTEXTSTR path );
		extern  int CPROC  MakePath( CTEXTSTR path );
		extern CTEXTSTR CPROC pathrchr( CTEXTSTR path );
		extern CTEXTSTR CPROC pathchr( CTEXTSTR path );
#ifdef __cplusplus
	}
}
using namespace sack::filesys;
#endif
#else
#define free(a)               Deallocate( POINTER, a )
#endif
SACK_VFS_NAMESPACE
// have to enable TRACE_LOG for most of the symbols to actually log
//#define DEBUG_TRACE_LOG
//#define DEBUG_ROLLBACK_JOURNAL
//#define DEBUG_FILE_OPS
// this is large binary blocks.
//#define DEBUG_DISK_IO
//#define DEBUG_DISK_DATA
//#define DEBUG_DIRECTORIES
//#define DEBUG_BLOCK_INIT
//#define DEBUG_TIMELINE_AVL
//#define DEBUG_TIMELINE_DIR_TRACKING
//#define DEBUG_FILE_SCAN
//#define DEBUG_FILE_OPEN
//#define DEBUG_VALIDATE_TREE
//#define DEBUG_BLOCK_COMPUTE
//#define DEBUG_SECTOR_DIRT
//#define DEBUG_CACHE_FAULTS
//#define DEBUG_CACHE_FLUSH
//#define DEBUG_SET_SECTOR_SIZE
//#define DEBUG_FILE_TRUNCATE
#define FILE_BASED_VFS
#define VIRTUAL_OBJECT_STORE
#ifndef _MSC_VER
#endif
/**************
  VFS_VERSION
     used to track migration of keys and keying methods.
  0x100 = version 1; SHORTKEY_LENGTH = 16
 **************/
#define VFS_VERSION     0x100
// 12 bits = 1 << 12 = 4096
#define BLOCK_SIZE_BITS 12
// BLOCKINDEX is either 4 or 8 bytes... sizeof( size_t )...
// all constants though should compile out to a single value... and just for grins went to 16 bit size_t and 0 shift... or 1 byte
#define BLOCK_BAT_SHIFT (BLOCK_SIZE_BITS-(sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_INDEX_SHIFT ((sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_BYTE_SHIFT (BLOCK_SIZE_BITS)
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
#define BLOCK_SMALL_SIZE     256
#define DIR_BLOCK_SIZE_BITS   12
#define DIR_BLOCK_SIZE      (1<<DIR_BLOCK_SIZE_BITS)
#define BAT_BLOCK_SIZE      4096
#define NAME_BLOCK_SIZE     4096
#define KEY_SIZE            1024
#define TIME_BLOCK_SIZE     4096
#define ROLLBACK_BLOCK_SIZE 4096
#define FILE_NAME_MAXLEN    4096
#define BLOCK_MASK (BLOCK_SIZE-1)
#ifdef VIRTUAL_OBJECT_STORE
// if the block index & BAT_BLOCK_MASK, is a data block
// all BATs are 4096
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT)-1)
#  define BLOCK_SECTOR_MASK BLOCKS_PER_BAT
#else
#  undef BLOCKS_PER_BAT
#  undef BLOCK_SECTOR_MASK
#  define BLOCKS_PER_BAT ((BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT))
#  define BLOCK_SECTOR_MASK (BLOCKS_PER_BAT-1)
#endif
#define BAT_BLOCK_MASK ( ( BAT_BLOCK_SIZE >> BLOCK_INDEX_SHIFT ) - 1)
#define BLOCKS_PER_SECTOR (1+BLOCKS_PER_BAT)
// per-sector perumation; needs to be a power of 2 (in bytes)
#define SHORTKEY_LENGTH 16
#ifndef VFS_DISK_DATATYPE
#  define VFS_DISK_DATATYPE size_t
#endif
 // BLOCK_SIZE blocks...
typedef VFS_DISK_DATATYPE BLOCKINDEX;
 // file position type
typedef VFS_DISK_DATATYPE FPI;
/* BEFORE DEF */
#undef BC
#ifdef VIRTUAL_OBJECT_STORE
/* THIS DEFINES SACK_VFS_OS_VOLUME */
#  define BC(n) BLOCK_CACHE_VOS_##n
#    ifdef sack_vfs_volume
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_os
#    define directory_entry directory_entry_os
#    define sack_vfs_disk sack_vfs_disk_os
#    define sack_vfs_diskSection sack_vfs_diskSection_os
#    define directory_hash_lookup_block directory_hash_lookup_block_os
#    define sack_vfs_volume sack_vfs_os_volume
#    define sack_vfs_file sack_vfs_os_file
#   ifdef __cplusplus
namespace objStore {
#   endif
#elif defined FILE_BASED_VFS
#  define BC(n) BLOCK_CACHE_FS_##n
#    ifdef block_cache_entries
#      undef block_cache_entries
#      undef directory_entry
#      undef sack_vfs_disk
#      undef sack_vfs_diskSection
#      undef directory_hash_lookup_block
#      undef sack_vfs_volume
#      undef sack_vfs_file
#    endif
#    define block_cache_entries block_cache_entries_fs
#    define directory_entry directory_entry_fs
#    define sack_vfs_disk sack_vfs_disk_fs
#    define sack_vfs_diskSection sack_vfs_diskSection_fs
#    define directory_hash_lookup_block directory_hash_lookup_block_fs
/* THIS DEFINES SACK_VS_VOLUME */
#    define sack_vfs_volume sack_vfs_fs_volume
#    define sack_vfs_file sack_vfs_fs_file
#   ifdef __cplusplus
namespace fs {
#   endif
#else
#  define BC(n) BLOCK_CACHE_##n
#endif
/* AFTER DEF */
enum block_cache_entries
{
	BC( ZERO )
	, BC( DIRECTORY ) = 0
#ifdef VIRTUAL_OBJECT_STORE
	, BC( DIRECTORY_LAST ) = BC( DIRECTORY ) + 64
#endif
	, BC( NAMES )
	, BC( NAMES_LAST ) = BC( NAMES ) + 16
	, BC( BAT )
#ifdef VIRTUAL_OBJECT_STORE
	// keep a few tables for cache (file system too?)
	, BC( BAT_LAST ) = BC( BAT ) + 16
#endif
	, BC(DATAKEY)
	, BC(FILE)
	, BC(FILE_LAST) = BC(FILE) + 32
#ifdef VIRTUAL_OBJECT_STORE
	, BC( TIMELINE )
	, BC( TIMELINE_LAST ) = BC( TIMELINE ) + 48
#endif
#if defined( VIRTUAL_OBJECT_STORE )
	// really shouldn't need more than one of these...
	// record
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// replay
	// 1 - header
	// 0/1 - entry (might be with header)
	// 1 - small/big block journal entry
	// 1 - target disk sector
	, BC( ROLLBACK )
	, BC( ROLLBACK_LAST ) = BC( ROLLBACK ) + 6
#endif
#if defined( VIRTUAL_OBJECT_STORE ) && defined( DEBUG_VALIDATE_TREE )
	// debug timeline, keep a mirror for comparisons, when links were lost, etc...
	// can be factored out at some point.
	, BC( TIMELINE_RO )
	, BC( TIMELINE_RO_LAST ) = BC( TIMELINE_RO ) + 48
#endif
	, BC(COUNT)
};
// could effecitvely be fewer than this
// 82 dirents * 512 byte names = 40000
#define DIRENT_NAME_OFFSET_OFFSET             0x0001FFFF
// (sealant length / 4)  (mulitply by 4 to get real length)
#define DIRENT_NAME_OFFSET_FLAG_SEALANT       0x003E0000
#define DIRENT_NAME_OFFSET_FLAG_SEALANT_SHIFT 17
#define DIRENT_NAME_OFFSET_FLAG_OWNED         0x00400000
#define DIRENT_NAME_OFFSET_FLAG_READ_KEYED    0x00800000
// unused flag; previous indicated versioning.
#define DIRENT_NAME_OFFSET_UNUSED_0         0x01000000
#define DIRENT_NAME_OFFSET_VERSION_SHIFT      25
#define DIRENT_NAME_OFFSET_VERSIONS           0x1E000000
#define DIRENT_NAME_OFFSET_UNUSED             0xFE000000
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct directory_entry
{
  // name offset from beginning of disk
	FPI name_offset;
  // first block of data of the file
	BLOCKINDEX first_block;
  // how big the file is
	VFS_DISK_DATATYPE filesize;
#ifdef VIRTUAL_OBJECT_STORE
  // when the file was created/last written
	uint64_t timelineEntry;
#endif
} PACKED;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#undef VFS_DIRECTORY_ENTRIES
#ifdef VIRTUAL_OBJECT_STORE
// subtract name has index
// subtrace name index
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE - ( 2*sizeof(BLOCKINDEX) + 256*sizeof(BLOCKINDEX)) ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#else
#  define VFS_DIRECTORY_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#  define VFS_PATCH_ENTRIES ( ( BLOCK_SIZE ) /sizeof( struct directory_entry) )
#endif
/*
struct sack_vfs_diskSection
{
	// BAT is at 0 of every BLOCK_SIZE blocks (4097 total)
	// &BAT[0] == itself....
	// BAT[0] == first directory entry (actually next entry; first is always here)
	// BAT[1] == first name entry (actually next name block; first is known as here)
	// bat[BLOCK_SIZE] == NEXT_BAT[0]; NEXT_BAT = BAT + BLOCK_SIZE + 1024*BLOCK_SIZE;
	// bat[8192] == ... ( 0 + ( BLOCK_SIZE + BLOCKS_PER_BAT*BLOCK_SIZE ) * N >> 12 )
	BLOCKINDEX BAT[BLOCKS_PER_BAT];
	//struct directory_entry directory[BLOCK_SIZE/sizeof( struct directory_entry)]; // 256
	//char  names[BLOCK_SIZE/sizeof(char)];
	uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
};
struct sack_vfs_disk {
	struct sack_vfs_diskSection firstBlock;
	struct sack_vfs_diskSection blocks[];
};
*/
#undef SMUDGECACHE
#undef CLEANCACHE
#ifdef DEBUG_SECTOR_DIRT
#define SMUDGECACHE(vol,n) {	 lprintf( "set dirty on %d %d %d", n, vol->segment[n], vol->bufferFPI[n]);	 vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 lprintf( "reset dirty on %d", n);	 RESETFLAG( vol->dirty, n ); }
#else
#define SMUDGECACHE(vol,n) {    vfs_os_smudge_cache(vol,n);   }
#define CLEANCACHE(vol,n) {	 RESETFLAG( vol->dirty, n ); }
#endif
#ifndef ROLLBACK_JOURNAL_DEFINED
#define ROLLBACK_JOURNAL_DEFINED
static int const seglock_mask_size = 4;
struct sack_vfs_os_BAT_info {
	FPI sectorStart;
	FPI sectorEnd;
	BLOCKINDEX blockStart;
	int size;
};
struct vfs_os_rollback_journal {
	struct sack_vfs_os_file* rollback_file;
	struct sack_vfs_os_file* rollback_journal_file;
	struct sack_vfs_os_file* rollback_small_journal_file;
	PDATALIST pdlPendingRecord;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	PDATALIST pdlJournaled;
 // sectors that are in rollback already
	BLOCKINDEX *pJournaled;
 // how long pJournaled is used
	int journalLength;
 // max length of pJournaled
	int journalAvail;
};
#ifdef small
#  undef small
#endif
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct vfs_os_rollback_entry {
	BLOCKINDEX fileBlock;
	struct {
		uint64_t small : 1;
  // block was full of 0's
		uint64_t zero : 1;
	} flags;
	// block size is retrievable when the block is reloadeded to write
// PACKED entries[1];
};
PREFIX_PACKED struct vfs_os_rollback_header {
	struct {
		uint64_t dirty : 1;
		uint64_t processing : 1;
	} flags;
  // where the blocks are tracked.
	BLOCKINDEX journal;
 // where small blocks are tracked
	BLOCKINDEX small_journal;
	BLOCKINDEX unused_rollbackLength;
	BLOCKINDEX nextBlock;
	BLOCKINDEX nextSmallBlock;
	BLOCKINDEX nextEntry;
  // align entries on 4096 boundaries
	uint64_t   Filler1;
	// where this is tracked.
	struct vfs_os_rollback_entry  entries[1];
}PACKED ;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#endif
struct sack_vfs_volume {
	const char * volname;
#ifdef FILE_BASED_VFS
	FILE *file;
	struct file_system_mounted_interface *mount;
#else
	struct sack_vfs_disk *disk;
 // disk might be offset from diskReal because it's a .exe attached.
	struct sack_vfs_disk *diskReal;
#endif
	//uint32_t dirents;  // constant 0
	//uint32_t nameents; // constant 1
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BC(COUNT)];
// associated with usekey[n]
	BLOCKINDEX segment[BC(COUNT)];
#ifdef VIRTUAL_OBJECT_STORE
	struct vfs_volume_flags {
		BIT_FIELD skipRollbackProcessing : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD halted : 1;
 // stop any disk activity; test journal recoverability.
		BIT_FIELD versioned : 1;
	}flags;
	struct vfs_os_rollback_journal journal;
	BLOCKINDEX lastBlock;
	PDATALIST pdl_BAT_information;
	PLIST pending_rollback;
	//PDATASTACK pdsCTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
	//PDATASTACK pdsWTimeStack;// = CreateDataStack( sizeof( struct memoryTimelineNode ) );
 // timeline root
	struct storageTimeline *timeline;
	enum block_cache_entries timelineCache;
 // timeline root key
	struct storageTimeline *timelineKey;
	struct sack_vfs_os_file *timeline_file;
	struct sack_vfs_os_file* timeline_index_file;
	//struct storageTimelineCursor *timeline_cache;
  // segment is locked into cache.
	MASKSET_( seglock, BC( COUNT ), 4 );
	unsigned int sector_size[BC( COUNT )];
#endif
	uint8_t fileCacheAge[BC(FILE_LAST) - BC(FILE)];
#ifdef VIRTUAL_OBJECT_STORE
	uint8_t dirHashCacheAge[BC(DIRECTORY_LAST) - BC(DIRECTORY)];
	uint8_t batHashCacheAge[BC(BAT_LAST) - BC(BAT)];
	uint8_t timelineCacheAge[BC( TIMELINE_LAST ) - BC( TIMELINE )];
	uint8_t rollbackCacheAge[BC( ROLLBACK_LAST ) - BC( ROLLBACK )];
#endif
	uint8_t nameCacheAge[BC(NAMES_LAST) - BC(NAMES)];
	struct random_context *entropy;
  // root of all cached key buffers
	uint8_t* key;
#ifdef FILE_BASED_VFS
  // root of all cached key buffers
	uint8_t* oldkey;
#endif
#ifndef VIRTUAL_OBJECT_STORE
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
 // composite key
	uint8_t* usekey[BC( COUNT )];
#endif
  // signature of executable attached as header
	uint8_t* sigkey;
  // signature of executable attached as header
	uint8_t* sigsalt;
	size_t sigkeyLength;
#  ifdef FILE_BASED_VFS
  // root buffer space of all cache blocks
	uint8_t* key_buffer;
 // data cache blocks
	uint8_t* usekey_buffer[BC(COUNT)];
 // duplicate copy of original sector data
	uint8_t* usekey_buffer_clean[BC(COUNT)];
	PTHREAD flusher;
	volatile LOGICAL flushing;
	PVARTEXT pvtDeleteBuffer;
#ifdef DEBUG_CACHE_FAULTS
	int cacheRequests[10];
	int cacheFaults[10];
#endif
	FLAGSET( dirty, BC(COUNT) );
	FLAGSET( _dirty, BC( COUNT ) );
	FPI bufferFPI[BC(COUNT)];
#  endif
	BLOCKINDEX lastBatBlock;
	PDATALIST pdlFreeBlocks;
#ifdef VIRTUAL_OBJECT_STORE
	BLOCKINDEX lastBatSmallBlock;
	PDATALIST pdlFreeSmallBlocks;
#endif
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	volatile uint32_t lock;
#ifdef VFS_IMPLEMENT_FILE_LOCKING
	THREAD_ID locked_thread;
#endif
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
};
#if !defined( VIRTUAL_OBJECT_STORE )
struct sack_vfs_file
{
 // which volume this is in
	struct sack_vfs_volume *vol;
	struct directory_entry dirent_key;
	FPI fpi;
	BLOCKINDEX _first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
	BLOCKINDEX *blockChain;
	BLOCKINDEX blockChainAvail;
	BLOCKINDEX blockChainLength;
#  ifdef FILE_BASED_VFS
  // where to write the directory entry update to
	FPI entry_fpi;
#    ifdef VIRTUAL_OBJECT_STORE
	enum block_cache_entries cache;
	struct memoryTimelineNode *timeline;
	uint8_t *seal;
	uint8_t *sealant;
	uint8_t *readKey;
	uint16_t readKeyLen;
	uint8_t sealantLen;
 // boolean, on read, validates seal.  Defaults to FALSE.
	uint8_t sealed;
	char *filename;
#    endif
  // has file size within
	struct directory_entry _entry;
  // has file size within
	struct directory_entry *entry;
#  else
  // has file size within
	struct directory_entry *entry;
#  endif
};
#endif
#  undef TSEEK
#  undef BTSEEK
#  ifdef VIRTUAL_OBJECT_STORE
#    define TSEEK(type,v,o,s,c) ((type)vfs_os_SEEK(v,o,s,&c))
#    define BTSEEK(type,v,o,s,c) ((type)vfs_os_BSEEK(v,o,s,&c))
#  elif defined FILE_BASED_VFS
#    define TSEEK(type,v,o,c) ((type)vfs_fs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_fs_BSEEK(v,o,&c))
#  else
#    define TSEEK(type,v,o,c) ((type)vfs_SEEK(v,o,&c))
#    define BTSEEK(type,v,o,c) ((type)vfs_BSEEK(v,o,&c))
#  endif
#if defined( __GNUC__ ) && !defined( _WIN32 )
#define HIDDEN __attribute__ ((visibility ("hidden")))
#else
#define HIDDEN
#endif
#if !defined( VIRTUAL_OBJECT_STORE ) && !defined( FILE_BASED_VFS )
  uintptr_t vfs_SEEK( struct sack_vfs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_BSEEK( struct sack_vfs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( VIRTUAL_OBJECT_STORE )
  uintptr_t vfs_os_SEEK( struct sack_vfs_os_volume* vol, FPI offset, int size, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_os_BSEEK( struct sack_vfs_os_volume* vol, BLOCKINDEX block, int size, enum block_cache_entries* cache_index ) HIDDEN;
#elif defined( FILE_BASED_VFS )
  uintptr_t vfs_fs_SEEK( struct sack_vfs_fs_volume* vol, FPI offset, enum block_cache_entries* cache_index ) HIDDEN;
  uintptr_t vfs_fs_BSEEK( struct sack_vfs_fs_volume* vol, BLOCKINDEX block, enum block_cache_entries* cache_index ) HIDDEN;
#endif
#if defined( VIRTUAL_OBJECT_STORE ) || defined( FILE_BASED_VFS )
#   ifdef __cplusplus
}
using namespace sack::SACK_VFS;
#   endif
#  endif
#define vfs_SEEK vfs_os_SEEK
#define vfs_BSEEK vfs_os_BSEEK
#define MAX_FILENAME_LEN 256
struct memoryTimelineNode;
#ifdef __cplusplus
namespace objStore {
#endif
//#define PARANOID_INIT
#undef LoG
#undef LoG_
#ifdef DEBUG_TRACE_LOG
#define LoG( a,... ) lprintf( a,##__VA_ARGS__ )
#define LoG_( a,... ) _lprintf(DBG_RELAY)( a,##__VA_ARGS__ )
#else
#define LoG( a,... )
#define LoG_( a,... )
#endif
//#if !defined __GNUC__ and defined( __CPLUSPLUS )
#define sane_offsetof(type,member) ((size_t)&(((type*)0)->member))
//#endif
#define EOFBLOCK  (~(BLOCKINDEX)0)
#define EOBBLOCK  ((BLOCKINDEX)1)
#define EODMARK   (1)
#define DIR_ALLOCATING_MARK (~0)
//#define DIR_DELETED_MARK    (1)
//#define DIR_CREATED_MARK    (2)
#undef GFB_INIT_NONE
#undef GFB_INIT_DIRENT
#undef GFB_INIT_NAMES
enum getFreeBlockInit {
	GFB_INIT_NONE       ,
	GFB_INIT_DIRENT     ,
	GFB_INIT_NAMES      ,
	GFB_INIT_PATCHBLOCK ,
	GFB_INIT_TIMELINE   ,
	GFB_INIT_TIMELINE_MORE,
	GFB_INIT_ROLLBACK   ,
};
// End Of Text Block
#define UTF8_EOTB 0xFF
// End Of Text
#define UTF8_EOT 0xFE
#define FIRST_DIR_BLOCK      0
//#define FIRST_NAMES_BLOCK    1
#define FIRST_TIMELINE_BLOCK 2
#define FIRST_ROLLBACK_BLOCK 3
// use this byte in hash as parent directory (block & char)
// utf8 names never use 0xFF as a codeunit.
#define DIRNAME_CHAR_PARENT 0xFF
struct dirent_cache {
	BLOCKINDEX entry_fpi;
  // has file size within
	struct directory_entry entry;
  // has file size within
	struct directory_entry entry_key;
	struct dirent_cache *patches;
	int usedPatches;
	int availPatches;
} dirCache;
struct hashnode {
	char leadin[MAX_FILENAME_LEN];
	int leadinDepth;
	BLOCKINDEX this_dir_block;
	size_t thisent;
};
struct sack_vfs_os_find_info {
	char filename[FILE_NAME_MAXLEN];
	struct sack_vfs_os_volume *vol;
	CTEXTSTR base;
	size_t base_len;
	size_t filenamelen;
	size_t filesize;
	CTEXTSTR mask;
#ifdef VIRTUAL_OBJECT_STORE
	char leadin[MAX_FILENAME_LEN];
	int leadinDepth;
	PDATASTACK pds_directories;
	uint64_t ctime;
	uint64_t wtime;
	struct memoryTimelineNode *time;
#else
	BLOCKINDEX this_dir_block;
	size_t thisent;
#endif
};
static void sack_vfs_os_flush_block( struct sack_vfs_os_volume* vol, enum block_cache_entries entry );
static void vfs_os_smudge_cache( struct sack_vfs_os_volume* vol, enum block_cache_entries n );
static BLOCKINDEX _os_GetFreeBlock_( struct sack_vfs_os_volume *vol, enum block_cache_entries* cache, enum getFreeBlockInit init, int blocksize, LOGICAL flush_BAT_caches  DBG_PASS );
#define _os_GetFreeBlock(v,c,i,s) _os_GetFreeBlock_(v,c,i,s,FALSE DBG_SRC )
#define IS_OWNED(file)  ( (file->entry->name_offset) & DIRENT_NAME_OFFSET_FLAG_OWNED )
LOGICAL _os_ScanDirectory_( struct sack_vfs_os_volume *vol, const char * filename
	, BLOCKINDEX dirBlockSeg
	, BLOCKINDEX *nameBlockStart
	, struct sack_vfs_os_file *file
	, int path_match
	, char *leadin
	, int *leadinDepth
);
#define _os_ScanDirectory(v,f,db,nb,file,pm) ((l.leadinDepth = 0), _os_ScanDirectory_(v,f,db,nb,file,pm, l.leadin, &l.leadinDepth ))
// This getNextBlock is optional allocate new one; it uses _os_getFreeBlock_
static BLOCKINDEX vfs_os_GetNextBlock_v2( struct sack_vfs_os_volume* vol, BLOCKINDEX block, enum block_cache_entries* blockCache, enum getFreeBlockInit init, LOGICAL expand, int blockSize, int* realBlockSize, LOGICAL flush_BAT_caches );
static BLOCKINDEX vfs_os_GetNextBlock( struct sack_vfs_os_volume *vol, BLOCKINDEX block, enum block_cache_entries *cache, enum getFreeBlockInit init, LOGICAL expand, int blockSize, int *realBlockSize );
static LOGICAL _os_ExpandVolume( struct sack_vfs_os_volume *vol, BLOCKINDEX fromBlock, int size );
//static void reloadTimeEntry( struct memoryTimelineNode *time, struct sack_vfs_os_volume *vol, uint64_t timeEntry DBG_PASS );
#define vfs_os_BSEEK(v,b,s,c) vfs_os_BSEEK_(v,b,s,c DBG_SRC )
uintptr_t vfs_os_BSEEK_( struct sack_vfs_os_volume *vol, BLOCKINDEX block, int blockSize, enum block_cache_entries *cache_index DBG_PASS );
uint8_t* vfs_os_DSEEK_( struct sack_vfs_os_volume* vol, FPI dataFPI, int blockSize, enum block_cache_entries* cache_index DBG_PASS );
#define vfs_os_DSEEK(v,b,s,c) vfs_os_DSEEK_(v,b,s,c DBG_SRC )
uintptr_t vfs_os_FSEEK( struct sack_vfs_os_volume* vol
	, struct sack_vfs_os_file* file
	, BLOCKINDEX firstblock
	, FPI offset
	, enum block_cache_entries* cache_index
	, int blockSize
	DBG_PASS
);
static size_t CPROC sack_vfs_os_seek_internal( struct sack_vfs_os_file* file, size_t pos, int whence );
static size_t CPROC sack_vfs_os_write_internal( struct sack_vfs_os_file* file, const void* data_, size_t length
	, POINTER writeState );
static size_t CPROC sack_vfs_os_read_internal( struct sack_vfs_os_file* file, uint64_t version, void* data_, size_t length );
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct directory_hash_lookup_block
{
	BLOCKINDEX next_block[256];
	struct directory_entry entries[VFS_DIRECTORY_ENTRIES];
	BLOCKINDEX names_first_block;
	uint8_t used_names;
} PACKED;
PREFIX_PACKED struct directory_patch_block
{
	union direction_patch_block_entry_union {
		struct direction_patch_block_entry {
			BIT_FIELD index : 8;
			BIT_FIELD hash_block : 24;
		} dirIndex;
		FPI raw;
	}entries[(DIR_BLOCK_SIZE-sizeof(BLOCKINDEX))/sizeof(uint32_t)];
	uint8_t usedEntries;
	BLOCKINDEX morePatches;
} PACKED;
PREFIX_PACKED struct directory_patch_ref_block
{
	PREFIX_PACKED struct directory_patch_ref_entry {
		BLOCKINDEX patchBlockStart;
 // first patch block
		BLOCKINDEX dirBlock;
		uint16_t patchNum;
 // which directory entry this patches
		uint8_t dirEntry;
	} entries[(DIR_BLOCK_SIZE)/sizeof( struct directory_patch_ref_entry )] PACKED;
} PACKED;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
enum sack_vfs_os_seal_states {
	SACK_VFS_OS_SEAL_NONE = 0,
	SACK_VFS_OS_SEAL_LOAD,
	SACK_VFS_OS_SEAL_VALID,
	SACK_VFS_OS_SEAL_STORE,
  // validate failed (read whole file check)
	SACK_VFS_OS_SEAL_INVALID,
  // stored patch is writeable
	SACK_VFS_OS_SEAL_CLEARED,
  // stored patch new sealant (after read valid, new write)
	SACK_VFS_OS_SEAL_STORE_PATCH,
};
struct file_block_definition {
	uint32_t avail;
	uint32_t used;
};
struct file_block_small_definition {
	uint16_t avail;
	uint16_t used;
};
struct file_block_large_definition {
	uint64_t avail;
	uint64_t used;
};
struct file_header {
	struct file_block_small_definition sealant;
	struct file_block_definition references;
	struct file_block_large_definition fileData;
	struct file_block_small_definition indexes;
	struct file_block_definition referencedBy;
};
#if 0
static void flushFileSuffix( struct sack_vfs_os_file* file );
static void WriteIntoBlock( struct sack_vfs_os_file* file, int blockType, FPI pos, CPOINTER data, FPI length );
#endif
//#define DEBUG_TEST_LOCKS
//#define DEBUG_VALIDATE_TREE_ADD
//#define DEBUG_LOG_LOCKS
//#define INVERSE_TEST
//#define DEBUG_DELETE_BALANCE
//#define DEBUG_TIMELINE_REORDER_LOGGING
//#define DEBUG_AVL_DETAIL
int nodes;
struct storageTimelineCache {
	BLOCKINDEX timelineSector;
	FPI dirEntry[BLOCK_SIZE / sizeof( FPI )];
	struct dirent_cache caches[BLOCK_SIZE / sizeof( FPI )];
	//	struct dirent_cache caches[BLOCK_SIZE / sizeof( FPI )];
};
#define timelineBlockIndexNull 0
typedef union timelineBlockType {
	// 0 is invalid; indexes must subtract 1 to get
	// real timeline index.
	uint64_t raw;
	struct timelineBlockReference {
		uint64_t index;
	} ref;
} TIMELINE_BLOCK_TYPE;
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
PREFIX_PACKED struct timelineHeader {
	TIMELINE_BLOCK_TYPE first_free_entry;
	TIMELINE_BLOCK_TYPE crootNode_deleted;
  // this index is 0 when initialized, and has a +1 to the entry number.
	TIMELINE_BLOCK_TYPE srootNode;
	TIMELINE_BLOCK_TYPE last_added_entry;
	uint64_t unused[4];
	//uint64_t unused2[8];
} PACKED;
// current size is 64 bytes.
// me_fpi is the physical FPI in the timeline file of the TIMELINE_BLOCK_TYPE that references 'this' block.
// structure defines little endian structure for storage.
PREFIX_PACKED struct storageTimelineNode0 {
	// if dirent_fpi == 0; it's free; and priorData will point at another free node
	uint64_t dirent_fpi;
	uint32_t priorTime;
	uint16_t priorDataPad;
 // how much of the last block in the file is not used
	uint8_t  filler8_1;
 // lesser least significant byte of time... sometimes can read time including timezone offset with time - 1 byte
	uint8_t  timeTz;
	uint64_t time;
 // if not 0, references a start block version of data.
	uint64_t priorData;
} PACKED;
PREFIX_PACKED struct storageTimelineNode {
	// if dirent_fpi == 0; it's free; and priorData will point at another free node
	uint64_t dirent_fpi;
	uint32_t priorTime;
	uint16_t priorDataPad;
 // how much of the last block in the file is not used
	uint8_t  filler8_1;
 // lesser least significant byte of time... sometimes can read time including timezone offset with time - 1 byte
	uint8_t  timeTz;
	uint64_t time;
 // if not 0, references a start block version of data.
	uint64_t priorData;
 // if not 0, references a start block version of data.
	uint64_t nextWrite;
 // if not 0, references a start block version of data.
	uint64_t priorWrite;
 // This is the actual size of the data starting at block priorData
	uint64_t priorDataSize;
 // if not 0, references a start block version of data.
	uint64_t filler64_2;
} PACKED;
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
struct memoryTimelineNode {
	// if dirent_fpi == 0; it's free.
	FPI this_fpi;
	uint64_t index;
	// the end of this is the same as storage timeline.
	struct storageTimelineNode* disk;
	enum block_cache_entries diskCache;
};
struct storageTimelineCursor {
  // save stack of parents in cursor
	PDATASTACK parentNodes;
 // temp; needs work.
	struct storageTimelineCache dirents;
};
struct sack_vfs_os_time_cursor {
	struct sack_vfs_os_volume* vol;
	uint64_t at;
};
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
#define NUM_ROOT_TIMELINE_NODES (TIME_BLOCK_SIZE - sizeof( struct timelineHeader )) / sizeof( struct storageTimelineNode )
PREFIX_PACKED struct storageTimeline {
	struct timelineHeader header;
	struct storageTimelineNode entries[NUM_ROOT_TIMELINE_NODES];
} PACKED;
/*
#define NUM_TIMELINE_NODES (TIME_BLOCK_SIZE) / sizeof( struct storageTimelineNode )
PREFIX_PACKED struct storageTimelineBlock {
	struct storageTimelineNode entries[(TIME_BLOCK_SIZE) / sizeof( struct storageTimelineNode )];
} PACKED;
*/
#  ifdef _MSC_VER
#    pragma pack (pop)
#  endif
#ifdef DEBUG_VALIDATE_TREE
#define VTReadOnly  , TRUE
#define VTReadWrite  , FALSE
#else
#define VTReadOnly
#define VTReadWrite
#endif
#ifdef _DEBUG
#define GRTENoLog ,0
#define GRTELog ,1
#else
#define GRTENoLog
#define GRTELog
#endif
#define convertMeToParentFPI(n) ((n)&~0x3f)
#define convertMeToParentIndex(n) (((n)>sizeof(struct timelineHeader))?( ( convertMeToParentFPI((n)&~0x3f)- sizeof( struct timelineHeader ) ) / sizeof( struct storageTimelineNode ) + 1 ):0)
struct storageTimelineNode* getRawTimeEntry( struct sack_vfs_os_volume* vol, uint64_t timeEntry, enum block_cache_entries *cache
#if _DEBUG
	, int log
#endif
	 DBG_PASS )
{
	int locks;
	cache[0] = BC( TIMELINE );
	FPI pos = sane_offsetof( struct storageTimeline, entries[timeEntry - 1] );
/*no block*/
	struct storageTimelineNode* node = ( struct storageTimelineNode* )vfs_os_FSEEK( vol, vol->timeline_file, 0, pos, cache, TIME_BLOCK_SIZE DBG_SRC );
	//_lprintf(DBG_RELAY)( "Load Entry %d", (int)timeEntry );
	locks = GETMASK_( vol->seglock, seglock, cache[0] );
#ifdef DEBUG_TEST_LOCKS
#  ifdef DEBUG_LOG_LOCKS
#    ifdef _DEBUG
	if( log )
#    endif
		_lprintf(DBG_RELAY)( "Lock %d %d %d", (int)timeEntry, cache[0], locks );
#  endif
	if( locks > 9 ) {
		lprintf( "Lock OVERFLOW" );
		DebugBreak();
	}
#endif
	locks++;
	SETMASK_( vol->seglock, seglock, cache[0], locks );
	return node;
}
TIMELINE_BLOCK_TYPE* getRawTimePointer( struct sack_vfs_os_volume* vol, uint64_t fpi, enum block_cache_entries *cache ) {
	cache[0] = BC( TIMELINE );
/*no block*/
	return (TIMELINE_BLOCK_TYPE*)vfs_os_FSEEK( vol, vol->timeline_file, 0, fpi, cache, TIME_BLOCK_SIZE DBG_SRC );
}
void dropRawTimeEntry( struct sack_vfs_os_volume* vol, enum block_cache_entries cache
#if _DEBUG
	, int log
#endif
	 DBG_PASS ) {
	int locks;
	locks = GETMASK_( vol->seglock, seglock, cache );
#ifdef DEBUG_TEST_LOCKS
#  ifdef DEBUG_LOG_LOCKS
#    ifdef _DEBUG
	if( log )
#    endif
	_lprintf(DBG_RELAY)( "UnLock %d %d", cache, locks );
#  endif
	if( !locks ) {
		lprintf( "Lock UNDERFLOW" );
		DebugBreak();
	}
#endif
	locks--;
	SETMASK_( vol->seglock, seglock, cache, locks );
}
void reloadTimeEntry( struct memoryTimelineNode* time, struct sack_vfs_os_volume* vol, uint64_t timeEntry
#ifdef DEBUG_VALIDATE_TREE
	, LOGICAL readOnly
#endif
#if _DEBUG
	, int log
#endif
	 DBG_PASS )
{
	enum block_cache_entries cache =
#ifdef DEBUG_VALIDATE_TREE
		readOnly ?BC(TIMELINE_RO):
#endif
		BC( TIMELINE );
	//uintptr_t vfs_os_FSEEK( struct sack_vfs_os_volume *vol, BLOCKINDEX firstblock, FPI offset, enum block_cache_entries *cache_index DBG_SRC ) {
	//if( timeEntry > 62 )DebugBreak();
	int locks;
	FPI pos = sane_offsetof( struct storageTimeline, entries[timeEntry - 1] );
	//lprintf( "Read Entry %d", (int)timeEntry );
/*no block*/
	struct storageTimelineNode* node = ( struct storageTimelineNode* )vfs_os_FSEEK( vol, vol->timeline_file, 0, pos, &cache, TIME_BLOCK_SIZE DBG_RELAY );
	locks = GETMASK_( vol->seglock, seglock, cache );
#ifdef DEBUG_TEST_LOCKS
#ifdef DEBUG_LOG_LOCKS
#ifdef _DEBUG
	if( log )
#endif
		_lprintf(DBG_RELAY)( "Lock %d %d %d", (int)timeEntry, cache, locks );
#endif
	if( locks > 12 ) {
		lprintf( "Lock OVERFLOW" );
		DebugBreak();
	}
#endif
	locks++;
	SETMASK_( vol->seglock, seglock, cache, locks );
	time->disk = node;
	time->diskCache = cache;
	time->index = timeEntry;
	time->this_fpi = pos;
}
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
// didn't actually have to use this.
static void dumpTimeline( struct sack_vfs_os_volume* vol ) {
	lprintf( "--- Timeline ----" );
	lprintf( "root %lld last %lld free %lld", vol->timeline->header.srootNode.raw, vol->timeline->header.last_added_entry.raw, vol->timeline->header.first_free_entry.raw );
	int entry;
	enum block_cache_entries_os cache = BC( TIMELINE );
	struct storageTimelineNode* block;
	for( entry = 1; entry != vol->timeline->header.first_free_entry.raw; entry++ ) {
		block = getRawTimeEntry( vol, entry, &cache GRTENoLog DBG_SRC );
		lprintf( "Entry %d  de:%lld prev:%lld next:%lld time:%lld tz:%d", entry, block->dirent_fpi, block->priorWrite, block->nextWrite, block->time, block->timeTz );
		dropRawTimeEntry( vol, cache GRTENoLog DBG_SRC );
	}
}
#endif
//-----------------------------------------------------------------------------------
// Timeline Support Functions
//-----------------------------------------------------------------------------------
static void reorderEntry( struct memoryTimelineNode* time, struct sack_vfs_os_volume* vol, int toEnd DBG_PASS ) {
	if( time ) {
		// time changed...(maybe?)
		{
			uint64_t myself = time->index;
			struct storageTimelineNode* prev;
			enum block_cache_entries_os cache, _cache = BC(ZERO);
			if( time->disk->priorWrite ) {
				prev = getRawTimeEntry( vol, time->disk->priorWrite, &cache GRTENoLog DBG_RELAY );
			} else { prev = NULL; cache = BC(ZERO); }
			enum block_cache_entries_os cache2, _cache2 = BC(ZERO);
			struct storageTimelineNode* next;
			if( time->disk->nextWrite ) {
				next = getRawTimeEntry( vol, time->disk->nextWrite, &cache2 GRTENoLog DBG_RELAY );
			} else { next = NULL; cache2 = BC(ZERO); }
			if( toEnd ) {
				enum block_cache_entries_os cache3;
				struct storageTimelineNode* last;
				last = getRawTimeEntry( vol, vol->timeline->header.last_added_entry.ref.index, &cache3 GRTENoLog DBG_SRC );
				if( last && last->time <= time->disk->time ) {
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
					dumpTimeline( vol );
#endif
					last->nextWrite = myself;
					if( !time->disk->priorWrite ) {
						if( next ) next->priorWrite = 0;
						vol->timeline->header.srootNode.ref.index = time->disk->nextWrite;
					} else if(next ) next->priorWrite = time->disk->priorWrite;
					if( prev ) prev->nextWrite = time->disk->nextWrite;
					time->disk->priorWrite = vol->timeline->header.last_added_entry.ref.index;
					time->disk->nextWrite = 0;
					// if this is the new end of the list, update the last entry....
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
					lprintf( "new last block:%lld after %lld", myself, vol->timeline->header.last_added_entry.ref.index );
#endif
					vol->timeline->header.last_added_entry.ref.index = myself;
					SMUDGECACHE( vol, vol->timelineCache );
					if( prev ) dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
					if( next ) dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
					if( last ) dropRawTimeEntry( vol, cache3 GRTELog DBG_RELAY );
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
					dumpTimeline( vol );
#endif
					return;
				} else {
					if( last ) dropRawTimeEntry( vol, cache3 GRTENoLog DBG_RELAY );
				}
			}
			if( next && ( next->time < time->disk->time ) ) {
				//myself = next->priorWrite;
				if( prev )
					prev->nextWrite = time->disk->nextWrite;
				else {
					vol->timeline->header.srootNode.ref.index = time->disk->nextWrite;
					SMUDGECACHE( vol, vol->timelineCache );
				}
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
				lprintf( "Searching forward...." );
#endif
				next->priorWrite = time->disk->priorWrite;
				while( ( prev = next ) && ( ( _cache ? dropRawTimeEntry( vol, _cache GRTENoLog DBG_RELAY ) : (void)0 ), ( _cache = cache ), ( cache = BC( TIMELINE ) ),
					( next = getRawTimeEntry( vol, prev->nextWrite, &cache GRTENoLog DBG_SRC ) ) )
					) {
					if( !next->nextWrite ) {
						if( !time->disk->priorWrite ) {
							struct storageTimelineNode* next;
							enum block_cache_entries_os cache = BC( TIMELINE );
							next = getRawTimeEntry( vol, time->disk->nextWrite, &cache GRTENoLog DBG_RELAY );
							if( next ) next->priorWrite = 0;
							vol->timeline->header.srootNode.ref.index = time->disk->nextWrite;
							dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
						}
						time->disk->priorWrite = prev->nextWrite;
						time->disk->nextWrite = 0;
						next->nextWrite = myself;
						dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
						if( cache2 ) dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
						// if this is the new end of the list, update the last entry....
						vol->timeline->header.last_added_entry.ref.index = myself;
						SMUDGECACHE( vol, vol->timelineCache );
 // done. (at end anyway)
						break;
					}
					if( next->time > time->disk->time ) {
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
						lprintf( "found insertion point %lld  %lld %lld", myself, prev->nextWrite, next->priorWrite );
#endif
						if( !time->disk->priorWrite ) {
							struct storageTimelineNode* next;
							enum block_cache_entries_os cache = BC( TIMELINE );
							next = getRawTimeEntry( vol, time->disk->nextWrite, &cache GRTENoLog DBG_RELAY );
							if( next ) next->priorWrite = 0;
							vol->timeline->header.srootNode.ref.index = time->disk->nextWrite;
							dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
						}
						time->disk->nextWrite = prev->nextWrite;
						time->disk->priorWrite = next->priorWrite;
						prev->nextWrite = myself;
						next->priorWrite = myself;
						dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
						if( cache2 ) dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
						break;
					}
				}
			} else if( prev && ( prev->time > time->disk->time ) ) {
				//myself = prev->nextWrite;
				if( !( prev->nextWrite = time->disk->nextWrite ) ) {
					vol->timeline->header.last_added_entry.ref.index = time->disk->priorWrite;
					SMUDGECACHE( vol, vol->timelineCache );
				}
				if( next )
					next->priorWrite = time->disk->priorWrite;
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
				lprintf( "Searching backward" );
				dumpTimeline( vol );
#endif
				while( ( _cache2 ? dropRawTimeEntry( vol, _cache2 GRTENoLog DBG_RELAY ) : (void)0 ), ( _cache2 = cache2 ), ( cache2 = BC( TIMELINE ) )
					, ( next = prev ) ) {
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
					lprintf( "checking next record %lld", next->priorWrite );
#endif
					if( !next->priorWrite ) {
						next->priorWrite = myself;
						if( !time->disk->nextWrite ) {
							struct storageTimelineNode* prev;
							enum block_cache_entries_os cache = BC( TIMELINE );
							prev = getRawTimeEntry( vol, time->disk->priorWrite, &cache GRTENoLog DBG_RELAY );
							if( prev ) prev->nextWrite = 0;
							vol->timeline->header.last_added_entry.ref.index = time->disk->priorWrite;
							dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
						}
						time->disk->nextWrite = vol->timeline->header.srootNode.ref.index;
						time->disk->priorWrite = 0;
						vol->timeline->header.srootNode.ref.index = myself;
						SMUDGECACHE( vol, vol->timelineCache );
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
						lprintf( "Saving as first..." );
#endif
						if( cache ) dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
						dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
						break;
					} else {
						( prev = getRawTimeEntry( vol, next->priorWrite, &cache2 GRTENoLog DBG_SRC ) );
					}
					if( !prev->priorWrite ) {
						// new root node...
						vol->timeline->header.srootNode.ref.index = prev->priorWrite = myself;
						SMUDGECACHE( vol, vol->timelineCache );
						if( !time->disk->nextWrite ) {
							struct storageTimelineNode* prev;
							enum block_cache_entries_os cache = BC( TIMELINE );
							prev = getRawTimeEntry( vol, time->disk->priorWrite, &cache GRTENoLog DBG_RELAY );
							if( prev ) prev->nextWrite = 0;
							vol->timeline->header.last_added_entry.ref.index = time->disk->priorWrite;
							dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
						}
						time->disk->nextWrite = next->priorWrite;
						time->disk->priorWrite = 0;
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
						lprintf( "Saving as first(2)..." );
#endif
						if( cache ) dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
						dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
 // done. (at end anyway)
						break;
					}
					if( prev->time < time->disk->time ) {
						if( !time->disk->nextWrite ) {
							struct storageTimelineNode* prev;
							enum block_cache_entries_os cache = BC( TIMELINE );
							prev = getRawTimeEntry( vol, time->disk->priorWrite, &cache GRTENoLog DBG_RELAY );
							if( prev ) prev->nextWrite = 0;
							vol->timeline->header.last_added_entry.ref.index = time->disk->priorWrite;
							dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
						}
						time->disk->nextWrite = prev->nextWrite;
						time->disk->priorWrite = next->priorWrite;
						prev->nextWrite = myself;
						next->priorWrite = myself;
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
						lprintf( "Saving in middle..." );
#endif
						if( cache ) dropRawTimeEntry( vol, cache GRTELog DBG_RELAY );
						dropRawTimeEntry( vol, cache2 GRTELog DBG_RELAY );
						break;
					}
				}
			} else {
				// didn't have to move anything... maybe it's time is still the same relative to everything?
			}
		}
	}
#ifdef DEBUG_TIMELINE_REORDER_LOGGING
	dumpTimeline( vol );
#endif
}
//-----------------------------------------------------------------------------------
// Timeline Support Functions
//-----------------------------------------------------------------------------------
void updateTimeEntry( struct memoryTimelineNode* time, struct sack_vfs_os_volume* vol, LOGICAL drop DBG_PASS ) {
	if( time ) {
		SMUDGECACHE( vol, time->diskCache );
		// time changed...(maybe?)
	}
	if( drop ) {
		int locks;
		int bit = time->diskCache;
		locks = GETMASK_( vol->seglock, seglock, bit );
#ifdef DEBUG_TEST_LOCKS
#ifdef DEBUG_LOG_LOCKS
		lprintf( "Unlock %d %d", time->diskCache, locks );
#endif
		if( !locks ) {
			lprintf( "Lock UNDERFLOW" );
			DebugBreak();
		}
#endif
		locks--;
		SETMASK_( vol->seglock, seglock, bit, locks );
	}
}
//---------------------------------------------------------------------------
void reloadDirectoryEntry( struct sack_vfs_os_volume* vol, struct memoryTimelineNode* time, struct sack_vfs_os_find_info* decoded_dirent DBG_PASS ) {
	enum block_cache_entries cache = BC( DIRECTORY );
// , * entkey;
	struct directory_entry* dirent;
	struct directory_hash_lookup_block* dirblock;
	//struct directory_hash_lookup_block* dirblockkey;
	PDATASTACK pdsChars = CreateDataStack( 1 );
	BLOCKINDEX this_dir_block = (time->disk->dirent_fpi >> DIR_BLOCK_SIZE_BITS )-1;
	BLOCKINDEX next_block;
	dirblock = BTSEEK( struct directory_hash_lookup_block*, vol, this_dir_block, DIR_BLOCK_SIZE, cache );
	//dirblockkey = (struct directory_hash_lookup_block*)vol->usekey[cache];
	dirent = (struct directory_entry*)( ( (uintptr_t)dirblock ) + ( time->disk->dirent_fpi & ( DIR_BLOCK_SIZE - 1 ) ) );
	//entkey = (struct directory_entry*)(((uintptr_t)dirblockkey) + (time->dirent_fpi & BLOCK_SIZE));
	decoded_dirent->vol = vol;
	// all of this regards the current state of a find cursor...
	decoded_dirent->base = NULL;
	decoded_dirent->base_len = 0;
	decoded_dirent->mask = NULL;
	decoded_dirent->pds_directories = NULL;
	decoded_dirent->filesize = (size_t)( dirent->filesize );
	if( time->disk->priorTime ) {
		enum block_cache_entries cache;
		struct storageTimelineNode* prior = getRawTimeEntry( vol, time->disk->priorTime, &cache GRTENoLog DBG_SRC );
		while( prior->priorTime ) {
			dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
			prior = getRawTimeEntry( vol, prior->priorTime, &cache GRTENoLog DBG_RELAY );
		}
		decoded_dirent->ctime = prior->time;
		dropRawTimeEntry( vol, cache GRTENoLog DBG_RELAY );
	}
	else
		decoded_dirent->ctime = time->disk->time;
	decoded_dirent->wtime = time->disk->time;
	while( (next_block = dirblock->next_block[DIRNAME_CHAR_PARENT]) ) {
		enum block_cache_entries back_cache = BC( DIRECTORY );
		struct directory_hash_lookup_block* back_dirblock;
		back_dirblock = BTSEEK( struct directory_hash_lookup_block*, vol, next_block, DIR_BLOCK_SIZE, back_cache );
		//back_dirblockkey = (struct directory_hash_lookup_block*)vol->usekey[back_cache];
		int i;
		for( i = 0; i < DIRNAME_CHAR_PARENT; i++ ) {
			if( (back_dirblock->next_block[i]) == this_dir_block ) {
				PushData( &pdsChars, &i );
				break;
			}
		}
		if( i == DIRNAME_CHAR_PARENT ) {
			// directory didn't have a forward link to it?
			DebugBreak();
		}
		this_dir_block = next_block;
		dirblock = back_dirblock;
	}
	char* c;
	int n = 0;
	// could fill leadin....
	decoded_dirent->leadin[0] = 0;
	decoded_dirent->leadinDepth = 0;
	while( c = (char*)PopData( &pdsChars ) )
		decoded_dirent->filename[n++] = c[0];
	DeleteDataStack( &pdsChars );
	{
		BLOCKINDEX nameBlock;
		nameBlock = dirblock->names_first_block;
		FPI name_offset = (dirent[n].name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
		enum block_cache_entries cache = BC( NAMES );
		const char* dirname = (const char*)vfs_os_FSEEK( vol, NULL, nameBlock, name_offset, &cache, NAME_BLOCK_SIZE DBG_SRC );
		const char* dirname_ = dirname;
		//const char* dirkey = (const char*)(vol->usekey[cache]) + (name_offset & BLOCK_MASK);
		const char* prior_dirname = dirname;
		int c;
		do {
			while( (((unsigned char)(c = (dirname[0] )) != UTF8_EOT))
				&& ((((uintptr_t)prior_dirname) & ~BLOCK_MASK) == (((uintptr_t)dirname) & ~BLOCK_MASK))
				) {
				decoded_dirent->filename[n++] = c;
				dirname++;
				//dirkey++;
			}
			if( ((((uintptr_t)prior_dirname) & ~BLOCK_MASK) != (((uintptr_t)dirname) & ~BLOCK_MASK)) ) {
				int partial = (int)(dirname - dirname_);
				cache = BC( NAMES );
				dirname = (const char*)vfs_os_FSEEK( vol, NULL, nameBlock, name_offset + partial, &cache, NAME_BLOCK_SIZE DBG_SRC );
				//dirkey = (const char*)(vol->usekey[cache]) + ((name_offset + partial) & BLOCK_MASK);
				dirname_ = dirname - partial;
				prior_dirname = dirname;
				continue;
			}
			// didn't stop because it exceeded a sector boundary
			break;
		} while( 1 );
	}
	decoded_dirent->filename[n] = 0;
	decoded_dirent->filenamelen = n;
	//time->dirent_fpi
}
//---------------------------------------------------------------------------
static void deleteTimelineIndex( struct sack_vfs_os_volume* vol, BLOCKINDEX index ) {
	BLOCKINDEX next;
	do {
		struct storageTimelineNode* time;
		enum block_cache_entries cache = BC( TIMELINE );
		//lprintf( "Delete start... %d", index );
		time = getRawTimeEntry( vol, index, &cache GRTELog DBG_SRC );
 // this type is larger than index in some configurations
		next = (BLOCKINDEX)time->priorTime;
		nodes--;
		if( !next ) {
			if( vol->timeline->header.srootNode.ref.index == index ) {
				vol->timeline->header.srootNode.ref.index = time->nextWrite;
			}
		}
		{
			struct storageTimeline* timeline = vol->timeline;
			time->priorTime = (uint32_t)timeline->header.first_free_entry.ref.index;
			timeline->header.first_free_entry.ref.index = index;
			SMUDGECACHE( vol, vol->timelineCache );
			SMUDGECACHE( vol, cache );
		}
		dropRawTimeEntry( vol, cache GRTELog DBG_SRC );
#ifdef DEBUG_VALIDATE_TREE
		//ValidateTimelineTree( vol DBG_SRC );
#endif
		//lprintf( "Delete done... %d", index );
	} while( index = next );
#ifdef DEBUG_DELETE_LAST
	checkRoot( vol );
#endif
	//lprintf( "Root is now %d %d", nodes, vol->timeline->header.srootNode.ref.index );
}
BLOCKINDEX getTimeEntry( struct memoryTimelineNode* time, struct sack_vfs_os_volume* vol, LOGICAL unused, void(*init)(uintptr_t, struct memoryTimelineNode*), uintptr_t psv DBG_PASS ) {
	//enum block_cache_entries cache = BC( TIMELINE );
	//enum block_cache_entries cache_last = BC( TIMELINE );
	//enum block_cache_entries cache_free = BC( TIMELINE );
	//enum block_cache_entries cache_new = BC( TIMELINE );
	struct storageTimeline* timeline = vol->timeline;
	TIMELINE_BLOCK_TYPE freeIndex;
	BLOCKINDEX index;
	//BLOCKINDEX priorIndex = (BLOCKINDEX)time->index; // ref.index type is larger than index in some configurations; but won't exceed those bounds
	BLOCKINDEX lastIndex = timeline->header.last_added_entry.ref.index;
	freeIndex.ref.index = timeline->header.first_free_entry.ref.index;
	// update next free.
 // ref.index type is larger than index in some configurations; but won't exceed those bounds
	reloadTimeEntry( time, vol, index = (BLOCKINDEX)freeIndex.ref.index VTReadWrite GRTELog DBG_RELAY );
	if( !timeline->header.srootNode.ref.index )
		timeline->header.srootNode.ref.index = 1;
	timeline->header.first_free_entry.ref.index = timeline->header.first_free_entry.ref.index + 1;
	// make sure the new entry is emptied.
	//time->disk->me_fpi = 0;
	time->disk->dirent_fpi = 0;
	time->disk->priorTime = 0;
	time->disk->priorData = 0;
	time->disk->priorDataSize = 0;
	if( lastIndex )
	{
		enum block_cache_entries cache_near = BC( TIMELINE );
		struct storageTimelineNode* last = getRawTimeEntry( vol, lastIndex, &cache_near GRTENoLog DBG_RELAY );
		if( !last->nextWrite ) {
			last->nextWrite = index;
			// updated a value here...
			SMUDGECACHE( vol, cache_near );
		} else {
			lprintf( "Shouldn't have to find what the last node in the chain is...." );
			/*
			dropRawTimeEntry( vol, cache_near GRTENoLog DBG_RELAY );
			while( last = getRawTimeEntry( vol, last->nextWrite, &cache_near GRTENoLog DBG_RELAY ) ) {
				dropRawTimeEntry( vol, cache_near );
				if( !last->nextWrite ) {
					last->nextWrite = index;
					break;
				}
			}
			*/
		}
		dropRawTimeEntry( vol, cache_near GRTENoLog DBG_RELAY );
	}
	time->disk->priorWrite = lastIndex;
	time->disk->nextWrite = 0;
 // there really shouldn't be any times after this one....
	time->disk->time = timeGetTime64ns();
	timeline->header.last_added_entry.ref.index = index;
	SMUDGECACHE( vol, vol->timelineCache );
	{
		int tz = GetTimeZone();
		if( tz < 0 )
 // -840/15 = -56
			tz = -( ( ( -tz / 100 ) * 60 ) + ( -tz % 100 ) ) / 15;
		else
 // -840/15 = -56  720/15 = 48
			tz = ( ( ( tz / 100 ) * 60 ) + ( tz % 100 ) ) / 15;
		//time->disk->time += (int64_t)tz * 900 * (int64_t)1000000000;
		time->disk->timeTz = tz;
	}
	if( init ) init( psv, time );
	//nodes++;
	//lprintf( "Add start... %d", freeIndex.ref.index );
#if defined( DEBUG_TIMELINE_DIR_TRACKING) || defined( DEBUG_TIMELINE_AVL )
	LoG( "Return time entry:%d", time->index );
#endif
 // don't drop; returning this one.
	updateTimeEntry( time, vol, FALSE DBG_RELAY );
	return index;
}
BLOCKINDEX updateTimeEntryTime( struct memoryTimelineNode* time
			, struct sack_vfs_os_volume *vol, uint64_t index
			, LOGICAL allocateNew
			, void( *init )( uintptr_t, struct memoryTimelineNode* ), uintptr_t psv DBG_PASS ) {
	if( allocateNew ) {
		if( time ) {
			uint64_t inputIndex = time ? time->index : index;
			// gets a new timestamp.
			//enum block_cache_entries inputCache = time ? time->diskCache : BC( ZERO );
			BLOCKINDEX newIndex = getTimeEntry( time, vol, TRUE, init, psv DBG_RELAY );
			time->disk->priorTime = (uint32_t)inputIndex;
			updateTimeEntry( time, vol, FALSE DBG_RELAY );
			//dropRawTimeEntry( vol, inputCache GRTELog DBG_RELAY );
			return newIndex;
		}
		else {
			struct memoryTimelineNode time_;
			struct storageTimelineNode* timeold;
			uint64_t inputIndex = index;
			enum block_cache_entries inputCache;
			FPI dirent_fpi;
			timeold = getRawTimeEntry( vol, index, &inputCache GRTELog DBG_RELAY );
 // ref.index type is larger than index in some configurations; but won't exceed those bounds
			dirent_fpi = (FPI)timeold->dirent_fpi;
			dropRawTimeEntry( vol, inputCache GRTELog DBG_RELAY );
			// gets a new timestamp.
			time_.index = index;
			BLOCKINDEX newIndex = getTimeEntry( &time_, vol, TRUE, init, psv DBG_RELAY );
			time_.disk->priorTime = (uint32_t)inputIndex;
			time_.disk->dirent_fpi = dirent_fpi;
			updateTimeEntry( &time_, vol, TRUE DBG_RELAY );
			return newIndex;
		}
	}
	else {
		struct memoryTimelineNode time_;
		//LOGICAL existing = ( time ) ? 1 : 0;
		if( !time ) time = &time_;
		reloadTimeEntry( time, vol, index VTReadWrite GRTENoLog DBG_RELAY );
		time->disk->time = timeGetTime64ns();
		{
			int tz = GetTimeZone();
			if( tz < 0 )
 // -840/15 = -56
				tz = -( ( ( -tz / 100 ) * 60 ) + ( -tz % 100 ) ) / 15;
			else
 // -840/15 = -56  720/15 = 48
				tz = ( ( ( tz / 100 ) * 60 ) + ( tz % 100 ) ) / 15;
			//time->disk->time += (int64_t)tz * 900 * (int64_t)1000000000;
			time->disk->timeTz = tz;
		}
		reorderEntry( time, vol, 1 DBG_RELAY );
		updateTimeEntry( time, vol, TRUE DBG_RELAY );
 // index type is larger than index in some configurations; but won't exceed those bounds
		return (BLOCKINDEX)index;
	}
}
LOGICAL setTimeEntryTime( struct memoryTimelineNode* time
			, struct sack_vfs_os_volume *vol
			, uint64_t tick
			, int tz ) {
	if( !time ) {
//time = &time_;
		lprintf( "invalid time entry passed" );
		return FALSE;
	} else {
		//reloadTimeEntry( time, vol, index VTReadWrite GRTENoLog DBG_RELAY );
		time->disk->timeTz = tz;
		time->disk->time = tick;
		reorderEntry( time, vol, 0 DBG_SRC );
		updateTimeEntry( time, vol, FALSE DBG_SRC );
		return TRUE;
	}
}
struct sack_vfs_os_time_cursor* sack_vfs_os_get_time_cursor( struct sack_vfs_os_volume *vol ) {
	struct sack_vfs_os_time_cursor* cursor;
	cursor = New( struct sack_vfs_os_time_cursor );
	cursor->vol = vol;
	cursor->at = 0;
	return cursor;
}
//--------------------------------
//  read TIme Cursor reads/steps the cursor...
//    step==0 && time === 0 && at === 0 ; start at the start of timeline.
//    step==0 && time === N ; seek to time N, update at to the found record
//    step==1 && time === N ; seek to record N, update at to the time at the indexed record
//
LOGICAL sack_vfs_os_read_time_cursor( struct sack_vfs_os_time_cursor* cursor, int step, uint64_t time, uint64_t* result_entry, const char**filename
	, uint64_t *result_timestamp, int8_t *result_tz, const char**buffer, size_t *size ) {
	static char* dataBuffer;
	static size_t bufsize;
	//uint64_t time = (time_ >> 8) * 1000000;
 // last raw entry cache
	enum block_cache_entries_os cache;
	LOGICAL dropCache = FALSE;
 // used as the record found indicator.
	uint64_t entry = 0;
	if( step == 2 ) {
		entry = cursor->at;
	}
	else if( step == 1 ) {
		if( !time ) {
			cursor->at = entry = cursor->vol->timeline->header.srootNode.ref.index;
		}else
			cursor->at = entry = time;
	}
	else if( step == 0 ) {
		// if( !time_ )
		struct storageTimelineNode* timeNode = getRawTimeEntry( cursor->vol, cursor->vol->timeline->header.srootNode.ref.index, &cache GRTENoLog DBG_SRC );
		while( timeNode && timeNode->time < time ) {
			uint64_t next = timeNode->nextWrite;
			dropRawTimeEntry( cursor->vol, cache  GRTENoLog DBG_SRC );
			if( next ) timeNode = getRawTimeEntry( cursor->vol, next, &cache GRTENoLog DBG_SRC );
			else timeNode = NULL;
			entry = next;
		}
		if( !timeNode )
			return FALSE;
		dropCache = TRUE;
	}
	if( entry )
	{
		LOGICAL retVal = TRUE;
		{
		struct memoryTimelineNode memEntry;
		reloadTimeEntry( &memEntry, cursor->vol, entry GRTENoLog DBG_SRC );
		if( memEntry.disk->dirent_fpi ) {
			cursor->at = memEntry.disk->nextWrite;
			struct sack_vfs_os_find_info decoded_dirent;
			reloadDirectoryEntry( cursor->vol, &memEntry, &decoded_dirent DBG_SRC );
			if( result_entry ) {
				result_entry[0] = memEntry.index;
			}
			if( result_tz ) {
				result_tz[0] = memEntry.disk->timeTz;
			}
			if( result_timestamp ) {
				result_timestamp[0] = memEntry.disk->time;
			}
			if( filename ) {
				filename[0] = StrDup( decoded_dirent.filename );
			}
			if( size ) {
				size[0] = decoded_dirent.filesize;
				if( buffer ) {
					if( bufsize < size[0] ) {
						dataBuffer = (char*)Reallocate( dataBuffer, size[0] );
					}
					buffer[0] = dataBuffer;
					{
						// there might be a more optimal method of doing this; but this is easy to read.
						struct sack_vfs_file* file = sack_vfs_os_openfile( cursor->vol, decoded_dirent.filename );
						sack_vfs_os_read( file, dataBuffer, size[0] );
						sack_vfs_os_close( file );
					}
				}
			}
		} else
			retVal = FALSE;
		dropRawTimeEntry( cursor->vol, memEntry.diskCache GRTENoLog DBG_SRC );
		if( dropCache )
			dropRawTimeEntry( cursor->vol, cache  GRTENoLog DBG_SRC );
		}
		return retVal;
		//cursor->at = time;
	}
	return FALSE;
}
//#include "vfs_os_timeline.c"
//#define priorData prior.ref.index
struct blockInfo {
	BLOCKINDEX block;
	FPI start;
	int size;
};
struct sack_vfs_os_file
{
 // which volume this is in
	struct sack_vfs_os_volume* vol;
	FPI fpi;
	BLOCKINDEX _first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
	struct blockInfo* blockChain;
	unsigned int blockChainAvail;
	unsigned int blockChainLength;
#  ifdef FILE_BASED_VFS
  // where to write the directory entry update to
	FPI entry_fpi;
 // delete also needs the block number
	BLOCKINDEX dir_block;
#    ifdef XX_VIRTUAL_OBJECT_STORE
	/* extended internal file information that just makes it harder to recover in a crash.*/
	int blockSize;
	struct file_header diskHeader;
  // in-memory size, so we can just do generic move op
	struct file_header header;
	//struct memoryTimelineNode timeline;
	uint8_t* seal;
	uint8_t* sealant;
	uint8_t* readKey;
	uint16_t readKeyLen;
	//uint8_t sealantLen;
 // boolean, on read, validates seal.  Defaults to FALSE.
	uint8_t sealed;
	//char* filename;
	LOGICAL fileName;
#    endif
	struct sack_vfs_os_file_flags {
		BIT_FIELD versioned : 1;
	}flags;
  // has file size within
	struct directory_entry  entry_;
  // has file size within
	struct directory_entry* entry;
  // how big the file is (live - reflects size for files opened by version)
	VFS_DISK_DATATYPE filesize_;
 // files without names use this as thier preferred cache target
	enum block_cache_entries cache;
#  else
  // has file size within
	struct directory_entry* entry;
#  endif
};
typedef struct sack_vfs_os_file VFS_OS_FILE;
#define MAXVFS_OS_FILESPERSET 256
DeclareSet( VFS_OS_FILE );
#define l vfs_os_local
static struct {
	struct directory_entry zero_entkey;
	uint8_t zerokey[KEY_SIZE];
	uint16_t index[256][256];
	char leadin[MAX_FILENAME_LEN];
	int leadinDepth;
	PLINKQUEUE plqCrypters;
	PLIST volumes;
	LOGICAL exited;
	PVFS_OS_FILESET files;
 // symbol not defined
#ifdef DEBUG_CONVERT_DIRECTORY
	int fileCount;
	int fileCount_old;
#endif
} l;
//static void _os_UpdateFileBlocks( struct sack_vfs_os_file* file );
static struct sack_vfs_os_file* _os_createFile( struct sack_vfs_os_volume* vol, BLOCKINDEX first_block, int blockSize );
static int sack_vfs_os_close_internal( struct sack_vfs_os_file* file, int unlock );
static enum block_cache_entries _os_UpdateSegmentKey_( struct sack_vfs_os_volume* vol, enum block_cache_entries* cache_idx, BLOCKINDEX segment DBG_PASS );
#ifdef DEBUG_DIRECTORIES
static int _os_dumpDirectories( struct sack_vfs_os_volume *vol, BLOCKINDEX start, LOGICAL init );
#endif
//#include "vfs_os_index.c"
#ifdef XX_VIRTUAL_OBJECT_STORE
static void _os_SetSmallBlockUsage( struct file_block_small_definition* block, int more ) {
	block->used = more;
	while( block->avail < block->used )
		block->avail += 128;
}
static uint32_t _os_AddSmallBlockUsage( struct file_block_small_definition* block, uint32_t more ) {
	uint32_t oldval = block->used;
	_os_SetSmallBlockUsage( block, block->used + more );
	return oldval;
}
static void _os_SetFileBlockUsage( struct file_block_small_definition* block, uint32_t more ) {
	block->used = more;
	while( block->avail < block->used )
		block->avail += 256;
}
#endif
ATEXIT( flushVolumes ){
	INDEX idx;
	struct sack_vfs_os_volume* vol;
	l.exited = 1;
	LIST_FORALL( l.volumes, idx, struct sack_vfs_os_volume*, vol ) {
		if( vol->file )
		sack_vfs_os_flush_volume( vol, TRUE );
#ifdef DEBUG_DIRECTORIES
		_os_dumpDirectories( vol, 0, 1 );
#endif
	}
}
#if 0
#define FILE_BLOCK_SEALANT 0
#define FILE_BLOCK_REFERENCES 1
#define FILE_BLOCK_DATA 2
#define FILE_BLOCK_INDEXES 3
#define FILE_BLOCK_REFERENCED_BY 4
static FPI GetBlockStart( struct sack_vfs_os_file* file, int blockType ) {
	FPI blockStart = sizeof( struct file_header );
	switch( blockType ) {
		//case 5:
		//	blockStart += file->header.fileData.avail; // end of file.
	case FILE_BLOCK_REFERENCED_BY:
		blockStart += file->header.indexes.avail;
	case FILE_BLOCK_INDEXES:
		blockStart += (FPI)file->header.fileData.avail;
	case FILE_BLOCK_DATA:
		blockStart += file->header.references.avail;
	case FILE_BLOCK_REFERENCES:
		blockStart += file->header.sealant.avail;
	case FILE_BLOCK_SEALANT:
		// starts at position 0.
		break;
	}
	return blockStart;
}
void WriteIntoBlock( struct sack_vfs_os_file* file, int blockType, FPI pos, CPOINTER data, FPI length ) {
	FPI blockStart = GetBlockStart( file, blockType );
	sack_vfs_os_seek_internal( file, (size_t)blockStart, SEEK_SET );
	sack_vfs_os_write_internal( file, data, (size_t)length, NULL );
}
static void _os_SetLargeBlockUsage( struct file_block_large_definition* block, uint64_t more ) {
	block->used = more;
	while( block->avail < block->used )
		block->avail = ( block->used + BLOCK_SIZE ) & BLOCK_MASK;
}
#endif
static void _os_ExtendBlockChain( struct sack_vfs_os_file* file ) {
	int newSize = ( file->blockChainAvail ) * 2 + 1;
	file->blockChain = ( struct blockInfo*)Reallocate( file->blockChain, newSize * sizeof( struct blockInfo ) );
#ifdef _DEBUG
	// debug
	memset( file->blockChain + file->blockChainAvail, 0, ( newSize - file->blockChainAvail ) * sizeof( struct blockInfo ) );
#endif
	 file->blockChainAvail = newSize;
}
static unsigned int getBlockChainBlock( struct sack_vfs_os_file* file, FPI fpi ) {
	unsigned int fileBlock = file->blockChainLength;
	int block;
	int minLen = 0;
	int maxLen = file->blockChainLength - 1;
	while( minLen <= maxLen ) {
		block = ( minLen + maxLen ) / 2;
		if( fpi >= ( file->blockChain[block].start + file->blockChain[block].size ) )
			minLen = block + 1;
		else if( fpi < file->blockChain[block].start )
			maxLen = block - 1;
		else {
			fileBlock = block;
			break;
		}
	}
	return fileBlock;
}
static void _os_SetBlockChain( struct sack_vfs_os_file* file, FPI fpi, BLOCKINDEX newBlock, int size ) {
	FPI fileBlock = file->blockChainLength;
	//lprintf( "Set chain %p %d %d %d", file, (int)fpi, (int)newBlock, (int)size );
	if( file->blockChainLength ) {
		if( fpi < ( file->blockChain[file->blockChainLength - 1].start + file->blockChain[file->blockChainLength - 1].size ) ) {
			// when seek happens and initial position is past the end,
			// seek has to step through the file, for each block to adjust size properly...
			//lprintf( "Re-setting an internal block?" );
			fileBlock = getBlockChainBlock( file, fpi );
		}
		else if( fpi == ( file->blockChain[file->blockChainLength - 1].start + file->blockChain[file->blockChainLength - 1].size ) ) {
		}
	}
#ifdef _DEBUG
	if( !newBlock ) DebugBreak();
#endif
	while( (fileBlock) >= file->blockChainAvail ) {
		_os_ExtendBlockChain( file );
	}
	if( fileBlock >= file->blockChainLength )
		file->blockChainLength = (unsigned int)(fileBlock + 1);
	//_lprintf(DBG_SRC)( "setting file at %d  to  %d to %d", (int)file->_first_block, (int)fileBlock, (int)newBlock );
	if( file->blockChain[fileBlock].block ) {
		if( file->blockChain[fileBlock].block == newBlock ) {
			return;
		}
		else {
			lprintf( "Re-setting chain to a new block... %d was %d and wants to be %d", (int)fpi, (int)file->blockChain[fileBlock].block, (int)newBlock );
			DebugBreak();
		}
	}
	file->blockChain[fileBlock].block = newBlock;
	file->blockChain[fileBlock].size = size;
	file->blockChain[fileBlock].start = fpi;
}
// seek by byte position from a starting block; as file; result with an offset into a block.
uintptr_t vfs_os_FSEEK_v2( struct sack_vfs_os_volume *vol
  // if no file, first block must be manually specified
	, struct sack_vfs_os_file *file
  // if file, firstblock comes from the file
	, BLOCKINDEX firstblock
    // offset in the block-chain from the specified start
	, FPI offset
  // this is the cache entry that the data was loaded into
	, enum block_cache_entries *cache_index
   // if a new block is needed, use this size to allocate.
	, int blockSize
 // where the new block ( if any) is updated;
	, LOGICAL flush_BAT_caches
	DBG_PASS
)
{
#ifdef DEBUG_FILE_SEEK
	LoG_( "File Seek: %p %d %d", file, (int)offset, cache_index[0] );
#endif
	enum block_cache_entries cacheRoot = cache_index[0];
	size_t priorSize;
	uint8_t *data;
	FPI pos = 0;
	if( file ) {
		unsigned chainBlock = getBlockChainBlock( file, offset );
		if( chainBlock < file->blockChainLength ) {
			firstblock = file->blockChain[chainBlock].block;
			pos = file->blockChain[chainBlock].start;
			offset -= pos;
			priorSize = file->blockChain[chainBlock].size;
		} else {
			if( file->blockChainLength ) {
				if( offset >= file->blockChain[file->blockChainLength - 1].start ) {
					firstblock = file->blockChain[file->blockChainLength - 1].block;
					offset -= ( pos = file->blockChain[file->blockChainLength - 1].start );
					priorSize = file->blockChain[file->blockChainLength - 1].size;
				}
				else {
					lprintf( "Should have found a block for this offset before here." );
					DebugBreak();
				}
			}
			else {
				firstblock = file->_first_block;
				priorSize = vol->sector_size[cache_index[0]];
				cache_index[0] = cacheRoot;
			}
		}
	} else priorSize = blockSize;
	while( firstblock != EOFBLOCK && offset >= priorSize ) {
		int size;
		enum block_cache_entries cache =
				file ?
#ifdef XX_VIRTUAL_OBJECT_STORE
			file->fileName ? BC( FILE ) :
#endif
			file->cache: cacheRoot;
#ifdef DEBUG_FILE_SEEK
		LoG_( "Getting next block after %p %d %d", file, firstblock, blockSize );
#endif
		firstblock = vfs_os_GetNextBlock_v2( vol, firstblock
			, &cache
			, file?
#ifdef XX_VIRTUAL_OBJECT_STORE
			file->fileName?GFB_INIT_NONE:
#endif
			GFB_INIT_TIMELINE_MORE:GFB_INIT_NAMES, 1, blockSize, &size, flush_BAT_caches );
		if( size != blockSize ) {
			lprintf( "Tried to allocate %d got %d at %d (from %d)", blockSize, size, *cache_index, cacheRoot );
			DebugBreak();
		}
		offset -= priorSize;
		pos += priorSize;
		priorSize = size;
		if( file ) {
			_os_SetBlockChain( file, pos, firstblock, size );
		}
	}
	data = (uint8_t*)vfs_os_BSEEK_( vol, firstblock, blockSize, cache_index DBG_RELAY );
#if DEBUG_SET_SECTOR_SIZE
	LoG_( "Sector size: %p (ss)%d (blk)%d (ofs)%d (cache)%d",data, priorSize, (int)firstblock, (int)offset , cache_index[0] );
#endif
	return (uintptr_t)(data + (offset));
}
uintptr_t vfs_os_FSEEK( struct sack_vfs_os_volume* vol
  // if no file, first block must be manually specified
	, struct sack_vfs_os_file* file
  // if file, firstblock comes from the file
	, BLOCKINDEX firstblock
    // offset in the block-chain from the specified start
	, FPI offset
  // this is the cache entry that the data was loaded into
	, enum block_cache_entries* cache_index
   // if a new block is needed, use this size to allocate.
	, int blockSize
	DBG_PASS
) {
	return vfs_os_FSEEK_v2( vol, file, firstblock, offset, cache_index, blockSize, FALSE DBG_RELAY );
}
static void vfs_os_empty_rollback( struct sack_vfs_os_volume* vol ) {
	enum block_cache_entries rollbackCache = BC( ROLLBACK );
	struct vfs_os_rollback_header* rollback = ( struct vfs_os_rollback_header* )vfs_os_FSEEK( vol, vol->journal.rollback_file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
#ifdef DEBUG_ROLLBACK_JOURNAL
	LoG( "------- ROLLBACK FLUSH---------------- %d", rollback->flags.dirty );
#endif
	if( rollback->flags.dirty ) {
		vol->journal.pdlJournaled->Cnt = 0;
		vol->journal.journalLength = 0;
		rollback->flags.dirty = 0;
		rollback->nextBlock = 0;
		rollback->nextSmallBlock = 0;
		rollback->nextEntry = 0;
		SMUDGECACHE( vol, rollbackCache );
		sack_vfs_os_flush_block( vol, rollbackCache );
	}
}
//---------------------------------------------------------------------------
static void ExpandJournalIndex(struct vfs_os_rollback_journal *journal ) {
 // sectors that are in rollback already
	BLOCKINDEX *pNewJournaled;
	//int journalLength; // how long pJournaled is used
	//int journalAvail; // max length of pJournaled
	journal->journalAvail = journal->journalAvail*2+1;
	pNewJournaled = NewArray( BLOCKINDEX,	 journal->journalAvail );
	MemCpy( pNewJournaled, journal->pJournaled, journal->journalLength * sizeof( *pNewJournaled ) );
	Release( journal->pJournaled );
	journal->pJournaled = pNewJournaled;
}
//---------------------------------------------------------------------------
static void vfs_os_record_rollback( struct sack_vfs_os_volume* vol, enum block_cache_entries entry ) {
	INDEX nextRecord = 0;
	INDEX curIdx = 0;
	BLOCKINDEX segment = vol->segment[entry];
	if( entry >= BC( ROLLBACK ) ) {
		return;
	}
	// not setup to journal yet (initial loading/configuration)
	if( !vol->journal.rollback_file ) {
		//lprintf( "Journal is not a file... bad open? Unjournaled storage?");
		//AddLink( &vol->pending_rollback, (uintptr_t)entry );
		sack_vfs_os_flush_block( vol, entry );
		return;
	}
	if( vol->journal.journalLength )
	{
		int imin = 0;
		int imax = vol->journal.journalLength-1;
		if( segment < vol->journal.pJournaled[imax] )
		{
			curIdx = imax >> 1;
			while( imin <= imax && ( curIdx <= imax ) && ( imax >= 0 ) ) {
				int d;
				//LoG( "this name: %s", names );
				if( ( d = (int)(segment - vol->journal.pJournaled[curIdx] ) ) == 0  ) {
					return;
				}
				if( d > 0 ) {
					imin = (int)curIdx + 1;
				} else {
					if( !curIdx ) break;
					imax = (int)curIdx - 1;
				}
				curIdx = (imin + imax) >> 1;
			}
		}
		else if( segment == vol->journal.pJournaled[imax] )
 // is already saved as the last.
			return;
		else
			curIdx = imax;
		if( 0 )
		{
			INDEX idx;
			BLOCKINDEX* check;
			DATA_FORALL( vol->journal.pdlJournaled, idx, BLOCKINDEX*, check ) {
				if( check[0] == segment ) {
#ifdef DEBUG_ROLLBACK_JOURNAL
					LoG( "Journal recording already has this sector marked %d %d", idx, segment );
#endif
					return;
				}
			}
		}
	}
#ifdef DEBUG_ROLLBACK_JOURNAL
	LoG( "Recording rollback for %d %d", (int)entry, (int)vol->segment[entry] );
#endif
	if( vol->journal.pdlPendingRecord->Cnt ) {
		// is already in-progress, record that this should be done later.
		AddDataItem( &vol->journal.pdlPendingRecord, &entry );
		return;
	}
	// mark in-progress.
	AddDataItem( &vol->journal.pdlPendingRecord, &entry );
	{
		if( (vol->journal.journalLength+1) >= vol->journal.journalAvail ) ExpandJournalIndex( &vol->journal );
		if( curIdx >= vol->journal.journalLength ) {
			if( curIdx && ( segment < vol->journal.pJournaled[curIdx-1] ) )  {
				vol->journal.pJournaled[curIdx] = vol->journal.pJournaled[curIdx-1];
				vol->journal.pJournaled[curIdx-1] = segment;
				vol->journal.journalLength++;
			}else {
				vol->journal.pJournaled[curIdx] = segment;
				vol->journal.journalLength++;
			}
		} else {
			if( segment < vol->journal.pJournaled[curIdx] ){
				if( curIdx ) {
					if( segment > vol->journal.pJournaled[curIdx-1] ){
						for( int n = vol->journal.journalLength; n > curIdx; n-- ) {
							vol->journal.pJournaled[n] = vol->journal.pJournaled[n-1];
						}
					}
					else lprintf( "segment is bad" );
				}else {
					for( int n = vol->journal.journalLength; n > curIdx; n-- ) {
						vol->journal.pJournaled[n] = vol->journal.pJournaled[n-1];
					}
				}
			}
			else if( segment > vol->journal.pJournaled[curIdx] ){
				if( curIdx + 1 >= vol->journal.journalLength ) {
					curIdx = curIdx+1;
				} else {
					while( segment > vol->journal.pJournaled[curIdx] ) curIdx++;
					for( int n = vol->journal.journalLength; n > (curIdx); n-- ) {
						vol->journal.pJournaled[n] = vol->journal.pJournaled[n-1];
					}
				}
			}
			vol->journal.pJournaled[curIdx] = segment;
			vol->journal.journalLength++;
		}
	}
	//AddDataItem( &vol->journal.pdlJournaled, &segment );
	enum block_cache_entries rollbackCache = BC( ROLLBACK );
	struct vfs_os_rollback_header* rollback = ( struct vfs_os_rollback_header* )vfs_os_FSEEK( vol, vol->journal.rollback_file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
 // don't journal recovery.
	if( rollback->flags.processing ) return;
	rollback->flags.dirty = 1;
	do {
		enum block_cache_entries rollbackCacheJournal;
		enum block_cache_entries rollbackEntryCache ;
// = vfs_os_FSEEK( vol, vol->journal.rollback_file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
		struct vfs_os_rollback_entry* rollbackEntry;
		POINTER journal;
		rollbackEntryCache = BC( ROLLBACK );
#ifdef DEBUG_ROLLBACK_JOURNAL
		LoG( "Record to journal: e: %d fpi:%x seg:%d  ne: %d  at %d", entry, (int)vol->bufferFPI[entry], (int)vol->segment[entry], rollback->nextEntry, sane_offsetof( struct vfs_os_rollback_header, entries[rollback->nextEntry]) );
#endif
		rollbackEntry = (struct vfs_os_rollback_entry*)vfs_os_FSEEK_v2( vol, vol->journal.rollback_file, 0
			, sane_offsetof( struct vfs_os_rollback_header, entries[rollback->nextEntry++] )
			, &rollbackEntryCache, ROLLBACK_BLOCK_SIZE, FALSE DBG_SRC );
		rollbackEntry->fileBlock = vol->segment[entry];
		rollbackCacheJournal = BC( ROLLBACK );
		if( vol->sector_size[entry] == BLOCK_SIZE ) {
			int n;
			uint64_t* p = (uint64_t*)vol->usekey_buffer_clean[entry];
			rollbackEntry->flags.zero = 0;
			rollbackEntry->flags.small = 0;
			for( n = 0; !p[0] && (n < (BLOCK_SIZE / sizeof( uint64_t ))); n++, p++ ) ;
			if( n < BLOCK_SIZE / sizeof( uint64_t ) ) {
#ifdef DEBUG_ROLLBACK_JOURNAL
				LoG( "Found non 0 at: %d  %d", n, p[0] );
				LoG( "Saving large, clean block" );
#endif
				journal = (POINTER)vfs_os_FSEEK_v2( vol, vol->journal.rollback_journal_file, 0, vol->sector_size[entry] * rollback->nextBlock++, &rollbackCacheJournal, vol->sector_size[entry], TRUE DBG_SRC );
			}  else {
#ifdef DEBUG_ROLLBACK_JOURNAL
				LoG( "Save as large zero" );
#endif
				rollbackEntry->flags.zero = 1;
			}
		} else {
			int n;
			uint64_t* p = (uint64_t*)vol->usekey_buffer_clean[entry];
			rollbackEntry->flags.zero = 0;
			rollbackEntry->flags.small = 1;
			for( n = 0; !p[0] && n < BLOCK_SMALL_SIZE / sizeof( uint64_t ); n++, p++ ) ;
			if( n < BLOCK_SMALL_SIZE / sizeof( uint64_t ) ) {
#ifdef DEBUG_ROLLBACK_JOURNAL
				LoG( "Found non 0 at: %d  %d", n, p[0] );
				LoG( "Saving small, clean block" );
#endif
				journal = (POINTER)vfs_os_FSEEK_v2( vol, vol->journal.rollback_small_journal_file, 0, vol->sector_size[entry] * rollback->nextSmallBlock++, &rollbackCacheJournal, vol->sector_size[entry], TRUE DBG_SRC );
			} else {
#ifdef DEBUG_ROLLBACK_JOURNAL
				LoG( "Save as small zero" );
#endif
				rollbackEntry->flags.zero = 1;
			}
		}
		if( !rollbackEntry->flags.zero ) {
			memcpy( journal, vol->usekey_buffer_clean[entry], vol->sector_size[entry] );
			SMUDGECACHE( vol, rollbackCacheJournal );
			sack_vfs_os_flush_block( vol, rollbackCacheJournal );
		}
		if( rollbackEntryCache != rollbackCache ) {
			SMUDGECACHE( vol, rollbackEntryCache );
			sack_vfs_os_flush_block( vol, rollbackEntryCache );
		}
		if( ++nextRecord < vol->journal.pdlPendingRecord->Cnt )
			entry = ( ( enum block_cache_entries* )GetDataItem( &vol->journal.pdlPendingRecord, nextRecord ) )[0];
		else {
 // empty the list.
			vol->journal.pdlPendingRecord->Cnt = 0;
			//vol->journal.pdlJournaled->Cnt = 0; // empty the list.
		}
	} while( vol->journal.pdlPendingRecord->Cnt );
	{
		int n;
		BLOCKINDEX prior = vol->journal.pJournaled[0];
		for( n = 1; n < vol->journal.journalLength; n++ ) {
			if( vol->journal.pJournaled[n] < prior ) DebugBreak();
			prior = vol->journal.pJournaled[n];
		}
	}
	SMUDGECACHE( vol, rollbackCache );
	sack_vfs_os_flush_block( vol, rollbackCache );
}
// reads the rollback journal and reverts anything.
static void vfs_os_process_rollback( struct sack_vfs_os_volume* vol ) {
	enum block_cache_entries rollbackCache = BC( ROLLBACK );
	enum block_cache_entries rollbackCacheJournal;
	enum block_cache_entries rollbackEntryCache;
	enum block_cache_entries rollbackEntryCache_ = BC( ZERO );
	enum block_cache_entries entry;
	struct vfs_os_rollback_header* rollback = ( struct vfs_os_rollback_header* )vfs_os_FSEEK( vol, vol->journal.rollback_file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
// = vfs_os_FSEEK( vol, vol->journal.rollback_file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
	struct vfs_os_rollback_entry* rollbackEntry;
	POINTER journal;
	SETMASK_( vol->seglock, seglock, rollbackCache, GETMASK_( vol->seglock, seglock, rollbackCache )+1 );
	BLOCKINDEX e;
#ifdef DEBUG_ROLLBACK_JOURNAL
	LoG( "---- READ ROLLBACK ---- %d", rollback->flags.dirty );
#endif
	if( rollback->flags.dirty ) {
		BLOCKINDEX bigSector = 0;
		BLOCKINDEX smallSector = 0;
		struct BATInfo {
			struct vfs_os_rollback_entry entry;
			BLOCKINDEX bigSector;
		};
		PDATALIST pdlBATs = CreateDataList( sizeof( struct BATInfo ) );
		rollback->flags.processing = 1;
		for( e = 0; e < rollback->nextEntry; e++ ) {
			rollbackEntryCache = BC( ROLLBACK );
			rollbackEntry = ( struct vfs_os_rollback_entry* )vfs_os_FSEEK( vol, vol->journal.rollback_file, 0
				, sane_offsetof( struct vfs_os_rollback_header, entries[e] )
				, &rollbackEntryCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
			if( rollbackEntryCache != rollbackEntryCache_ ) {
				if( rollbackEntryCache_ ) {
					// unlock the previous (if there was one)
					SETMASK_( vol->seglock, seglock, rollbackEntryCache_, GETMASK_( vol->seglock, seglock, rollbackEntryCache_ ) - 1 );
				}
				// lock the new one
				SETMASK_( vol->seglock, seglock, rollbackEntryCache, GETMASK_( vol->seglock, seglock, rollbackEntryCache ) + 1 );
				rollbackEntryCache_ = rollbackEntryCache;
			}
			if( ( ( rollbackEntry->fileBlock - 1 ) % BLOCKS_PER_SECTOR ) == 0 ) {
				// defer restoring BAT blocks until end;
				// the journal itself may exist in the dirty blocks already in the image.
				struct BATInfo info;
				info.entry = rollbackEntry[0];
				info.bigSector = bigSector++;
				AddDataItem( &pdlBATs, &info );
				continue;
			}
#ifdef DEBUG_ROLLBACK_JOURNAL
			LoG( "Reading rollback fileblock:%d %s", rollbackEntry->fileBlock, rollbackEntry->flags.zero ? "Empty" : "" );
#endif
			entry = BC( ROLLBACK );
			_os_UpdateSegmentKey_( vol, &entry, rollbackEntry->fileBlock DBG_SRC );
			vol->sector_size[entry] = rollbackEntry->flags.small ? BLOCK_SMALL_SIZE : BLOCK_SIZE;
			if( rollbackEntry->flags.zero ) {
				memset( vol->usekey_buffer[entry], 0, rollbackEntry->flags.small ? BLOCK_SMALL_SIZE : BLOCK_SIZE );
			}
			else {
				int useSize;
				rollbackCacheJournal = BC( ROLLBACK );
				if( !rollbackEntry->flags.small ) {
					journal = (POINTER)vfs_os_FSEEK( vol, vol->journal.rollback_journal_file, 0
						, BLOCK_SIZE * bigSector++, &rollbackCacheJournal, BLOCK_SIZE DBG_SRC );
#ifdef DEBUG_ROLLBACK_JOURNAL
					if( memcmp( vol->usekey_buffer[entry], journal, BLOCK_SIZE ) == 1 ) {
						LoG( "Journal is actually updating data..." );
					}
#endif
					memcpy( vol->usekey_buffer[entry], journal, useSize = BLOCK_SIZE );
				}
				else {
					journal = (POINTER)vfs_os_FSEEK( vol, vol->journal.rollback_small_journal_file, 0
						, BLOCK_SMALL_SIZE * smallSector++, &rollbackCacheJournal, BLOCK_SMALL_SIZE DBG_SRC );
#ifdef DEBUG_ROLLBACK_JOURNAL
					if( memcmp( vol->usekey_buffer[entry], journal, BLOCK_SMALL_SIZE ) == 1 ) {
						LoG( "Journal is actually updating data..." );
					}
#endif
					memcpy( vol->usekey_buffer[entry], journal, useSize = BLOCK_SMALL_SIZE );
				}
				{
					int seg;
					for( seg = 0; seg < BC( ROLLBACK ); seg++ ) {
						if( vol->segment[seg] == rollbackEntry->fileBlock ) {
							//lprintf( "Duplicate! %d", vol->segment[seg] );
							memcpy( vol->usekey_buffer[seg], vol->usekey_buffer[entry], useSize );
							memcpy( vol->usekey_buffer_clean[seg], vol->usekey_buffer[entry], useSize );
						}
					}
				}
			}
			SMUDGECACHE( vol, entry );
		}
		// finally, clear the BAT entries with any existing bat sectors
		{
			struct BATInfo *info;
			DATA_FORALL( pdlBATs, e, struct BATInfo*, info ) {
				entry = BC( ROLLBACK );
				_os_UpdateSegmentKey_( vol, &entry, info->entry.fileBlock DBG_SRC );
				// BATs are always not-small blocks.
				vol->sector_size[entry] = BLOCK_SIZE;
				if( info->entry.flags.zero ) {
					// might happen later; usually these are non-zero filled
					memset( vol->usekey_buffer[entry], 0, BLOCK_SIZE );
				}
				else {
					rollbackCacheJournal = BC( ROLLBACK );
					journal = (POINTER)vfs_os_FSEEK( vol, vol->journal.rollback_journal_file, 0
						, BLOCK_SIZE * info->bigSector++, &rollbackCacheJournal, BLOCK_SIZE DBG_SRC );
					memcpy( vol->usekey_buffer[entry], journal, BLOCK_SIZE );
					memcpy( vol->usekey_buffer_clean[entry], journal, BLOCK_SIZE );
				}
				{
					int seg;
					for( seg = 0; seg < BC( ROLLBACK ); seg++ ) {
						if( vol->segment[seg] == info->entry.fileBlock ) {
							//lprintf( "Duplicate! %d", vol->segment[seg] );
							memcpy( vol->usekey_buffer[seg], vol->usekey_buffer[entry], BLOCK_SIZE );
							memcpy( vol->usekey_buffer_clean[seg], vol->usekey_buffer[entry], BLOCK_SIZE );
						}
					}
				}
			}
			DeleteDataList( &pdlBATs );
		}
		rollback->flags.dirty = 0;
		rollback->nextEntry = 0;
		rollback->nextBlock = 0;
		rollback->nextSmallBlock = 0;
		SETMASK_( vol->seglock, seglock, rollbackEntryCache_, GETMASK_( vol->seglock, seglock, rollbackEntryCache_ ) - 1 );
		//SETMASK_( vol->seglock, seglock, rollbackCacheJournal, GETMASK_( vol->seglock, seglock, rollbackCacheJournal ) - 1 );
		SETMASK_( vol->seglock, seglock, rollbackCache, GETMASK_( vol->seglock, seglock, rollbackCache ) - 1 );
		SMUDGECACHE( vol, rollbackCache );
		rollback->flags.processing = 0;
		// after processing, the disk should be back to 0; so don't rollback NEXT reload again.
		sack_vfs_os_flush_block( vol, rollbackCache );
	}
}
void vfs_os_smudge_cache( struct sack_vfs_os_volume* vol, enum block_cache_entries n ) {
	if( !TESTFLAG( vol->dirty, n ) ) {
#ifdef DEBUG_SECTOR_DIRT
		lprintf( "set dirty on %d", n);
#endif
		SETFLAG( vol->dirty, n );
		if( !TESTFLAG( vol->_dirty, n ) )
			vfs_os_record_rollback( vol, n );
	}
}
// pass absolute, 0 based, block number that is the index of the block in the filesystem.
static FPI vfs_os_compute_block( struct sack_vfs_os_volume *vol, BLOCKINDEX block, enum block_cache_entries cache ) {
	struct sack_vfs_os_BAT_info *info;
	INDEX idx = block / BLOCKS_PER_SECTOR;
	info = (struct sack_vfs_os_BAT_info*)GetDataItem( &vol->pdl_BAT_information, idx );
	if( !info ) {
		if( !block ) return 0;
		else {
			info = (struct sack_vfs_os_BAT_info*)GetDataItem( &vol->pdl_BAT_information, idx-1 );
			if( info )
				return info->sectorEnd;
		}
		return ~0;
	}
	{
 // not reading a BAT, add the fixed offset, 0 based data offset
		if( block % BLOCKS_PER_SECTOR ) {
			//if( cache < BC(COUNT) )
#if defined( DEBUG_SET_SECTOR_SIZE )
			LoG( "Setting sector size according to BAT information:%d %d %d %d", info->size, (int)block, (cache<BC(COUNT))?(int)vol->segment[cache]:0, (int)cache );
#endif
//lprintf( "CACHE OVERFLOW not setting info %d", info->size );
			if( cache >= BC(COUNT) ) ;
			else vol->sector_size[cache] = info->size;
			// the first 'block' is always bat size, so add that, and then the remaining
			// smaller blocks...
			return info->sectorStart + BAT_BLOCK_SIZE + ( ( block % BLOCKS_PER_SECTOR ) - 1 ) * info->size;
		} else {
//lprintf( "CACHE OVERFLOW skipping size(BAT)" );
			if( cache >= BC(COUNT) ) ;
			else vol->sector_size[cache] = BAT_BLOCK_SIZE;
			return info->sectorStart;
		}
	}
	return 0;
}
// pass absolute, 0 based, block number that is the index of the block in the filesystem.
static FPI vfs_os_compute_data_block( struct sack_vfs_os_volume* vol, BLOCKINDEX block, enum block_cache_entries cache ) {
	struct sack_vfs_os_BAT_info* info;
	INDEX idx = block / BLOCKS_PER_BAT;
	info = ( struct sack_vfs_os_BAT_info* )GetDataItem( &vol->pdl_BAT_information, idx );
	if( !info ) return 0;
	// not reading a BAT, add the fixed offset, 0 based data offset
	if( cache < BC( COUNT ) )
		vol->sector_size[cache] = info->size;
	// the first 'block' is always bat size, so add that, and then the remaining
	// smaller blocks...
	return info->sectorStart + BAT_BLOCK_SIZE + ( ( block - 1 ) % BLOCKS_PER_BAT ) * info->size;
}
#define tolower_(c) (c)
static int  _os_PathCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && ((unsigned char)s2[0] != UTF8_EOT) && (s1[0] == s2[0]) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return s1[0] - (((unsigned char)s2[0] == UTF8_EOT)?0:s2[0]);
	return 0;
}
// read the byte from namespace at offset; decrypt byte in-register
// compare against the filename bytes.
static int _os_MaskStrCmp( struct sack_vfs_os_volume *vol, CTEXTSTR filename, BLOCKINDEX nameBlock, FPI name_offset, int path_match ) {
	enum block_cache_entries cache = BC(NAMES);
	const char *dirname = (const char*)vfs_os_FSEEK( vol, NULL, nameBlock, name_offset, &cache, NAME_BLOCK_SIZE DBG_SRC );
	//const char *prior_dirname = dirname;
	if( !dirname ) return 1;
	{
		//LoG( "doesn't volume always have a key?" );
		if( path_match ) {
			size_t l;
			int r = _os_PathCaseCmpEx( filename, dirname, l = strlen( filename ) );
			if( !r )
				if( (dirname)[l] == '/' || (dirname)[l] == '\\' )
					return 0;
				else
					return 1;
			return r;
		}
		else
			return _os_PathCaseCmpEx( filename, dirname, strlen(filename) );
	}
}
#ifdef DEBUG_TRACE_LOG
static void _os_MaskStrCpy( char *output, size_t outlen, struct sack_vfs_os_volume *vol, enum block_cache_entries cache, FPI name_offset ) {
	{
		int c;
		FPI name_start = name_offset;
		while( UTF8_EOT != (unsigned char)( c = vol->usekey_buffer[cache][name_offset&BLOCK_MASK] ) ) {
			if( ( name_offset - name_start ) < outlen )
				output[name_offset-name_start] = c;
			name_offset++;
		}
		if( ( name_offset - name_start ) < outlen )
			output[name_offset-name_start] = 0;
		else
			output[outlen-1] = 0;
	}
}
#endif
#ifdef DEBUG_DIRECTORIES
int _os_dumpDirectories( struct sack_vfs_os_volume *vol, BLOCKINDEX start, LOGICAL init ) {
	struct directory_hash_lookup_block *dirBlock;
	struct directory_entry *next_entries;
	static char leadin[MAX_FILENAME_LEN];
	static int leadinDepth;
	char outfilename[MAX_FILENAME_LEN];
	int outfilenamelen;
	size_t n;
	if( init )
		leadinDepth = 0;
	LoG( "Starting directory dump: %d %d", start, init );
	{
		enum block_cache_entries cache = BC( DIRECTORY );
		enum block_cache_entries name_cache = BC( NAMES );
		struct directory_hash_lookup_block _dirBlock;
		dirBlock = BTSEEK( struct directory_hash_lookup_block *, vol, start, DIR_BLOCK_SIZE, cache );
		_dirBlock = dirBlock[0];
		dirBlock = &_dirBlock;
		lprintf( "leadin : %*.*s %d names:%d start:%d", leadinDepth, leadinDepth, leadin, leadinDepth, dirBlock->used_names, (int)start );
		next_entries = dirBlock->entries;
		for( n = 0; n < dirBlock->used_names; n++ ) {
			FPI name_ofs = next_entries[n].name_offset & DIRENT_NAME_OFFSET_OFFSET;
			const char *filename;
			int l;
			// if file is deleted; don't check it's name.
			if( (name_ofs) > vol->dwSize ) {
				LoG( "corrupted volume." );
				return 0;
			}
			name_cache = BC( NAMES );
			filename = (const char *)vfs_os_FSEEK( vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
			if( !filename ) return 0;
			outfilenamelen = 0;
			for( l = 0; l < leadinDepth; l++ ) outfilename[outfilenamelen++] = leadin[l];
			if( vol->key ) {
				int c;
				while( (c = (((uint8_t*)filename)[0] )) != UTF8_EOT ) {
					if( c == UTF8_EOTB ) break;
					outfilename[outfilenamelen++] = c;
					//filename++;
					name_ofs++;
					name_cache = BC( NAMES );
					filename = (const char *)vfs_os_FSEEK( vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
				}
			}
			else {
				int c;
				while( (c = (((uint8_t*)filename)[0] )) != UTF8_EOT ) {
					if( c == UTF8_EOTB ) break;
					outfilename[outfilenamelen++] = c;
					//filename++;
					name_ofs++;
					name_cache = BC( NAMES );
					filename = (const char *)vfs_os_FSEEK( vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
				}
			}
			lprintf( "%3d filename: %5d %.*s", n, next_entries[n].name_offset & DIRENT_NAME_OFFSET_OFFSET, outfilenamelen, outfilename );
			if( outfilenamelen > 44 ) DebugBreak();
		}
		for( n = 0; n < 255; n++ ) {
			BLOCKINDEX block = dirBlock->next_block[n];
			if( block ) {
				lprintf( "Found directory with char '%c' %d", n, block );
				leadin[leadinDepth] = (char)n;
				leadinDepth = leadinDepth + 1;
#ifdef DEBUG_DIRECTORIES
				_os_dumpDirectories( vol, block, 0 );
#endif
				leadinDepth = leadinDepth - 1;
			}
		}
	};
	return 0;
}
#endif
#ifdef _MSC_VER
// this is about nLeast not being initialized.
// it will be set if it's used, if it's not
// initialized, it won't be used.
#pragma warning( disable: 6001 )
#endif
#define _os_updateCacheAge(v,c,s,a,l) _os_updateCacheAge_(v,c,s,a,l DBG_SRC )
//
// THis is assigning segment into a cache entry, and then reading that data into memory.
// Large block filebuffers (? like 64 megs of empty space?)
// where the block is located determines the size of that block; this updates
// the size
static void _os_updateCacheAge_( struct sack_vfs_os_volume *vol, enum block_cache_entries *cache_idx, BLOCKINDEX segment, uint8_t *age, int ageLength DBG_PASS ) {
	int n, m;
	int least;
	int nLeast = -1;
	enum block_cache_entries cacheRoot = cache_idx[0];
	BLOCKINDEX *test_segment = vol->segment + cacheRoot;
	least = ageLength + 1;
#ifdef DEBUG_CACHE_FAULTS
	switch( cacheRoot ) {
	case BC(TIMELINE):
		vol->cacheRequests[0]++;
		break;
	case BC( DIRECTORY ):
		vol->cacheRequests[1]++;
		break;
	}
#endif
	for( n = 0; n < (ageLength); n++,test_segment++ ) {
		if( test_segment[0] == segment ) {
			//if( pFile ) LoG_( "Cache found existing segment already. %d at %d(%d)", (int)segment, (cache_idx[0]+n), (int)n );
#ifdef DEBUG_VALIDATE_TREE
			//if( cache_idx[0] < BC( TIMELINE_RO ) )
			//	_lprintf( DBG_RELAY )( "FOUND segment in cache: %d   %d  %d   %d", segment, n, age[n], cache_idx[0] );
#endif
			cache_idx[0] = (enum block_cache_entries)((cache_idx[0]) + n);
			for( m = 0; m < (ageLength); m++ ) {
				if( !age[m] ) break;
				if( age[m] > age[n] ) {
					age[m]--;
				}
			}
			age[n] = m;
			return;
			//break;
		}
 // end of list, empty entry.
		if( !age[n] ) {
			//LoG_( "Cache found unused segment already. %d at %d(%d)", (int)segment, (cache_idx[0] + n), (int)n );
			cache_idx[0] = (enum block_cache_entries)((cache_idx[0]) + n);
 // age entries up to this one.
			for( m = 0; m < (ageLength); m++ ) {
				if( !age[m] ) break;
				if( age[m] > ( n + 1 ) )
					age[m]--;
			}
			vol->segment[cache_idx[0]] = segment;
 // make this one newest
			age[n] = n + 1;
			break;
		}
		if( (age[n] < least) && !GETMASK_( vol->seglock, seglock, cache_idx[0] + n ) ) {
			least = age[n];
 // this one will be oldest, unlocked candidate
			nLeast = n;
		}
	}
	if( ( n == ( ageLength ) ) && ( nLeast < 0 ) ) {
		lprintf( "All cache blocks are locked, unable to find a free, old block." );
		DebugBreak();
	}
	if( n == (ageLength) ) {
		int useCache = cacheRoot + nLeast;
#ifdef _DEBUG
		if( least > ageLength ) DebugBreak();
#endif
  // age evernthing.
		for( n = 0; n < (ageLength); n++ ) {
			if( age[n] > least )
				age[n]--;
		}
		cache_idx[0] = (enum block_cache_entries)useCache;
 // make this one the newest, and return it.
		age[nLeast] = (ageLength);
		//_lprintf(DBG_RELAY)( "reclaim %d for seg %d", useCache, segment );
		if( TESTFLAG( vol->dirty, useCache ) || TESTFLAG( vol->_dirty, useCache ) ) {
#ifdef DEBUG_DISK_IO
			LoG_( "MUST CLAIM SEGMENT Flush dirty segment: %d fpi:%x %d cache:%d", nLeast, vol->bufferFPI[useCache], vol->segment[useCache], useCache );
#  ifdef DEBUG_DISK_DATA
			LogBinary( vol->usekey_buffer[useCache], vol->sector_size[useCache] );
#  endif
#endif
			sack_fseek( vol->file, (size_t)vol->bufferFPI[useCache], SEEK_SET );
			if( vol->key ) {
				uint8_t* crypt;
				size_t cryptlen;
				SRG_XSWS_encryptData( vol->usekey_buffer[useCache], vol->sector_size[useCache]
					, vol->segment[useCache], (const uint8_t*)vol->key, 1024
					, &crypt, &cryptlen );
				if( !vol->flags.halted )
					sack_fwrite( crypt, 1, vol->sector_size[useCache], vol->file );
				Deallocate( uint8_t*, crypt );
			}else {
				if( !vol->flags.halted )
					sack_fwrite( vol->usekey_buffer[useCache], 1, vol->sector_size[useCache], vol->file );
			}
#ifdef DEBUG_CACHE_FLUSH
			// if not dirty, then clean and buffer have to match; and this is clearing the dirty flag
			memcpy( vol->usekey_buffer_clean[useCache], vol->usekey_buffer[useCache], BLOCK_SIZE );
#  ifdef DEBUG_VALIDATE_TREE
 // timeline cache is noisy for readonly
			if( useCache < BC( TIMELINE_RO ) )
#  endif
				_lprintf(DBG_RELAY)( "(usedto)Updated clean buffer %d", useCache );
#endif
			CLEANCACHE( vol, useCache );
			RESETFLAG( vol->_dirty, useCache );
		}
#ifdef DEBUG_VALIDATE_TREE
		else {
#ifdef DEBUG_CACHE_FLUSH
#  ifdef DEBUG_VALIDATE_TREE
			if( cache_idx[0] < BC(TIMELINE_RO) )
#  endif
				if( memcmp( vol->usekey_buffer_clean[cache_idx[0]], vol->usekey_buffer[cache_idx[0]], BLOCK_SIZE ) ) {
					lprintf( "Block was written to, but was not flagged as dirty, changes will be lost." );
					DebugBreak();
				}
#endif
		}
#endif
		vol->segment[useCache] = segment;
	}
#ifdef DEBUG_VALIDATE_TREE
	//if( cache_idx[0] < BC(TIMELINE_RO) )
	//	_lprintf(DBG_RELAY)( "Get segment into cache: %d   %d", segment, cache_idx[0] );
#endif
#ifdef DEBUG_CACHE_FAULTS
	switch( cacheRoot ) {
	case BC( TIMELINE ):
		vol->cacheFaults[0]++;
		break;
	case BC( DIRECTORY ):
		vol->cacheFaults[1]++;
		break;
	}
#endif
	{
		size_t short_Read;
		do {
			vol->bufferFPI[cache_idx[0]] = vfs_os_compute_block( vol, segment - 1, cache_idx[0] );
			if( vol->bufferFPI[cache_idx[0]] == ~0 )
				_os_ExpandVolume( vol, vol->lastBlock, vol->sector_size[cache_idx[0]] );
		} while( vol->bufferFPI[cache_idx[0]] == ~0 );
		// read new buffer for new segment
		sack_fseek( vol->file, (size_t)vol->bufferFPI[cache_idx[0]], SEEK_SET );
#ifdef DEBUG_DISK_IO
		LoG_( "Read into block: fpi:%x cache:%d n:%d  seg:%d buf:%p size:%d", (int)vol->bufferFPI[cache_idx[0]], (int)cache_idx[0] , (int)n, (int)segment, vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]]  );
#endif
		if( !( short_Read = sack_fread( vol->usekey_buffer[cache_idx[0]], 1, vol->sector_size[cache_idx[0]], vol->file ) ) ) {
			memset( vol->usekey_buffer[cache_idx[0]], 0, vol->sector_size[cache_idx[0]] );
			// only need to clear this if it's checked for write data without setting dirty flag.
			memset( vol->usekey_buffer_clean[cache_idx[0]], 0, vol->sector_size[cache_idx[0]] );
		} else {
			if( short_Read != vol->sector_size[cache_idx[0]] ) {
				lprintf( "Short read on file:%" _size_f, short_Read );
			}
			if( vol->key )
				SRG_XSWS_decryptData( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]]
					, vol->segment[cache_idx[0]], (const uint8_t*)vol->oldkey?vol->oldkey:vol->key, 1024
					, NULL, NULL );
			// after reading what was on the disk (in the sector), save it as the 'clean' state for journaling
			// modifications happen to usekey_buffer before SMUDGE is called.
			memcpy( vol->usekey_buffer_clean[cache_idx[0]], vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]] );
#ifdef DEBUG_CACHE_FLUSH
#  ifdef DEBUG_VALIDATE_TREE
			if( cache_idx[0] < BC(TIMELINE_RO) )
#  endif
				_lprintf(DBG_RELAY)( "Updated clean buffer %d", cache_idx[0] );
#endif
		}
#ifdef DEBUG_DISK_IO
#  ifdef DEBUG_DISK_DATA
		LogBinary( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]] );
#  endif
#endif
	}
#ifdef DEBUG_CACHE_AGING
	LoG( "age end2:" );
	LogBinary( age, ageLength );
#endif
}
#define _os_UpdateSegmentKey(v,c,s) _os_UpdateSegmentKey_(v,c,s DBG_SRC )
enum block_cache_entries _os_UpdateSegmentKey_( struct sack_vfs_os_volume *vol, enum block_cache_entries* cache_idx, BLOCKINDEX segment DBG_PASS )
{
	//BLOCKINDEX oldSegs[BC(COUNT)];
	//memcpy(oldSegs, vol->segment, sizeof(oldSegs));
	if( cache_idx[0] == BC(FILE) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->fileCacheAge, (BC(FILE_LAST) - BC(FILE)) DBG_RELAY );
	}
	else if( cache_idx[0] == BC(NAMES) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->nameCacheAge, (BC(NAMES_LAST) - BC(NAMES)) DBG_RELAY );
	}
#ifdef VIRTUAL_OBJECT_STORE
	else if( cache_idx[0] == BC(DIRECTORY) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->dirHashCacheAge, (BC(DIRECTORY_LAST) - BC(DIRECTORY)) DBG_RELAY );
	}
	else if( cache_idx[0] == BC( TIMELINE ) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->timelineCacheAge, (BC( TIMELINE_LAST ) - BC( TIMELINE )) DBG_RELAY );
	}
	else if( cache_idx[0] == BC( ROLLBACK ) ) {
		//lprintf( "Cache age rollback: %d", (int)segment );
		_os_updateCacheAge_( vol, cache_idx, segment, vol->rollbackCacheAge, ( BC( ROLLBACK_LAST ) - BC( ROLLBACK ) ) DBG_RELAY );
	}
#ifdef DEBUG_VALIDATE_TREE
	else if( cache_idx[0] == BC( TIMELINE_RO ) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->timelineCacheAge, ( BC( TIMELINE_RO_LAST ) - BC( TIMELINE_RO ) ) DBG_RELAY );
		{
			int n;
			for( n = BC( TIMELINE ); n < BC( TIMELINE_LAST ); n++ ) {
				if( vol->segment[n] == segment ) {
					if( TESTFLAG( vol->dirty, n ) || TESTFLAG( vol->_dirty, n ) ) {
						// use the cached value instead of the disk value.
						memcpy( vol->usekey_buffer[cache_idx[0]], vol->usekey_buffer[n], BLOCK_SIZE );
						memcpy( vol->usekey_buffer_clean[cache_idx[0]], vol->usekey_buffer[n], BLOCK_SIZE );
						//lprintf( "Updaed clean buffer %d", n );
					}
					break;
				}
			}
		}
	}
#endif
	else if( cache_idx[0] == BC( BAT ) ) {
		_os_updateCacheAge_( vol, cache_idx, segment, vol->batHashCacheAge, (BC(BAT_LAST) - BC(BAT)) DBG_RELAY );
	}
#endif
	else {
		if( vol->segment[cache_idx[0]] != segment ) {
			if( TESTFLAG( vol->dirty, cache_idx[0] ) || TESTFLAG( vol->_dirty, cache_idx[0] ) ) {
#ifdef DEBUG_DISK_IO
				LoG_( "MUST CLAIM SEGMENT Flush dirty segment: fpi:%x %d", vol->bufferFPI[cache_idx[0]], vol->segment[cache_idx[0]] );
#  ifdef DEBUG_DISK_DATA
				LogBinary( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]] );
#  endif
#endif
				sack_fseek( vol->file, (size_t)vol->bufferFPI[cache_idx[0]], SEEK_SET );
				if( vol->key ) {
					uint8_t* crypt;
					size_t cryptlen;
					SRG_XSWS_encryptData( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]]
						, vol->segment[cache_idx[0]], (const uint8_t*)vol->key, 1024
						, &crypt, &cryptlen );
					if( !vol->flags.halted )
						sack_fwrite( crypt, 1, vol->sector_size[cache_idx[0]], vol->file );
					Deallocate( uint8_t*, crypt );
				}
				else {
					if( !vol->flags.halted )
						sack_fwrite( vol->usekey_buffer[cache_idx[0]], 1, vol->sector_size[cache_idx[0]], vol->file );
				}
				CLEANCACHE( vol, cache_idx[0] );
				RESETFLAG( vol->_dirty, cache_idx[0] );
#ifdef DEBUG_DISK_IO
				LoG( "Flush dirty sector: %d", cache_idx[0], vol->bufferFPI[cache_idx[0]] );
#endif
			}
			// read new buffer for new segment
			vol->bufferFPI[cache_idx[0]] = vfs_os_compute_block( vol, segment - 1, cache_idx[0] );
			if( vol->bufferFPI[cache_idx[0]] >= vol->dwSize ) _os_ExpandVolume( vol, vol->lastBlock, vol->sector_size[cache_idx[0]] );
			sack_fseek( vol->file, (size_t)(vol->bufferFPI[cache_idx[0]]), SEEK_SET);
#ifdef DEBUG_DISK_IO
			LoG( "OS VFS read old sector: fpi:%d %d %d", (int)vol->bufferFPI[cache_idx[0]], cache_idx[0], segment );
#endif
			if( !sack_fread( vol->usekey_buffer[cache_idx[0]], 1, vol->sector_size[cache_idx[0]], vol->file ) ) {
				//lprintf( "Cleared BLock on failed read." );
				memset( vol->usekey_buffer[cache_idx[0]], 0, vol->sector_size[cache_idx[0]] );
				// only need to clear this if it's checked for write data without setting dirty flag.
				memset( vol->usekey_buffer_clean[cache_idx[0]], 0, vol->sector_size[cache_idx[0]] );
			}
			else {
				if( vol->key )
					SRG_XSWS_decryptData( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]]
						, vol->segment[cache_idx[0]], (const uint8_t*)vol->oldkey?vol->oldkey:vol->key, 1024
						, NULL, NULL );
				// after reading what was on the disk (in the sector), save it as the 'clean' state for journaling
				// modifications happen to usekey_buffer before SMUDGE is called.
				memcpy( vol->usekey_buffer_clean[cache_idx[0]], vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]] );
			}
#ifdef DEBUG_DISK_IO
#  ifdef DEBUG_DISK_DATA
		LogBinary( vol->usekey_buffer[cache_idx[0]], vol->sector_size[cache_idx[0]] );
#  endif
#endif
		}
		vol->segment[cache_idx[0]] = segment;
	}
//#ifdef DEBUG_TRACE_LOG
//	if (segment != oldSegs[cache_idx])
//		_lprintf(DBG_RELAY)("UPDATE OS SEGKEY %d %d", cache_idx, segment);
//#endif
	//LoG( "Resulting stored segment in %d", cache_idx );
	//lprintf( "Got Block %d into cache %d", (int)segment, cache_idx );
	return cache_idx[0];
}
#ifdef _MSC_VER
#pragma warning( default: 6001 )
#endif
//---------------------------------------------------------------------------
struct sack_vfs_os_file * _os_createFile( struct sack_vfs_os_volume *vol, BLOCKINDEX first_block, int blockSize )
{
//New( struct sack_vfs_os_file );
	struct sack_vfs_os_file * file = GetFromSet( VFS_OS_FILE, &l.files );
	// breaks in C++
	//file[0] = ( struct sack_vfs_os_file ){ 0 };
	MemSet( file, 0, sizeof( struct sack_vfs_os_file ) );
	_os_SetBlockChain( file, 0, first_block, blockSize );
	//lprintf( "Create simple file: %d", first_block );
	file->_first_block = first_block;
	file->block = first_block;
	file->vol = vol;
	file->cache = BC( FILE );
	return file;
}
//---------------------------------------------------------------------------
uintptr_t vfs_os_block_index_SEEK( struct sack_vfs_os_volume* vol, BLOCKINDEX block, int blockSize, enum block_cache_entries* cache_index ) {
	FPI offset;
	while( ( offset = vfs_os_compute_block( vol, block, cache_index[0] ) ) >= vol->dwSize )
		if( !_os_ExpandVolume( vol, vol->lastBlock, blockSize ) ) return 0;
	{
		_os_UpdateSegmentKey( vol, cache_index, block + 1 );
		//LoG( "RETURNING SEEK CACHED %p %d  0x%x   %d", vol->usekey_buffer[cache_index[0]], cache_index[0], (int)offset, (int)seg );
		return ( (uintptr_t)vol->usekey_buffer[cache_index[0]] ) + ( offset % vol->sector_size[cache_index[0]] );
	}
}
// shared with fuse module
// seek by byte position; result with an offset into a block.
// this is used to access BAT information; and should be otherwise avoided.
uintptr_t vfs_os_SEEKX( struct sack_vfs_os_volume* vol, FPI offset, int blockSize, enum block_cache_entries* cache_index ) {
	//lprintf( "This is more complicated with variable size data blocks" );
	// unused function mostly.
	while( offset >= vol->dwSize ) if( !_os_ExpandVolume( vol, vol->lastBlock, blockSize ) ) return 0;
	// this assumes that all blocks are the same size; which is untrue.  This should be removed.
	{
		BLOCKINDEX seg = ( offset / BLOCK_SIZE ) + 1;
		_os_UpdateSegmentKey( vol, cache_index, seg );
		//LoG( "RETURNING SEEK CACHED %p %d  0x%x   %d", vol->usekey_buffer[cache_index[0]], cache_index[0], (int)offset, (int)seg );
		return ( (uintptr_t)vol->usekey_buffer[cache_index[0]] ) + ( offset & BLOCK_MASK );
	}
}
// shared with fuse module
// seek by block, outside of BAT.  block 0 = first block after first BAT.
uintptr_t vfs_os_BSEEK_( struct sack_vfs_os_volume* vol, BLOCKINDEX block, int blockSize, enum block_cache_entries* cache_index DBG_PASS ) {
	// b is the absolute block number
	if( block != DIR_ALLOCATING_MARK ) {
 /* for first BAT */
		BLOCKINDEX b = ( 1 + ( block / BLOCKS_PER_BAT ) * (BLOCKS_PER_SECTOR)+( block % BLOCKS_PER_BAT ) );
#define _os_segment_to_block( s ) ( ( (s) - 1 ) / BLOCKS_PER_SECTOR ) * BLOCKS_PER_BAT + ( ( (s) - ( 1 + (s) / BLOCKS_PER_SECTOR ) ) % BLOCKS_PER_BAT );
#if defined( DEBUG_BLOCK_COMPUTE )
		{
			//int block_ = ( ( b - 1 ) / BLOCKS_PER_SECTOR ) * BLOCKS_PER_BAT + ( ( b - ( 1 + b / BLOCKS_PER_SECTOR ) ) % BLOCKS_PER_BAT );
			int block_ = _os_segment_to_block( b );
			if( block_ != block ) {
				lprintf( "FAILED" );
				DebugBreak();
			}
		}
#endif
		// first call can skip setting information
		while( vfs_os_compute_block( vol, b, BC( COUNT ) ) >= vol->dwSize ) if( !_os_ExpandVolume( vol, vol->lastBlock, blockSize ) ) return 0;
		{
			_os_UpdateSegmentKey_( vol, cache_index, b + 1 DBG_RELAY );
			//LoG( "RETURNING BSEEK CACHED %p  %d %d %d  0x%x  %d   %d", vol->usekey_buffer[cache_index[0]], cache_index[0], (int)(block/ BLOCKS_PER_BAT), (int)(BLOCKS_PER_BAT-1), (int)b, (int)block, (int)seg );
/* + (b&BLOCK_MASK) always 0 */
			return ( (uintptr_t)vol->usekey_buffer[cache_index[0]] );
		}
	} else {
		BLOCKINDEX b = _os_GetFreeBlock( vol, cache_index, GFB_INIT_NONE, blockSize );
 /* for first BAT */
		b = ( 1 + ( b / BLOCKS_PER_BAT ) * (BLOCKS_PER_SECTOR)+( b % BLOCKS_PER_BAT ) );
		_os_UpdateSegmentKey_( vol, cache_index, b + 1 DBG_RELAY );
		// the returned block is set in the ((segment[cache_index[0]]-1)-1)
		return ( (uintptr_t)vol->usekey_buffer[cache_index[0]] );
	}
}
// shared with fuse module
// seek by block, outside of BAT.  block 0 = first block of disk.
uint8_t * vfs_os_DSEEK_( struct sack_vfs_os_volume* vol, FPI dataFPI, int blockSize, enum block_cache_entries* cache_index DBG_PASS ) {
	BLOCKINDEX block;
	struct sack_vfs_os_BAT_info* info;
	INDEX idx;
	INDEX minIndex = 0;
	INDEX maxIndex = vol->pdl_BAT_information->Cnt;
	//DATA_FORALL( vol->pdl_BAT_information, idx, struct sack_vfs_os_BAT_info *, info )
	while( minIndex <= maxIndex )
	{
		idx = ( minIndex + maxIndex ) / 2;
		info = ((struct sack_vfs_os_BAT_info*)vol->pdl_BAT_information->data) + idx;
		if( dataFPI < info->sectorStart ) { maxIndex = idx - 1; continue; }
		if( dataFPI > info->sectorEnd ) { minIndex = idx + 1; continue; }
		{
			dataFPI -= info->sectorStart;
			if( dataFPI < BAT_BLOCK_SIZE )
				block = 0;
			else
				block = 1 + ( dataFPI - BAT_BLOCK_SIZE ) / info->size;
			_os_UpdateSegmentKey( vol, cache_index, info->blockStart + block + 1 );
			return vol->usekey_buffer[cache_index[0]] + ( dataFPI & (vol->sector_size[cache_index[0]] - 1) );
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
static LOGICAL _os_ValidateBAT( struct sack_vfs_os_volume *vol ) {
	//BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
	BLOCKINDEX n;
	enum block_cache_entries cache = BC(BAT);
	//BLOCKINDEX sector = 0;
	{
		struct sack_vfs_os_BAT_info info;
		struct sack_vfs_os_BAT_info *priorInfo;
		FPI thisPos;
		//struct sack_vfs_os_BAT_info* oldinfo;
		vol->pdl_BAT_information->Cnt = 0;
		info.sectorEnd = BAT_BLOCK_SIZE + ( BLOCKS_PER_BAT * 4096 );
		info.sectorStart = 0;
		info.blockStart = n = 0;
		info.size = 4096;
		AddDataItem( &vol->pdl_BAT_information, &info );
		priorInfo = (struct sack_vfs_os_BAT_info*)GetDataItem( &vol->pdl_BAT_information, vol->pdl_BAT_information->Cnt-1 );
		for( n = 0; ( thisPos = info.sectorStart ) < vol->dwSize; n += BLOCKS_PER_SECTOR ) {
			BLOCKINDEX dataBlock = ( n / BLOCKS_PER_SECTOR ) * BLOCKS_PER_BAT;
			size_t m;
			BLOCKINDEX *BAT;
 // reset cache, so we get a new bat cache block
			cache = BC(BAT);
			// seek loads and updates the segment key...
			BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, n, 0, &cache );
			info.size = priorInfo->size = BAT[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
			{
				priorInfo->sectorEnd = thisPos + BAT_BLOCK_SIZE + ( ( ( BLOCKS_PER_BAT * info.size ) + 4095 ) & ~4095 );
				info.sectorStart = priorInfo->sectorEnd;
				info.blockStart = n + BLOCKS_PER_SECTOR;
				vol->lastBlock = n + BLOCKS_PER_SECTOR;
				AddDataItem( &vol->pdl_BAT_information, &info );
				priorInfo = (struct sack_vfs_os_BAT_info*)GetDataItem( &vol->pdl_BAT_information, vol->pdl_BAT_information->Cnt-1 );
			}
			//sector++;
			for( m = 0; m < BLOCKS_PER_BAT; m++ )
			{
				BLOCKINDEX block = BAT[0];
				BAT++;
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) {
					if( info.size == 4096 )
						vol->lastBatBlock = dataBlock + m;
					else
						vol->lastBatSmallBlock = dataBlock + m;
					break;
				}
				//if( block >= last_block ) return FALSE;
				if( block == 0 ) {
					if( info.size == 4096 ) {
 // use as a temp variable....
						vol->lastBatBlock = dataBlock + m;
						LoG( "Marking free (lg)blank sector %d", vol->lastBatBlock );
						AddDataItem( &vol->pdlFreeBlocks, &vol->lastBatBlock );
					}
					else {
 // use as a temp variable....
						vol->lastBatSmallBlock = dataBlock + m;
						LoG( "Marking free (sm)blank sector %d", vol->lastBatBlock );
						AddDataItem( &vol->pdlFreeSmallBlocks, &vol->lastBatSmallBlock );
					}
				}
			}
			//if( m < BLOCKS_PER_BAT ) break;
		}
		// this ends up pusing 1 more so that compute can actually work on reload
		vol->pdl_BAT_information->Cnt--;
		priorInfo = (struct sack_vfs_os_BAT_info*)GetDataItem( &vol->pdl_BAT_information, vol->pdl_BAT_information->Cnt-1 );
		if( priorInfo->sectorEnd > vol->dwSize )
			vol->dwSize = priorInfo->sectorEnd;
	}
	// need to handle rollback before any timeline/directory loading
	// otherwise they will cache sectors that are duplicated here.
	if( !vol->journal.rollback_file ) {
		struct sack_vfs_os_file* file;
		file = _os_createFile( vol, FIRST_ROLLBACK_BLOCK, ROLLBACK_BLOCK_SIZE );
		file->cache = BC( ROLLBACK );
		enum block_cache_entries rollbackCache = BC( ROLLBACK );
		struct vfs_os_rollback_header* rollback = (struct vfs_os_rollback_header*)vfs_os_FSEEK( vol, file, 0, 0, &rollbackCache, ROLLBACK_BLOCK_SIZE DBG_SRC );
		if( !rollback->journal ) {
			enum block_cache_entries firstBlockCache = BC( ROLLBACK );
			rollback->journal = _os_GetFreeBlock( vol, &firstBlockCache, GFB_INIT_NONE, 4096 );
			firstBlockCache = BC( ROLLBACK );
			rollback->small_journal = _os_GetFreeBlock( vol, &firstBlockCache, GFB_INIT_NONE, 256 );
			LoG( "Initial allocate of journal blocks: %d %d", rollback->journal, rollback->small_journal );
		} else {
			LoG( "Reload allocate of journal blocks: %d %d", rollback->journal, rollback->small_journal );
		}
		vol->journal.rollback_journal_file = _os_createFile( vol, rollback->journal, BLOCK_SIZE );
		vol->journal.rollback_journal_file->cache = BC( ROLLBACK );
		vol->journal.rollback_small_journal_file = _os_createFile( vol, rollback->small_journal, BLOCK_SMALL_SIZE );
		vol->journal.rollback_small_journal_file->cache = BC( ROLLBACK );
		vol->journal.rollback_file = file;
		vol->journal.pdlPendingRecord = CreateDataList( sizeof( enum block_cache_entries ) );
		vol->journal.pdlJournaled = CreateDataList( sizeof( BLOCKINDEX ) );
		if( !vol->flags.skipRollbackProcessing )
			vfs_os_process_rollback( vol );
		{
			INDEX idx;
			enum block_cache_entries block;
			LIST_FORALL( vol->pending_rollback, idx, enum block_cache_entries, block ) {
				vfs_os_record_rollback( vol, block );
			}
			DeleteList( &vol->pending_rollback );
			sack_vfs_os_polish_volume( vol );
		}
	}
	vol->timeline_file = _os_createFile( vol, FIRST_TIMELINE_BLOCK, TIME_BLOCK_SIZE );
	vol->timeline_file->cache = BC( TIMELINE );
	{
		int locks;
		vol->timelineCache = BC( TIMELINE );
		vol->timeline = (struct storageTimeline *)vfs_os_BSEEK( vol, FIRST_TIMELINE_BLOCK, TIME_BLOCK_SIZE, &vol->timelineCache );
		SETMASK_( vol->seglock, seglock, vol->timelineCache, locks = GETMASK_( vol->seglock, seglock, vol->timelineCache )+1 );
		if( locks > 5 ) {
			lprintf( "Lock is in danger of overflow" );
		}
	}
	if( !_os_ScanDirectory( vol, NULL, FIRST_DIR_BLOCK, NULL, NULL, 0 ) ) return FALSE;
	//lprintf( "total files:%d", l.fileCount );
	return TRUE;
}
//-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
static void _os_AddSalt2( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct datatype { void* start; size_t length; } *data = (struct datatype*)psv;
	(*salt_size) = data->length;
	(*salt) = (POINTER)data->start;
	// only need to make one pass of it....
	data->length = 0;
	data->start = NULL;
}
const uint8_t *sack_vfs_os_get_signature2( POINTER disk, POINTER diskReal ) {
	if( disk != diskReal ) {
		static uint8_t usekey[BLOCK_SIZE];
		static struct random_context *entropy;
		static struct datatype { void* start; size_t length; } data;
		data.start = diskReal;
		data.length = ((uintptr_t)disk - (uintptr_t)diskReal) - BLOCK_SIZE;
		if( !entropy ) entropy = SRG_CreateEntropy2( _os_AddSalt2, (uintptr_t)&data );
		SRG_ResetEntropy( entropy );
		SRG_GetEntropyBuffer( entropy, (uint32_t*)usekey, BLOCK_SIZE*CHAR_BIT );
		return usekey;
	}
	return NULL;
}
// add some space to the volume....
LOGICAL _os_ExpandVolume( struct sack_vfs_os_volume *vol, BLOCKINDEX fromBlock, int size ) {
	LOGICAL created = FALSE;
	//LOGICAL path_checked = FALSE;
	int n;
	LoG( "Expand Volume: %d %d", fromBlock, size );
	size_t oldsize = vol->dwSize;
	if( vol->file && vol->read_only ) return TRUE;
	if( !size ) return FALSE;
	if( !vol->file ) {
		char *fname;
		char *iface;
		char *tmp;
#ifndef USE_STDIO
		if( tmp =(char*)StrChr( vol->volname, '@' ) ) {
			if( tmp[1] == '@' ) {
				strcpy( tmp, tmp + 1 );
				goto defaultOpen;
			} else {
				tmp[0] = 0;
				iface = (char*)vol->volname;
				fname = tmp + 1;
				struct file_system_mounted_interface* mount = sack_get_mounted_filesystem( iface );
				//struct file_system_interface *iface = sack_get_filesystem_interface( iface );
				if( !sack_exists( fname ) ) {
					vol->file = sack_fopenEx( 0, fname, "rb+", mount );
					if( !vol->file )
						vol->file = sack_fopenEx( 0, fname, "wb+", mount );
					created = TRUE;
				} else
					vol->file = sack_fopenEx( 0, fname, "rb+", mount );
				tmp[0] = '@';
			}
		}
		else {
defaultOpen:
			{
				char* tmp = StrDup( vol->volname );
				char* dir = (char*)pathrchr( tmp );
				if( dir ) {
					dir[0] = 0;
					if( !IsPath( tmp ) ) MakePath( tmp );
				}
				free( tmp );
				//Deallocate( char*, tmp );
			}
			vol->file = sack_fopenEx( 0, vol->volname, "rb+", vol->mount );
			if( !vol->file ) {
				created = TRUE;
				vol->file = sack_fopenEx( 0, vol->volname, "wb+", vol->mount );
			}
		}
#else
		vol->file = fopen( 0, vol->volname, "rb+" );
		if( !vol->file ) {
			created = TRUE;
			vol->file = fopen( 0, vol->volname, "wb+" );
		}
#endif
		if( !vol->file ) {
			//lprintf( "Failed to open volume" );
			return FALSE;
		}
		sack_fseek( vol->file, 0, SEEK_END );
		vol->dwSize = sack_ftell( vol->file );
		if( vol->dwSize == 0 )
			created = TRUE;
		sack_fseek( vol->file, 0, SEEK_SET );
	}
	{
		struct sack_vfs_os_BAT_info info;
		struct sack_vfs_os_BAT_info* pinfo;
		if( vol->pdl_BAT_information->Cnt )
			pinfo = ( struct sack_vfs_os_BAT_info* )GetDataItem( &vol->pdl_BAT_information, vol->pdl_BAT_information->Cnt - 1 );
		else
			pinfo = NULL;
		info.sectorEnd = ( pinfo ? pinfo->sectorEnd : 0 ) + ( BAT_BLOCK_SIZE + ( ( ( BLOCKS_PER_BAT * size ) + 4095 ) & ( ~4095 ) ) );
		info.sectorStart = ( pinfo ? pinfo->sectorEnd : 0 );
		info.blockStart = ( pinfo ? ( pinfo->blockStart + BLOCKS_PER_SECTOR ) : 0 );
		info.size = size;
		AddDataItem( &vol->pdl_BAT_information, &info );
		/*
		{
			INDEX idx;
			struct sack_vfs_os_BAT_info *info;
			// dump reloaded bat information (or bat so far...)
			DATA_FORALL( vol->pdl_BAT_information, idx, struct sack_vfs_os_BAT_info *, info ) {
				lprintf( "BAT Updated expanded: %d %d %d %d", info->blockStart, info->sectorStart, info->sectorEnd, info->size );
			}
		}
		*/
		// a BAT plus the sectors it references... ( BLOCKS_PER_BAT + 1 ) * BLOCK_SIZE
		if( info.sectorEnd > vol->dwSize )
			vol->dwSize = info.sectorEnd;
	}
	LoG( "created expanded volume: %p from %p size:%" _size_f, vol->file, BLOCKS_PER_SECTOR*size, vol->dwSize );
	vol->lastBlock += BLOCKS_PER_SECTOR;
	// can't recover dirents and nameents dynamically; so just assume
	// use the _os_GetFreeBlock because it will update encypted
	//vol->disk->BAT[0] = EOFBLOCK;  // allocate 1 directory entry block
	//vol->disk->BAT[1] = EOFBLOCK;  // allocate 1 name block
	n = 0;
	if( created || ( (n=1),size == BLOCK_SMALL_SIZE && oldsize == ( BLOCK_SIZE * BLOCKS_PER_SECTOR ) ) ) {
		enum block_cache_entries cache = BC(BAT);
		_os_UpdateSegmentKey( vol, &cache, n*BLOCKS_PER_SECTOR + 1 );
		((BLOCKINDEX*)vol->usekey_buffer[cache])[0] = EOBBLOCK;
		((BLOCKINDEX*)vol->usekey_buffer[cache])[BLOCKS_PER_BAT] = (size== BLOCK_SMALL_SIZE )?1:(size==4096)?0:2;
		if( created ) {
			enum block_cache_entries dirCache = BC( DIRECTORY );
			enum block_cache_entries timeCache = BC( TIMELINE );
			enum block_cache_entries rollbackCache = BC( ROLLBACK );
			//BLOCKINDEX dirblock =
				_os_GetFreeBlock( vol, &dirCache, GFB_INIT_DIRENT, DIR_BLOCK_SIZE );
			//BLOCKINDEX timeblock =
				_os_GetFreeBlock( vol, &timeCache, GFB_INIT_TIMELINE, TIME_BLOCK_SIZE );
			//BLOCKINDEX rollbackblock =
				_os_GetFreeBlock( vol, &rollbackCache, GFB_INIT_ROLLBACK, ROLLBACK_BLOCK_SIZE );
			vol->lastBatBlock = 0;
		}
		else {
			//vol->lastBatSmallBlock = BLOCKS_PER_BAT;
		}
		SMUDGECACHE( vol, cache );
		sack_vfs_os_flush_block( vol, cache );
		vol->bufferFPI[cache] = oldsize;
	}
	return TRUE;
}
static BLOCKINDEX _os_GetFreeBlock_( struct sack_vfs_os_volume *vol, enum block_cache_entries *blockCache, enum getFreeBlockInit init, int blockSize, LOGICAL flush_BAT_caches DBG_PASS )
{
	size_t n;
	unsigned int b = 0;
	enum block_cache_entries cache = BC( BAT );
	BLOCKINDEX *current_BAT;
	BLOCKINDEX check_val;
	if( blockSize == 4096 ) {
		if( vol->pdlFreeBlocks->Cnt ) {
			BLOCKINDEX newblock = ((BLOCKINDEX*)GetDataItem( &vol->pdlFreeBlocks, vol->pdlFreeBlocks->Cnt - 1 ))[0];
			check_val = 0;
			b = (unsigned int)(newblock / BLOCKS_PER_BAT);
			n = newblock % BLOCKS_PER_BAT;
			vol->pdlFreeBlocks->Cnt--;
		}
		else {
			check_val = EOBBLOCK;
			b = (unsigned int)(vol->lastBatBlock / BLOCKS_PER_BAT);
			n = vol->lastBatBlock % BLOCKS_PER_BAT;
		}
	}
	else {
		if( vol->pdlFreeSmallBlocks->Cnt ) {
			BLOCKINDEX newblock = ( (BLOCKINDEX*)GetDataItem( &vol->pdlFreeSmallBlocks, vol->pdlFreeSmallBlocks->Cnt - 1 ) )[0];
			check_val = 0;
			n = newblock % BLOCKS_PER_BAT;
			b = (unsigned int)( newblock / BLOCKS_PER_BAT );
			vol->pdlFreeSmallBlocks->Cnt--;
		}
		else {
			check_val = EOBBLOCK;
			n = vol->lastBatSmallBlock % BLOCKS_PER_BAT;
			b = (unsigned int)( vol->lastBatSmallBlock / BLOCKS_PER_BAT );
		}
	}
#ifdef DEBUG_SET_SECTOR_SIZE
	LoG_( "GetFreeBlock is using... check, start, b, n %d %d %d %d", (int)check_val, (int) vol->lastBatBlock, (int)b, (int)n );
#endif
//	vfs_os_compute_block( vol, b * BLOCKS_PER_SECTOR, cache );
	current_BAT =  (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, b*BLOCKS_PER_SECTOR, blockSize, &cache ) + n;
	if( !current_BAT ) return 0;
	current_BAT[0] = EOFBLOCK;
	if( (check_val == EOBBLOCK) ) {
		if( n < (BLOCKS_PER_BAT - 1) ) {
			current_BAT[1] = EOBBLOCK;
			if( blockSize == 4096 )
				vol->lastBatBlock++;
			else
				vol->lastBatSmallBlock++;
		}
		else {
			BLOCKINDEX lastB = ( ( vol->lastBatSmallBlock > vol->lastBatBlock ) ? vol->lastBatSmallBlock : vol->lastBatBlock ) / BLOCKS_PER_BAT;
			enum block_cache_entries cache = BC( BAT );
			//_os_ExpandVolume( vol, lastB, blockSize );
			current_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, ( lastB + 1 ) * ( BLOCKS_PER_SECTOR ), blockSize, &cache );
			current_BAT[BLOCKS_PER_BAT] = ( blockSize == BLOCK_SMALL_SIZE ) ? 1 : ( blockSize == 4096 ) ? 0 : 2;
			//lprintf( "Initialized bat at block %d to %d", lastB + 1, current_BAT[BLOCKS_PER_BAT] );
			current_BAT[0] = EOBBLOCK;
			// update the clean buffer, so journal writes initialized data.
			//memcpy( vol->usekey_buffer_clean[cache], vol->usekey_buffer[cache], DIR_BLOCK_SIZE );
			if( blockSize == 4096 )
				vol->lastBatBlock = ( lastB + 1) * BLOCKS_PER_BAT;
			else
				vol->lastBatSmallBlock = ( lastB + 1 ) * BLOCKS_PER_BAT;
			if( flush_BAT_caches ) sack_vfs_os_flush_block( vol, cache );
 // make sure this gets saved...
			else SMUDGECACHE( vol, cache );
			//lprintf( "Set last block....%d", (int)vol->lastBatBlock );
		}
	}
	if( flush_BAT_caches ) sack_vfs_os_flush_block( vol, cache );
	else SMUDGECACHE( vol, cache );
	switch( init ) {
	case GFB_INIT_DIRENT: {
			struct directory_hash_lookup_block *dir;
#ifdef DEBUG_BLOCK_INIT
			LoG( "Create new directory: result %d", (int)(b * BLOCKS_PER_BAT + n) );
#endif
			blockCache[0] = BC( DIRECTORY );
			_os_UpdateSegmentKey_( vol, blockCache, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 DBG_RELAY );
			memset( vol->usekey_buffer[blockCache[0]], 0, DIR_BLOCK_SIZE );
			dir = (struct directory_hash_lookup_block *)vol->usekey_buffer[blockCache[0]];
			enum block_cache_entries newcache2 = BC( NAMES );
			dir->names_first_block = _os_GetFreeBlock( vol, &newcache2, GFB_INIT_NAMES, NAME_BLOCK_SIZE );
			dir->used_names = 0;
			// update the clean buffer, so journal writes initialized data.
			//memcpy( vol->usekey_buffer_clean[newcache], vol->usekey_buffer[newcache2], DIR_BLOCK_SIZE );
			break;
		}
	case GFB_INIT_TIMELINE: {
			struct storageTimeline *tl;
#ifdef DEBUG_BLOCK_INIT
			LoG( "new block, init as root timeline" );
#endif
			_os_UpdateSegmentKey_( vol, blockCache, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 DBG_RELAY );
			tl = (struct storageTimeline *)vol->usekey_buffer[blockCache[0]];
			//tl->header.timeline_length  = 0;
			//tl->header.crootNode.raw = 0;
			tl->header.srootNode.raw = 0;
			tl->header.first_free_entry.ref.index = 1;
			//tl->header.first_free_entry.ref.depth = 0;
			// update the clean buffer, so journal writes initialized data.
			//memcpy( vol->usekey_buffer_clean[blockCache[0]], vol->usekey_buffer[blockCache[0]], TIME_BLOCK_SIZE );
			break;
		}
	case GFB_INIT_TIMELINE_MORE:
#ifdef DEBUG_BLOCK_INIT
		LoG( "new block, init timeline more " );
#endif
		_os_UpdateSegmentKey_( vol, blockCache, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 DBG_RELAY );
		memset( vol->usekey_buffer[blockCache[0]], 0, vol->sector_size[blockCache[0]] );
		// update the clean buffer, so journal writes initialized data.
		//memcpy( vol->usekey_buffer_clean[blockCache[0]],  vol->usekey_buffer[blockCache[0]], TIME_BLOCK_SIZE );
		break;
	case GFB_INIT_NAMES:
#ifdef DEBUG_BLOCK_INIT
		LoG( "new block, init names" );
#endif
		_os_UpdateSegmentKey_( vol, blockCache, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 DBG_RELAY );
		memset( vol->usekey_buffer[blockCache[0]], 0, vol->sector_size[blockCache[0]] );
		((char*)(vol->usekey_buffer[blockCache[0]]))[0] = (char)UTF8_EOTB;
		// update the clean buffer, so journal writes initialized data.
		//memcpy( vol->usekey_buffer_clean[blockCache[0]], vol->usekey_buffer[blockCache[0]], DIR_BLOCK_SIZE );
		//LoG( "New Name Buffer: %x %p", vol->segment[blockCache[0]], vol->usekey_buffer[blockCache[0]] );
		break;
	default:
#ifdef DEBUG_BLOCK_INIT
		LoG( "Default or NO init..." );
#endif
		_os_UpdateSegmentKey_( vol, blockCache, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 DBG_RELAY );
		break;
	}
	SMUDGECACHE( vol, blockCache[0] );
#ifdef DEBUG_ROLLBACK_JOURNAL
	LoG( "(post smudge)Return Free block:%d   %d  %d", (int)(b*BLOCKS_PER_BAT + n), (int)b, (int)n );
#endif
	//lprintf( "return block allocated: %d %d %d", (int)(b* BLOCKS_PER_BAT + n), (int)b, n );
	return b * BLOCKS_PER_BAT + n;
}
static BLOCKINDEX vfs_os_GetNextBlock_v2( struct sack_vfs_os_volume *vol, BLOCKINDEX block, enum block_cache_entries* blockCache, enum getFreeBlockInit init, LOGICAL expand, int blockSize, int *realBlockSize, LOGICAL flush_BAT_caches ) {
	BLOCKINDEX sector = block / BLOCKS_PER_BAT;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *this_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, sector * (BLOCKS_PER_SECTOR), blockSize, &cache );
	int thisSize = this_BAT[BLOCKS_PER_BAT]? BLOCK_SMALL_SIZE :4096;
	BLOCKINDEX check_val;
 // if this passes, later ones will also.
	if( !this_BAT ) return 0;
#ifdef _DEBUG
	if( !block ) DebugBreak();
#endif
	check_val = (this_BAT[block % BLOCKS_PER_BAT]);
#ifdef _DEBUG
	if( !check_val ) {
		lprintf( "STOP: %p  %d  %d  %d", this_BAT, (int)check_val, (int)(block), (int)sector );
		DebugBreak();
	}
#endif
	if( check_val == EOBBLOCK ) {
		(this_BAT[block % (BLOCKS_PER_BAT)]) = EOFBLOCK;
		if( block < (BLOCKS_PER_BAT - 1) )
			(this_BAT[(1 + block) % BLOCKS_PER_BAT]) = EOBBLOCK;
		//else
		//	lprintf( "THIS NEEDS A NEW BAT BLOCK TO MOVE THE MARKER" );//
	}
	if( check_val == EOFBLOCK || check_val == EOBBLOCK ) {
		if( expand ) {
			SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )+1 );
			check_val = _os_GetFreeBlock_( vol, blockCache, init, blockSize, flush_BAT_caches DBG_SRC );
#ifdef _DEBUG
			if( !check_val )DebugBreak();
#endif
			{
				// free block might have expanded... get the size that was actually allocated
				BLOCKINDEX nextSector = check_val / BLOCKS_PER_BAT;
				if( sector != nextSector ) {
					enum block_cache_entries cache = BC(BAT);
					BLOCKINDEX* this_BAT2 = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, nextSector * ( BLOCKS_PER_SECTOR ), BAT_BLOCK_SIZE, &cache );
					if( !this_BAT2 ) {
						lprintf( "failed to load next bat to get size" );
						return 0;
					}
					thisSize = this_BAT2[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
				} else
					thisSize = this_BAT[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
			}
			// segment could already be set from the _os_GetFreeBlock...
			//lprintf( "set block %d %d %d to %d", (int)block, (int)( block % BLOCKS_PER_BAT ), (int)sector, (int)check_val );
			this_BAT[block % BLOCKS_PER_BAT] = check_val;
			//lprintf( "Set %d  %d %d to %d", block, sector, block % BLOCKS_PER_BAT, check_val );
			if( flush_BAT_caches ) sack_vfs_os_flush_block( vol, cache );
			else SMUDGECACHE( vol, cache );
			SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache ) - 1 );
		}
	} else {
		enum block_cache_entries cache = BC(BAT);
		BLOCKINDEX nextSector = check_val / BLOCKS_PER_BAT;
		if( nextSector != sector ) {
			BLOCKINDEX* this_BAT2 = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, nextSector * ( BLOCKS_PER_SECTOR ), BAT_BLOCK_SIZE, &cache );
			if( !this_BAT2 ) {
				lprintf( "failed to load next bat to get size" );
				return 0;
			}
			thisSize = this_BAT2[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
		} else
			thisSize = this_BAT[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
	}
#ifdef _DEBUG
	if( !check_val )DebugBreak();
#endif
	if( realBlockSize ) realBlockSize[0] = thisSize;
	//LoG( "return next block:%d %d", (int)block, (int)check_val );
	return check_val;
}
static BLOCKINDEX vfs_os_GetNextBlock( struct sack_vfs_os_volume* vol, BLOCKINDEX block, enum block_cache_entries* blockCache, enum getFreeBlockInit init, LOGICAL expand, int blockSize, int* realBlockSize ) {
	return vfs_os_GetNextBlock_v2( vol, block, blockCache, init, expand, blockSize, realBlockSize, FALSE );
}
static void _os_AddSalt( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct sack_vfs_os_volume *vol = (struct sack_vfs_os_volume *)psv;
	if( vol->sigsalt ) {
		(*salt_size) = vol->sigkeyLength;
		(*salt) = (POINTER)vol->sigsalt;
		vol->sigsalt = NULL;
	}
	else if( vol->datakey ) {
		(*salt_size) = BLOCK_SIZE;
		(*salt) = (POINTER)vol->datakey;
		vol->datakey = NULL;
	}
	else if( vol->userkey ) {
		(*salt_size) = StrLen( vol->userkey );
		(*salt) = (POINTER)vol->userkey;
		vol->userkey = NULL;
	}
	else if( vol->devkey ) {
		(*salt_size) = StrLen( vol->devkey );
		(*salt) = (POINTER)vol->devkey;
		vol->devkey = NULL;
	}
	else if( vol->curseg < BC(COUNT) && vol->segment[vol->curseg] != ~0 ) {
		BLOCKINDEX sector = vol->segment[vol->curseg];
		switch( vol->clusterKeyVersion ) {
		case 0:
			( *salt_size ) = sizeof( vol->segment[vol->curseg] );
			( *salt ) = &vol->segment[vol->curseg];
			break;
		case 1:
			memcpy( vol->tmpSalt, vol->key, 16 );
			vol->tmpSalt[sector & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[0];
			vol->tmpSalt[( sector >> 4 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[1];
			vol->tmpSalt[( sector >> 8 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[2];
			vol->tmpSalt[( sector >> 12 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[3];
			( (BLOCKINDEX*)vol->tmpSalt )[0] ^= sector;
			( (BLOCKINDEX*)vol->tmpSalt )[1] ^= sector;
			( *salt_size ) = 12;
			( *salt ) = vol->tmpSalt;
			break;
		}
	}
	else
		(*salt_size) = 0;
}
static void _os_AssignKey( struct sack_vfs_os_volume *vol, const char *key1, const char *key2 )
{
	// *2 is to duplicate all buffers so there's a backing clean-copy for rollback
	uintptr_t size = BLOCK_SIZE + BLOCK_SIZE * ( BC(COUNT) * 2 )
		+ BLOCK_SIZE + SHORTKEY_LENGTH;
	if( !vol->key_buffer ) {
		int n;
		// internal buffers to read and decode into
// NewArray( uint8_t, size );
		vol->key_buffer = (uint8_t*)HeapAllocateAligned( NULL, size, 4096 );
		memset( vol->key_buffer, 0, size );
		for( n = 0; n < BC(COUNT); n++ ) {
			vol->usekey_buffer[n] = vol->key_buffer + (n + 1) * BLOCK_SIZE;
			vol->usekey_buffer_clean[n] = vol->key_buffer + ( n + 1 + BC(COUNT) ) * BLOCK_SIZE ;
		}
		for( n = 0; n < BC( COUNT ); n++ ) {
 // if not dirty, ~0 wont' be written but ages don't have to change.
			vol->segment[n] = ~0;
			CLEANCACHE( vol, n );
			RESETFLAG( vol->_dirty, n );
		}
	}
	vol->userkey = key1;
	vol->devkey = key2;
	if( key1 || key2 )
	{
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( _os_AddSalt, (uintptr_t)vol );
		else
			SRG_ResetEntropy( vol->entropy );
		if( vol->oldkey ) Release( vol->oldkey );
		vol->oldkey = vol->key;
 //NewArray( uint8_t, size );
		vol->key = (uint8_t*)HeapAllocateAligned( NULL, 1024, 4096 );
		vol->curseg = BC(COUNT);
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->key, 1024 * 8 );
	}
	else {
		if( vol->oldkey ) Release( vol->oldkey );
		vol->oldkey = vol->key;
		vol->key = NULL;
	}
}
static void sack_vfs_os_flush_block( struct sack_vfs_os_volume* vol, enum block_cache_entries entry ) {
	INDEX idx = entry;
#ifdef DEBUG_DISK_IO
	LoG( "Flush dirty segment: %d  fpi:%zx %d", (int)idx, vol->bufferFPI[idx], vol->segment[idx] );
#  ifdef DEBUG_DISK_DATA
	LogBinary( vol->usekey_buffer[idx], vol->sector_size[idx] );
#  endif
#endif
	sack_fseek( vol->file, (size_t)vol->bufferFPI[idx], SEEK_SET );
	if( vol->key ) {
		uint8_t* crypt;
		size_t cryptlen;
		SRG_XSWS_encryptData( vol->usekey_buffer[idx], vol->sector_size[idx]
			, vol->segment[idx], (const uint8_t*)vol->key, 1024
			, &crypt, &cryptlen );
		if( !vol->flags.halted )
			sack_fwrite( crypt, 1, vol->sector_size[idx], vol->file );
		Deallocate( uint8_t*, crypt );
	} else {
		if( !vol->flags.halted )
			sack_fwrite( vol->usekey_buffer[idx], vol->sector_size[idx], 1, vol->file );
	}
	/*
	if( !GETMASK_( vol->seglock, seglock, idx ) )
		// don't HAVE To release that this segment is in this cache block...
		// it's just claimable, and not dirty.
		// vol->segment[idx] = ~0;
		;
	*/
	memcpy( vol->usekey_buffer_clean[idx], vol->usekey_buffer[idx], vol->sector_size[idx] );
	//lprintf( "Updated clean buffer %d", idx );
	CLEANCACHE( vol, idx );
	RESETFLAG( vol->_dirty, idx );
	//RESETFLAG( vol->dirty, idx );  // CLEANCACHE is this op...
}
void sack_vfs_os_flush_volume( struct sack_vfs_os_volume * vol, LOGICAL unload ) {
	{
		INDEX idx;
		while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
		for( idx = 0; idx < BC( ROLLBACK ); idx++ ) {
			if( unload ) {
  // reset any locks. (will fail any open files)
				SETMASK_( vol->seglock, seglock, idx, 0 );
				//RESETFLAG( vol->seglock, idx );
			}
			if( TESTFLAG( vol->dirty, idx ) || TESTFLAG( vol->_dirty, idx ) ) {
				sack_vfs_os_flush_block( vol, ( enum block_cache_entries )idx );
			} else {
#ifdef DEBUG_CACHE_FLUSH
				if( memcmp( vol->usekey_buffer_clean[idx], vol->usekey_buffer[idx], BLOCK_SIZE ) ) {
					lprintf( "Block was written to, but was not flagged as dirty, changes will be lost." );
					DebugBreak();
				}
#endif
			}
		}
		vfs_os_empty_rollback( vol );
	}
	vol->lock = 0;
}
static uintptr_t volume_flusher( PTHREAD thread ) {
	struct sack_vfs_os_volume *vol = (struct sack_vfs_os_volume *)GetThreadParam( thread );
	while( 1 ) {
		vol->flushing = 1;
		while( 1 ) {
			int updated;
			INDEX idx;
			updated = 0;
			if( !LockedExchange( &vol->lock, 1 ) ) {
				// this could be 'faster' testing the whole
				// flag type size data.
				for( idx = 0; idx < BC( COUNT ); idx++ )
					if( TESTFLAG( vol->dirty, idx ) ) {
						updated = 1;
						SETFLAG( vol->_dirty, idx );
						CLEANCACHE( vol, idx );
					}
				if( updated ) {
 // data changed, don't flush.
					vol->lock = 0;
					WakeableSleep( 256 );
					if( l.exited )break;
				}
				else
 // have lock, break; no new changes; flush dirty sectors(if any)
					break;
			}
 // didn't get lock, wait.
			else {
				WakeableSleep( 10 );
				if( l.exited )break;
				continue;
			}
		}
		if( l.exited )break;
		{
			INDEX idx;
			for( idx = 0; idx < BC( ROLLBACK ); idx++ )
  // last pass marked this dirty
				if( TESTFLAG( vol->_dirty, idx )
 // hasn't been re-marked as dirty, so it's been idle...
					&& !TESTFLAG( vol->dirty, idx ) ) {
					sack_vfs_os_flush_block( vol, (enum block_cache_entries)idx );
				}
				else {
#ifdef DEBUG_CACHE_FLUSH
					if( !TESTFLAG( vol->_dirty, idx )
						// hasn't been re-marked as dirty, so it's been idle...
						&& !TESTFLAG( vol->dirty, idx ) )
						if( memcmp( vol->usekey_buffer_clean[idx], vol->usekey_buffer[idx], BLOCK_SIZE ) ) {
							lprintf( "Block was written to, but was not flagged as dirty, changes will be lost." );
							//DebugBreak();
						}
#endif
				}
#ifdef DEBUG_DIRECTORIES
			_os_dumpDirectories( vol, 0, 1 );
#endif
			vfs_os_empty_rollback(vol);
		}
		vol->flushing = 0;
		vol->lock = 0;
		// for all dirty
		WakeableSleep( SLEEP_FOREVER );
		if( l.exited )break;
	}
	return 0;
}
void sack_vfs_os_polish_volume( struct sack_vfs_os_volume* vol ) {
	if( !vol->flusher )
		vol->flusher = ThreadTo( volume_flusher, (uintptr_t)vol );
	else if( !vol->flushing )
		WakeThread( vol->flusher );
}
void sack_vfs_os_unload_volume( struct sack_vfs_os_volume* vol );
struct sack_vfs_os_volume *sack_vfs_os_load_volume( const char * filepath, struct file_system_mounted_interface*mount )
{
	struct sack_vfs_os_volume *vol = New( struct sack_vfs_os_volume );
	memset( vol, 0, sizeof( struct sack_vfs_os_volume ) );
	if( !mount )
		mount = sack_get_default_mount();
	vol->mount = mount;
	// since time is morely forward going; keeping the stack for the avl
	// balancer can reduce forward-scanning insertion time
	// vol->pdsCTimeStack = CreateDataStack( sizeof( struct memoryTimelineNode ) );
	// vol->pdsWTimeStack = CreateDataStack( sizeof( struct memoryTimelineNode ) );
	vol->pdl_BAT_information = CreateDataList( sizeof( struct sack_vfs_os_BAT_info ) );
	vol->pdlFreeBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->pdlFreeSmallBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->volname = StrDup( filepath );
#ifdef DEBUG_DELETE_LAST
	vol->pvtDeleteBuffer = VarTextCreate();
#endif
	_os_AssignKey( vol, NULL, NULL );
	if( !_os_ExpandVolume( vol, 0, 4096 )
	  || !_os_ExpandVolume(vol, BLOCKS_PER_SECTOR, BLOCK_SMALL_SIZE )
	  || !_os_ValidateBAT( vol ) )
	{
		sack_vfs_os_unload_volume( vol );
		return NULL;
	}
#ifdef DEBUG_DIRECTORIES
	_os_dumpDirectories( vol, 0, 1 );
#endif
	AddLink( &l.volumes, vol );
	return vol;
}
struct sack_vfs_os_volume* sack_vfs_os_load_volume_v2( int flags, CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey, struct file_system_mounted_interface* mount )	 {
	struct sack_vfs_os_volume *vol = New( struct sack_vfs_os_volume );
	MemSet( vol, 0, sizeof( struct sack_vfs_os_volume ) );
	if( !mount )
		mount = sack_get_default_mount();
	vol->mount = mount;
	if( !version ) version = 2;
	if( flags & 1 ) vol->flags.skipRollbackProcessing = TRUE;
	if( flags & 2 ) vol->flags.halted = TRUE;
	vol->pdl_BAT_information = CreateDataList( sizeof( struct sack_vfs_os_BAT_info ) );
	vol->pdlFreeBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->pdlFreeSmallBlocks = CreateDataList( sizeof( BLOCKINDEX ) );
	vol->clusterKeyVersion = version - 1;
	vol->volname = StrDup( filepath );
	vol->pvtDeleteBuffer = VarTextCreate();
	_os_AssignKey( vol, userkey, devkey );
	if( !_os_ExpandVolume( vol, 0, 4096 ) || !_os_ExpandVolume( vol, BLOCKS_PER_SECTOR, BLOCK_SMALL_SIZE ) || !_os_ValidateBAT( vol ) ) { sack_vfs_os_unload_volume( vol ); return NULL; }
#ifdef DEBUG_DIRECTORIES
	_os_dumpDirectories( vol, 0, 1 );
#endif
	AddLink( &l.volumes, vol );
	return vol;
}
struct sack_vfs_os_volume* sack_vfs_os_load_crypt_volume( const char* filepath, uintptr_t version, const char* userkey, const char* devkey, struct file_system_mounted_interface* mount ) {
	return sack_vfs_os_load_volume_v2( 0, filepath, version, userkey, devkey, mount );
}
void sack_vfs_os_unload_volume( struct sack_vfs_os_volume * vol ) {
	INDEX idx;
	struct sack_vfs_file *file;
#ifdef DEBUG_DIRECTORIES
	_os_dumpDirectories( vol, 0, 1 );
#endif
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file )
		break;
	if( file ) {
		vol->closed = TRUE;
		return;
	}
	DeleteLink( &l.volumes, vol );
	if( vol->file )
		sack_vfs_os_flush_volume( vol, TRUE );
	free( (char*)vol->volname );
	DeleteListEx( &vol->files DBG_SRC );
	sack_fclose( vol->file );
	DeleteDataList( &vol->pdl_BAT_information );
	DeleteDataList( &vol->pdlFreeBlocks );
	DeleteDataList( &vol->pdlFreeSmallBlocks );
	//if( !vol->external_memory )	CloseSpace( vol->diskReal );
	if( vol->key ) {
		Deallocate( uint8_t*, vol->key );
		SRG_DestroyEntropy( &vol->entropy );
	}
	Deallocate( uint8_t*, vol->key_buffer );
	Deallocate( struct sack_vfs_os_volume*, vol );
}
void sack_vfs_os_shrink_volume( struct sack_vfs_os_volume * vol ) {
	size_t n;
	unsigned int b = 0;
	//int found_free; // this block has free data; should be last BAT?
	//BLOCKINDEX last_block = 0;
	//unsigned int last_bat = 0;
	enum block_cache_entries cache = BC(BAT);
	BLOCKINDEX *current_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, 0, 0, &cache );
 // expand failed, tseek failed in response, so don't do anything
	if( !current_BAT ) return;
	do {
		BLOCKINDEX check_val;
		for( n = 0; n < BLOCKS_PER_BAT; n++ ) {
			check_val = *(current_BAT++);
			if( check_val ) {
				//last_bat = b;
				//last_block = n;
			}
		}
		b++;
		if( vfs_os_compute_block( vol, b * BLOCKS_PER_SECTOR, BC(COUNT) ) < vol->dwSize ) {
			current_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK(  vol, b * ( BLOCKS_PER_SECTOR), 0, &cache );
		} else
			break;
	}while( 1 );
	sack_fclose( vol->file );
	vol->file = NULL;
	// setting 0 size will cause expand to do an initial open instead of expanding
	vol->dwSize = 0;
}
LOGICAL sack_vfs_os_decrypt_volume( struct sack_vfs_os_volume *vol )
{
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume is already decrypted, cannot remove key
	if( !vol->key ) { vol->lock = 0; return FALSE; }
	_os_AssignKey( vol, NULL, NULL );
	{
		enum block_cache_entries cache = BC(BAT);
		enum block_cache_entries cache2 = BC(BAT);
		size_t n;
		for( n = 0; vfs_os_compute_block( vol, n, BC(COUNT) ) < vol->dwSize; n++ ) {
			size_t m;
			BLOCKINDEX *block = (BLOCKINDEX*)vfs_os_block_index_SEEK(  vol, n, 0, &cache );
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) break;
 // load the block using oldkey, flush will use new key
				else if( block[0] ) vfs_os_block_index_SEEK( vol, n + m, 0, &cache2 );
				block++;
			}
			if( m < BLOCKS_PER_BAT ) break;
			n += m;
		}
	}
	return TRUE;
}
LOGICAL sack_vfs_os_encrypt_volume( struct sack_vfs_os_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 ) {
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	//if( vol->key ) { vol->lock = 0; return FALSE; } // volume already has a key, cannot apply new key
	if( !version ) version = 2;
 // how key gets computed.
	vol->clusterKeyVersion = version-1;
	_os_AssignKey( vol, key1, key2 );
	{
		size_t n;
		enum block_cache_entries cache = BC(BAT);
		enum block_cache_entries cache2 = BC(BAT);
		for( n = 0; vfs_os_compute_block( vol, n, BC(COUNT) ) < vol->dwSize; n++ ) {
			size_t m;
			BLOCKINDEX *block = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, n, 0, &cache );
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) break;
 // load the block using oldkey, flush will use new key
				else if( block[0] ) vfs_os_block_index_SEEK( vol, n + m, 0, &cache2 );
				block++;
			}
			if( m < BLOCKS_PER_BAT ) break;
			n += m;
		}
	}
	vol->lock = 0;
	return TRUE;
}
const char *sack_vfs_os_get_signature( struct sack_vfs_os_volume *vol ) {
	static char signature[257];
	static const char *output = "0123456789ABCDEF";
	if( !vol )
		return NULL;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	{
		static BLOCKINDEX datakey[BLOCKS_PER_BAT];
		uint8_t usekey[128];
		signature[256] = 0;
		memset( datakey, 0, sizeof( datakey ) );
		{
			{
				size_t n;
				BLOCKINDEX this_dir_block = 0;
				BLOCKINDEX next_dir_block;
				BLOCKINDEX *next_entries;
				do {
					enum block_cache_entries cache = BC(DATAKEY);
					next_entries = BTSEEK( BLOCKINDEX *, vol, this_dir_block, DIR_BLOCK_SIZE, cache );
					for( n = 0; n < ( DIR_BLOCK_SIZE / BLOCKS_PER_BAT ); n++ )
						datakey[n] ^= next_entries[n];
					next_dir_block = vfs_os_GetNextBlock( vol, this_dir_block, &cache, GFB_INIT_DIRENT, FALSE, 4096, NULL );
#ifdef _DEBUG
					if( this_dir_block == next_dir_block )
						DebugBreak();
					if( next_dir_block == 0 )
						DebugBreak();
#endif
					this_dir_block = next_dir_block;
				}
				while( next_dir_block != EOFBLOCK );
			}
		}
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( _os_AddSalt, (uintptr_t)vol );
		SRG_ResetEntropy( vol->entropy );
		vol->curseg = BC(DIRECTORY);
		vol->segment[vol->curseg] = 0;
		vol->datakey = (const char *)datakey;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)usekey, sizeof(usekey) * 8 );
		{
			int n;
			for( n = 0; n < sizeof(usekey); n++ ) {
				signature[n*2] = output[( usekey[n] >> 4 ) & 0xF];
				signature[n*2+1] = output[usekey[n] & 0xF];
			}
		}
	}
	vol->lock = 0;
	return signature;
}
LOGICAL checkFileLength( struct sack_vfs_os_volume *vol
	, BLOCKINDEX firstBlock
	, FPI expectedLength ) {
	BLOCKINDEX curBlock = firstBlock;
	size_t len;
	enum block_cache_entries cache;
	BLOCKINDEX sector = firstBlock / BLOCKS_PER_BAT;
	enum block_cache_entries batcache = BC(BAT);
	BLOCKINDEX *this_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, sector * (BLOCKS_PER_SECTOR), BLOCK_SIZE, &batcache );
	len = this_BAT[BLOCKS_PER_BAT] ? BLOCK_SMALL_SIZE : 4096;
	while( curBlock != EOFBLOCK ) {
		int blockSize;
		cache = BC(FILE);
		curBlock = vfs_os_GetNextBlock( vol, curBlock, &cache, GFB_INIT_NONE, FALSE, 0, &blockSize );
		if( curBlock != EOFBLOCK )
			len += blockSize;
	}
	if( len < expectedLength ) {
		lprintf( "Short file chain: %d %d", (int)len, (int)expectedLength );
		return FALSE;
	}
	//else lprintf( "Success: %d %d %d",  (int) firstBlock, (int)len, (int)expectedLength );
	return TRUE;
}
//-----------------------------------------------------------------------------------
// Director Support Functions
//-----------------------------------------------------------------------------------
LOGICAL _os_ScanDirectory_( struct sack_vfs_os_volume *vol, const char * filename
	, BLOCKINDEX dirBlockSeg
	, BLOCKINDEX *nameBlockStart
	, struct sack_vfs_os_file *file
	, int path_match
	, char *leadin
	, int *leadinDepth
) {
	int ofs = 0;
	BLOCKINDEX this_dir_block = dirBlockSeg;
	int usedNames;
	int minName;
	int curName;
	struct directory_hash_lookup_block *dirblock;
	//struct directory_entry *next_entries;
	if( filename && filename[0] == '.' && ( filename[1] == '/' || filename[1] == '\\' ) ) filename += 2;
	if( !file && !filename && nameBlockStart )
		lprintf( "Begin a scan dir:%d", (int)dirBlockSeg );
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		BLOCKINDEX nameBlock;
		dirblock = BTSEEK( struct directory_hash_lookup_block *, vol, this_dir_block, DIR_BLOCK_SIZE, cache );
		SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )+1 );
		if( !dirblock->next_block[255] ) {
 // symbol not defined
#ifdef DEBUG_CONVERT_DIRECTORY
			l.fileCount = 0;
#endif
		}
		else{
			if( !file && !filename && nameBlockStart )
				 lprintf( "parent block(may be truncated): %d(%d) %d p:%d c:%d c:%c", (int)this_dir_block, cache, (int)dirblock->used_names
							, (int)(dirblock->next_block[255] >> 8)
							, (int)(dirblock->next_block[255] & 0xFF), (char)(dirblock->next_block[255] & 0xFF) );
		}
		nameBlock = dirblock->names_first_block;
		if( filename )
		{
			BLOCKINDEX nextblock = dirblock->next_block[(unsigned)filename[ofs]];
			if( nextblock ) {
				leadin[(*leadinDepth)++] = filename[ofs];
				ofs += 1;
				this_dir_block = nextblock;
				// just stepping to new block - unlock old, will lock new.
				SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )-1 );
				//lprintf( "Follow subdirectory %d", (int)nextblock );
				continue;
			}
		}
		else {
			uint8_t charIndex;
			for( charIndex = 0; charIndex < 255; charIndex++ ) {
				BLOCKINDEX nextblock = dirblock->next_block[charIndex];
				if( nextblock ) {
					LOGICAL r;
					leadin[(*leadinDepth)++] = (char)charIndex;
#ifdef _DEBUG
					if( !file && !filename && nameBlockStart )
						lprintf( "Check subdirectory %d %d %c", (int)nextblock, (int)(dirblock->next_block[255] >> 8), charIndex );
#endif
					r = _os_ScanDirectory_( vol, NULL, nextblock, nameBlockStart, file, path_match, leadin, leadinDepth );
					(*leadinDepth)--;
					if( r && r != 2 )   {
						lprintf( "scan is returning early.. %d",r );
						SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )-1 );
						return r;
					}
				}
			}
		}
		usedNames = dirblock->used_names - 1;
		if( SUS_GT( usedNames, int, ( sizeof( dirblock->entries ) / sizeof( dirblock->entries[0] ) ), size_t ) ) {
			lprintf( "Directory block name count is corrupt." );
			DebugBreak();
		}
		minName = 0;
		curName = (usedNames) >> 1;
		{
			//next_entries = dirblock->entries;
			//lprintf( "name block %d %d %d", (int)dirBlockSeg, (int)usedNames, (int)cache );
			while( minName <= usedNames && ( curName <= usedNames ) && ( curName >= 0 ) )
			{
				BLOCKINDEX bi;
				//enum block_cache_entries name_cache = BC(NAMES);
				struct directory_entry *entry = dirblock->entries + curName;
				//const char * testname;
				FPI name_ofs = ( entry->name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
 // symbol not defined
#ifdef DEBUG_CONVERT_DIRECTORY
				l.fileCount++;
#endif
#ifdef DEBUG_TIMELINE_DIR_TRACKING
 // else we have a different issue.
				if( entry->timelineEntry )
				{
					// make sure timeline and file entries reference each other.
					struct memoryTimelineNode time;
					reloadTimeEntry( &time, vol, entry->timelineEntry VTReadOnly GRTELog DBG_SRC );
					FPI entry_fpi = vol->bufferFPI[cache] + sane_offsetof( struct directory_hash_lookup_block, entries[curName] );
					if( entry_fpi != time.disk->dirent_fpi ) {
						lprintf( "!!!! directory entry doesn't match: %d %d", entry_fpi, time.disk->dirent_fpi );
						DebugBreak();
					}
					dropRawTimeEntry( vol, time.diskCache GRTELog DBG_SRC );
				}
#endif
				//if( filename && !name_ofs )	return FALSE; // done.
				if( 0 ) {
					LoG( "%d name_ofs = %" _size_f "(%" _size_f ") block = %d  vs %s"
						, curName, name_ofs
						, entry->name_offset
						, entry->first_block
						, filename + ofs );
				}
				if( curName < usedNames ) {
					bi = entry->first_block ;
					// if file is deleted; don't check it's name.
					if( !bi ) {
						lprintf( "File is already deleted... (these should be removed)" );
						continue;
					}
					// if file is end of directory, done sanning.
// done.
					if( bi == EODMARK ) { lprintf( "Found end of directory mark." ); return filename ? FALSE : (2); }
					if( name_ofs > vol->dwSize ) { lprintf( "name offset is bigger than volume size!"); return FALSE; }
				}
				//testname =
				if( filename ) {
					int d;
					//LoG( "this name: %s", names );
					if( ( d = _os_MaskStrCmp( vol, filename+ofs, nameBlock, name_ofs, path_match ) ) == 0 ) {
						if( file )
						{
							/* can just keep the existing lock...
							int locks = GETMASK_( vol->seglock, seglock, cache ) + 1;
							if( locks > 12 ) {
								lprintf( "Too many locks open... " );
								DebugBreak();
							}
							SETMASK_( vol->seglock, seglock, cache, locks );
							*/
							file->cache = cache;
							file->entry_fpi = vol->bufferFPI[BC(DIRECTORY)] + ((uintptr_t)(((struct directory_hash_lookup_block *)0)->entries + curName));
							file->dir_block = this_dir_block;
							file->entry_.name_offset = ( entry->name_offset & DIRENT_NAME_OFFSET_OFFSET ) + vfs_os_compute_data_block( vol, dirblock->names_first_block, BC( COUNT ) );
							file->entry = entry;
						}
#ifdef DEBUG_DIRECTORIES
						if(0)
						LoG( "return found entry: %p (%" _size_f ":%" _size_f ") %*.*s%s"
							, entry, name_ofs, entry->first_block
							, *leadinDepth, *leadinDepth, leadin
							, filename+ofs );
#endif
						if( nameBlockStart ) nameBlockStart[0] = dirblock->names_first_block ;
						// keep the lock because of the file cache reference.
						if( !file )
							SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )-1 );
						return TRUE;
					}
					if( d > 0 ) {
						minName = curName + 1;
					} else {
						usedNames = curName - 1;
					}
					curName = (minName + usedNames) >> 1;
				}
				else {
					if( minName < usedNames && !file ) {
						if( !checkFileLength( vol, entry->first_block, entry->filesize ) ) {
							lprintf( "directory scan found a short file chain" );
							return FALSE;
						}
					}
					curName++;
				}
			}
			// no file created, found end, unlock this directory
			SETMASK_( vol->seglock, seglock, cache, GETMASK_( vol->seglock, seglock, cache )-1 );
 // done.;
			return filename ? FALSE : (2);
		}
		// unreachable, and broken code.
#if 0
		BLOCKINDEX next_dir_block;
		next_dir_block = vfs_os_GetNextBlock( vol, this_dir_block, GFB_INIT_TIMELINE_MORE, TRUE, DIR_BLOCK_SIZE, NULL );
#ifdef _DEBUG
		if( this_dir_block == next_dir_block ) DebugBreak();
  // should have a last-entry before no more blocks....
		if( next_dir_block == 0 ) { DebugBreak(); return FALSE; }
#endif
		this_dir_block = next_dir_block;
#endif
	}
	while( 1 );
}
// this results in an absolute disk position
static FPI _os_SaveFileName( struct sack_vfs_os_volume *vol, BLOCKINDEX firstNameBlock, const char * filename, size_t namelen ) {
	int blocks = 0;
	LOGICAL scanToEnd = FALSE;
	BLOCKINDEX this_name_block = firstNameBlock;
#ifdef _DEBUG
	if( !firstNameBlock ) DebugBreak();
#endif
	//lprintf( "Save filename:%s", filename );
	while( 1 ) {
		enum block_cache_entries cache = BC(NAMES);
		unsigned char *names = BTSEEK( unsigned char *, vol, this_name_block, NAME_BLOCK_SIZE, cache );
		unsigned char *name = (unsigned char*)names;
		if( scanToEnd ) {
			while(
				(UTF8_EOT != (name[0] ))
				&& (name - names < NAME_BLOCK_SIZE)
				) name++;
			if( ( name - names ) >= NAME_BLOCK_SIZE ) {
				// wow, that is a really LONG name.
				cache = BC( NAMES );
				this_name_block = vfs_os_GetNextBlock( vol, this_name_block, &cache, GFB_INIT_NAMES, TRUE, NAME_BLOCK_SIZE, NULL );
				blocks++;
				continue;
			}
		}
		scanToEnd = FALSE;
		while( name < ( (unsigned char*)names + NAME_BLOCK_SIZE ) ) {
			int c = name[0];
			if( (unsigned char)c == UTF8_EOTB ) {
				if( namelen < (size_t)( ( (unsigned char*)names + NAME_BLOCK_SIZE ) - name ) ) {
					//LoG( "using unused entry for new file...%" _size_f " %d(%d)  %" _size_f " %s", this_name_block, cache, cache - BC(NAMES), name - names, filename );
					memcpy( name, filename, namelen );
					name[namelen+0] = UTF8_EOT;
					name[namelen+1] = UTF8_EOTB;
					SMUDGECACHE( vol, cache );
					//LoG( "save name OFFSET:%d %d", (name) - (names), +blocks * NAME_BLOCK_SIZE );
					return (name) - (names) + blocks * NAME_BLOCK_SIZE;
				}
			}
			else
				if( _os_MaskStrCmp( vol, filename, firstNameBlock, (name - names)+blocks*NAME_BLOCK_SIZE, 0 ) == 0 ) {
					LoG( "using existing entry for new file...%s", filename );
					lprintf( "name already in cache %d", cache );
					return (name) - (names) + blocks * NAME_BLOCK_SIZE;
				}
			while(
				( UTF8_EOT != ( name[0] ) )
				&& ( name-names < NAME_BLOCK_SIZE )
			) name++;
			if( name - names <= NAME_BLOCK_SIZE ) {
				if( name - names < NAME_BLOCK_SIZE ) {
					name++;
				}
				else {
					// next seek will be on right character...
				}
			}
			else
 // still looking for EOT
				scanToEnd = TRUE;
			//LoG( "new position is %" _size_f "  %" _size_f, this_name_block, name - names );
		}
		this_name_block = vfs_os_GetNextBlock( vol, this_name_block, &cache, GFB_INIT_NAMES, TRUE, NAME_BLOCK_SIZE, NULL );
		blocks++;
		//LoG( "Need a new name block.... %d", this_name_block );
	}
	lprintf( "didn't actually save the name?" );
}
static void deleteDirectoryEntryName( struct sack_vfs_os_volume* vol, struct sack_vfs_os_file* file, int nameOffset, enum block_cache_entries nameCache, BLOCKINDEX dir_block_index ) {
	size_t n;
	FPI nameoffset_temp = 0;
	//static uint8_t namebuffer[3 * 4096];
	uint8_t* nameblock = NULL;
	uint8_t* nameblock_;
	int f;
	int e = -1;
	enum block_cache_entries name_cache = BC(ZERO), name_cache_;
 // this will be a smallish int
	int endNameOffset = 0;
	int findNameOffset = nameOffset;
	struct directory_hash_lookup_block* dirblock = (struct directory_hash_lookup_block*)vol->usekey_buffer[nameCache];
	BLOCKINDEX name_block = dirblock->names_first_block;
#ifdef DEBUG_FILE_OPEN
	LoG( "------------ BEGIN DELETE DIRECTORY ENTRY NAME ----------------------" );
#endif
	// read name block chain into a single array
	do {
		uint8_t* out;
		uint8_t* in;
		name_cache_ = name_cache;
		name_cache = BC( NAMES );
		nameblock_ = nameblock;
		nameblock = BTSEEK( uint8_t*, vol, name_block, NAME_BLOCK_SIZE, name_cache );
		if( findNameOffset < NAME_BLOCK_SIZE ) {
			// first read block (nameoffset_temp = 0)
			// not already found end of text mark ( endNameOffset = 0 )
			SETMASK_( vol->seglock, seglock, name_cache, GETMASK_( vol->seglock, seglock, name_cache ) + 1 );
			if( !endNameOffset ) {
				for( n = findNameOffset; n < NAME_BLOCK_SIZE; n++ ) {
					if( nameblock[n] == UTF8_EOT ) {
						endNameOffset = (int)(nameoffset_temp + n + 1);
						break;
					}
				}
				// if the difference was found, move the rest of this block.
				if( endNameOffset ) {
					in = nameblock + endNameOffset;
					out = nameblock + findNameOffset;
					for( n = endNameOffset; n < NAME_BLOCK_SIZE; n++ ) {
						( *out++ ) = ( *in++ );
					}
  // re-wrote block;
					SMUDGECACHE( vol, name_cache );
				}
			}
			else {
				// already have a known end of name, and the offset
				// move the data in this block forward.
				unsigned int namelength = ( endNameOffset - findNameOffset );
				unsigned int length = NAME_BLOCK_SIZE - ( namelength );
				in = nameblock;
				out = nameblock_ + length;
				for( n = 0; n < namelength; n++ ) {
					( *out++ ) = ( *in++ );
				}
				// switch blocks.
				out = nameblock;
				for( n = 0; n < length; n++ ) {
					( *out++ ) = ( *in++ );
				}
  // re-wrote block;
				SMUDGECACHE( vol, name_cache );
				// unlock the previous block (if there was one);
				if( name_cache_ )
					SETMASK_( vol->seglock, seglock, name_cache_, GETMASK_( vol->seglock, seglock, name_cache_ ) - 1 );
			}
			nameoffset_temp += NAME_BLOCK_SIZE;
		}
		else {
			findNameOffset -= NAME_BLOCK_SIZE;
		}
		enum block_cache_entries gnbCache = BC( NAMES );
		name_block = vfs_os_GetNextBlock( vol, name_block, &gnbCache, GFB_INIT_NONE, FALSE, NAME_BLOCK_SIZE, NULL );
	} while( name_block != EOFBLOCK );
	// unlock the last block
	SETMASK_( vol->seglock, seglock, name_cache, GETMASK_( vol->seglock, seglock, name_cache ) - 1 );
	{
		uint8_t* out;
		out = nameblock + ( n = NAME_BLOCK_SIZE - ( endNameOffset - findNameOffset ) );
		// fill tail of block with 0.
		for( ; n < NAME_BLOCK_SIZE; n++ ) {
			( *out++ ) = 0;
		}
	}
	// move the directory entries down.
	//file->entry->name_offset = 0;
	for( f = 0; f < dirblock->used_names; f++ ) {
		if( USS_GT( ( dirblock->entries[f].name_offset & DIRENT_NAME_OFFSET_OFFSET ), FPI, nameOffset, int ) )
			dirblock->entries[f].name_offset -= endNameOffset - findNameOffset;
		if( ( dirblock->entries + f ) == file->entry ) {
			e = f;
		}
		else if( e >= 0 ) {
			if( dirblock->entries[f].timelineEntry ) {
				struct memoryTimelineNode time;
				//enum block_cache_entries  timeCache = BC( TIMELINE );
				reloadTimeEntry( &time, vol, ( dirblock->entries[f].timelineEntry ) VTReadWrite GRTENoLog DBG_SRC );
				time.disk->dirent_fpi = vol->bufferFPI[nameCache] + sane_offsetof( struct directory_hash_lookup_block, entries[f - 1] );
				{
					uint64_t index = time.disk->priorTime;
					while( index ) {
						struct memoryTimelineNode time2;
						reloadTimeEntry( &time2, vol, index GRTENoLog VTReadWrite DBG_SRC );
						time2.disk->dirent_fpi = time.disk->dirent_fpi;
						index = time2.disk->priorTime;
						updateTimeEntry( &time2, vol, TRUE DBG_SRC );
					}
				}
#ifdef DEBUG_TIMELINE_DIR_TRACKING
				lprintf( "Set timeline %d to %d", (int)time.index, (int)time.disk->dirent_fpi );
#endif
				updateTimeEntry( &time, vol, TRUE DBG_SRC );
			}
			dirblock->entries[f - 1] = dirblock->entries[f];
		}
	}
	dirblock->used_names--;
	SMUDGECACHE( vol, name_cache );
}
static void ConvertDirectory( struct sack_vfs_os_volume *vol, const char *leadin, int leadinLength, BLOCKINDEX this_dir_block, struct directory_hash_lookup_block *orig_dirblock, enum block_cache_entries *newCache ) {
	size_t n;
#ifdef DEBUG_CONVERT_DIRECTORY
	LoG( "------------ BEGIN CONVERT DIRECTORY ---------------------- %d", this_dir_block );
#endif
 // symbol not defined
#ifdef DEBUG_CONVERT_DIRECTORY
	{
		BLOCKINDEX a;
		if( !_os_ScanDirectory( vol, NULL, FIRST_DIR_BLOCK, NULL, NULL, 0 ) ) {
			 lprintf( "Directory scan in close failed" );
			DebugBreak();
			//return ;
		}
		if( l.fileCount_old > l.fileCount ) {
			BLOCKINDEX x;
			lprintf( "operation befoe the convert lost files. %d %d", l.fileCount_old, l.fileCount );
			//if( !_os_ScanDirectory( vol, NULL, FIRST_DIR_BLOCK, &x, NULL, 0 ) ) {
			 //lprintf( "Directory scan in close failed" );
			DebugBreak();
			//return ;
		}
	}
	lprintf( "total files:%d", l.fileCount );
	l.fileCount_old = l.fileCount;
#endif
	do {
		enum block_cache_entries cache = BC(DIRECTORY);
		FPI nameoffset_temp = 0;
		BLOCKINDEX new_dir_block;
		struct directory_hash_lookup_block *dirblock;
		dirblock = BTSEEK( struct directory_hash_lookup_block *, vol, this_dir_block, DIR_BLOCK_SIZE, cache );
		{
			static int counters[256];
			static uint8_t namebuffer[18*4096];
			uint8_t *nameblock;
			int maxc = 0;
			int imax = 0;
			int f;
			enum block_cache_entries name_cache;
			BLOCKINDEX name_block = dirblock->names_first_block;
			// read name block chain into a single array
			do {
				uint8_t *out = namebuffer + nameoffset_temp;
				name_cache = BC( NAMES );
				nameblock = BTSEEK( uint8_t *, vol, name_block, NAME_BLOCK_SIZE, name_cache );
				for( n = 0; n < 4096; n++ )
					(*out++) = (*nameblock++);
				enum block_cache_entries gnbCache = BC( NAMES );
				name_block = vfs_os_GetNextBlock( vol, name_block, &gnbCache, GFB_INIT_NONE, 0, NAME_BLOCK_SIZE, NULL );
				nameoffset_temp += NAME_BLOCK_SIZE;
			} while( name_block != EOFBLOCK );
			memset( counters, 0, sizeof( counters ) );
			// 257/85
			for( f = 0; f < VFS_DIRECTORY_ENTRIES; f++ ) {
				BLOCKINDEX first = dirblock->entries[f].first_block;
				FPI name;
				int count;
				if( first == EODMARK ) break;
				name = dirblock->entries[f].name_offset & DIRENT_NAME_OFFSET_OFFSET;
				count = (++counters[namebuffer[name]]);
				if( count > maxc ) {
					imax = namebuffer[name];
					maxc = count;
				}
			}
			// after finding most used first byte; get a new block, and point
			// hash entry to that.
			enum block_cache_entries newBlockCache = BC( DIRECTORY );
			dirblock->next_block[imax]
				= ( new_dir_block
				  = _os_GetFreeBlock( vol, &newBlockCache, GFB_INIT_DIRENT, 4096 ) );
			//if( new_dir_block == 48 || new_dir_block == 36 )
			//	DebugBreak();
			SMUDGECACHE( vol, cache );
			{
				struct directory_hash_lookup_block *newDirblock;
				enum block_cache_entries newdir_cache;
				BLOCKINDEX newFirstNameBlock;
				int usedNames = dirblock->used_names;
				//int _usedNames = usedNames;
				int nf = 0;
				//int firstNameOffset = -1;
				//int finalNameOffset = 0;;
				int movedEntry = 0;
				int offset;
				newdir_cache = BC(DIRECTORY);
				newDirblock = BTSEEK( struct directory_hash_lookup_block *, vol, new_dir_block, DIR_BLOCK_SIZE, newdir_cache );
#ifdef DEBUG_CONVERT_DIRECTORY
				LoG( "new dir block cache is  %d   %d   %d  %d", newdir_cache, (int)new_dir_block, (int)this_dir_block, imax );
#endif
				newFirstNameBlock = newDirblock->names_first_block;
#ifdef _DEBUG
				if( !newDirblock->names_first_block )
					DebugBreak();
#endif
				newDirblock->next_block[DIRNAME_CHAR_PARENT] = (this_dir_block << 8) | imax;
				//SMUDGECACHE( vol, newdir_cache ); // this will be dirty because it was init above.
				for( f = 0; f < usedNames; f++ ) {
					//BLOCKINDEX first = dirblock->entries[f].first_block;
					struct directory_entry *entry;
					struct directory_entry *newEntry;
					FPI name;
					FPI name_ofs;
					entry = dirblock->entries + (f);
					name = ( entry->name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
					if( namebuffer[name] == imax ) {
						int namelen;
						if( !movedEntry ) movedEntry = f+1;
						newEntry = newDirblock->entries + (nf);
						//LoG( "Saving existing name %d %s", name, namebuffer + name );
						//LogBinary( namebuffer, 32 );
						namelen = 0;
						while( namebuffer[name + namelen] != UTF8_EOT )namelen++;
						name_ofs = _os_SaveFileName( vol, newFirstNameBlock, (char*)(namebuffer + name + 1), namelen -1 );
						{
							INDEX idx;
							struct sack_vfs_os_file  * file;
							LIST_FORALL( vol->files, idx, struct sack_vfs_file  *, file ) {
								if( file->entry == entry ) {
 // new entry_fpi.
									file->entry_fpi = 0;
								}
							}
						}
						dirblock->used_names = ((dirblock->used_names) - 1);
						if( dirblock->used_names > ( sizeof( dirblock->entries ) / sizeof( dirblock->entries[0] ) ) ) {
							lprintf( "Directory block name count is corrupt." );
							DebugBreak();
						}
						newEntry->filesize = entry->filesize;
						{
							struct memoryTimelineNode time;
							FPI oldFPI;
							//enum block_cache_entries  timeCache = BC( TIMELINE );
							reloadTimeEntry( &time, vol, (entry->timelineEntry     ) VTReadWrite GRTENoLog DBG_SRC );
 // dirent_fpi type is larger than index in some configurations; but won't exceed those bounds
							oldFPI = (FPI)time.disk->dirent_fpi;
							// new entry is still the same timeline entry as the old entry.
							newEntry->timelineEntry = (entry->timelineEntry     )     ;
							// timeline points at new entry.
							time.disk->dirent_fpi = vol->bufferFPI[newdir_cache] + sane_offsetof(struct directory_hash_lookup_block, entries[nf]);
							{
								uint64_t index = time.disk->priorTime;
								while( index ) {
									struct memoryTimelineNode time2;
									reloadTimeEntry( &time2, vol, index VTReadWrite GRTENoLog DBG_SRC );
									time2.disk->dirent_fpi = time.disk->dirent_fpi;
									updateTimeEntry( &time2, vol, TRUE DBG_SRC );
									index = time2.disk->priorTime;
								}
							}
#ifdef DEBUG_TIMELINE_DIR_TRACKING
							lprintf( "Set timeline %d to %d", (int)time.index, (int)time.disk->dirent_fpi );
#endif
							updateTimeEntry( &time, vol, TRUE DBG_SRC );
#ifdef DEBUG_TIMELINE_DIR_TRACKING
							lprintf( "direntry at %d  %d is time %d", (int)new_dir_block, (int)nf, (int)newEntry->timelineEntry );
#endif
							{
								INDEX idx;
								struct sack_vfs_file  * file;
								LIST_FORALL( vol->files, idx, struct sack_vfs_file  *, file ) {
									if( file->entry_fpi == oldFPI ) {
										// unlock old directory
										int locks = GETMASK_( vol->seglock, seglock, file->cache ) - 1;
										if( locks < 0 ) {
											lprintf( "File lock in convert underflow... " );
											DebugBreak();
										}
										SETMASK_( vol->seglock, seglock, cache, locks );
										// new entry_fpi.
 // dirent_fpi type is larger than index in some configurations; but won't exceed those bounds
										file->entry_fpi = (FPI)time.disk->dirent_fpi;
										//file->dir_block = time.disk->dir
										lprintf( "File cache might have been wrong... (AND USED OLD ENTRY)" );
										file->entry = newEntry;
										file->cache = newdir_cache;
										// lock new cache entry
										locks = GETMASK_( vol->seglock, seglock, file->cache ) + 1;
										if( locks < 0 ) {
											lprintf( "File lock in convert underflow... " );
											DebugBreak();
										}
										SETMASK_( vol->seglock, seglock, cache, locks );
									}
								}
							}
						}
						newEntry->name_offset = name_ofs;
						newEntry->first_block = (entry->first_block ) ;
						//lprintf( "Convert File new block %d", entry->first_block );
						SMUDGECACHE( vol, cache );
						nf++;
						newDirblock->used_names = ((newDirblock->used_names) + 1);
						if( newDirblock->used_names > ( sizeof( newDirblock->entries ) / sizeof( newDirblock->entries[0] ) ) ) {
							lprintf( "Directory block name count is corrupt." );
							DebugBreak();
						}
						//usedNames--;
					}
					else {
						if( movedEntry ) {
							break;
						}
					}
				}
				LoG( "blocks: %d %d %d old names new names %d %d = %d"
						, this_dir_block, new_dir_block
						, imax
						, dirblock->used_names, newDirblock->used_names, dirblock->used_names+ newDirblock->used_names );
				// move all others down 1.
				movedEntry = movedEntry - 1;
				offset = (f - movedEntry);
				usedNames -= (f-movedEntry);
				//for( ; f < usedNames; f++ )
				{
					int m;
					for( m = movedEntry; m < usedNames; m++ ) {
						dirblock->entries[m].first_block = dirblock->entries[m + offset].first_block;
						dirblock->entries[m].name_offset = dirblock->entries[m + offset].name_offset;
						dirblock->entries[m].filesize = dirblock->entries[m + offset].filesize;
						dirblock->entries[m].timelineEntry = dirblock->entries[m + offset].timelineEntry;
#ifdef DEBUG_TIMELINE_DIR_TRACKING
						lprintf( "direntry at %d  %d is time %d", (int)this_dir_block, (int)m, (int)dirblock->entries[m].timelineEntry );
#endif
						{
							struct memoryTimelineNode time;
							//enum block_cache_entries  timeCache = BC( TIMELINE );
							reloadTimeEntry( &time, vol, (dirblock->entries[m + offset].timelineEntry) VTReadWrite GRTENoLog DBG_SRC );
 /*vol->bufferFPI[cache]*/
							time.disk->dirent_fpi = this_dir_block * BLOCK_SIZE + sane_offsetof( struct directory_hash_lookup_block, entries[m] );
							{
								uint64_t index = time.disk->priorTime;
								while( index ) {
									struct memoryTimelineNode time2;
									reloadTimeEntry( &time2, vol, index VTReadWrite GRTENoLog DBG_SRC );
									time2.disk->dirent_fpi = time.disk->dirent_fpi;
									updateTimeEntry( &time2, vol, TRUE DBG_SRC );
									index = time2.disk->priorTime;
								}
							}
#ifdef DEBUG_TIMELINE_DIR_TRACKING
							lprintf( "Set timeline %d to %d", (int)time.index, (int)time.disk->dirent_fpi );
#endif
							updateTimeEntry( &time, vol, TRUE DBG_SRC );
						}
#ifdef _DEBUG
						if( !dirblock->names_first_block ) DebugBreak();
#endif
					}
					for( m = usedNames; m < VFS_DIRECTORY_ENTRIES; m++ ) {
						dirblock->entries[m].first_block = (0);
						dirblock->entries[m].name_offset = (0);
						dirblock->entries[m].filesize = (0);
						dirblock->entries[m].timelineEntry = (0);
#ifdef _DEBUG
						if( !dirblock->names_first_block ) DebugBreak();
#endif
					}
				}
				if( usedNames ) {
					static uint8_t newnamebuffer[18 * 4096];
					int newout = 0;
					//int min_name = NAME_BLOCK_SIZE + 1;
					//int _min_name = -1; // min found has to be after this one.
					//lprintf( "%d names remained.", usedNames );
					for( f = 0; f < usedNames; f++ ) {
						struct directory_entry *entry;
						FPI name;
						entry = dirblock->entries + (f);
						name = ( entry->name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
						entry->name_offset = ( newout )
							| ( (entry->name_offset)
								& ~DIRENT_NAME_OFFSET_OFFSET );
						while( namebuffer[name] != UTF8_EOT )
							newnamebuffer[newout++] = namebuffer[name++];
						newnamebuffer[newout++] = namebuffer[name++];
					}
					newnamebuffer[newout++] = UTF8_EOTB;
					memcpy( namebuffer, newnamebuffer, newout );
 // tidy up the end of the old buffer.
					memset( namebuffer + newout, 0, NAME_BLOCK_SIZE - newout );
					memset( newnamebuffer, 0, newout );
				}
				else {
					namebuffer[0] = UTF8_EOTB;
				}
				{
					name_block = dirblock->names_first_block;
					nameoffset_temp = 0;
					do {
						uint8_t *out;
						nameblock = namebuffer + nameoffset_temp;
						name_cache = BC( NAMES );
						out = BTSEEK( uint8_t *, vol, name_block, NAME_BLOCK_SIZE, name_cache );
						for( n = 0; n < 4096; n++ )
							(*out++) = (*nameblock++);
						SMUDGECACHE( vol, name_cache );
						enum block_cache_entries gnbCache = BC(NAMES);
						name_block = vfs_os_GetNextBlock( vol, name_block, &gnbCache, GFB_INIT_NONE, 0, NAME_BLOCK_SIZE, NULL );
						nameoffset_temp += 4096;
					} while( name_block != EOFBLOCK );
				}
			}
 // symbol not defined
#ifdef DEBUG_CONVERT_DIRECTORY
			if( !_os_ScanDirectory( vol, NULL, FIRST_DIR_BLOCK, NULL, NULL, 0 ) ) {
				 lprintf( "Directory scan in close failed" );
				DebugBreak();
				//return ;
			}
			if( l.fileCount_old > l.fileCount ) {
				BLOCKINDEX x;
				lprintf( "This convert operation lost files. %d %d", l.fileCount_old, l.fileCount );
				if( !_os_ScanDirectory( vol, NULL, FIRST_DIR_BLOCK, &x, NULL, 0 ) ) {
					 lprintf( "Directory scan in close failed" );
					DebugBreak();
					//return ;
				}
				DebugBreak();
			}
			lprintf( "total files:%d", l.fileCount );
			l.fileCount_old = l.fileCount;
#endif
  // a set of names has been moved out of this block.
			break;
			// has block.
		}
	} while( 0 );
	// unlink here
	// unlink dirblock->names_first_block
}
static struct directory_entry * _os_GetNewDirectory( struct sack_vfs_os_volume *vol,
#if defined( _MSC_VER )
	_In_
#endif
	const char * filename
		, struct sack_vfs_os_file *file ) {
	size_t n;
	//const char *_filename = filename;
	static char leadin[256];
	static int leadinDepth = 0;
	BLOCKINDEX this_dir_block = FIRST_DIR_BLOCK;
	//struct directory_entry *next_entries;
	//LOGICAL moveMark = FALSE;
	if( filename && filename[0] == '.' && ( filename[1] == '/' || filename[1] == '\\' ) ) filename += 2;
	leadinDepth = 0;
	do {
		enum block_cache_entries cache;
		FPI dirblockFPI;
		int usedNames;
		struct directory_hash_lookup_block *dirblock;
		BLOCKINDEX firstNameBlock;
		cache = BC( DIRECTORY );
		dirblock = BTSEEK( struct directory_hash_lookup_block *, vol, this_dir_block, DIR_BLOCK_SIZE, cache );
#ifdef _DEBUG
		if( !dirblock->names_first_block ) {
			if( dirblock->used_names )
				DebugBreak();
			{
				enum block_cache_entries newcache = BC( NAMES );
				dirblock->names_first_block = _os_GetFreeBlock( vol, &newcache, GFB_INIT_NAMES, NAME_BLOCK_SIZE );
			}
			dirblock->used_names = 0;
		}
#endif
		dirblockFPI = vol->bufferFPI[cache];
		firstNameBlock = dirblock->names_first_block;
		{
			BLOCKINDEX nextblock = dirblock->next_block[(unsigned)filename[0]];
			if( nextblock ) {
				leadin[leadinDepth++] = filename[0];
				filename++;
				this_dir_block = nextblock;
				// retry;
				continue;
			}
		}
		usedNames = dirblock->used_names;
		//lprintf( " --------------- THIS DIR BLOCK ---------------" );
		if( usedNames == VFS_DIRECTORY_ENTRIES ) {
			ConvertDirectory( vol, leadin, leadinDepth, this_dir_block, dirblock, &cache );
			/* retry */
#ifdef DEBUG_DIRECTORIES
			lprintf( "----- CONVERTED-------" );
			_os_dumpDirectories( vol, this_dir_block, 1 );
			lprintf( "----- CONVERTED (ALL)-------" );
			_os_dumpDirectories( vol, 0, 1 );
#endif
			continue;
		}
		{
			struct directory_entry *ent;
			FPI name_ofs;
			//BLOCKINDEX first_blk;
			//next_entries = dirblock->entries;
			ent = dirblock->entries;
			for( n = 0; USS_LT( n, size_t, usedNames, int ); n++ ) {
				ent = dirblock->entries + (n);
				name_ofs = ( ent->name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
				//first_blk = ent->first_block;
				// not name_offset (end of list) or not first_block(free entry) use this entry
				//if( name_ofs && (first_blk > 1) )  continue;
				if( _os_MaskStrCmp( vol, filename, firstNameBlock, name_ofs, 0 ) < 0 ) {
					int m;
#ifdef DEBUG_FILE_OPEN
					LoG( "Insert new directory" );
#endif
					for( m = dirblock->used_names; SUS_GT( m, int, n, size_t ); m-- ) {
						struct memoryTimelineNode node;
						dirblock->entries[m].filesize      = dirblock->entries[m - 1].filesize      ;
						dirblock->entries[m].first_block   = dirblock->entries[m - 1].first_block   ;
						dirblock->entries[m].name_offset   = dirblock->entries[m - 1].name_offset   ;
						reloadTimeEntry( &node, vol, dirblock->entries[m - 1].timelineEntry VTReadWrite GRTENoLog DBG_SRC );
						dirblock->entries[m].timelineEntry = dirblock->entries[m - 1].timelineEntry;
#ifdef DEBUG_TIMELINE_DIR_TRACKING
						LoG( "direntry at %d  %d is time %d", (int)this_dir_block, (int)m, (int)dirblock->entries[m].timelineEntry );
#endif
						node.disk->dirent_fpi = dirblockFPI + sane_offsetof( struct directory_hash_lookup_block, entries[m] );
						{
							uint64_t index = node.disk->priorTime;
							while( index ) {
								struct memoryTimelineNode time2;
								reloadTimeEntry( &time2, vol, index VTReadWrite GRTENoLog DBG_SRC );
								time2.disk->dirent_fpi = node.disk->dirent_fpi;
#ifdef DEBUG_TIMELINE_DIR_TRACKING
								LoG( "(Move)Set timeline %d to %d", (int)time2.index, (int)time2.disk->dirent_fpi );
#endif
								updateTimeEntry( &time2, vol, TRUE DBG_SRC );
								index = time2.disk->priorTime;
							}
						}
#ifdef DEBUG_TIMELINE_DIR_TRACKING
						lprintf( "Set timeline %d to %d", (int)node.index, (int)node.disk->dirent_fpi );
#endif
						updateTimeEntry( &node, vol, TRUE DBG_SRC );
					}
					dirblock->used_names++;
					break;
				}
			}
			ent = dirblock->entries + (n);
			if( n == usedNames ) {
				dirblock->used_names = (uint8_t)((n + 1));
			}
			if( dirblock->used_names > ( sizeof( dirblock->entries ) / sizeof( dirblock->entries[0] ) ) ) {
				lprintf( "Directory block name count is corrupt." );
				DebugBreak();
			}
			//LoG( "Get New Directory save naem:%s", filename );
			name_ofs = _os_SaveFileName( vol, firstNameBlock, filename, StrLen( filename ) );
			ent->filesize = 0;
			ent->name_offset = name_ofs;
			// have to allocate a block for the file, otherwise it would be deleted.
// first_blk;
			ent->first_block = DIR_ALLOCATING_MARK;
			{
				struct memoryTimelineNode time_;
				struct memoryTimelineNode *time = &time_;
				time_.index = 0;
				ent->timelineEntry = getTimeEntry( time, vol, 0, NULL, 0 DBG_SRC );
				// reset dirent_fpi afterward.
				time->disk->dirent_fpi = dirblockFPI + sane_offsetof( struct directory_hash_lookup_block, entries[n] );;
				// associate a time entry with this directory entry, and vice-versa.
#ifdef DEBUG_TIMELINE_DIR_TRACKING
				lprintf( "Set timeline %d to %d", (int)time->index, (int)time->disk->dirent_fpi );
#endif
#ifdef DEBUG_TIMELINE_DIR_TRACKING
				lprintf( "direntry at %d  %d is time %d", (int)this_dir_block, (int)n, (int)dirblock->entries[n].timelineEntry );
#endif
				// update drop the new entry.
				updateTimeEntry( time, vol, TRUE DBG_SRC );
			}
			if( file ) {
				int locks;
				locks = GETMASK_( vol->seglock, seglock, cache ) + 1;
				if( locks > 12 ) {
					lprintf( "Too many locks open... " );
					DebugBreak();
				}
				SETMASK_( vol->seglock, seglock, cache, locks );
				file->entry_fpi = dirblockFPI + sane_offsetof( struct directory_hash_lookup_block, entries[n] );;
				file->dir_block = this_dir_block;
				file->entry_.name_offset = ( file->entry->name_offset & DIRENT_NAME_OFFSET_OFFSET ) + vfs_os_compute_data_block( vol, dirblock->names_first_block, BC( COUNT ) );
				// the modern version only uses entry and cache; entry_fpi, dir_block above are unused; this dirent is locked into the caching subsystem.
				file->entry = ent;
				file->cache = cache;
			}
			SMUDGECACHE( vol, cache );
			return ent;
		}
	}
	while( 1 );
}
static struct sack_vfs_os_file * CPROC sack_vfs_os_openfile_internal( struct sack_vfs_os_volume *vol, const char * filename, uint64_t version, LOGICAL create ) {
//New( struct sack_vfs_os_file );
	struct sack_vfs_os_file *file = GetFromSet( VFS_OS_FILE, &l.files );
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	MemSet( file, 0, sizeof( struct sack_vfs_os_file ) );
#ifdef XX_VIRTUAL_OBJECT_STORE
	BLOCKINDEX offset;
#endif
	file->vol = vol;
 // default to internal buffer; might never have a real directory
	file->entry = &file->entry_;
	//file->sealant = NULL;
	if( filename[0] == '.' && ( filename[1] == '\\' || filename[1] == '/' ) ) filename += 2;
#ifdef DEBUG_FILE_OPEN
	LoG( "sack_vfs open %s = %p on %s", filename, file, vol->volname );
#endif
	if( filename )
		if( !_os_ScanDirectory( vol, filename, FIRST_DIR_BLOCK, NULL, file, 0 ) ) {
			if( vol->read_only ) { LoG( "Fail open: readonly" ); vol->lock = 0;
 //Deallocate( struct sack_vfs_os_file*, file );
				DeleteFromSet( VFS_OS_FILE, &l.files, file );
				return NULL;
			}
			else _os_GetNewDirectory( vol, filename, file );
		}
	if( ( file->entry->first_block != DIR_ALLOCATING_MARK ) && create ) {
		// if there is already data
		file->flags.versioned = 1;
	} else
		file->flags.versioned = 0;
 // saved for versioning really
	file->filesize_ = file->entry->filesize;
	// update to the file's first block (allocating, data, whatever)
	file->_first_block = file->block = file->entry->first_block;
  // sort of a opened for write
	if( create ) {
		// this updates the timestamp of the file, and allocates a new one
		//PDATALIST pdlTimes = CreateDataList( sizeof( uint64_t ) );
		struct sack_vfs_os_volume* vol = file->vol;
		struct memoryTimelineNode time;
		//enum block_cache_entries  timeCache = BC( TIMELINE );
		//BLOCKINDEX priorData = file->entry->first_block;
		reloadTimeEntry( &time, vol, file->entry->timelineEntry VTReadWrite GRTENoLog  DBG_SRC );
#ifdef _DEBUG
		if( !time.disk->time ) DebugBreak();
#endif
		// open oldest by default, with no prior time set...
		if( time.disk->priorTime ) {
			BLOCKINDEX priorTime = time.disk->priorTime;
			while( priorTime ) {
				enum block_cache_entries cache;
				struct storageTimelineNode* prior = getRawTimeEntry( vol, priorTime, &cache GRTENoLog DBG_SRC );
				//prior->
				priorTime = prior->priorTime;
				//priorData = prior->priorData;
				file->filesize_ = prior->priorDataSize;
				if( prior->time <= version ) break;
				dropRawTimeEntry( file->vol, cache GRTENoLog DBG_SRC );
			}
		}
		dropRawTimeEntry( vol, time.diskCache GRTENoLog DBG_SRC );
	}
	//file->filename = StrDup( filename );
	//file->fileName = !!filename;
#ifdef XX_VIRTUAL_OBJECT_STORE
 // file->entry->name_offset;
	offset = file->entry_.name_offset;
	if( ( file->entry->name_offset ) & DIRENT_NAME_OFFSET_FLAG_SEALANT ) {
		sack_vfs_os_read_internal( file, 0, &file->diskHeader, sizeof( file->diskHeader ) );
		file->header = file->diskHeader;
		file->fpi = file->header.sealant.avail + file->header.references.avail;
		{
			uint32_t sealLen = (offset & DIRENT_NAME_OFFSET_FLAG_SEALANT) >> DIRENT_NAME_OFFSET_FLAG_SEALANT_SHIFT;
			if( sealLen ) {
				file->seal = NewArray( uint8_t, sealLen );
				//file->sealantLen = sealLen;
				file->sealed = SACK_VFS_OS_SEAL_LOAD;
			}
			else {
				file->seal = NULL;
				//file->sealantLen = 0;
				file->sealed = SACK_VFS_OS_SEAL_NONE;
			}
		}
	}
#endif
	AddLink( &vol->files, file );
	vol->lock = 0;
	return file;
}
struct sack_vfs_os_file * CPROC sack_vfs_os_openfile( struct sack_vfs_os_volume *vol, const char * filename ) {
	return sack_vfs_os_openfile_internal( vol, filename, 0, FALSE );
}
static struct sack_vfs_os_file * CPROC sack_vfs_os_open( uintptr_t psvInstance, const char * filename, const char *opts ) {
	return sack_vfs_os_openfile( (struct sack_vfs_os_volume*)psvInstance, filename );
}
#ifdef XX_VIRTUAL_OBJECT_STORE
static char * getFilename( const char *objBuf, size_t objBufLen
	, char *sealBuf, size_t sealBufLen, LOGICAL owner
	, char **idBuf, size_t *idBufLen ) {
	if( sealBuf ) {
		struct random_context *signEntropy = (struct random_context *)DequeLink( &l.plqCrypters );
		char *fileKey;
		size_t keyLen;
		uint8_t outbuf[32];
		if( !signEntropy )
			signEntropy = SRG_CreateEntropy4( NULL, (uintptr_t)0 );
		if( owner ) {
			char *metakey = SRG_ID_Generator3();
			SRG_ResetEntropy( signEntropy );
			SRG_FeedEntropy( signEntropy, (const uint8_t*)metakey, 44 );
			SRG_FeedEntropy( signEntropy, (const uint8_t*)sealBuf, sealBufLen );
			SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outbuf, 256 );
		}
		else {
			SRG_ResetEntropy( signEntropy );
			SRG_FeedEntropy( signEntropy, (const uint8_t*)sealBuf, sealBufLen );
			SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outbuf, 256 );
		}
		SRG_ResetEntropy( signEntropy );
		SRG_FeedEntropy( signEntropy, (const uint8_t*)objBuf, objBufLen );
		SRG_FeedEntropy( signEntropy, (const uint8_t*)outbuf, 32 );
		fileKey = EncodeBase64Ex( outbuf, 32, &keyLen, (const char*)1 );
		SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outbuf, 256 );
		SRG_DestroyEntropy( &signEntropy );
		idBuf[0] = EncodeBase64Ex( outbuf, 256 / 8, idBufLen, (const char *)1 );
		EnqueLink( &l.plqCrypters, signEntropy );
		return fileKey;
	}
	else {
		idBuf[0] = SRG_ID_Generator3();
		idBufLen[0] = 42;
		return idBuf[0];
	}
}
#endif
int CPROC sack_vfs_os_exists( struct sack_vfs_os_volume *vol, const char * file ) {
	LOGICAL result;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( file[0] == '.' && file[1] == '/' ) file += 2;
	result = _os_ScanDirectory( vol, file, FIRST_DIR_BLOCK, NULL, NULL, 0 );
	vol->lock = 0;
	return result;
}
size_t CPROC sack_vfs_os_tell( struct sack_vfs_os_file *file ) { return (size_t)file->fpi; }
size_t CPROC sack_vfs_os_size( struct sack_vfs_os_file *file ) {	return (size_t)(file->filesize_); }
size_t CPROC sack_vfs_os_seek_internal( struct sack_vfs_os_file *file, size_t pos, int whence )
{
	FPI old_fpi = file->fpi;
	if( whence == SEEK_SET ) file->fpi = pos;
	if( whence == SEEK_CUR ) file->fpi += pos;
	if( whence == SEEK_END ) file->fpi = ( file->filesize_  ) + pos;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	{
		if( file->fpi >= old_fpi ) {
			FPI dist = file->fpi - old_fpi;
			if( dist > 4096 ) {
				do {
					int blockSize;
					if( file->fpi <= old_fpi ) {
						file->vol->lock = 0;
 // block in file can accept data now...
						return (size_t)file->fpi;
					}
					enum block_cache_entries gnbCache = BC( FILE );
					file->block = vfs_os_GetNextBlock( file->vol, file->block, &gnbCache, GFB_INIT_NONE
						, TRUE
						, dist>4096?4096:dist<2048? BLOCK_SMALL_SIZE :4096
						, &blockSize );
					old_fpi += blockSize;
				} while( 1 );
			}
		}
	}
	{
		size_t n = 0;
///aa
		BLOCKINDEX b = file->_first_block;
		while( n < ( pos ) ) {
			enum block_cache_entries cache;
			int bs;
			size_t dist = pos-n;
			cache = BC( FILE );
			if( b == DIR_ALLOCATING_MARK )
				file->entry->first_block
					= file->_first_block
					= b
					= _os_GetFreeBlock( file->vol, &cache, GFB_INIT_NONE, bs=(dist > 4096 ? 4096 : dist < 2048 ? BLOCK_SMALL_SIZE : 4096) );
			else
				b = vfs_os_GetNextBlock( file->vol, b, &cache, GFB_INIT_NONE, TRUE, dist>4096?4096:dist<2048? BLOCK_SMALL_SIZE :4096, &bs );
			n += bs;
		}
		file->block = b;
	}
	file->vol->lock = 0;
	return (size_t)file->fpi;
}
size_t CPROC sack_vfs_os_seek( struct sack_vfs_os_file* file, size_t pos, int whence ) {
	return sack_vfs_os_seek_internal( (struct sack_vfs_os_file*) file, pos, whence );
}
size_t CPROC sack_vfs_os_write_internal( struct sack_vfs_os_file* file, const void* data_, size_t length
		, POINTER writeState ) {
	const char* data = (const char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	LOGICAL updated = FALSE;
#ifdef DEBUG_DISK_DATA
	lprintf( "Write to %p %d at %d", data_, length, file->fpi );
	LogBinary( data, file->blockSize );
#endif
#ifdef XX_VIRTUAL_OBJECT_STORE
	uint8_t* cdata;
	size_t cdataLen;
	if( file->readKey && !file->fpi ) {
		enum block_cache_entries cache;
		struct storageTimelineNode* time = getRawTimeEntry( file->vol, file->entry->timelineEntry, &cache GRTENoLog DBG_SRC );
		SRG_XSWS_encryptData( (uint8_t*)data, length, time->time
			, (const uint8_t*)file->readKey, file->readKeyLen
			, &cdata, &cdataLen );
		dropRawTimeEntry( file->vol, cache GRTENoLog DBG_SRC );
		data = (const char*)cdata;
		length = cdataLen;
	}
	else {
		cdata = NULL;
	}
#endif
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	if( file->entry->first_block != DIR_ALLOCATING_MARK )
		if( file->flags.versioned )
		{
			// if versioned, but no limit, just do this.
			if( file->entry->name_offset & DIRENT_NAME_OFFSET_VERSIONS ) {
				// if there's a limit to the number of versions
			}
			{
				int last = file->blockChainLength - 1;
				enum block_cache_entries cache;
				struct storageTimelineNode* timeline = getRawTimeEntry( file->vol, file->entry->timelineEntry, &cache GRTENoLog DBG_SRC );
				timeline->priorDataPad = (uint16_t)( file->blockChain[last].size - ( file->entry->filesize & ( file->blockChain[last].size - 1 ) ) );
				//timeline->priorData = file->entry->first_block;
				timeline->priorData = file->entry->first_block;
				timeline->priorDataSize = file->entry->filesize;
				file->entry->first_block = DIR_ALLOCATING_MARK;
				file->entry->filesize = 0;
				file->filesize_ = 0;
				file->blockChainLength = 0;
				dropRawTimeEntry( file->vol, cache GRTENoLog DBG_SRC );
			}
			//lprintf( "this needs to result with the new timestamp" );
			//file->entry->timelineEntry = file->entry->timelineEntry;
			updated = TRUE;
		} else {
			// no versioning - so just keep 1 block so we get last write and first create
			if( !( file->entry->name_offset & DIRENT_NAME_OFFSET_VERSIONS ) ) {
				// don't have a new time block for write time; so create one
				file->entry->timelineEntry = updateTimeEntryTime( NULL, file->vol, file->entry->timelineEntry, TRUE, NULL, 0 DBG_SRC );
				file->entry->name_offset |= 1 << DIRENT_NAME_OFFSET_VERSION_SHIFT;
			}
			else {
				// update the current time.
				file->entry->timelineEntry = updateTimeEntryTime( NULL, file->vol, file->entry->timelineEntry, FALSE, NULL, 0 DBG_SRC );
			}
			//file->entry->timelineEntry = file->timeline.index;
			updated = TRUE;
		}
#ifdef XX_VIRTUAL_OBJECT_STORE
	if( (file->entry->name_offset) & DIRENT_NAME_OFFSET_FLAG_SEALANT ) {
		char* filename;
		size_t filenameLen = 64;
		// read-only data block.
		lprintf( "INCOMPLETE - TODO WRITE PATCH" );
		char* sealer = getFilename( data, length, (char*)file->sealant, file->header.sealant.used, IS_OWNED( file ), &filename, &filenameLen );
		struct sack_vfs_os_file* pFile = (struct sack_vfs_os_file*)sack_vfs_os_openfile( file->vol, filename );
		pFile->sealant = (uint8_t*)sealer;
		if( cdata ) Release( cdata );
		return sack_vfs_os_write_internal( pFile, data, length, (POINTER)1 );
	}
#endif
#ifdef DEBUG_FILE_OPS
	LoG( "Write to file %p %" _size_f "  @%" _size_f, file, length, ofs );
#endif
	if( ofs ) {
		enum block_cache_entries cache = BC( FILE );
		uint8_t* block = (uint8_t*)vfs_os_BSEEK( file->vol, file->block, length > 4096 ? 4096 : length < 2048 ? BLOCK_SMALL_SIZE : 4096, &cache );
		int blockSize = file->vol->sector_size[cache];
		if( length >= (blockSize - (ofs)) ) {
			memcpy( block + ofs, data, blockSize-ofs );
			SMUDGECACHE( file->vol, cache );
			data += blockSize - ofs;
			written += blockSize - ofs;
			file->fpi += blockSize - ofs;
			if( file->fpi > (file->entry->filesize) ) {
				file->filesize_ = file->entry->filesize = file->fpi;
				updated = TRUE;
			}
			length -= blockSize - ofs;
			cache = BC( FILE );
			// the following code is never run anyway, it's always a get next block...
			if( file->block == DIR_ALLOCATING_MARK )
				file->entry->first_block
				= file->_first_block
				= file->block
				= _os_GetFreeBlock( file->vol, &cache, GFB_INIT_NONE, length > 4096 ? 4096 : length < 2048 ? BLOCK_SMALL_SIZE : 4096 );
			else
				file->block = vfs_os_GetNextBlock( file->vol, file->block, &cache, GFB_INIT_NONE, TRUE
					,
#ifdef XX_VIRTUAL_OBJECT_STORE
					file->blockSize
						? file->blockSize
						:
#endif
					(length>4096)?4096:length<2048? BLOCK_SMALL_SIZE :4096, (int*)&blockSize );
		}
		else {
			memcpy( block+ofs, data, length );
			SMUDGECACHE( file->vol, cache );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > (file->entry->filesize) ) {
				file->filesize_ = file->entry->filesize = file->fpi;
				updated = TRUE;
			}
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BC( FILE );
		uint8_t* block = (uint8_t*)vfs_os_BSEEK( file->vol, file->block,
			/*
#ifdef XX_VIRTUAL_OBJECT_STORE
			file->blockSize
			? file->blockSize
			:
#endif
			*/
			length > 4096 ? 4096 : length < 2048 ? BLOCK_SMALL_SIZE : 4096, &cache );
		unsigned int blockSize = file->vol->sector_size[cache];
		if( file->block == DIR_ALLOCATING_MARK ) {
  // directy now has a real block.
			updated = TRUE;
			// this are data blocks...
			file->block = file->entry->first_block = (
				( file->vol->segment[cache] - 2 ) / BLOCKS_PER_SECTOR ) * BLOCKS_PER_BAT
				+ ( ( file->vol->segment[cache] - 1 - ( 1+ ( file->vol->segment[cache] - 1 ) / BLOCKS_PER_SECTOR ) ) % BLOCKS_PER_BAT );
				//- 1 /* minus first BAT */;
			//lprintf( "computed new file block %d from %d", (int)file->block, (int)file->vol->segment[cache] );
		}
#ifdef _DEBUG
		if( file->block < 2 ) DebugBreak();
#endif
		if( length >= blockSize ) {
			memcpy( block, data, blockSize );
			SMUDGECACHE( file->vol, cache );
			data += blockSize;
			written += blockSize;
			file->fpi += blockSize;
			if( file->fpi > ( file->entry->filesize  ) ) {
				updated = TRUE;
				file->filesize_ = file->entry->filesize = file->fpi ;
			}
			length -= blockSize;
			cache = BC( FILE );
			file->block = vfs_os_GetNextBlock( file->vol, file->block, &cache, GFB_INIT_NONE, TRUE
				,
#ifdef XX_VIRTUAL_OBJECT_STORE
				file->blockSize
				? file->blockSize
				:
#endif
				(length>4096)?4096:length<2048?BLOCK_SMALL_SIZE:4096, (int*)&blockSize );
		}
		else {
			memcpy( block, data, length );
			SMUDGECACHE( file->vol, cache );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > (file->entry->filesize ) ) {
				updated = TRUE;
				file->filesize_ = file->entry->filesize = file->fpi ;
			}
			length = 0;
		}
	}
#if 0
	if( !writeState && file->sealant && (void*)file->sealant != (void*)data ) {
		flushFileSuffix( file );
		BLOCKINDEX saveSize = file->entry->filesize;
		BLOCKINDEX saveFpi = file->fpi;
		sack_vfs_os_write_internal( file, (char*)file->sealant, file->header.sealant.used, (POINTER)1 );
		file->entry->filesize = saveSize;
		file->fpi = saveFpi;
	}
#endif
	if( updated ) {
		SMUDGECACHE( file->vol, file->cache );
	}
	//if( cdata ) Release( cdata );
	//if( !writeState )
	file->vol->lock = 0;
	return written;
}
size_t CPROC sack_vfs_os_write( struct sack_vfs_os_file *file, const void * data_, size_t length ) {
	return sack_vfs_os_write_internal( (struct sack_vfs_os_file* )file, data_, length, NULL );
}
#ifdef XX_VIRTUAL_OBJECT_STORE
static enum sack_vfs_os_seal_states ValidateSeal( struct sack_vfs_os_file *file, char *data, size_t length ) {
	BLOCKINDEX offset = (file->entry->name_offset );
	uint32_t sealLen = (offset & DIRENT_NAME_OFFSET_FLAG_SEALANT) >> DIRENT_NAME_OFFSET_FLAG_SEALANT_SHIFT;
// = (struct random_context *)DequeLink( &signingEntropies );
	struct random_context *signEntropy;
	uint8_t outbuf[32];
	signEntropy = SRG_CreateEntropy4( NULL, (uintptr_t)0 );
	SRG_ResetEntropy( signEntropy );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)file->sealant, file->header.sealant.used );
	SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outbuf, 256 );
	if( (file->header.sealant.used != 32) || MemCmp( outbuf, file->sealant, 32 ) )
		return SACK_VFS_OS_SEAL_INVALID;
	SRG_ResetEntropy( signEntropy );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)data, length );
	// DO NOT DOUBLE_PROCESS THIS DATA
	SRG_FeedEntropy( signEntropy, (const uint8_t*)file->sealant, file->header.sealant.used );
	SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outbuf, 256 );
	SRG_DestroyEntropy( &signEntropy );
	{
		enum sack_vfs_os_seal_states success = SACK_VFS_OS_SEAL_INVALID;
		size_t len;
		char *rid = EncodeBase64Ex( outbuf, 256 / 8, &len, (const char *)1 );
		//if( StrCmp( file->filename, rid ) == 0 )
		//	success = SACK_VFS_OS_SEAL_VALID;
		Deallocate( char *, rid );
		return success;
	}
}
#endif
size_t CPROC sack_vfs_os_read_internal( struct sack_vfs_os_file *file, uint64_t version, void * data_, size_t length ) {
	char* data = (char*)data_;
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
#ifdef XX_VIRTUAL_OBJECT_STORE
	if( (file->entry->name_offset ) & DIRENT_NAME_OFFSET_FLAG_READ_KEYED ) {
		if( !file->readKey ) return 0;
	}
#endif
	if( ( file->filesize_ ) < ( file->fpi + length ) ) {
		if( ( file->filesize_ ) < file->fpi )
			length = 0;
		else
			length = (size_t)(( file->filesize_ ) - file->fpi);
	}
	if( !length || file->block == EOFBLOCK ) {  return 0; }
	if( ofs ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_os_BSEEK( file->vol, file->block, 0, &cache );
		int blockSize = file->vol->sector_size[cache];
		if( length >= ( blockSize - ( ofs ) ) ) {
			memcpy( data, block+ofs, blockSize-ofs );
			written += blockSize - ofs;
			data += blockSize - ofs;
			length -= blockSize - ofs;
			file->fpi += blockSize - ofs;
			cache = BC( FILE );
			file->block = vfs_os_GetNextBlock( file->vol, file->block, &cache, GFB_INIT_NONE, FALSE, 0, &blockSize );
#ifdef _DEBUG
			if( file->block == EOFBLOCK ) {
				lprintf( "bad read - file data too short" );
				DebugBreak();
			}
#endif
		} else {
			memcpy( data, block + ofs, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BC(FILE);
		uint8_t* block = (uint8_t*)vfs_os_BSEEK( file->vol, file->block, 0, &cache );
		unsigned int blockSize = file->vol->sector_size[cache];
		if( length >= blockSize ) {
			memcpy( data, block, blockSize - ofs );
			written += blockSize;
			data += blockSize;
			length -= blockSize;
			file->fpi += blockSize;
			cache = BC( FILE );
			file->block = vfs_os_GetNextBlock( file->vol, file->block, &cache, GFB_INIT_NONE, FALSE, 0, (int*)&blockSize );
#ifdef _DEBUG
			if( file->block == EOFBLOCK ) {
				lprintf( "bad read - file data too short" );
				DebugBreak();
			}
#endif
		} else {
			memcpy( data, block, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
#ifdef XX_VIRTUAL_OBJECT_STORE
	if( file->readKey
 //entry->filesize ) )
	   && ( file->fpi == ( file->filesize_ ) )
	   && ( (file->entry->name_offset)
	      & DIRENT_NAME_OFFSET_FLAG_READ_KEYED) )
	{
		uint8_t *outbuf;
		size_t outlen;
		enum block_cache_entries cache;
		struct storageTimelineNode* time = getRawTimeEntry( file->vol, file->entry->timelineEntry, &cache GRTENoLog DBG_SRC );
		SRG_XSWS_decryptData( (uint8_t*)data, written, time->time
		                    , (const uint8_t*)file->readKey, file->readKeyLen
		                    , &outbuf, &outlen );
		dropRawTimeEntry( file->vol, cache GRTENoLog DBG_SRC );
		memcpy( data, outbuf, outlen );
		Release( outbuf );
		written = outlen;
	}
	if( file->sealant
		&& (void*)file->sealant != (void*)data
 //file->entry->filesize ) ) {
		&& length == ( file->filesize_ ) ) {
		BLOCKINDEX saveSize = file->entry->filesize;
		BLOCKINDEX saveFpi = file->fpi;
		file->entry->filesize = ((file->entry->filesize
			) + file->header.sealant.used + sizeof( BLOCKINDEX ))
			;
		sack_vfs_os_read_internal( file, 0, (char*)file->sealant, file->header.sealant.used );
		file->entry->filesize = saveSize;
		file->fpi = saveFpi;
		file->sealed = ValidateSeal( file, data, length );
	}
#endif
	return written;
}
size_t CPROC sack_vfs_os_read( struct sack_vfs_os_file* file, void* data_, size_t length ) {
	size_t result;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	result = sack_vfs_os_read_internal( (struct sack_vfs_os_file*)file, 0, data_, length );
	file->vol->lock = 0;
	return result;
}
#ifdef XX_VIRTUAL_OBJECT_STORE
static BLOCKINDEX sack_vfs_os_read_patches( struct sack_vfs_os_file *file ) {
	size_t written = 0;
	BLOCKINDEX saveFpi = file->fpi;
	size_t length;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
//entry->filesize);
	length = (size_t)(file->filesize_ );
	if( !length ) { file->vol->lock = 0; return 0; }
	sack_vfs_os_seek_internal( file, length, SEEK_SET );
#if 0
	if( file->sealant ) {
		BLOCKINDEX saveSize = file->entry->filesize;
		BLOCKINDEX patches;
		//WriteIntoBlock( file, 0, 0, file->sealant, file->header.sealant.used );
		file->entry->filesize = saveSize;
		file->fpi = saveFpi;
		file->sealed = SACK_VFS_OS_SEAL_LOAD;
		return patches;
	}
#endif
	file->vol->lock = 0;
	return written;
}
static size_t sack_vfs_os_set_patch_block( struct sack_vfs_os_file *file, BLOCKINDEX patchBlock ) {
	size_t written = 0;
	size_t length;
	BLOCKINDEX saveFpi = file->fpi;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	length = (size_t)(file->entry->filesize);
	if( !length ) { file->vol->lock = 0; return 0; }
	sack_vfs_os_seek_internal( file, length, SEEK_SET );
	if( file->header.sealant.avail ) {
		sack_vfs_os_seek_internal( file, file->header.sealant.used, SEEK_CUR );
		sack_vfs_os_write_internal( file, (char*)&patchBlock, sizeof( BLOCKINDEX ), NULL );
		file->fpi = saveFpi;
	} else {
		BLOCKINDEX saveSize = file->entry->filesize;
		sack_vfs_os_seek_internal( file, file->header.sealant.used, SEEK_CUR );
		sack_vfs_os_write_internal( file, (char*)&patchBlock, sizeof( BLOCKINDEX ), NULL );
		file->fpi = saveFpi;
	}
	file->vol->lock = 0;
	return written;
}
static size_t sack_vfs_os_set_reference_block( struct sack_vfs_os_file *file, BLOCKINDEX patchBlock ) {
	size_t written = 0;
	size_t length;
	BLOCKINDEX saveFpi = file->fpi;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	length = (size_t)(file->entry->filesize);
	if( !length ) { file->vol->lock = 0; return 0; }
	sack_vfs_os_seek_internal( file, length, SEEK_SET );
	if( file->sealant ) {
		sack_vfs_os_seek_internal( file, file->header.sealant.used, SEEK_CUR );
		sack_vfs_os_write_internal( file, (char*)&patchBlock, sizeof( BLOCKINDEX ), NULL );
		file->fpi = saveFpi;
	}
	else {
		sack_vfs_os_seek_internal( file, file->header.sealant.used, SEEK_CUR );
		sack_vfs_os_write_internal( file, (char*)&patchBlock, sizeof( BLOCKINDEX ), NULL );
		file->fpi = saveFpi;
	}
	file->vol->lock = 0;
	return written;
}
#endif
static void sack_vfs_os_unlink_file_entry( struct sack_vfs_os_volume *vol, struct sack_vfs_os_file *dirinfo, BLOCKINDEX first_block, LOGICAL deleted ) {
	//FPI entFPI, struct directory_entry *entry, struct directory_entry *entkey
	BLOCKINDEX block, _block;
	struct sack_vfs_os_file *file_found = NULL;
	struct sack_vfs_os_file *file;
	INDEX idx;
	LIST_FORALL( vol->files, idx, struct sack_vfs_os_file *, file ) {
		if( file->_first_block == first_block ) {
			file_found = file;
			file->delete_on_close = TRUE;
		}
	}
	if( !deleted ) {
		// delete the file entry now; this disk entry may be reused immediately.
		dirinfo->entry_.first_block = dirinfo->_first_block;
		dirinfo->_first_block = dirinfo->entry->first_block = 0;
		SMUDGECACHE( vol, dirinfo->cache );
	}
	if( !file_found ) {
		_block = block = first_block;
#ifdef DEBUG_DIRECTORIES
		LoG( "(marking physical deleted (again?)) entry starts at %d", block );
#endif
		// wipe out file chain BAT
		if( first_block != DIR_ALLOCATING_MARK )
			do {
				enum block_cache_entries cache = BC(BAT);
				enum block_cache_entries fileCache = BC(DATAKEY);
				BLOCKINDEX *this_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, ( ( block / BLOCKS_PER_BAT ) * ( BLOCKS_PER_SECTOR ) ), 0, &cache );
				uint8_t* blockData = (uint8_t*)vfs_os_BSEEK( vol, block, 0, &fileCache );
				//LoG( "Clearing file datablock...%p", (uintptr_t)blockData - (uintptr_t)vol->disk );
				memset( blockData, 0, vol->sector_size[fileCache] );
				// after seek, block was read, and file position updated.
				SMUDGECACHE( vol, fileCache );
				SMUDGECACHE( vol, cache );
				//lprintf( "clear block %d %d %d ", (int)block, (int)( block% BLOCKS_PER_BAT ), (int)(block/BLOCKS_PER_BAT) );
				enum block_cache_entries gnbCache = BC( ZERO );
				block = vfs_os_GetNextBlock( vol, block, &gnbCache, GFB_INIT_NONE, FALSE, vol->sector_size[fileCache], NULL );
				this_BAT[_block % BLOCKS_PER_BAT] = 0;
				if( vol->sector_size[fileCache] == BLOCK_SMALL_SIZE )
					AddDataItem( &vol->pdlFreeSmallBlocks, &_block );
				else
					AddDataItem( &vol->pdlFreeBlocks, &_block );
				LoG( "unlink storing free block:%d", _block );
				_block = block;
			} while( block != EOFBLOCK );
		// this deletes the allocated name
		// it also removes the directory entry from list of entries
 // timelineEntry type is larger than index in some configurations; but won't exceed those bounds
		deleteTimelineIndex( vol, (BLOCKINDEX)dirinfo->entry->timelineEntry );
		deleteDirectoryEntryName( vol, dirinfo, dirinfo->entry->name_offset & DIRENT_NAME_OFFSET_OFFSET, dirinfo->cache, dirinfo->dir_block );
	}
}
static void _os_shrinkBAT( struct sack_vfs_os_file *file ) {
	struct sack_vfs_os_volume *vol = file->vol;
	BLOCKINDEX block, _block;
	size_t bsize = 0;
	int smallBlocks = 0;
	int nBlock = 0;
  // no data blocks already.
	if( file->entry->first_block == EOFBLOCK ) return;
	_block = block = file->entry->first_block;
	do {
		enum block_cache_entries cache = BC(BAT);
		enum block_cache_entries data_cache = BC( FILE );
		//lprintf( " block %d %d %d ", (int)block, (int)( block % BLOCKS_PER_BAT ), (int)( block / BLOCKS_PER_BAT ) );
		BLOCKINDEX *this_BAT = (BLOCKINDEX*)vfs_os_block_index_SEEK( vol, ( ( block / BLOCKS_PER_BAT ) * ( BLOCKS_PER_SECTOR) ), 0, &cache );
		if( !this_BAT[block % BLOCKS_PER_BAT] ) {
			lprintf( "This file is already deleted..." );
			return;
		}
		enum block_cache_entries gnbCache = BC( FILE );
		block = vfs_os_GetNextBlock( vol, block, &gnbCache, GFB_INIT_NONE, FALSE, BAT_BLOCK_SIZE, NULL );
		if( bsize >= (file->entry->filesize) ) {
#ifdef VFS_OS_PARANOID_TRUNCATE
			uint8_t* blockData = (uint8_t*)vfs_os_BSEEK( file->vol, _block, 0, &data_cache );
			memset( blockData, 0, file->vol->sector_size[data_cache] );
			//LoG( "clearing a datablock after a file..." );
#endif
			//lprintf( "Should be able to unlink this... extra block of data %d", (int)_block );
			if( vol->sector_size[data_cache] == BLOCK_SMALL_SIZE )
				AddDataItem( &vol->pdlFreeSmallBlocks, &_block );
			else
				AddDataItem( &vol->pdlFreeBlocks, &_block );
#ifdef DEBUG_FILE_TRUNCATE
			LoG( "shrink storing free block:%d", _block );
#endif
			this_BAT[_block % BLOCKS_PER_BAT] = 0;
		} else {
			if( this_BAT[BLOCKS_PER_BAT] ) {
				smallBlocks++;
				bsize += BLOCK_SMALL_SIZE;
			} else
				bsize += 4096;
			if( bsize > (file->entry->filesize) ) {
				uint8_t* blockData = (uint8_t*)vfs_os_BSEEK( file->vol, _block, 0, &data_cache );
				int blockSize = file->vol->sector_size[data_cache];
				//LoG( "clearing a partial datablock after a file..., %d, %d", blockSize-(file->entry->filesize & (blockSize-1)), ( file->entry->filesize & (blockSize-1)) );
#ifdef VFS_OS_PARANOID_TRUNCATE
				memset( blockData + (file->entry->filesize & (blockSize-1)), 0, blockSize-(file->entry->filesize & (blockSize-1)) );
#endif
				//this_BAT[_block % BLOCKS_PER_BAT] = 0;
			}
			else if( file->entry->filesize )
				nBlock++;
		}
		_block = block;
	} while( block != EOFBLOCK );
	if( !file->entry->filesize ) {
		file->_first_block = file->block = file->entry->first_block = EOFBLOCK;
#ifdef DEBUG_FILE_TRUNCATE
		LoG( "Truncated file block chain length is now:%d", nBlock );
#endif
		file->blockChainLength = nBlock;
	}
	if( smallBlocks > ( 4096 / BLOCK_SMALL_SIZE ) * 2 ) {
		lprintf( "File has lots of fragments, consider defragmenting its small blocks" );
	}
}
size_t CPROC sack_vfs_os_truncate_internal( struct sack_vfs_os_file *file ) {
	if( file->entry->filesize != file->fpi ) {
		file->filesize_ = file->entry->filesize = file->fpi;
		_os_shrinkBAT( file );
		SMUDGECACHE( file->vol, file->cache );
	}
	return (size_t)file->fpi;
}
size_t CPROC sack_vfs_os_truncate( struct sack_vfs_os_file* file ) {
	size_t result;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	result = sack_vfs_os_truncate_internal( (struct sack_vfs_os_file*)file );
	file->vol->lock = 0;
	return result;
}
int sack_vfs_os_close_internal( struct sack_vfs_os_file *file, int unlock ) {
#ifdef DEBUG_TRACE_LOG
#  ifdef DEBUG_FILE_OPS
	{
		enum block_cache_entries cache = BC(NAMES);
		static char fname[256];
		FPI name_ofs = file->entry_.name_offset;
		// this following line needs to be updated.
		//FPI base = (const char *)
		//char const *filename = (char const *)vfs_os_DSEEK( file->vol, name_ofs, 0, &cache ); // have to do the seek to the name block otherwise it might not be loaded.
		_os_MaskStrCpy( fname, sizeof( fname ), file->vol, cache, name_ofs );
		LoG( "close file:%s(%p)", fname, file );
	}
#  endif
#endif
	DeleteLink( &file->vol->files, file );
	if( file->delete_on_close ) sack_vfs_os_unlink_file_entry( file->vol, file, file->_first_block, TRUE );
	{
		INDEX idx;
		struct sack_vfs_file * testFile;
		LIST_FORALL( file->vol->files, idx, struct sack_vfs_file *, testFile ) {
			if( testFile->cache == file->cache )
				break;
		}
		if( !testFile ) {
			int locks = GETMASK_( file->vol->seglock, seglock, file->cache );
			if( !locks ) {
				lprintf( "Underflow file locks... " );
				DebugBreak();
			}
			locks--;
			SETMASK_( file->vol->seglock, seglock, file->cache, locks );
		}
	}
	//Deallocate( char *, file->filename );
#ifdef XX_VIRTUAL_OBJECT_STORE
	if( file->sealant )
		Deallocate( uint8_t*, file->sealant );
#endif
	if( file->vol->closed ) sack_vfs_os_unload_volume( file->vol );
	if( unlock ) file->vol->lock = 0;
	DeleteFromSet( VFS_OS_FILE, &l.files, file );
	//Deallocate( struct sack_vfs_os_file *, file );
	return 0;
}
int CPROC sack_vfs_os_close( struct sack_vfs_os_file* file ) {
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	int status = sack_vfs_os_close_internal( (struct sack_vfs_os_file*) file, TRUE );
	return status;
}
int CPROC sack_vfs_os_unlink_file( struct sack_vfs_os_volume *vol, const char * filename ) {
	int result = 0;
	struct sack_vfs_os_file tmp_dirinfo;
	if( !vol ) return 0;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
#ifdef DEBUG_DIRECTORIES
	LoG( "unlink file:%s", filename );
#endif
	if( _os_ScanDirectory( vol, filename, FIRST_DIR_BLOCK, NULL, &tmp_dirinfo, 0 ) ) {
		sack_vfs_os_unlink_file_entry( vol, &tmp_dirinfo, tmp_dirinfo.entry->first_block, FALSE );
		{
			int locks = GETMASK_( vol->seglock, seglock, tmp_dirinfo.cache );
			if( !locks ) {
				lprintf( "File locks underflowed" );
				DebugBreak();
			}
			else locks--;
			SETMASK_( vol->seglock, seglock, tmp_dirinfo.cache, locks );
		}
		result = 1;
	}
	vol->lock = 0;
	return result;
}
	/* noop */
int CPROC sack_vfs_os_flush( struct sack_vfs_os_file *file ) {	return 0; }
static LOGICAL CPROC sack_vfs_os_need_copy_write( void ) {	return FALSE; }
struct sack_vfs_os_find_info * CPROC sack_vfs_os_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask )
{
	struct sack_vfs_os_find_info *info = New( struct sack_vfs_os_find_info );
	info->pds_directories = CreateDataStack( sizeof( struct hashnode ) );
	info->base = base;
	info->base_len = StrLen( base );
	info->mask = mask;
	info->vol = (struct sack_vfs_os_volume *)psvInst;
	info->leadinDepth = 0;
	return (struct sack_vfs_os_find_info*)info;
}
static int _os_iterate_find( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	struct directory_hash_lookup_block *dirBlock;
	struct directory_entry *next_entries;
	int n;
	do
	{
		enum block_cache_entries cache = BC(DIRECTORY);
		enum block_cache_entries name_cache = BC(NAMES);
		struct hashnode node = ((struct hashnode *)PopData( &info->pds_directories ))[0];
		dirBlock = BTSEEK( struct directory_hash_lookup_block *, info->vol, node.this_dir_block, 0, cache );
		if( !node.thisent ) {
			struct hashnode subnode;
			subnode.thisent = 0;
			for( n = 254; n >= 0; n-- ) {
				BLOCKINDEX block = dirBlock->next_block[n];
				if( block ) {
					memcpy( subnode.leadin, node.leadin, node.leadinDepth );
					subnode.leadin[node.leadinDepth] = (char)n;
					subnode.leadinDepth = node.leadinDepth + 1;
					subnode.leadin[subnode.leadinDepth] = 0;
					subnode.this_dir_block = block;
					PushData( &info->pds_directories, &subnode );
				}
			}
		}
		//lprintf( "%p ledin : %*.*s %d", node, node.leadinDepth, node.leadinDepth, node.leadin, node.leadinDepth );
		next_entries = dirBlock->entries;
		for( n = (int)node.thisent; n < (dirBlock->used_names ); n++ ) {
			FPI name_ofs = ( next_entries[n].name_offset ) & DIRENT_NAME_OFFSET_OFFSET;
			FPI name_ofs_ = name_ofs;
			const char *filename, *filename_;
			int l;
			struct memoryTimelineNode time;
			//enum block_cache_entries  timeCache = BC( TIMELINE );
			reloadTimeEntry( &time, info->vol, (next_entries[n].timelineEntry) VTReadWrite GRTENoLog  DBG_SRC );
			if( !time.disk->time ) DebugBreak();
			if( time.disk->priorTime )
			{
				enum block_cache_entries cache;
				struct storageTimelineNode* prior = getRawTimeEntry( info->vol, time.disk->priorTime, &cache GRTENoLog DBG_SRC );
				while( prior->priorTime ) prior = getRawTimeEntry( info->vol, prior->priorTime, &cache GRTENoLog DBG_SRC );
				info->ctime = (prior->time/1000000)<<8 | prior->timeTz;
			}
			else
				info->ctime = (time.disk->time / 1000000) << 8 | time.disk->timeTz;
			info->wtime = (time.disk->time / 1000000) << 8 | time.disk->timeTz;
			dropRawTimeEntry( info->vol, time.diskCache GRTENoLog DBG_SRC );
			// if file is deleted; don't check it's name.
			info->filesize = (size_t)(next_entries[n].filesize);
			if( (name_ofs) > info->vol->dwSize ) {
				lprintf( "corrupted volume." );
				return 0;
			}
			name_cache = BC( NAMES );
			filename = (const char *)vfs_os_FSEEK( info->vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
			filename_ = filename;
			info->filenamelen = 0;
			for( l = 0; l < node.leadinDepth; l++ ) info->filename[info->filenamelen++] = node.leadin[l];
			if( info->vol->key ) {
				int c;
				do {
					while( ((name_ofs & ~BLOCK_MASK) == (name_ofs_ & ~BLOCK_MASK))
						&& (((c = ((uint8_t*)filename)[0] )) != UTF8_EOT)
						) {
						info->filename[info->filenamelen++] = c;
						filename++;
						name_ofs++;
					}
					if( ((name_ofs & ~BLOCK_MASK) == (name_ofs_ & ~BLOCK_MASK)) ) {
						name_cache = BC( NAMES );
						filename = (const char *)vfs_os_FSEEK( info->vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
						name_ofs_ = name_ofs;
						continue;
					}
					break;
				} while( 1 );
				info->filename[info->filenamelen]	 = 0;
				//LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			} else {
				int c;
				do {
					while(
						((name_ofs&~BLOCK_MASK) == (name_ofs_ & ~BLOCK_MASK))
						&& ((c = (((uint8_t*)filename)[0])) != UTF8_EOT)
						) {
						info->filename[info->filenamelen++] = c;
						filename_ = filename;
						filename++;
						name_ofs++;
					}
					if( ((((uintptr_t)filename)&~BLOCK_MASK) != (((uintptr_t)filename_)&~BLOCK_MASK)) ) {
						name_cache = BC( NAMES );
						filename = (const char*)vfs_os_FSEEK( info->vol, NULL, dirBlock->names_first_block, name_ofs, &name_cache, NAME_BLOCK_SIZE DBG_SRC );
						name_ofs_ = name_ofs;
						continue;
					}
					break;
				}
				while( 1 );
				info->filename[info->filenamelen] = 0;
#ifdef DEBUG_FILE_SCAN
				LoG( "Scan return filename: %s", info->filename );
#endif
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			}
			node.thisent = n + 1;
			PushData( &info->pds_directories, &node );
			return 1;
		}
	}
	while( info->pds_directories->Top );
	return 0;
}
int CPROC sack_vfs_os_find_first( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	struct hashnode root;
	root.this_dir_block = 0;
	root.leadinDepth = 0;
	root.thisent = 0;
	PushData( &info->pds_directories, &root );
	//info->thisent = 0;
	return _os_iterate_find( _info );
}
int CPROC sack_vfs_os_find_close( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	Deallocate( struct sack_vfs_os_find_info*, info ); return 0; }
int CPROC sack_vfs_os_find_next( struct sack_vfs_os_find_info *_info ) { return _os_iterate_find( _info ); }
char * CPROC sack_vfs_os_find_get_name( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	return info->filename; }
size_t CPROC sack_vfs_os_find_get_size( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	return info->filesize; }
LOGICAL CPROC sack_vfs_os_find_is_directory( struct sack_vfs_os_find_info *cursor ) { return FALSE; }
LOGICAL CPROC sack_vfs_os_is_directory( uintptr_t psvInstance, const char *path ) {
	if( path[0] == '.' && path[1] == 0 ) return TRUE;
	{
		struct sack_vfs_os_volume *vol = (struct sack_vfs_os_volume *)psvInstance;
		if( _os_ScanDirectory( vol, path, FIRST_DIR_BLOCK, NULL, NULL, 1 ) ) {
			return TRUE;
		}
	}
	return FALSE;
}
uint64_t CPROC sack_vfs_os_find_get_ctime( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	if( info ) return info->ctime;
	return 0;
}
uint64_t CPROC sack_vfs_os_find_get_wtime( struct sack_vfs_os_find_info *_info ) {
	struct sack_vfs_os_find_info *info = (struct sack_vfs_os_find_info *)_info;
	if( info ) return info->wtime;
	return 0;
}
LOGICAL CPROC sack_vfs_os_rename( uintptr_t psvInstance, const char *original, const char *newname ) {
	//struct sack_vfs_os_volume *vol = (struct sack_vfs_os_volume *)psvInstance;
	lprintf( "RENAME IS NOT SUPPORTED IN OBJECT STORAGE(OR NEEDS TO BE FIXED)" );
	// fail if the names are the same.
	return TRUE;
}
uintptr_t CPROC sack_vfs_os_file_ioctl_internal( struct sack_vfs_os_file* file, uintptr_t opCode, va_list args ) {
	//va_list args;
	//va_start( args, opCode );
	switch( opCode ) {
	default:
		// unhandled/ignored opcode
		return FALSE;
		break;
	case SOSFSFIO_DESTROY_INDEX:
	{
		//const char* indexname = va_arg( args, const char* );
		break;
	}
	case SOSFSFIO_CREATE_INDEX:
	{
		//const char* indexname = va_arg( args, const char* );
		//size_t indexnameLen = va_arg( args, size_t );
		lprintf( "Indexes should be implemented higher..." );
		//enum jsox_value_types type = va_arg( args, enum jsox_value_types );
		//int typeExtra = va_arg( args, int );
		//struct memoryStorageIndex* index = allocateIndex( file, indexname, indexnameLen );
		//file->
/*index*/
		return (uintptr_t)0;
		break;
	}
	case SOSFSFIO_ADD_INDEX_ITEM:
	{
		//struct memoryStorageIndex* index = (struct memoryStorageIndex*)va_arg( args, uintptr_t );
		//struct sack_vfs_os_file *reference = va_arg( args, struct sack_vfs_os_file* );
		//struct jsox_value_container * value = va_arg( args, struct jsox_value_container* );
		//file->
		break;
	}
	case SOSFSFIO_REMOVE_INDEX_ITEM:
	{
		//const char* indexname = va_arg( args, const char* );
		//file->
		break;
	}
	case SOSFSFIO_ADD_REFERENCE:
	{
		//const char* indexname = va_arg( args, const char* );
		//file->
		break;
	}
	case SOSFSFIO_REMOVE_REFERENCE:
	{
		//const char* indexname = va_arg( args, const char* );
		//file->
		break;
	}
	case SOSFSFIO_ADD_REFERENCE_BY:
	{
		//const char* indexname = va_arg( args, const char* );
		//file->
		break;
	}
	case SOSFSFIO_REMOVE_REFERENCE_BY:
	{
		//const char* indexname = va_arg( args, const char* );
		//file->
		break;
	}
	case SOSFSFIO_TAMPERED:
	{
		//struct sack_vfs_file *file = (struct sack_vfs_file *)psvInstance;
#ifdef XX_VIRTUAL_OBJECT_STORE
		int *result = va_arg( args, int* );
		if( file->sealant ) {
			switch( file->sealed ) {
			case SACK_VFS_OS_SEAL_STORE:
			case SACK_VFS_OS_SEAL_VALID:
				(*result) = 1;
            break;
			default:
				(*result) = 0;
			}
		}
		else
			(*result) = 1;
#endif
	}
	break;
	case SOSFSFIO_PROVIDE_SEALANT:
#ifdef XX_VIRTUAL_OBJECT_STORE
	{
		const char *sealant = va_arg( args, const char * );
		size_t sealantLen = va_arg( args, size_t );
		lprintf( "This should be a higher level thing." );
		//struct sack_vfs_file *file = (struct sack_vfs_file *)psvInstance;
		{
			size_t len;
			if( file->sealant )
				Release( file->sealant );
			file->sealant = (uint8_t*)DecodeBase64Ex( sealant, sealantLen, &len, (const char*)1 );
			_os_SetSmallBlockUsage( &file->header.sealant, (uint8_t)len );
			//_os_UpdateFileBlocks( file );
			if( file->sealed == SACK_VFS_OS_SEAL_NONE )
				file->sealed = SACK_VFS_OS_SEAL_STORE;
			else if( file->sealed == SACK_VFS_OS_SEAL_VALID || file->sealed == SACK_VFS_OS_SEAL_LOAD )
				file->sealed = SACK_VFS_OS_SEAL_STORE_PATCH;
			else
				lprintf( "Unhandled SEAL state." );
			//file->sealant = sealant;
			//file->sealantLen = sealantLen;
			// set the sealant length in the name offset.
			file->entry->name_offset = (((file->entry->name_offset)
				| ((len >> 2) << 17)) );
		}
	}
#endif
	break;
	case SOSFSFIO_PROVIDE_READKEY:
#ifdef XX_VIRTUAL_OBJECT_STORE
	{
		const char *sealant = va_arg( args, const char * );
		size_t sealantLen = va_arg( args, size_t );
		//struct sack_vfs_file *file = (struct sack_vfs_file *)psvInstance;
		{
			size_t len;
			if( file->readKey )
				Release( file->readKey );
			file->readKey = (uint8_t*)DecodeBase64Ex( sealant, sealantLen, &len, (const char*)1 );
			file->readKeyLen = (uint16_t)len;
			// set the sealant length in the name offset.
			file->entry->name_offset = (((file->entry->name_offset )
				| DIRENT_NAME_OFFSET_FLAG_READ_KEYED) );
		}
	}
#endif
	break;
	case SOSFSFIO_SET_TIME:
	{
		uint64_t timestamp = va_arg( args, uint64_t );
		int8_t tz = (uint8_t)va_arg( args, int );
		return sack_vfs_os_set_time( file, timestamp, tz );
	}
	break;
	case SOSFSFIO_GET_TIME:
	{
		//uint64_t** timeArray = va_arg( args, uint64_t** );
		//int8_t** tzArray = va_arg( args, int8_t** );
		//size_t* timeCount  = va_arg( args, size_t* );
		return file->entry->timelineEntry;
	}
	break;
	case SOSFSFIO_GET_TIMES:
	{
		uint64_t** timeArray = va_arg( args, uint64_t** );
		int8_t** tzArray = va_arg( args, int8_t** );
		size_t* timeCount  = va_arg( args, size_t* );
		return sack_vfs_os_get_times( file, timeArray, tzArray, timeCount );
	}
	break;
 // automatic managment is good enough?
	case SOSFSFIO_SET_BLOCKSIZE:
	{
		//int size = va_arg( args, int );
		//file->blockSize = size;
	}
	break;
	}
	return TRUE;
}
uintptr_t CPROC sack_vfs_os_file_ioctl_interface( uintptr_t psvInstance, uintptr_t opCode, va_list args ) {
	return sack_vfs_os_file_ioctl_internal( (struct sack_vfs_os_file*)psvInstance, opCode, args );
}
uintptr_t CPROC sack_vfs_os_file_ioctl( struct sack_vfs_os_file *psvInstance, uintptr_t opCode, ... ) {
	va_list args;
	va_start( args, opCode );
	return sack_vfs_os_file_ioctl_internal( (struct sack_vfs_os_file*)psvInstance, opCode, args );
}
uintptr_t CPROC sack_vfs_os_system_ioctl_internal( struct sack_vfs_os_volume *vol, uintptr_t opCode, va_list args ) {
	//va_list args;
	//va_start( args, opCode );
	switch( opCode ) {
	default:
		// unhandled/ignored opcode
		return FALSE;
	case SOSFSSIO_OPEN_VERSION:
		{
			const char * name;name = va_arg( args, const char* );
			uint64_t version = va_arg( args, uint64_t );
			return (uintptr_t)sack_vfs_os_openfile_internal( vol, name, version, FALSE );
		}
		break;
	case SOSFSSIO_NEW_VERSION:
		{
			const char * name;name = va_arg( args, const char* );
			return (uintptr_t)sack_vfs_os_openfile_internal( vol, name, 0, TRUE );
		}
		break;
	case SOSFSSIO_OPEN_TIMELINE:
		{
			return (uintptr_t)sack_vfs_os_get_time_cursor( vol );
		}
		break;
	case SOSFSSIO_READ_TIMELINE:
		{
			struct sack_vfs_os_time_cursor* cursor;cursor = va_arg(args, struct sack_vfs_os_time_cursor* );
			int step = va_arg( args, int );
			uint64_t timestamp; timestamp = va_arg( args, uint64_t );
			uint64_t* result_entry; result_entry = va_arg( args, uint64_t* );
			const char ** filename;filename = va_arg( args, const char ** );
			uint64_t* timestamp_result;timestamp_result = va_arg( args, uint64_t* );
			int8_t* tz_result;tz_result = va_arg( args, int8_t* );
			const char** buffer;buffer = va_arg( args, const char** );
			size_t* size_result;size_result = va_arg( args, size_t* );
			sack_vfs_os_read_time_cursor( cursor, step, timestamp, result_entry, filename, timestamp_result, tz_result, buffer, size_result );
			return TRUE;
		}
		break;
	case SOSFSSIO_LOAD_OBJECT:
		return FALSE;
	case SOSFSSIO_PATCH_OBJECT:
		{
		//LOGICAL owner;owner = va_arg( args, LOGICAL );  // seal input is a constant, generate random meta key
		//char *objIdBuf;objIdBuf = va_arg( args, char * );
		/*
		size_t objIdBufLen = va_arg( args, size_t );
		char *patchAuth = va_arg( args, char * );
		size_t patchAuthLen = va_arg( args, size_t );
		char *objBuf = va_arg( args, char * );
		size_t objBufLen = va_arg( args, size_t );
		char *sealBuf = va_arg( args, char * );
		size_t sealBufLen = va_arg( args, size_t );
		char *keyBuf = va_arg( args, char * );
		size_t keyBufLen = va_arg( args, size_t );
		char *idBuf = va_arg( args, char * );
		size_t idBufLen = va_arg( args, size_t );
		*/
#ifdef XX_VIRTUAL_OBJECT_STORE
		if( sack_vfs_os_exists( vol, objIdBuf ) ) {
			struct sack_vfs_os_file* file = (struct sack_vfs_os_file*)sack_vfs_os_openfile( vol, objIdBuf );
			BLOCKINDEX patchBlock = sack_vfs_os_read_patches( file );
			enum block_cache_entries cacheSomething = BC(FILE);
			if( !patchBlock ) {
				patchBlock = _os_GetFreeBlock( vol, &cacheSomething, GFB_INIT_PATCHBLOCK, 4096 );
			}
			{
				enum block_cache_entries cache;
				struct directory_patch_block *newPatchblock;
				cache = BC(FILE);
				newPatchblock = BTSEEK( struct directory_patch_block *, vol, patchBlock, DIR_BLOCK_SIZE, cache );
				while( 1 ) {
					//char objId[45];
					//size_t objIdLen;
					char *seal = getFilename( objBuf, objBufLen, sealBuf, sealBufLen, FALSE, &idBuf, &idBufLen );
					if( sack_vfs_os_exists( vol, idBuf ) ) {
 // accidental key collision.
						if( !sealBuf ) {
 // try again.
							continue;
						}
						else {
							// deliberate key collision; and record already exists.
							return TRUE;
						}
					}
					else {
						struct sack_vfs_os_file* file = (struct sack_vfs_os_file*)sack_vfs_os_openfile( vol, idBuf );
						//  file->entry_fpi
						newPatchblock->entries[newPatchblock->usedEntries].raw
							= file->entry_fpi;
						newPatchblock->usedEntries = (newPatchblock->usedEntries + 1);
						SMUDGECACHE( vol, cache );
						file->sealant = (uint8_t*)seal;
						_os_SetSmallBlockUsage( &file->header.sealant, (uint8_t)strlen( seal ) );
						//_os_UpdateFileBlocks( file );
						sack_vfs_os_seek_internal( file, (size_t)GetBlockStart( file, FILE_BLOCK_DATA ), SEEK_SET );
						sack_vfs_os_write_internal( file, objBuf, objBufLen, 0 );
						sack_vfs_os_close_internal( file, FALSE );
					}
					return TRUE;
				}
			}
		}
#endif
 // object to patch was not found.
		return FALSE;
	}
	break;
	case SOSFSSIO_STORE_OBJECT:
	#if 0
	{
  // seal input is a constant, generate random meta key
		LOGICAL owner = va_arg( args, LOGICAL );
		char *objBuf = va_arg( args, char * );
		size_t objBufLen = va_arg( args, size_t );
  // provided for re-write; provided also for private named objects
		char *objIdBuf = va_arg( args, char * );
		size_t objIdBufLen = va_arg( args, size_t );
  // user provided sealant if any
		char *sealBuf = va_arg( args, char * );
		size_t sealBufLen = va_arg( args, size_t );
  // encryption key
		char *keyBuf = va_arg( args, char * );
		size_t keyBufLen = va_arg( args, size_t );
  // output buffer
		char **idBuf = va_arg( args, char ** );
		size_t *idBufLen = va_arg( args, size_t* );
		while( 1 ) {
			char *seal = getFilename( objBuf, objBufLen, sealBuf, sealBufLen, owner, idBuf, idBufLen );
			if( sack_vfs_os_exists( vol, idBuf[0] ) ) {
 // accidental key collision.
				if( !sealBuf ) {
 // try again.
					continue;
				}
				else {
					// deliberate key collision; and record already exists.
					return TRUE;
				}
			}
			else {
				struct sack_vfs_os_file* file = (struct sack_vfs_os_file*)sack_vfs_os_openfile( vol, idBuf[0] );
#ifdef XX_VIRTUAL_OBJECT_STORE
				if( sealBuf ) {
					file->sealant = (uint8_t*)seal;
					_os_SetSmallBlockUsage( &file->header.sealant, (uint8_t)strlen( seal ) );
					WriteIntoBlock( file, 0, 0, seal, strlen( seal ) );
					//file->sealantLen = (uint8_t)strlen( seal );
				} else {
					file->sealant = NULL;
					_os_SetSmallBlockUsage( &file->header.sealant, 0 );
					//file->sealantLen = 0;
				}
#endif
				sack_vfs_os_write_internal( file, objBuf, objBufLen, NULL );
				sack_vfs_os_close_internal( file, FALSE );
			}
			return TRUE;
		}
	}
#endif
	break;
	}
	return 0;
}
uintptr_t CPROC sack_vfs_os_system_ioctl_interface( uintptr_t psvInstance, uintptr_t opCode, va_list args ) {
	return sack_vfs_os_system_ioctl_internal( (struct sack_vfs_os_volume*)psvInstance, opCode, args );
}
uintptr_t CPROC sack_vfs_os_system_ioctl( struct sack_vfs_os_volume* vol, uintptr_t opCode, ... ) {
	va_list args;
	va_start( args, opCode );
	return sack_vfs_os_system_ioctl_internal( vol, opCode, args );
}
LOGICAL sack_vfs_os_get_times( struct sack_vfs_os_file* file, uint64_t** timeArray, int8_t** tzArray, size_t* timeCount ) {
	if( !timeArray ) return TRUE;
	struct s_scratchTime {
		uint64_t scratchTime;
		uint8_t scratchTz;
	} scratch;
	PDATALIST pdlTimes = CreateDataList( sizeof( scratch ) );
	struct sack_vfs_os_volume* vol = file->vol;
	struct memoryTimelineNode time;
	//enum block_cache_entries  timeCache = BC( TIMELINE );
	reloadTimeEntry( &time, vol, file->entry->timelineEntry VTReadWrite GRTENoLog  DBG_SRC );
	if( !time.disk->time ) DebugBreak();
	scratch.scratchTime = time.disk->time;
	scratch.scratchTz = time.disk->timeTz;
	AddDataItem( &pdlTimes, &scratch );
	if( time.disk->priorTime ) {
		BLOCKINDEX priorTime = time.disk->priorTime;
		while( priorTime ) {
			enum block_cache_entries cache;
			struct storageTimelineNode* prior = getRawTimeEntry( vol, priorTime, &cache GRTENoLog DBG_SRC );
			scratch.scratchTime = prior->time;
			scratch.scratchTz = prior->timeTz;
			priorTime = prior->priorTime;
			dropRawTimeEntry( file->vol, cache GRTENoLog DBG_SRC );
			AddDataItem( &pdlTimes, &scratch );
		}
	}
	dropRawTimeEntry( vol, time.diskCache GRTENoLog DBG_SRC );
	timeArray[0] = NewArray( uint64_t, pdlTimes->Cnt );
	tzArray[0] = NewArray( int8_t, pdlTimes->Cnt );
	{
		struct s_scratchTime* st;
		INDEX idx;
		DATA_FORALL( pdlTimes, idx, struct s_scratchTime*, st ) {
			timeArray[0][idx] = st->scratchTime;
			tzArray[0][idx] = st->scratchTz;
		}
	}
	//MemCpy( timeArray[0], pdlTimes->data, pdlTimes->Cnt * sizeof( timeArray[0] ) );
	timeCount[0] = pdlTimes->Cnt;
	DeleteDataList( &pdlTimes );
	return TRUE;
}
LOGICAL sack_vfs_os_set_time( struct sack_vfs_os_file* file, uint64_t timeVal, int8_t tz ) {
	struct sack_vfs_os_volume* vol = file->vol;
	struct memoryTimelineNode time;
	//enum block_cache_entries  timeCache = BC( TIMELINE );
	reloadTimeEntry( &time, vol, file->entry->timelineEntry VTReadWrite GRTENoLog  DBG_SRC );
	//int tz = timeVal & 0xFF;
	//timeVal = ( timeVal >> 8 ) * 1000000LL;
	return setTimeEntryTime( &time, vol, timeVal, tz );
}
LOGICAL sack_vfs_os_halt( struct sack_vfs_os_volume* volume ) {
	LOGICAL prior = volume->flags.halted;
	volume->flags.halted = TRUE;
	return prior;
}
#ifndef USE_STDIO
static struct file_system_interface sack_vfs_os_fsi = {
                                                     (void*(CPROC*)(uintptr_t,const char *, const char*))sack_vfs_os_open
                                                   , (int(CPROC*)(void*))sack_vfs_os_close
                                                   , (size_t(CPROC*)(void*,void*,size_t))sack_vfs_os_read
                                                   , (size_t(CPROC*)(void*,const void*,size_t))sack_vfs_os_write
                                                   , (size_t(CPROC*)(void*,size_t,int))sack_vfs_os_seek
                                                   , (void(CPROC*)(void*))sack_vfs_os_truncate
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_os_unlink_file
                                                   , (size_t(CPROC*)(void*))sack_vfs_os_size
                                                   , (size_t(CPROC*)(void*))sack_vfs_os_tell
                                                   , (int(CPROC*)(void*))sack_vfs_os_flush
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_os_exists
                                                   , sack_vfs_os_need_copy_write
                                                   , (struct find_cursor*(CPROC*)(uintptr_t,const char *,const char *))             sack_vfs_os_find_create_cursor
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_os_find_first
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_os_find_close
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_os_find_next
                                                   , (char*(CPROC*)(struct find_cursor*))           sack_vfs_os_find_get_name
                                                   , (size_t(CPROC*)(struct find_cursor*))          sack_vfs_os_find_get_size
                                                   , (LOGICAL(CPROC*)(struct find_cursor*))         sack_vfs_os_find_is_directory
                                                   , (LOGICAL(CPROC*)(uintptr_t, const char*))      sack_vfs_os_is_directory
                                                   , (LOGICAL(CPROC*)(uintptr_t, const char*, const char*))sack_vfs_os_rename
                                                   , (uintptr_t(CPROC*)(uintptr_t, uintptr_t, va_list))sack_vfs_os_file_ioctl_interface
												   , (uintptr_t(CPROC*)(uintptr_t, uintptr_t, va_list))sack_vfs_os_system_ioctl_interface
	, (uint64_t( CPROC*)(struct find_cursor* cursor)) sack_vfs_os_find_get_ctime
	, (uint64_t( CPROC* )(struct find_cursor* cursor)) sack_vfs_os_find_get_wtime
};
PRIORITY_PRELOAD( Sack_VFS_OS_Register, CONFIG_SCRIPT_PRELOAD_PRIORITY - 2 )
{
#undef DEFAULT_VFS_NAME
#ifdef ALT_VFS_NAME
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME "-os.runner"
#else
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME "-os"
#endif
	sack_register_filesystem_interface( DEFAULT_VFS_NAME, &sack_vfs_os_fsi );
}
PRIORITY_PRELOAD( Sack_VFS_OS_RegisterDefaultFilesystem, SQL_PRELOAD_PRIORITY + 1 ) {
	if( SACK_GetProfileInt( GetProgramName(), "SACK/VFS/Mount FS VFS", 0 ) ) {
		struct sack_vfs_os_volume *vol;
		TEXTCHAR volfile[256];
		TEXTSTR tmp;
		SACK_GetProfileString( GetProgramName(), "SACK/VFS/OS File", "*/../assets.os", volfile, 256 );
		tmp = ExpandPath( volfile );
		vol = sack_vfs_os_load_volume( tmp, NULL );
		Deallocate( TEXTSTR, tmp );
		sack_mount_filesystem( "sack_shmem-os", sack_get_filesystem_interface( DEFAULT_VFS_NAME )
		                     , 900, (uintptr_t)vol, TRUE );
	}
}
#endif
#ifdef __cplusplus
}
#endif
#ifdef USE_STDIO
#  undef sack_fopen
#  undef sack_fseek
#  undef sack_fclose
#  undef sack_fread
#  undef sack_fwrite
#  undef sack_ftell
#  undef free
#  undef StrDup
#  define StrDup(o) StrDupEx( (o) DBG_SRC )
#endif
#undef free
SACK_VFS_NAMESPACE_END
#undef l
#endif
#undef SACK_VFS_SOURCE
#undef SACK_VFS_OS_SOURCE
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
#  pragma warning( default: 26451 )
#endif
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#ifndef MD5_SOURCE
#  define MD5_SOURCE
#endif
/* MD5.H - header file for MD5C.C
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#ifndef MD5_ALGORITHM_DEFINED
#define MD5_ALGORITHM_DEFINED
#ifdef MD5_SOURCE
#define MD5_PROC(type,name) EXPORT_METHOD type name
#else
#define MD5_PROC(type,name) IMPORT_METHOD type name
#endif
/* MD5 context. */
typedef struct {
	uint32_t state[4];
	uint32_t count[2];
  unsigned char buffer[64];
} MD5_CTX;
MD5_PROC( void, MD5Init )(MD5_CTX *);
MD5_PROC( void, MD5Update )(MD5_CTX *, unsigned char *, unsigned int);
MD5_PROC( void, MD5Final )(unsigned char [16], MD5_CTX *);
#endif
/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21
static void MD5Transform (uint32_t [4], unsigned char [64]);
static void Encode (unsigned char *, uint32_t *, unsigned int);
static void Decode (uint32_t *, unsigned char *, unsigned int);
static void MD5_memcpy (uint8_t*, uint8_t*, unsigned int);
static void MD5_memset (uint8_t*, int, unsigned int);
static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) {  (a) += F ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define GG(a, b, c, d, x, s, ac) {  (a) += G ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define HH(a, b, c, d, x, s, ac) {  (a) += H ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define II(a, b, c, d, x, s, ac) {  (a) += I ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
MD5_PROC( void, MD5Init )( MD5_CTX *context )
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}
/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
MD5_PROC( void, MD5Update ) ( MD5_CTX *context
									 , unsigned char *input
									 , unsigned int inputLen)
{
  unsigned int i, index, partLen;
  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
  /* Update number of bits */
  if ((context->count[0] += ((uint32_t)inputLen << 3))
   < ((uint32_t)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((uint32_t)inputLen >> 29);
  partLen = 64 - index;
  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((uint8_t*)&context->buffer[index], (uint8_t*)input, partLen);
 MD5Transform (context->state, context->buffer);
 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);
 index = 0;
  }
  else
 i = 0;
  /* Buffer remaining input */
  MD5_memcpy
 ((uint8_t*)&context->buffer[index], (uint8_t*)&input[i],
  inputLen-i);
}
/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
MD5_PROC( void, MD5Final )(unsigned char *digest, MD5_CTX *context)
{
  unsigned char bits[8];
  unsigned int index, padLen;
  /* Save number of bits */
  Encode (bits, context->count, 8);
  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);
  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);
  /* Zeroize sensitive information.
*/
  MD5_memset ((uint8_t*)context, 0, sizeof (*context));
}
/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (uint32_t state[4], unsigned char block[64])
{
  uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  Decode (x, block, 64);
  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478);
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756);
  FF (c, d, a, b, x[ 2], S13, 0x242070db);
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee);
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf);
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a);
  FF (c, d, a, b, x[ 6], S13, 0xa8304613);
  FF (b, c, d, a, x[ 7], S14, 0xfd469501);
  FF (a, b, c, d, x[ 8], S11, 0x698098d8);
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af);
  FF (c, d, a, b, x[10], S13, 0xffff5bb1);
  FF (b, c, d, a, x[11], S14, 0x895cd7be);
  FF (a, b, c, d, x[12], S11, 0x6b901122);
  FF (d, a, b, c, x[13], S12, 0xfd987193);
  FF (c, d, a, b, x[14], S13, 0xa679438e);
  FF (b, c, d, a, x[15], S14, 0x49b40821);
 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562);
  GG (d, a, b, c, x[ 6], S22, 0xc040b340);
  GG (c, d, a, b, x[11], S23, 0x265e5a51);
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa);
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d);
  GG (d, a, b, c, x[10], S22,  0x2441453);
  GG (c, d, a, b, x[15], S23, 0xd8a1e681);
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8);
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6);
  GG (d, a, b, c, x[14], S22, 0xc33707d6);
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87);
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed);
  GG (a, b, c, d, x[13], S21, 0xa9e3e905);
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8);
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9);
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);
  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942);
  HH (d, a, b, c, x[ 8], S32, 0x8771f681);
  HH (c, d, a, b, x[11], S33, 0x6d9d6122);
  HH (b, c, d, a, x[14], S34, 0xfde5380c);
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44);
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9);
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60);
  HH (b, c, d, a, x[10], S34, 0xbebfbc70);
  HH (a, b, c, d, x[13], S31, 0x289b7ec6);
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa);
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085);
  HH (b, c, d, a, x[ 6], S34,  0x4881d05);
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039);
  HH (d, a, b, c, x[12], S32, 0xe6db99e5);
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8);
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665);
  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244);
  II (d, a, b, c, x[ 7], S42, 0x432aff97);
  II (c, d, a, b, x[14], S43, 0xab9423a7);
  II (b, c, d, a, x[ 5], S44, 0xfc93a039);
  II (a, b, c, d, x[12], S41, 0x655b59c3);
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92);
  II (c, d, a, b, x[10], S43, 0xffeff47d);
  II (b, c, d, a, x[ 1], S44, 0x85845dd1);
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f);
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0);
  II (c, d, a, b, x[ 6], S43, 0xa3014314);
  II (b, c, d, a, x[13], S44, 0x4e0811a1);
  II (a, b, c, d, x[ 4], S41, 0xf7537e82);
  II (d, a, b, c, x[11], S42, 0xbd3af235);
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb);
  II (b, c, d, a, x[ 9], S44, 0xeb86d391);
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  /* Zeroize sensitive information.
   */
  MD5_memset ((uint8_t*)x, 0, sizeof (x));
}
/* Encodes input (uint32_t) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (unsigned char *output, uint32_t *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}
/* Decodes input (unsigned char) into output (uint32_t). Assumes len is
  a multiple of 4.
 */
static void Decode (uint32_t *output, unsigned char *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((uint32_t)input[j]) | (((uint32_t)input[j+1]) << 8) |
   (((uint32_t)input[j+2]) << 16) | (((uint32_t)input[j+3]) << 24);
}
/* Note: Replace "for loop" with standard memcpy if possible.
 */
static void MD5_memcpy (uint8_t* output, uint8_t* input, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
    output[i] = input[i];
}
/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (uint8_t* output, int value, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
}
/*
 *  sha1.c
 *
 *  Description:
 *      This file implements the Secure Hashing Algorithm 1 as
 *      defined in FIPS PUB 180-1 published April 17, 1995.
 *
 *      The SHA-1, produces a 160-bit message digest for a given
 *      data stream.  It should take about 2**n steps to find a
 *      message with the same digest as a given message and
 *      2**(n/2) to find any two messages with the same digest,
 *      when n is the digest size in bits.  Therefore, this
 *      algorithm can serve as a means of providing a
 *      "fingerprint" for a message.
 *
 *  Portability Issues:
 *      SHA-1 is defined in terms of 32-bit "words".  This code
 *      uses <stdint.h> (included via "sha1.h" to define 32 and 8
 *      bit unsigned integer types.  If your C compiler does not
 *      support 32 bit unsigned integers, this code is not
 *      appropriate.
 *
 *  Caveats:
 *      SHA-1 is designed to work with messages less than 2^64 bits
 *      long.  Although SHA-1 allows a message digest to be generated
 *      for messages of any number of bits less than 2^64, this
 *      implementation only works with messages with a length that is
 *      a multiple of the size of an 8-bit character.
 *
 */
/* SHA1 Standard library from somewhere... */
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef INCLUDED_SHA1_H_
#define INCLUDED_SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
#define SHA1_DIGEST_SIZE SHA1HashSize
typedef SHA1Context sha1_ctx;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifndef SHA1HashSize
#define SHA1Context SHA1_CTX
#endif
/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word)                 (((word) << (bits)) | ((word) >> (32-(bits))))
/* Local Function Prototyptes */
void SHA1PadMessage(SHA1Context *);
void SHA1ProcessMessageBlock(SHA1Context *);
/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Reset(SHA1Context *context)
{
    if (!context)
    {
        return shaNull;
    }
    context->Length_Low             = 0;
    context->Length_High            = 0;
    context->Message_Block_Index    = 0;
    context->Intermediate_Hash[0]   = 0x67452301;
    context->Intermediate_Hash[1]   = 0xEFCDAB89;
    context->Intermediate_Hash[2]   = 0x98BADCFE;
    context->Intermediate_Hash[3]   = 0x10325476;
    context->Intermediate_Hash[4]   = 0xC3D2E1F0;
    context->Computed   = 0;
    context->Corrupted  = 0;
    return shaSuccess;
}
/*
 *  SHA1Result
 *
 *  Description:
 *      This function will return the 160-bit message digest into the
 *      Message_Digest array  provided by the caller.
 *      NOTE: The first octet of hash is stored in the 0th element,
 *            the last octet of hash in the 19th element.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to use to calculate the SHA-1 hash.
 *      Message_Digest: [out]
 *          Where the digest is returned.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Result( SHA1Context *context,
                uint8_t Message_Digest[SHA1HashSize])
{
    int i;
    if (!context || !Message_Digest)
    {
        return shaNull;
    }
    if (context->Corrupted)
    {
        return context->Corrupted;
    }
    if (!context->Computed)
    {
        SHA1PadMessage(context);
        for(i=0; i<64; ++i)
        {
            /* message may be sensitive, clear it out */
            context->Message_Block[i] = 0;
        }
        context->Length_Low = 0;
        context->Length_High = 0;
        context->Computed = 1;
    }
    for(i = 0; i < SHA1HashSize; ++i)
    {
        Message_Digest[i] = (uint8_t)(context->Intermediate_Hash[i>>2]
                            >> 8 * ( 3 - ( i & 0x03 ) ));
    }
    return shaSuccess;
}
/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update
 *      message_array: [in]
 *          An array of characters representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Input(    SHA1Context    *context,
                  const uint8_t  *message_array,
                  size_t       length)
{
    if (!length)
    {
        return shaSuccess;
    }
    if (!context || !message_array)
    {
        return shaNull;
    }
    if (context->Computed)
    {
        context->Corrupted = shaStateError;
        return shaStateError;
    }
    if (context->Corrupted)
    {
         return context->Corrupted;
    }
    while(length-- && !context->Corrupted)
    {
    context->Message_Block[context->Message_Block_Index++] =
                    (*message_array & 0xFF);
    context->Length_Low += 8;
    if (context->Length_Low == 0)
    {
        context->Length_High++;
        if (context->Length_High == 0)
        {
            /* Message is too long */
            context->Corrupted = 1;
        }
    }
    if (context->Message_Block_Index == 64)
    {
        SHA1ProcessMessageBlock(context);
    }
    message_array++;
    }
    return shaSuccess;
}
/*
 *  SHA1ProcessMessageBlock
 *
 *  Description:
 *      This function will process the next 512 bits of the message
 *      stored in the Message_Block array.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Comments:
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the
 *      names used in the publication.
 *
 *
 */
void SHA1ProcessMessageBlock(SHA1Context *context)
{
    const uint32_t K[] =    {
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
                            };
    int           t;
    uint32_t      temp;
    uint32_t      W[80];
    uint32_t      A, B, C, D, E;
    /*
     *  Initialize the first 16 words in the array W
     */
    for(t = 0; t < 16; t++)
    {
        W[t] = context->Message_Block[t * 4] << 24;
        W[t] |= context->Message_Block[t * 4 + 1] << 16;
        W[t] |= context->Message_Block[t * 4 + 2] << 8;
        W[t] |= context->Message_Block[t * 4 + 3];
    }
    for(t = 16; t < 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
    }
    A = context->Intermediate_Hash[0];
    B = context->Intermediate_Hash[1];
    C = context->Intermediate_Hash[2];
    D = context->Intermediate_Hash[3];
    E = context->Intermediate_Hash[4];
    for(t = 0; t < 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 20; t < 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 40; t < 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 60; t < 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    context->Intermediate_Hash[0] += A;
    context->Intermediate_Hash[1] += B;
    context->Intermediate_Hash[2] += C;
    context->Intermediate_Hash[3] += D;
    context->Intermediate_Hash[4] += E;
    context->Message_Block_Index = 0;
}
/*
 *  SHA1PadMessage
 *
 *  Description:
 *      According to the standard, the message must be padded to an even
 *      512 bits.  The first padding bit must be a '1'.  The last 64
 *      bits represent the length of the original message.  All bits in
 *      between should be 0.  This function will pad the message
 *      according to those rules by filling the Message_Block array
 *      accordingly.  It will also call the ProcessMessageBlock function
 *      provided appropriately.  When it returns, it can be assumed that
 *      the message digest has been computed.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to pad
 *      ProcessMessageBlock: [in]
 *          The appropriate SHA*ProcessMessageBlock function
 *  Returns:
 *      Nothing.
 *
 */
void SHA1PadMessage(SHA1Context *context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context->Message_Block_Index > 55)
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 64)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
        SHA1ProcessMessageBlock(context);
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    else
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    /*
     *  Store the message length as the last 8 octets
     */
    context->Message_Block[56] = (uint8_t)(context->Length_High >> 24);
    context->Message_Block[57] = (uint8_t)(context->Length_High >> 16);
    context->Message_Block[58] = (uint8_t)(context->Length_High >> 8);
    context->Message_Block[59] = (uint8_t)(context->Length_High);
    context->Message_Block[60] = (uint8_t)(context->Length_Low >> 24);
    context->Message_Block[61] = (uint8_t)(context->Length_Low >> 16);
    context->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);
    context->Message_Block[63] = (uint8_t)(context->Length_Low);
    SHA1ProcessMessageBlock(context);
}
// $Log: sha1.c,v $
// Revision 1.5  2003/05/13 09:14:08  panther
// Remove carriage returns
//
// Revision 1.4  2003/03/25 08:45:57  panther
// Added CVS logging tag
//
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#if 0
#define UNROLL_LOOPS
#endif
#define SHA2_SOURCE
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef SHA2_H
#define SHA2_H
#ifdef SHA2_LOCAL
#  define SHA2_PROC   static
#else
#  ifdef SHA2_SOURCE
#    define SHA2_PROC   EXPORT_METHOD
#  else
#    define SHA2_PROC   IMPORT_METHOD
#  endif
#endif
#define SHA224_DIGEST_SIZE ( 224 / 8)
#define SHA256_DIGEST_SIZE ( 256 / 8)
#define SHA384_DIGEST_SIZE ( 384 / 8)
#define SHA512_DIGEST_SIZE ( 512 / 8)
#define SHA256_BLOCK_SIZE  ( 512 / 8)
#define SHA512_BLOCK_SIZE  (1024 / 8)
#define SHA384_BLOCK_SIZE  SHA512_BLOCK_SIZE
#define SHA224_BLOCK_SIZE  SHA256_BLOCK_SIZE
#ifndef SHA2_TYPES
#define SHA2_TYPES
typedef unsigned char uint8;
typedef unsigned int  uint32;
typedef unsigned long long uint64;
#endif
#ifdef __cplusplus
extern "C" {
#endif
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA256_BLOCK_SIZE];
    uint32 h[8];
}sha256_ctx;
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA512_BLOCK_SIZE];
    uint64 h[8];
}sha512_ctx;
typedef sha512_ctx sha384_ctx;
typedef sha256_ctx sha224_ctx;
SHA2_PROC void sha224_init(sha224_ctx *ctx);
SHA2_PROC void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha224_final(sha224_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha256_init(sha256_ctx * ctx);
SHA2_PROC void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha256_final(sha256_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha256(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha384_init(sha384_ctx *ctx);
SHA2_PROC void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha384_final(sha384_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha512_init(sha512_ctx *ctx);
SHA2_PROC void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha512_final(sha512_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest);
#ifdef __cplusplus
}
#endif
#endif
#ifdef __cplusplus
extern "C"{
#endif
#define SHFR(x, n)    (x >> n)
#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define CH(x, y, z)  ((x & y) ^ (~x & z))
#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))
#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))
#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))
#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))
#define SHA512_F1(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
#define SHA512_F2(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))
#define SHA512_F3(x) (ROTR(x,  1) ^ ROTR(x,  8) ^ SHFR(x,  7))
#define SHA512_F4(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHFR(x,  6))
#define UNPACK32(x, str)                      {                                                 *((str) + 3) = (uint8) ((x)      );           *((str) + 2) = (uint8) ((x) >>  8);           *((str) + 1) = (uint8) ((x) >> 16);           *((str) + 0) = (uint8) ((x) >> 24);       }
#define PACK32(str, x)                        {                                                 *(x) =   ((uint32) *((str) + 3)      )               | ((uint32) *((str) + 2) <<  8)               | ((uint32) *((str) + 1) << 16)               | ((uint32) *((str) + 0) << 24);   }
#define UNPACK64(x, str)                      {                                                 *((str) + 7) = (uint8) ((x)      );           *((str) + 6) = (uint8) ((x) >>  8);           *((str) + 5) = (uint8) ((x) >> 16);           *((str) + 4) = (uint8) ((x) >> 24);           *((str) + 3) = (uint8) ((x) >> 32);           *((str) + 2) = (uint8) ((x) >> 40);           *((str) + 1) = (uint8) ((x) >> 48);           *((str) + 0) = (uint8) ((x) >> 56);       }
#define PACK64(str, x)                        {                                                 *(x) =   ((uint64) *((str) + 7)      )               | ((uint64) *((str) + 6) <<  8)               | ((uint64) *((str) + 5) << 16)               | ((uint64) *((str) + 4) << 24)               | ((uint64) *((str) + 3) << 32)               | ((uint64) *((str) + 2) << 40)               | ((uint64) *((str) + 1) << 48)               | ((uint64) *((str) + 0) << 56);   }
/* Macros used for loops unrolling */
#define SHA256_SCR(i)                         {                                                 w[i] =  SHA256_F4(w[i -  2]) + w[i -  7]            + SHA256_F3(w[i - 15]) + w[i - 16]; }
#define SHA512_SCR(i)                         {                                                 w[i] =  SHA512_F4(w[i -  2]) + w[i -  7]            + SHA512_F3(w[i - 15]) + w[i - 16]; }
#define SHA256_EXP(a, b, c, d, e, f, g, h, j)               {                                                               t1 = wv[h] + SHA256_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha256_k[j] + w[j];                                  t2 = SHA256_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
#define SHA512_EXP(a, b, c, d, e, f, g ,h, j)               {                                                               t1 = wv[h] + SHA512_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha512_k[j] + w[j];                                  t2 = SHA512_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
static uint32 sha224_h0[8] =
            {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};
static uint32 sha256_h0[8] =
            {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
static uint64 sha384_h0[8] =
            {0xcbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL,
             0x9159015a3070dd17ULL, 0x152fecd8f70e5939ULL,
             0x67332667ffc00b31ULL, 0x8eb44a8768581511ULL,
             0xdb0c2e0d64f98fa7ULL, 0x47b5481dbefa4fa4ULL};
static uint64 sha512_h0[8] =
            {0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
             0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
             0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
             0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL};
static uint32 sha256_k[64] =
            {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
             0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
             0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
             0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
             0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
             0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
             0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
             0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
             0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
             0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
             0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
             0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
             0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
             0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
             0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
             0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
static uint64 sha512_k[80] =
            {0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
             0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
             0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
             0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
             0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
             0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
             0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
             0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
             0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
             0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
             0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
             0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
             0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
             0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
             0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
             0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
             0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
             0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
             0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
             0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
             0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
             0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
             0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
             0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
             0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
             0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
             0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
             0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
             0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
             0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
             0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
             0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
             0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
             0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
             0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
             0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
             0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
             0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
             0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
             0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL};
/* SHA-256 functions */
void sha256_transf(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint32 w[64];
    uint32 wv[8];
    uint32 t1, t2;
    const unsigned char *sub_block;
    int i;
#ifndef UNROLL_LOOPS
    int j;
#endif
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 6);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK32(&sub_block[j << 2], &w[j]);
        }
        for (j = 16; j < 64; j++) {
            SHA256_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 64; j++) {
            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha256_k[j] + w[j];
            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK32(&sub_block[ 0], &w[ 0]); PACK32(&sub_block[ 4], &w[ 1]);
        PACK32(&sub_block[ 8], &w[ 2]); PACK32(&sub_block[12], &w[ 3]);
        PACK32(&sub_block[16], &w[ 4]); PACK32(&sub_block[20], &w[ 5]);
        PACK32(&sub_block[24], &w[ 6]); PACK32(&sub_block[28], &w[ 7]);
        PACK32(&sub_block[32], &w[ 8]); PACK32(&sub_block[36], &w[ 9]);
        PACK32(&sub_block[40], &w[10]); PACK32(&sub_block[44], &w[11]);
        PACK32(&sub_block[48], &w[12]); PACK32(&sub_block[52], &w[13]);
        PACK32(&sub_block[56], &w[14]); PACK32(&sub_block[60], &w[15]);
        SHA256_SCR(16); SHA256_SCR(17); SHA256_SCR(18); SHA256_SCR(19);
        SHA256_SCR(20); SHA256_SCR(21); SHA256_SCR(22); SHA256_SCR(23);
        SHA256_SCR(24); SHA256_SCR(25); SHA256_SCR(26); SHA256_SCR(27);
        SHA256_SCR(28); SHA256_SCR(29); SHA256_SCR(30); SHA256_SCR(31);
        SHA256_SCR(32); SHA256_SCR(33); SHA256_SCR(34); SHA256_SCR(35);
        SHA256_SCR(36); SHA256_SCR(37); SHA256_SCR(38); SHA256_SCR(39);
        SHA256_SCR(40); SHA256_SCR(41); SHA256_SCR(42); SHA256_SCR(43);
        SHA256_SCR(44); SHA256_SCR(45); SHA256_SCR(46); SHA256_SCR(47);
        SHA256_SCR(48); SHA256_SCR(49); SHA256_SCR(50); SHA256_SCR(51);
        SHA256_SCR(52); SHA256_SCR(53); SHA256_SCR(54); SHA256_SCR(55);
        SHA256_SCR(56); SHA256_SCR(57); SHA256_SCR(58); SHA256_SCR(59);
        SHA256_SCR(60); SHA256_SCR(61); SHA256_SCR(62); SHA256_SCR(63);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        SHA256_EXP(0,1,2,3,4,5,6,7, 0); SHA256_EXP(7,0,1,2,3,4,5,6, 1);
        SHA256_EXP(6,7,0,1,2,3,4,5, 2); SHA256_EXP(5,6,7,0,1,2,3,4, 3);
        SHA256_EXP(4,5,6,7,0,1,2,3, 4); SHA256_EXP(3,4,5,6,7,0,1,2, 5);
        SHA256_EXP(2,3,4,5,6,7,0,1, 6); SHA256_EXP(1,2,3,4,5,6,7,0, 7);
        SHA256_EXP(0,1,2,3,4,5,6,7, 8); SHA256_EXP(7,0,1,2,3,4,5,6, 9);
        SHA256_EXP(6,7,0,1,2,3,4,5,10); SHA256_EXP(5,6,7,0,1,2,3,4,11);
        SHA256_EXP(4,5,6,7,0,1,2,3,12); SHA256_EXP(3,4,5,6,7,0,1,2,13);
        SHA256_EXP(2,3,4,5,6,7,0,1,14); SHA256_EXP(1,2,3,4,5,6,7,0,15);
        SHA256_EXP(0,1,2,3,4,5,6,7,16); SHA256_EXP(7,0,1,2,3,4,5,6,17);
        SHA256_EXP(6,7,0,1,2,3,4,5,18); SHA256_EXP(5,6,7,0,1,2,3,4,19);
        SHA256_EXP(4,5,6,7,0,1,2,3,20); SHA256_EXP(3,4,5,6,7,0,1,2,21);
        SHA256_EXP(2,3,4,5,6,7,0,1,22); SHA256_EXP(1,2,3,4,5,6,7,0,23);
        SHA256_EXP(0,1,2,3,4,5,6,7,24); SHA256_EXP(7,0,1,2,3,4,5,6,25);
        SHA256_EXP(6,7,0,1,2,3,4,5,26); SHA256_EXP(5,6,7,0,1,2,3,4,27);
        SHA256_EXP(4,5,6,7,0,1,2,3,28); SHA256_EXP(3,4,5,6,7,0,1,2,29);
        SHA256_EXP(2,3,4,5,6,7,0,1,30); SHA256_EXP(1,2,3,4,5,6,7,0,31);
        SHA256_EXP(0,1,2,3,4,5,6,7,32); SHA256_EXP(7,0,1,2,3,4,5,6,33);
        SHA256_EXP(6,7,0,1,2,3,4,5,34); SHA256_EXP(5,6,7,0,1,2,3,4,35);
        SHA256_EXP(4,5,6,7,0,1,2,3,36); SHA256_EXP(3,4,5,6,7,0,1,2,37);
        SHA256_EXP(2,3,4,5,6,7,0,1,38); SHA256_EXP(1,2,3,4,5,6,7,0,39);
        SHA256_EXP(0,1,2,3,4,5,6,7,40); SHA256_EXP(7,0,1,2,3,4,5,6,41);
        SHA256_EXP(6,7,0,1,2,3,4,5,42); SHA256_EXP(5,6,7,0,1,2,3,4,43);
        SHA256_EXP(4,5,6,7,0,1,2,3,44); SHA256_EXP(3,4,5,6,7,0,1,2,45);
        SHA256_EXP(2,3,4,5,6,7,0,1,46); SHA256_EXP(1,2,3,4,5,6,7,0,47);
        SHA256_EXP(0,1,2,3,4,5,6,7,48); SHA256_EXP(7,0,1,2,3,4,5,6,49);
        SHA256_EXP(6,7,0,1,2,3,4,5,50); SHA256_EXP(5,6,7,0,1,2,3,4,51);
        SHA256_EXP(4,5,6,7,0,1,2,3,52); SHA256_EXP(3,4,5,6,7,0,1,2,53);
        SHA256_EXP(2,3,4,5,6,7,0,1,54); SHA256_EXP(1,2,3,4,5,6,7,0,55);
        SHA256_EXP(0,1,2,3,4,5,6,7,56); SHA256_EXP(7,0,1,2,3,4,5,6,57);
        SHA256_EXP(6,7,0,1,2,3,4,5,58); SHA256_EXP(5,6,7,0,1,2,3,4,59);
        SHA256_EXP(4,5,6,7,0,1,2,3,60); SHA256_EXP(3,4,5,6,7,0,1,2,61);
        SHA256_EXP(2,3,4,5,6,7,0,1,62); SHA256_EXP(1,2,3,4,5,6,7,0,63);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha256(const unsigned char *message, unsigned int len, unsigned char *digest)
{
    sha256_ctx ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, message, len);
    sha256_final(&ctx, digest);
}
void sha256_init(sha256_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha256_h0[i];
    }
#else
    ctx->h[0] = sha256_h0[0]; ctx->h[1] = sha256_h0[1];
    ctx->h[2] = sha256_h0[2]; ctx->h[3] = sha256_h0[3];
    ctx->h[4] = sha256_h0[4]; ctx->h[5] = sha256_h0[5];
    ctx->h[6] = sha256_h0[6]; ctx->h[7] = sha256_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA256_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA256_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA256_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA256_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha256_final(sha256_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)
                     < (ctx->len % SHA256_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
   UNPACK32(ctx->h[7], &digest[28]);
#endif
}
/* SHA-512 functions */
void sha512_transf(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint64 w[80];
    uint64 wv[8];
    uint64 t1, t2;
    const unsigned char *sub_block;
    int i, j;
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 7);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK64(&sub_block[j << 3], &w[j]);
        }
        for (j = 16; j < 80; j++) {
            SHA512_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 80; j++) {
            t1 = wv[7] + SHA512_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha512_k[j] + w[j];
            t2 = SHA512_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK64(&sub_block[  0], &w[ 0]); PACK64(&sub_block[  8], &w[ 1]);
        PACK64(&sub_block[ 16], &w[ 2]); PACK64(&sub_block[ 24], &w[ 3]);
        PACK64(&sub_block[ 32], &w[ 4]); PACK64(&sub_block[ 40], &w[ 5]);
        PACK64(&sub_block[ 48], &w[ 6]); PACK64(&sub_block[ 56], &w[ 7]);
        PACK64(&sub_block[ 64], &w[ 8]); PACK64(&sub_block[ 72], &w[ 9]);
        PACK64(&sub_block[ 80], &w[10]); PACK64(&sub_block[ 88], &w[11]);
        PACK64(&sub_block[ 96], &w[12]); PACK64(&sub_block[104], &w[13]);
        PACK64(&sub_block[112], &w[14]); PACK64(&sub_block[120], &w[15]);
        SHA512_SCR(16); SHA512_SCR(17); SHA512_SCR(18); SHA512_SCR(19);
        SHA512_SCR(20); SHA512_SCR(21); SHA512_SCR(22); SHA512_SCR(23);
        SHA512_SCR(24); SHA512_SCR(25); SHA512_SCR(26); SHA512_SCR(27);
        SHA512_SCR(28); SHA512_SCR(29); SHA512_SCR(30); SHA512_SCR(31);
        SHA512_SCR(32); SHA512_SCR(33); SHA512_SCR(34); SHA512_SCR(35);
        SHA512_SCR(36); SHA512_SCR(37); SHA512_SCR(38); SHA512_SCR(39);
        SHA512_SCR(40); SHA512_SCR(41); SHA512_SCR(42); SHA512_SCR(43);
        SHA512_SCR(44); SHA512_SCR(45); SHA512_SCR(46); SHA512_SCR(47);
        SHA512_SCR(48); SHA512_SCR(49); SHA512_SCR(50); SHA512_SCR(51);
        SHA512_SCR(52); SHA512_SCR(53); SHA512_SCR(54); SHA512_SCR(55);
        SHA512_SCR(56); SHA512_SCR(57); SHA512_SCR(58); SHA512_SCR(59);
        SHA512_SCR(60); SHA512_SCR(61); SHA512_SCR(62); SHA512_SCR(63);
        SHA512_SCR(64); SHA512_SCR(65); SHA512_SCR(66); SHA512_SCR(67);
        SHA512_SCR(68); SHA512_SCR(69); SHA512_SCR(70); SHA512_SCR(71);
        SHA512_SCR(72); SHA512_SCR(73); SHA512_SCR(74); SHA512_SCR(75);
        SHA512_SCR(76); SHA512_SCR(77); SHA512_SCR(78); SHA512_SCR(79);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        j = 0;
        do {
            SHA512_EXP(0,1,2,3,4,5,6,7,j); j++;
            SHA512_EXP(7,0,1,2,3,4,5,6,j); j++;
            SHA512_EXP(6,7,0,1,2,3,4,5,j); j++;
            SHA512_EXP(5,6,7,0,1,2,3,4,j); j++;
            SHA512_EXP(4,5,6,7,0,1,2,3,j); j++;
            SHA512_EXP(3,4,5,6,7,0,1,2,j); j++;
            SHA512_EXP(2,3,4,5,6,7,0,1,j); j++;
            SHA512_EXP(1,2,3,4,5,6,7,0,j); j++;
        } while (j < 80);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha512_ctx ctx;
    sha512_init(&ctx);
    sha512_update(&ctx, message, len);
    sha512_final(&ctx, digest);
}
void sha512_init(sha512_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha512_h0[i];
    }
#else
    ctx->h[0] = sha512_h0[0]; ctx->h[1] = sha512_h0[1];
    ctx->h[2] = sha512_h0[2]; ctx->h[3] = sha512_h0[3];
    ctx->h[4] = sha512_h0[4]; ctx->h[5] = sha512_h0[5];
    ctx->h[6] = sha512_h0[6]; ctx->h[7] = sha512_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA512_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA512_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA512_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA512_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha512_final(sha512_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = 1 + ((SHA512_BLOCK_SIZE - 17)
                     < (ctx->len % SHA512_BLOCK_SIZE));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
    UNPACK64(ctx->h[6], &digest[48]);
    UNPACK64(ctx->h[7], &digest[56]);
#endif
}
/* SHA-384 functions */
void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha384_ctx ctx;
    sha384_init(&ctx);
    sha384_update(&ctx, message, len);
    sha384_final(&ctx, digest);
}
void sha384_init(sha384_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha384_h0[i];
    }
#else
    ctx->h[0] = sha384_h0[0]; ctx->h[1] = sha384_h0[1];
    ctx->h[2] = sha384_h0[2]; ctx->h[3] = sha384_h0[3];
    ctx->h[4] = sha384_h0[4]; ctx->h[5] = sha384_h0[5];
    ctx->h[6] = sha384_h0[6]; ctx->h[7] = sha384_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA384_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA384_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA384_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA384_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha384_final(sha384_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA384_BLOCK_SIZE - 17)
                     < (ctx->len % SHA384_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 6; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
#endif
}
/* SHA-224 functions */
void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha224_ctx ctx;
    sha224_init(&ctx);
    sha224_update(&ctx, message, len);
    sha224_final(&ctx, digest);
}
void sha224_init(sha224_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha224_h0[i];
    }
#else
    ctx->h[0] = sha224_h0[0]; ctx->h[1] = sha224_h0[1];
    ctx->h[2] = sha224_h0[2]; ctx->h[3] = sha224_h0[3];
    ctx->h[4] = sha224_h0[4]; ctx->h[5] = sha224_h0[5];
    ctx->h[6] = sha224_h0[6]; ctx->h[7] = sha224_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA224_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA224_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA224_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA224_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha224_final(sha224_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA224_BLOCK_SIZE - 9)
                     < (ctx->len % SHA224_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 7; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
#endif
}
#ifdef TEST_VECTORS
/* FIPS 180-2 Validation tests */
void test(const char *vector, unsigned char *digest,
          unsigned int digest_size)
{
    char output[2 * SHA512_DIGEST_SIZE + 1];
    int i;
    output[2 * digest_size] = '\0';
    for (i = 0; i < (int) digest_size ; i++) {
       sprintf(output + 2 * i, "%02x", digest[i]);
    }
    printf("H: %s\n", output);
    if (strcmp(vector, output)) {
        fprintf(stderr, "Test failed.\n");
        exit(EXIT_FAILURE);
    }
}
int main(void)
{
    static const char *vectors[4][3] =
    {
        {
        "23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7",
        "75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525",
        "20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67",
        },
        /* SHA-256 */
        {
        "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
        "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
        "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0",
        },
        /* SHA-384 */
        {
        "cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed"
        "8086072ba1e7cc2358baeca134c825a7",
        "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712"
        "fcc7c71a557e2db966c3e9fa91746039",
        "9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b"
        "07b8b3dc38ecc4ebae97ddd87f3d8985",
        },
        /* SHA-512 */
        {
        "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a"
        "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f",
        "8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018"
        "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909",
        "e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb"
        "de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"
        }
    };
    static const char message1[] = "abc";
    static const char message2a[] = "abcdbcdecdefdefgefghfghighijhi"
                                    "jkijkljklmklmnlmnomnopnopq";
    static const char message2b[] = "abcdefghbcdefghicdefghijdefghijkefghij"
                                    "klfghijklmghijklmnhijklmnoijklmnopjklm"
                                    "nopqklmnopqrlmnopqrsmnopqrstnopqrstu";
    unsigned char *message3;
    unsigned int message3_len = 1000000;
    unsigned char digest[SHA512_DIGEST_SIZE];
    message3 = malloc(message3_len);
    if (message3 == NULL) {
        fprintf(stderr, "Can't allocate memory\n");
        return -1;
    }
    memset(message3, 'a', message3_len);
    printf("SHA-2 FIPS 180-2 Validation tests\n\n");
    printf("SHA-224 Test vectors\n");
    sha224((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[0][0], digest, SHA224_DIGEST_SIZE);
    sha224((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[0][1], digest, SHA224_DIGEST_SIZE);
    sha224(message3, message3_len, digest);
    test(vectors[0][2], digest, SHA224_DIGEST_SIZE);
    printf("\n");
    printf("SHA-256 Test vectors\n");
    sha256((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[1][0], digest, SHA256_DIGEST_SIZE);
    sha256((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[1][1], digest, SHA256_DIGEST_SIZE);
    sha256(message3, message3_len, digest);
    test(vectors[1][2], digest, SHA256_DIGEST_SIZE);
    printf("\n");
    printf("SHA-384 Test vectors\n");
    sha384((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[2][0], digest, SHA384_DIGEST_SIZE);
    sha384((const unsigned char *)message2b, strlen(message2b), digest);
    test(vectors[2][1], digest, SHA384_DIGEST_SIZE);
    sha384(message3, message3_len, digest);
    test(vectors[2][2], digest, SHA384_DIGEST_SIZE);
    printf("\n");
    printf("SHA-512 Test vectors\n");
    sha512((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[3][0], digest, SHA512_DIGEST_SIZE);
    sha512((const unsigned char *) message2b, strlen(message2b), digest);
    test(vectors[3][1], digest, SHA512_DIGEST_SIZE);
    sha512(message3, message3_len, digest);
    test(vectors[3][2], digest, SHA512_DIGEST_SIZE);
    printf("\n");
    printf("All tests passed.\n");
    return 0;
}
#endif
#ifdef __cplusplus
}
#endif
// http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.c  2017/19/12
// sha3.c
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// Revised 07-Aug-15 to match with official release of FIPS PUB 202 "SHA3"
// Revised 03-Sep-15 for portability + OpenSSL - style API
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.h  2017/19/12
// sha3.h
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
#ifndef SHA3_H
#define SHA3_H
#ifndef KECCAKF_ROUNDS
#define KECCAKF_ROUNDS 24
#endif
#ifndef ROTL64
#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))
#endif
// state context
typedef struct {
                                 // state:
    union {
                     // 8-bit bytes
        uint8_t b[200];
                     // 64-bit words
        uint64_t q[25];
    } st;
                    // these don't overflow
    int pt, rsiz, mdlen;
} sha3_ctx_t;
// Compression function.
void sha3_keccakf(uint64_t st[25]);
// OpenSSL - like interfece
    // mdlen = hash output in bytes
int sha3_init(sha3_ctx_t *c, int mdlen);
int sha3_update(sha3_ctx_t *c, const void *data, size_t len);
    // digest goes to md
int sha3_final(sha3_ctx_t *c, void *md );
// compute a sha3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen);
// SHAKE128 and SHAKE256 extensible-output functions
#define shake128_init(c) sha3_init(c, 16)
#define shake256_init(c) sha3_init(c, 32)
#define shake_update sha3_update
void shake_xof(sha3_ctx_t *c);
void shake_out(sha3_ctx_t *c, void *out, size_t len);
#endif
// update the state with given number of rounds
void sha3_keccakf(uint64_t st[25])
{
    // constants
    const uint64_t keccakf_rndc[24] = {
        0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
        0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
        0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
        0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
        0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
        0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
        0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
        0x8000000000008080, 0x0000000080000001, 0x8000000080008008
    };
    const int keccakf_rotc[24] = {
        1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14,
        27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44
    };
    const int keccakf_piln[24] = {
        10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4,
        15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1
    };
    // variables
    int i, j, r;
    uint64_t t, bc[5];
#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
    uint8_t *v;
    // endianess conversion. this is redundant on little-endian targets
    for (i = 0; i < 25; i++) {
        v = (uint8_t *) &st[i];
        st[i] = ((uint64_t) v[0])     | (((uint64_t) v[1]) << 8) |
            (((uint64_t) v[2]) << 16) | (((uint64_t) v[3]) << 24) |
            (((uint64_t) v[4]) << 32) | (((uint64_t) v[5]) << 40) |
            (((uint64_t) v[6]) << 48) | (((uint64_t) v[7]) << 56);
    }
#endif
    // actual iteration
    for (r = 0; r < KECCAKF_ROUNDS; r++) {
        // Theta
        for (i = 0; i < 5; i++)
            bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];
        for (i = 0; i < 5; i++) {
            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);
            for (j = 0; j < 25; j += 5)
                st[j + i] ^= t;
        }
        // Rho Pi
        t = st[1];
        for (i = 0; i < 24; i++) {
            j = keccakf_piln[i];
            bc[0] = st[j];
            st[j] = ROTL64(t, keccakf_rotc[i]);
            t = bc[0];
        }
        //  Chi
        for (j = 0; j < 25; j += 5) {
            for (i = 0; i < 5; i++)
                bc[i] = st[j + i];
            for (i = 0; i < 5; i++)
                st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
        }
        //  Iota
        st[0] ^= keccakf_rndc[r];
    }
#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
    // endianess conversion. this is redundant on little-endian targets
    for (i = 0; i < 25; i++) {
        v = (uint8_t *) &st[i];
        t = st[i];
        v[0] = t & 0xFF;
        v[1] = (t >> 8) & 0xFF;
        v[2] = (t >> 16) & 0xFF;
        v[3] = (t >> 24) & 0xFF;
        v[4] = (t >> 32) & 0xFF;
        v[5] = (t >> 40) & 0xFF;
        v[6] = (t >> 48) & 0xFF;
        v[7] = (t >> 56) & 0xFF;
    }
#endif
}
// Initialize the context for SHA3
int sha3_init(sha3_ctx_t *c, int mdlen)
{
    int i;
	if( mdlen > 100 )
        mdlen = 100;
    for (i = 0; i < 25; i++)
        c->st.q[i] = 0;
    c->mdlen = mdlen;
    c->rsiz = 200 - 2 * mdlen;
    c->pt = 0;
    return 1;
}
// update state with more data
int sha3_update(sha3_ctx_t *c, const void *data, size_t len)
{
    size_t i;
    int j;
    j = c->pt;
    for (i = 0; i < len; i++) {
        c->st.b[j++] ^= ((const uint8_t *) data)[i];
        if (j >= c->rsiz) {
            sha3_keccakf(c->st.q);
            j = 0;
        }
    }
    c->pt = j;
    return 1;
}
// finalize and output a hash
int sha3_final( sha3_ctx_t *c, void *md )
{
    int i;
    c->st.b[c->pt] ^= 0x06;
    c->st.b[c->rsiz - 1] ^= 0x80;
    sha3_keccakf(c->st.q);
    for (i = 0; i < c->mdlen; i++) {
        ((uint8_t *) md)[i] = c->st.b[i];
    }
    return 1;
}
// compute a SHA-3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen)
{
    sha3_ctx_t sha3;
    sha3_init(&sha3, mdlen);
    sha3_update(&sha3, in, inlen);
    sha3_final(&sha3, md);
    return md;
}
// SHAKE128 and SHAKE256 extensible-output functionality
void shake_xof(sha3_ctx_t *c)
{
    c->st.b[c->pt] ^= 0x1F;
    c->st.b[c->rsiz - 1] ^= 0x80;
    sha3_keccakf(c->st.q);
    c->pt = 0;
}
void shake_out(sha3_ctx_t *c, void *out, size_t len)
{
    size_t i;
    int j;
    j = c->pt;
    for (i = 0; i < len; i++) {
        if (j >= c->rsiz) {
            sha3_keccakf(c->st.q);
            j = 0;
        }
        ((uint8_t *) out)[i] = c->st.b[j++];
    }
    c->pt = j;
}
/*
Implementation by Ronny Van Keer, hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
*/
#ifdef __64__
/*
Implementation by the Keccak Team, namely, Guido Bertoni, Joan Daemen,
Michal Peeters, Gilles Van Assche and Ronny Van Keer,
hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
---
Please refer to the XKCP for more details.
*/
#ifndef _KeccakP_1600_SnP_h_
#define _KeccakP_1600_SnP_h_
/*
 ---------------------------------------------------------------------------
 Copyright (c) 1998-2008, Brian Gladman, Worcester, UK. All rights reserved.
 LICENSE TERMS
 The redistribution and use of this software (with or without changes)
 is allowed without the payment of fees or royalties provided that:
  1. source code distributions include the above copyright notice, this
     list of conditions and the following disclaimer;
  2. binary distributions include the above copyright notice, this list
     of conditions and the following disclaimer in their documentation;
  3. the name of the copyright holder is not used to endorse products
     built using this software without specific written permission.
 DISCLAIMER
 This software is provided 'as is' with no explicit or implied warranties
 in respect of its properties, including, but not limited to, correctness
 and/or fitness for purpose.
 ---------------------------------------------------------------------------
 Issue Date: 20/12/2007
 Changes for ARM 9/9/2010
*/
#ifndef _BRG_ENDIAN_H
#define _BRG_ENDIAN_H
#define IS_BIG_ENDIAN      4321
#define IS_LITTLE_ENDIAN   1234
#if 0
/* Include files where endian defines and byteswap functions may reside */
#if defined( __sun )
#  include <sys/isa_defs.h>
#elif defined( __FreeBSD__ ) || defined( __OpenBSD__ ) || defined( __NetBSD__ )
#  include <sys/endian.h>
#elif defined( BSD ) && ( BSD >= 199103 ) || defined( __APPLE__ ) ||       defined( __CYGWIN32__ ) || defined( __DJGPP__ ) || defined( __osf__ )
#  include <machine/endian.h>
#elif defined( __linux__ ) || defined( __GNUC__ ) || defined( __GNU_LIBRARY__ )
#  if !defined( __MINGW32__ ) && !defined( _AIX )
#    include <endian.h>
#    if !defined( __BEOS__ )
#      include <byteswap.h>
#    endif
#  endif
#endif
#endif
/* Now attempt to set the define for platform byte order using any  */
/* of the four forms SYMBOL, _SYMBOL, __SYMBOL & __SYMBOL__, which  */
/* seem to encompass most endian symbol definitions                 */
#if defined( BIG_ENDIAN ) && defined( LITTLE_ENDIAN )
#  if defined( BYTE_ORDER ) && BYTE_ORDER == BIG_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#  elif defined( BYTE_ORDER ) && BYTE_ORDER == LITTLE_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#  endif
#elif defined( BIG_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#elif defined( LITTLE_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#endif
#if defined( _BIG_ENDIAN ) && defined( _LITTLE_ENDIAN )
#  if defined( _BYTE_ORDER ) && _BYTE_ORDER == _BIG_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#  elif defined( _BYTE_ORDER ) && _BYTE_ORDER == _LITTLE_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#  endif
#elif defined( _BIG_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#elif defined( _LITTLE_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#endif
#if defined( __BIG_ENDIAN ) && defined( __LITTLE_ENDIAN )
#  if defined( __BYTE_ORDER ) && __BYTE_ORDER == __BIG_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#  elif defined( __BYTE_ORDER ) && __BYTE_ORDER == __LITTLE_ENDIAN
#    define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#  endif
#elif defined( __BIG_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#elif defined( __LITTLE_ENDIAN )
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#endif
#if defined( __BIG_ENDIAN__ ) && defined( __LITTLE_ENDIAN__ )
#  if defined( __BYTE_ORDER__ ) && __BYTE_ORDER__ == __BIG_ENDIAN__
#    define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#  elif defined( __BYTE_ORDER__ ) && __BYTE_ORDER__ == __LITTLE_ENDIAN__
#    define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#  endif
#elif defined( __BIG_ENDIAN__ )
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#elif defined( __LITTLE_ENDIAN__ )
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#endif
/*  if the platform byte order could not be determined, then try to */
/*  set this define using common machine defines                    */
#if !defined(PLATFORM_BYTE_ORDER)
#if   defined( __alpha__ ) || defined( __alpha ) || defined( i386 )       ||       defined( __i386__ )  || defined( _M_I86 )  || defined( _M_IX86 )    ||       defined( __OS2__ )   || defined( sun386 )  || defined( __TURBOC__ ) ||       defined( vax )       || defined( vms )     || defined( VMS )        ||       defined( __VMS )     || defined( _M_X64 )
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#elif defined( AMIGA )    || defined( applec )    || defined( __AS400__ )  ||       defined( _CRAY )    || defined( __hppa )    || defined( __hp9000 )   ||       defined( ibm370 )   || defined( mc68000 )   || defined( m68k )       ||       defined( __MRC__ )  || defined( __MVS__ )   || defined( __MWERKS__ ) ||       defined( sparc )    || defined( __sparc)    || defined( SYMANTEC_C ) ||       defined( __VOS__ )  || defined( __TIGCC__ ) || defined( __TANDEM )   ||       defined( THINK_C )  || defined( __VMCMS__ ) || defined( _AIX )       ||       defined( __s390__ ) || defined( __s390x__ ) || defined( __zarch__ )
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#elif defined(__arm__)
# ifdef __BIG_ENDIAN
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
# else
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
# endif
#elif 1
#  define PLATFORM_BYTE_ORDER IS_LITTLE_ENDIAN
#elif 0
#  define PLATFORM_BYTE_ORDER IS_BIG_ENDIAN
#else
#  error Please edit lines 132 or 134 in brg_endian.h to set the platform byte order
#endif
#endif
#endif
#define KeccakP1600_implementation_config "all rounds unrolled"
#define KeccakP1600_fullUnrolling
/* Or */
/*
#define KeccakP1600_implementation_config "6 rounds unrolled"
#define KeccakP1600_unrolling 6
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, 6 rounds unrolled"
#define KeccakP1600_unrolling 6
#define KeccakP1600_useLaneComplementing
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, all rounds unrolled"
#define KeccakP1600_fullUnrolling
#define KeccakP1600_useLaneComplementing
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, all rounds unrolled, using SHLD for rotations"
#define KeccakP1600_fullUnrolling
#define KeccakP1600_useLaneComplementing
#define KeccakP1600_useSHLD
*/
#define KeccakP1600_implementation      "generic 64-bit optimized implementation (" KeccakP1600_implementation_config ")"
#define KeccakP1600_stateSizeInBytes    200
#define KeccakP1600_stateAlignment      8
#define KeccakF1600_FastLoop_supported
#define KeccakP1600_12rounds_FastLoop_supported
#define KeccakP1600_StaticInitialize()
void KeccakP1600_Initialize(void *state);
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
#define KeccakP1600_AddByte(state, byte, offset)     ((unsigned char*)(state))[(offset)] ^= (byte)
#else
void KeccakP1600_AddByte(void *state, unsigned char data, unsigned int offset);
#endif
void KeccakP1600_AddBytes(void *state, const unsigned char *data, unsigned int offset, unsigned int length);
void KeccakP1600_Permute_12rounds(void *state);
void KeccakP1600_ExtractBytes(const void *state, unsigned char *data, unsigned int offset, unsigned int length);
size_t KeccakP1600_12rounds_FastLoop_Absorb(void *state, unsigned int laneCount, const unsigned char *data, size_t dataByteLen);
#endif
#define KeccakP1600_implementation_config "all rounds unrolled"
#define KeccakP1600_fullUnrolling
/* Or */
/*
#define KeccakP1600_implementation_config "6 rounds unrolled"
#define KeccakP1600_unrolling 6
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, 6 rounds unrolled"
#define KeccakP1600_unrolling 6
#define KeccakP1600_useLaneComplementing
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, all rounds unrolled"
#define KeccakP1600_fullUnrolling
#define KeccakP1600_useLaneComplementing
*/
/* Or */
/*
#define KeccakP1600_implementation_config "lane complementing, all rounds unrolled, using SHLD for rotations"
#define KeccakP1600_fullUnrolling
#define KeccakP1600_useLaneComplementing
#define KeccakP1600_useSHLD
*/
/*
Implementation by the Keccak Team, namely, Guido Bertoni, Joan Daemen,
Michal Peeters, Gilles Van Assche and Ronny Van Keer,
hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
---
Please refer to the XKCP for more details.
*/
typedef unsigned char UINT8;
typedef unsigned long long int UINT64;
#if defined(KeccakP1600_useLaneComplementing)
#define UseBebigokimisa
#endif
#if defined(_MSC_VER )
#define ROL64(a, offset) ((((UINT64)a) << offset) | (((UINT64)a) >> (64-offset)))
//#define ROL64(a, offset) ( ( offset == 1 ) ? ( ( (a) & 0x8000000000000000ULL ) ? ((a) = (((a) << 1)|1)) : ( (a)<<1)  ) : ( _rotl64(a, offset) ) )
//#define ROL64(a, offset)  _rotl64(a, offset)
#elif defined(KeccakP1600_useSHLD)
    #define ROL64(x,N) ({     register UINT64 __out;     register UINT64 __in = x;     __asm__ ("shld %2,%0,%0" : "=r"(__out) : "0"(__in), "i"(N));     __out;     })
#else
#define ROL64(a, offset) ((((UINT64)a) << offset) | (((UINT64)a) >> (64-offset)))
#endif
#ifdef KeccakP1600_fullUnrolling
#define FullUnrolling
#else
#define Unrolling KeccakP1600_unrolling
#endif
static const UINT64 KeccakF1600RoundConstants[24] = {
    0x0000000000000001ULL,
    0x0000000000008082ULL,
    0x800000000000808aULL,
    0x8000000080008000ULL,
    0x000000000000808bULL,
    0x0000000080000001ULL,
    0x8000000080008081ULL,
    0x8000000000008009ULL,
    0x000000000000008aULL,
    0x0000000000000088ULL,
    0x0000000080008009ULL,
    0x000000008000000aULL,
    0x000000008000808bULL,
    0x800000000000008bULL,
    0x8000000000008089ULL,
    0x8000000000008003ULL,
    0x8000000000008002ULL,
    0x8000000000000080ULL,
    0x000000000000800aULL,
    0x800000008000000aULL,
    0x8000000080008081ULL,
    0x8000000000008080ULL,
    0x0000000080000001ULL,
    0x8000000080008008ULL };
/* ---------------------------------------------------------------- */
void KeccakP1600_Initialize(void *state)
{
    memset(state, 0, 200);
#ifdef KeccakP1600_useLaneComplementing
    ((UINT64*)state)[ 1] = ~(UINT64)0;
    ((UINT64*)state)[ 2] = ~(UINT64)0;
    ((UINT64*)state)[ 8] = ~(UINT64)0;
    ((UINT64*)state)[12] = ~(UINT64)0;
    ((UINT64*)state)[17] = ~(UINT64)0;
    ((UINT64*)state)[20] = ~(UINT64)0;
#endif
}
/* ---------------------------------------------------------------- */
void KeccakP1600_AddBytesInLane(void *state, unsigned int lanePosition, const unsigned char *data, unsigned int offset, unsigned int length)
{
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    UINT64 lane;
    if (length == 0)
        return;
    if (length == 1)
        lane = data[0];
    else {
        lane = 0;
        memcpy(&lane, data, length);
    }
    lane <<= offset*8;
#else
    UINT64 lane = 0;
    unsigned int i;
    for(i=0; i<length; i++)
        lane |= ((UINT64)data[i]) << ((i+offset)*8);
#endif
    ((UINT64*)state)[lanePosition] ^= lane;
}
/* ---------------------------------------------------------------- */
void KeccakP1600_AddLanes(void *state, const unsigned char *data, unsigned int laneCount)
{
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    unsigned int i = 0;
#ifdef NO_MISALIGNED_ACCESSES
    /* If either pointer is misaligned, fall back to byte-wise xor. */
    if (((((uintptr_t)state) & 7) != 0) || ((((uintptr_t)data) & 7) != 0)) {
      for (i = 0; i < laneCount * 8; i++) {
        ((unsigned char*)state)[i] ^= data[i];
      }
    }
    else
#endif
    {
      /* Otherwise... */
      for( ; (i+8)<=laneCount; i+=8) {
          ((UINT64*)state)[i+0] ^= ((UINT64*)data)[i+0];
          ((UINT64*)state)[i+1] ^= ((UINT64*)data)[i+1];
          ((UINT64*)state)[i+2] ^= ((UINT64*)data)[i+2];
          ((UINT64*)state)[i+3] ^= ((UINT64*)data)[i+3];
          ((UINT64*)state)[i+4] ^= ((UINT64*)data)[i+4];
          ((UINT64*)state)[i+5] ^= ((UINT64*)data)[i+5];
          ((UINT64*)state)[i+6] ^= ((UINT64*)data)[i+6];
          ((UINT64*)state)[i+7] ^= ((UINT64*)data)[i+7];
      }
      for( ; (i+4)<=laneCount; i+=4) {
          ((UINT64*)state)[i+0] ^= ((UINT64*)data)[i+0];
          ((UINT64*)state)[i+1] ^= ((UINT64*)data)[i+1];
          ((UINT64*)state)[i+2] ^= ((UINT64*)data)[i+2];
          ((UINT64*)state)[i+3] ^= ((UINT64*)data)[i+3];
      }
      for( ; (i+2)<=laneCount; i+=2) {
          ((UINT64*)state)[i+0] ^= ((UINT64*)data)[i+0];
          ((UINT64*)state)[i+1] ^= ((UINT64*)data)[i+1];
      }
      if (i<laneCount) {
          ((UINT64*)state)[i+0] ^= ((UINT64*)data)[i+0];
      }
    }
#else
    unsigned int i;
    const UINT8 *curData = data;
    for(i=0; i<laneCount; i++, curData+=8) {
        UINT64 lane = (UINT64)curData[0]
            | ((UINT64)curData[1] <<  8)
            | ((UINT64)curData[2] << 16)
            | ((UINT64)curData[3] << 24)
            | ((UINT64)curData[4] << 32)
            | ((UINT64)curData[5] << 40)
            | ((UINT64)curData[6] << 48)
            | ((UINT64)curData[7] << 56);
        ((UINT64*)state)[i] ^= lane;
    }
#endif
}
/* ---------------------------------------------------------------- */
#if (PLATFORM_BYTE_ORDER != IS_LITTLE_ENDIAN)
void KeccakP1600_AddByte(void *state, unsigned char byte, unsigned int offset)
{
    UINT64 lane = byte;
    lane <<= (offset%8)*8;
    ((UINT64*)state)[offset/8] ^= lane;
}
#endif
/* ---------------------------------------------------------------- */
#define SnP_AddBytes(state, data, offset, length, SnP_AddLanes, SnP_AddBytesInLane, SnP_laneLengthInBytes)     {         if ((offset) == 0) {             SnP_AddLanes(state, data, (length)/SnP_laneLengthInBytes);             SnP_AddBytesInLane(state,                 (length)/SnP_laneLengthInBytes,                 (data)+((length)/SnP_laneLengthInBytes)*SnP_laneLengthInBytes,                 0,                 (length)%SnP_laneLengthInBytes);         }         else {             unsigned int _sizeLeft = (length);             unsigned int _lanePosition = (offset)/SnP_laneLengthInBytes;             unsigned int _offsetInLane = (offset)%SnP_laneLengthInBytes;             const unsigned char *_curData = (data);             while(_sizeLeft > 0) {                 unsigned int _bytesInLane = SnP_laneLengthInBytes - _offsetInLane;                 if (_bytesInLane > _sizeLeft)                     _bytesInLane = _sizeLeft;                 SnP_AddBytesInLane(state, _lanePosition, _curData, _offsetInLane, _bytesInLane);                 _sizeLeft -= _bytesInLane;                 _lanePosition++;                 _offsetInLane = 0;                 _curData += _bytesInLane;             }         }     }
void KeccakP1600_AddBytes(void *state, const unsigned char *data, unsigned int offset, unsigned int length)
{
    SnP_AddBytes(state, data, offset, length, KeccakP1600_AddLanes, KeccakP1600_AddBytesInLane, 8);
}
/* ---------------------------------------------------------------- */
#define declareABCDE     UINT64 Aba, Abe, Abi, Abo, Abu;     UINT64 Aga, Age, Agi, Ago, Agu;     UINT64 Aka, Ake, Aki, Ako, Aku;     UINT64 Ama, Ame, Ami, Amo, Amu;     UINT64 Asa, Ase, Asi, Aso, Asu;     UINT64 Bba, Bbe, Bbi, Bbo, Bbu;     UINT64 Bga, Bge, Bgi, Bgo, Bgu;     UINT64 Bka, Bke, Bki, Bko, Bku;     UINT64 Bma, Bme, Bmi, Bmo, Bmu;     UINT64 Bsa, Bse, Bsi, Bso, Bsu;     UINT64 Ca, Ce, Ci, Co, Cu;     UINT64 Da, De, Di, Do, Du;     UINT64 Eba, Ebe, Ebi, Ebo, Ebu;     UINT64 Ega, Ege, Egi, Ego, Egu;     UINT64 Eka, Eke, Eki, Eko, Eku;     UINT64 Ema, Eme, Emi, Emo, Emu;     UINT64 Esa, Ese, Esi, Eso, Esu;
#define prepareTheta     Ca = Aba^Aga^Aka^Ama^Asa;     Ce = Abe^Age^Ake^Ame^Ase;     Ci = Abi^Agi^Aki^Ami^Asi;     Co = Abo^Ago^Ako^Amo^Aso;     Cu = Abu^Agu^Aku^Amu^Asu;
#ifdef UseBebigokimisa
/* --- Code for round, with prepare-theta (lane complementing pattern 'bebigokimisa') */
/* --- 64-bit lanes mapped to 64-bit words */
#define thetaRhoPiChiIotaPrepareTheta(i, A, E)     Da = Cu^ROL64(Ce, 1);     De = Ca^ROL64(Ci, 1);     Di = Ce^ROL64(Co, 1);     Do = Ci^ROL64(Cu, 1);     Du = Co^ROL64(Ca, 1);     A##ba ^= Da;     Bba = A##ba;     A##ge ^= De;     Bbe = ROL64(A##ge, 44);     A##ki ^= Di;     Bbi = ROL64(A##ki, 43);     A##mo ^= Do;     Bbo = ROL64(A##mo, 21);     A##su ^= Du;     Bbu = ROL64(A##su, 14);     E##ba =   Bba ^(  Bbe |  Bbi );     E##ba ^= KeccakF1600RoundConstants[i];     Ca = E##ba;     E##be =   Bbe ^((~Bbi)|  Bbo );     Ce = E##be;     E##bi =   Bbi ^(  Bbo &  Bbu );     Ci = E##bi;     E##bo =   Bbo ^(  Bbu |  Bba );     Co = E##bo;     E##bu =   Bbu ^(  Bba &  Bbe );     Cu = E##bu;     A##bo ^= Do;     Bga = ROL64(A##bo, 28);     A##gu ^= Du;     Bge = ROL64(A##gu, 20);     A##ka ^= Da;     Bgi = ROL64(A##ka, 3);     A##me ^= De;     Bgo = ROL64(A##me, 45);     A##si ^= Di;     Bgu = ROL64(A##si, 61);     E##ga =   Bga ^(  Bge |  Bgi );     Ca ^= E##ga;     E##ge =   Bge ^(  Bgi &  Bgo );     Ce ^= E##ge;     E##gi =   Bgi ^(  Bgo |(~Bgu));     Ci ^= E##gi;     E##go =   Bgo ^(  Bgu |  Bga );     Co ^= E##go;     E##gu =   Bgu ^(  Bga &  Bge );     Cu ^= E##gu;     A##be ^= De;     Bka = ROL64(A##be, 1);     A##gi ^= Di;     Bke = ROL64(A##gi, 6);     A##ko ^= Do;     Bki = ROL64(A##ko, 25);     A##mu ^= Du;     Bko = ROL64(A##mu, 8);     A##sa ^= Da;     Bku = ROL64(A##sa, 18);     E##ka =   Bka ^(  Bke |  Bki );     Ca ^= E##ka;     E##ke =   Bke ^(  Bki &  Bko );     Ce ^= E##ke;     E##ki =   Bki ^((~Bko)&  Bku );     Ci ^= E##ki;     E##ko = (~Bko)^(  Bku |  Bka );     Co ^= E##ko;     E##ku =   Bku ^(  Bka &  Bke );     Cu ^= E##ku;     A##bu ^= Du;     Bma = ROL64(A##bu, 27);     A##ga ^= Da;     Bme = ROL64(A##ga, 36);     A##ke ^= De;     Bmi = ROL64(A##ke, 10);     A##mi ^= Di;     Bmo = ROL64(A##mi, 15);     A##so ^= Do;     Bmu = ROL64(A##so, 56);     E##ma =   Bma ^(  Bme &  Bmi );     Ca ^= E##ma;     E##me =   Bme ^(  Bmi |  Bmo );     Ce ^= E##me;     E##mi =   Bmi ^((~Bmo)|  Bmu );     Ci ^= E##mi;     E##mo = (~Bmo)^(  Bmu &  Bma );     Co ^= E##mo;     E##mu =   Bmu ^(  Bma |  Bme );     Cu ^= E##mu;     A##bi ^= Di;     Bsa = ROL64(A##bi, 62);     A##go ^= Do;     Bse = ROL64(A##go, 55);     A##ku ^= Du;     Bsi = ROL64(A##ku, 39);     A##ma ^= Da;     Bso = ROL64(A##ma, 41);     A##se ^= De;     Bsu = ROL64(A##se, 2);     E##sa =   Bsa ^((~Bse)&  Bsi );     Ca ^= E##sa;     E##se = (~Bse)^(  Bsi |  Bso );     Ce ^= E##se;     E##si =   Bsi ^(  Bso &  Bsu );     Ci ^= E##si;     E##so =   Bso ^(  Bsu |  Bsa );     Co ^= E##so;     E##su =   Bsu ^(  Bsa &  Bse );     Cu ^= E##su;
/* --- Code for round (lane complementing pattern 'bebigokimisa') */
/* --- 64-bit lanes mapped to 64-bit words */
#define thetaRhoPiChiIota(i, A, E)     Da = Cu^ROL64(Ce, 1);     De = Ca^ROL64(Ci, 1);     Di = Ce^ROL64(Co, 1);     Do = Ci^ROL64(Cu, 1);     Du = Co^ROL64(Ca, 1);     A##ba ^= Da;     Bba = A##ba;     A##ge ^= De;     Bbe = ROL64(A##ge, 44);     A##ki ^= Di;     Bbi = ROL64(A##ki, 43);     A##mo ^= Do;     Bbo = ROL64(A##mo, 21);     A##su ^= Du;     Bbu = ROL64(A##su, 14);     E##ba =   Bba ^(  Bbe |  Bbi );     E##ba ^= KeccakF1600RoundConstants[i];     E##be =   Bbe ^((~Bbi)|  Bbo );     E##bi =   Bbi ^(  Bbo &  Bbu );     E##bo =   Bbo ^(  Bbu |  Bba );     E##bu =   Bbu ^(  Bba &  Bbe );     A##bo ^= Do;     Bga = ROL64(A##bo, 28);     A##gu ^= Du;     Bge = ROL64(A##gu, 20);     A##ka ^= Da;     Bgi = ROL64(A##ka, 3);     A##me ^= De;     Bgo = ROL64(A##me, 45);     A##si ^= Di;     Bgu = ROL64(A##si, 61);     E##ga =   Bga ^(  Bge |  Bgi );     E##ge =   Bge ^(  Bgi &  Bgo );     E##gi =   Bgi ^(  Bgo |(~Bgu));     E##go =   Bgo ^(  Bgu |  Bga );     E##gu =   Bgu ^(  Bga &  Bge );     A##be ^= De;     Bka = ROL64(A##be, 1);     A##gi ^= Di;     Bke = ROL64(A##gi, 6);     A##ko ^= Do;     Bki = ROL64(A##ko, 25);     A##mu ^= Du;     Bko = ROL64(A##mu, 8);     A##sa ^= Da;     Bku = ROL64(A##sa, 18);     E##ka =   Bka ^(  Bke |  Bki );     E##ke =   Bke ^(  Bki &  Bko );     E##ki =   Bki ^((~Bko)&  Bku );     E##ko = (~Bko)^(  Bku |  Bka );     E##ku =   Bku ^(  Bka &  Bke );     A##bu ^= Du;     Bma = ROL64(A##bu, 27);     A##ga ^= Da;     Bme = ROL64(A##ga, 36);     A##ke ^= De;     Bmi = ROL64(A##ke, 10);     A##mi ^= Di;     Bmo = ROL64(A##mi, 15);     A##so ^= Do;     Bmu = ROL64(A##so, 56);     E##ma =   Bma ^(  Bme &  Bmi );     E##me =   Bme ^(  Bmi |  Bmo );     E##mi =   Bmi ^((~Bmo)|  Bmu );     E##mo = (~Bmo)^(  Bmu &  Bma );     E##mu =   Bmu ^(  Bma |  Bme );     A##bi ^= Di;     Bsa = ROL64(A##bi, 62);     A##go ^= Do;     Bse = ROL64(A##go, 55);     A##ku ^= Du;     Bsi = ROL64(A##ku, 39);     A##ma ^= Da;     Bso = ROL64(A##ma, 41);     A##se ^= De;     Bsu = ROL64(A##se, 2);     E##sa =   Bsa ^((~Bse)&  Bsi );     E##se = (~Bse)^(  Bsi |  Bso );     E##si =   Bsi ^(  Bso &  Bsu );     E##so =   Bso ^(  Bsu |  Bsa );     E##su =   Bsu ^(  Bsa &  Bse );
#else
/* --- Code for round, with prepare-theta */
/* --- 64-bit lanes mapped to 64-bit words */
#define thetaRhoPiChiIotaPrepareTheta(i, A, E)     Da = Cu^ROL64(Ce, 1);     De = Ca^ROL64(Ci, 1);     Di = Ce^ROL64(Co, 1);     Do = Ci^ROL64(Cu, 1);     Du = Co^ROL64(Ca, 1);     A##ba ^= Da;     Bba = A##ba;     A##ge ^= De;     Bbe = ROL64(A##ge, 44);     A##ki ^= Di;     Bbi = ROL64(A##ki, 43);     A##mo ^= Do;     Bbo = ROL64(A##mo, 21);     A##su ^= Du;     Bbu = ROL64(A##su, 14);     E##ba =   Bba ^((~Bbe)&  Bbi );     E##ba ^= KeccakF1600RoundConstants[i];     Ca = E##ba;     E##be =   Bbe ^((~Bbi)&  Bbo );     Ce = E##be;     E##bi =   Bbi ^((~Bbo)&  Bbu );     Ci = E##bi;     E##bo =   Bbo ^((~Bbu)&  Bba );     Co = E##bo;     E##bu =   Bbu ^((~Bba)&  Bbe );     Cu = E##bu;     A##bo ^= Do;     Bga = ROL64(A##bo, 28);     A##gu ^= Du;     Bge = ROL64(A##gu, 20);     A##ka ^= Da;     Bgi = ROL64(A##ka, 3);     A##me ^= De;     Bgo = ROL64(A##me, 45);     A##si ^= Di;     Bgu = ROL64(A##si, 61);     E##ga =   Bga ^((~Bge)&  Bgi );     Ca ^= E##ga;     E##ge =   Bge ^((~Bgi)&  Bgo );     Ce ^= E##ge;     E##gi =   Bgi ^((~Bgo)&  Bgu );     Ci ^= E##gi;     E##go =   Bgo ^((~Bgu)&  Bga );     Co ^= E##go;     E##gu =   Bgu ^((~Bga)&  Bge );     Cu ^= E##gu;     A##be ^= De;     Bka = ROL64(A##be, 1);     A##gi ^= Di;     Bke = ROL64(A##gi, 6);     A##ko ^= Do;     Bki = ROL64(A##ko, 25);     A##mu ^= Du;     Bko = ROL64(A##mu, 8);     A##sa ^= Da;     Bku = ROL64(A##sa, 18);     E##ka =   Bka ^((~Bke)&  Bki );     Ca ^= E##ka;     E##ke =   Bke ^((~Bki)&  Bko );     Ce ^= E##ke;     E##ki =   Bki ^((~Bko)&  Bku );     Ci ^= E##ki;     E##ko =   Bko ^((~Bku)&  Bka );     Co ^= E##ko;     E##ku =   Bku ^((~Bka)&  Bke );     Cu ^= E##ku;     A##bu ^= Du;     Bma = ROL64(A##bu, 27);     A##ga ^= Da;     Bme = ROL64(A##ga, 36);     A##ke ^= De;     Bmi = ROL64(A##ke, 10);     A##mi ^= Di;     Bmo = ROL64(A##mi, 15);     A##so ^= Do;     Bmu = ROL64(A##so, 56);     E##ma =   Bma ^((~Bme)&  Bmi );     Ca ^= E##ma;     E##me =   Bme ^((~Bmi)&  Bmo );     Ce ^= E##me;     E##mi =   Bmi ^((~Bmo)&  Bmu );     Ci ^= E##mi;     E##mo =   Bmo ^((~Bmu)&  Bma );     Co ^= E##mo;     E##mu =   Bmu ^((~Bma)&  Bme );     Cu ^= E##mu;     A##bi ^= Di;     Bsa = ROL64(A##bi, 62);     A##go ^= Do;     Bse = ROL64(A##go, 55);     A##ku ^= Du;     Bsi = ROL64(A##ku, 39);     A##ma ^= Da;     Bso = ROL64(A##ma, 41);     A##se ^= De;     Bsu = ROL64(A##se, 2);     E##sa =   Bsa ^((~Bse)&  Bsi );     Ca ^= E##sa;     E##se =   Bse ^((~Bsi)&  Bso );     Ce ^= E##se;     E##si =   Bsi ^((~Bso)&  Bsu );     Ci ^= E##si;     E##so =   Bso ^((~Bsu)&  Bsa );     Co ^= E##so;     E##su =   Bsu ^((~Bsa)&  Bse );     Cu ^= E##su;
/* --- Code for round */
/* --- 64-bit lanes mapped to 64-bit words */
#define thetaRhoPiChiIota(i, A, E)     Da = Cu^ROL64(Ce, 1);     De = Ca^ROL64(Ci, 1);     Di = Ce^ROL64(Co, 1);     Do = Ci^ROL64(Cu, 1);     Du = Co^ROL64(Ca, 1);     A##ba ^= Da;     Bba = A##ba;     A##ge ^= De;     Bbe = ROL64(A##ge, 44);     A##ki ^= Di;     Bbi = ROL64(A##ki, 43);     A##mo ^= Do;     Bbo = ROL64(A##mo, 21);     A##su ^= Du;     Bbu = ROL64(A##su, 14);     E##ba =   Bba ^((~Bbe)&  Bbi );     E##ba ^= KeccakF1600RoundConstants[i];     E##be =   Bbe ^((~Bbi)&  Bbo );     E##bi =   Bbi ^((~Bbo)&  Bbu );     E##bo =   Bbo ^((~Bbu)&  Bba );     E##bu =   Bbu ^((~Bba)&  Bbe );     A##bo ^= Do;     Bga = ROL64(A##bo, 28);     A##gu ^= Du;     Bge = ROL64(A##gu, 20);     A##ka ^= Da;     Bgi = ROL64(A##ka, 3);     A##me ^= De;     Bgo = ROL64(A##me, 45);     A##si ^= Di;     Bgu = ROL64(A##si, 61);     E##ga =   Bga ^((~Bge)&  Bgi );     E##ge =   Bge ^((~Bgi)&  Bgo );     E##gi =   Bgi ^((~Bgo)&  Bgu );     E##go =   Bgo ^((~Bgu)&  Bga );     E##gu =   Bgu ^((~Bga)&  Bge );     A##be ^= De;     Bka = ROL64(A##be, 1);     A##gi ^= Di;     Bke = ROL64(A##gi, 6);     A##ko ^= Do;     Bki = ROL64(A##ko, 25);     A##mu ^= Du;     Bko = ROL64(A##mu, 8);     A##sa ^= Da;     Bku = ROL64(A##sa, 18);     E##ka =   Bka ^((~Bke)&  Bki );     E##ke =   Bke ^((~Bki)&  Bko );     E##ki =   Bki ^((~Bko)&  Bku );     E##ko =   Bko ^((~Bku)&  Bka );     E##ku =   Bku ^((~Bka)&  Bke );     A##bu ^= Du;     Bma = ROL64(A##bu, 27);     A##ga ^= Da;     Bme = ROL64(A##ga, 36);     A##ke ^= De;     Bmi = ROL64(A##ke, 10);     A##mi ^= Di;     Bmo = ROL64(A##mi, 15);     A##so ^= Do;     Bmu = ROL64(A##so, 56);     E##ma =   Bma ^((~Bme)&  Bmi );     E##me =   Bme ^((~Bmi)&  Bmo );     E##mi =   Bmi ^((~Bmo)&  Bmu );     E##mo =   Bmo ^((~Bmu)&  Bma );     E##mu =   Bmu ^((~Bma)&  Bme );     A##bi ^= Di;     Bsa = ROL64(A##bi, 62);     A##go ^= Do;     Bse = ROL64(A##go, 55);     A##ku ^= Du;     Bsi = ROL64(A##ku, 39);     A##ma ^= Da;     Bso = ROL64(A##ma, 41);     A##se ^= De;     Bsu = ROL64(A##se, 2);     E##sa =   Bsa ^((~Bse)&  Bsi );     E##se =   Bse ^((~Bsi)&  Bso );     E##si =   Bsi ^((~Bso)&  Bsu );     E##so =   Bso ^((~Bsu)&  Bsa );     E##su =   Bsu ^((~Bsa)&  Bse );
#endif
#define copyFromState(X, state)     X##ba = state[ 0];     X##be = state[ 1];     X##bi = state[ 2];     X##bo = state[ 3];     X##bu = state[ 4];     X##ga = state[ 5];     X##ge = state[ 6];     X##gi = state[ 7];     X##go = state[ 8];     X##gu = state[ 9];     X##ka = state[10];     X##ke = state[11];     X##ki = state[12];     X##ko = state[13];     X##ku = state[14];     X##ma = state[15];     X##me = state[16];     X##mi = state[17];     X##mo = state[18];     X##mu = state[19];     X##sa = state[20];     X##se = state[21];     X##si = state[22];     X##so = state[23];     X##su = state[24];
#define copyToState(state, X)     state[ 0] = X##ba;     state[ 1] = X##be;     state[ 2] = X##bi;     state[ 3] = X##bo;     state[ 4] = X##bu;     state[ 5] = X##ga;     state[ 6] = X##ge;     state[ 7] = X##gi;     state[ 8] = X##go;     state[ 9] = X##gu;     state[10] = X##ka;     state[11] = X##ke;     state[12] = X##ki;     state[13] = X##ko;     state[14] = X##ku;     state[15] = X##ma;     state[16] = X##me;     state[17] = X##mi;     state[18] = X##mo;     state[19] = X##mu;     state[20] = X##sa;     state[21] = X##se;     state[22] = X##si;     state[23] = X##so;     state[24] = X##su;
#define copyStateVariables(X, Y)     X##ba = Y##ba;     X##be = Y##be;     X##bi = Y##bi;     X##bo = Y##bo;     X##bu = Y##bu;     X##ga = Y##ga;     X##ge = Y##ge;     X##gi = Y##gi;     X##go = Y##go;     X##gu = Y##gu;     X##ka = Y##ka;     X##ke = Y##ke;     X##ki = Y##ki;     X##ko = Y##ko;     X##ku = Y##ku;     X##ma = Y##ma;     X##me = Y##me;     X##mi = Y##mi;     X##mo = Y##mo;     X##mu = Y##mu;     X##sa = Y##sa;     X##se = Y##se;     X##si = Y##si;     X##so = Y##so;     X##su = Y##su;
#if ((defined(FullUnrolling)) || (Unrolling == 12))
#define rounds12     prepareTheta     thetaRhoPiChiIotaPrepareTheta(12, A, E)     thetaRhoPiChiIotaPrepareTheta(13, E, A)     thetaRhoPiChiIotaPrepareTheta(14, A, E)     thetaRhoPiChiIotaPrepareTheta(15, E, A)     thetaRhoPiChiIotaPrepareTheta(16, A, E)     thetaRhoPiChiIotaPrepareTheta(17, E, A)     thetaRhoPiChiIotaPrepareTheta(18, A, E)     thetaRhoPiChiIotaPrepareTheta(19, E, A)     thetaRhoPiChiIotaPrepareTheta(20, A, E)     thetaRhoPiChiIotaPrepareTheta(21, E, A)     thetaRhoPiChiIotaPrepareTheta(22, A, E)     thetaRhoPiChiIota(23, E, A)
#elif (Unrolling == 6)
#define rounds12     prepareTheta     for(i=12; i<24; i+=6) {         thetaRhoPiChiIotaPrepareTheta(i  , A, E)         thetaRhoPiChiIotaPrepareTheta(i+1, E, A)         thetaRhoPiChiIotaPrepareTheta(i+2, A, E)         thetaRhoPiChiIotaPrepareTheta(i+3, E, A)         thetaRhoPiChiIotaPrepareTheta(i+4, A, E)         thetaRhoPiChiIotaPrepareTheta(i+5, E, A)     }
#elif (Unrolling == 4)
#define rounds12     prepareTheta     for(i=12; i<24; i+=4) {         thetaRhoPiChiIotaPrepareTheta(i  , A, E)         thetaRhoPiChiIotaPrepareTheta(i+1, E, A)         thetaRhoPiChiIotaPrepareTheta(i+2, A, E)         thetaRhoPiChiIotaPrepareTheta(i+3, E, A)     }
#elif (Unrolling == 3)
#define rounds12     prepareTheta     for(i=12; i<24; i+=3) {         thetaRhoPiChiIotaPrepareTheta(i  , A, E)         thetaRhoPiChiIotaPrepareTheta(i+1, E, A)         thetaRhoPiChiIotaPrepareTheta(i+2, A, E)         copyStateVariables(A, E)     }
#elif (Unrolling == 2)
#define rounds12     prepareTheta     for(i=12; i<24; i+=2) {         thetaRhoPiChiIotaPrepareTheta(i  , A, E)         thetaRhoPiChiIotaPrepareTheta(i+1, E, A)     }
#elif (Unrolling == 1)
#define rounds12     prepareTheta     for(i=12; i<24; i++) {         thetaRhoPiChiIotaPrepareTheta(i  , A, E)         copyStateVariables(A, E)     }
#else
#error "Unrolling is not correctly specified!"
#endif
void KeccakP1600_Permute_12rounds(void *state)
{
    declareABCDE
    #ifndef KeccakP1600_fullUnrolling
    unsigned int i;
    #endif
    UINT64 *stateAsLanes = (UINT64*)state;
    copyFromState(A, stateAsLanes)
    rounds12
    copyToState(stateAsLanes, A)
}
/* ---------------------------------------------------------------- */
void KeccakP1600_ExtractBytesInLane(const void *state, unsigned int lanePosition, unsigned char *data, unsigned int offset, unsigned int length)
{
    UINT64 lane = ((UINT64*)state)[lanePosition];
#ifdef KeccakP1600_useLaneComplementing
    if ((lanePosition == 1) || (lanePosition == 2) || (lanePosition == 8) || (lanePosition == 12) || (lanePosition == 17) || (lanePosition == 20))
        lane = ~lane;
#endif
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    {
        UINT64 lane1[1];
        lane1[0] = lane;
        memcpy(data, (UINT8*)lane1+offset, length);
    }
#else
    unsigned int i;
    lane >>= offset*8;
    for(i=0; i<length; i++) {
        data[i] = lane & 0xFF;
        lane >>= 8;
    }
#endif
}
/* ---------------------------------------------------------------- */
#if (PLATFORM_BYTE_ORDER != IS_LITTLE_ENDIAN)
static void fromWordToBytes(UINT8 *bytes, const UINT64 word)
{
    unsigned int i;
    for(i=0; i<(64/8); i++)
        bytes[i] = (word >> (8*i)) & 0xFF;
}
#endif
void KeccakP1600_ExtractLanes(const void *state, unsigned char *data, unsigned int laneCount)
{
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    memcpy(data, state, laneCount*8);
#else
    unsigned int i;
    for(i=0; i<laneCount; i++)
        fromWordToBytes(data+(i*8), ((const UINT64*)state)[i]);
#endif
#ifdef KeccakP1600_useLaneComplementing
    if (laneCount > 1) {
        ((UINT64*)data)[ 1] = ~((UINT64*)data)[ 1];
        if (laneCount > 2) {
            ((UINT64*)data)[ 2] = ~((UINT64*)data)[ 2];
            if (laneCount > 8) {
                ((UINT64*)data)[ 8] = ~((UINT64*)data)[ 8];
                if (laneCount > 12) {
                    ((UINT64*)data)[12] = ~((UINT64*)data)[12];
                    if (laneCount > 17) {
                        ((UINT64*)data)[17] = ~((UINT64*)data)[17];
                        if (laneCount > 20) {
                            ((UINT64*)data)[20] = ~((UINT64*)data)[20];
                        }
                    }
                }
            }
        }
    }
#endif
}
/* ---------------------------------------------------------------- */
#define SnP_ExtractBytes(state, data, offset, length, SnP_ExtractLanes, SnP_ExtractBytesInLane, SnP_laneLengthInBytes)     {         if ((offset) == 0) {             SnP_ExtractLanes(state, data, (length)/SnP_laneLengthInBytes);             SnP_ExtractBytesInLane(state,                 (length)/SnP_laneLengthInBytes,                 (data)+((length)/SnP_laneLengthInBytes)*SnP_laneLengthInBytes,                 0,                 (length)%SnP_laneLengthInBytes);         }         else {             unsigned int _sizeLeft = (length);             unsigned int _lanePosition = (offset)/SnP_laneLengthInBytes;             unsigned int _offsetInLane = (offset)%SnP_laneLengthInBytes;             unsigned char *_curData = (data);             while(_sizeLeft > 0) {                 unsigned int _bytesInLane = SnP_laneLengthInBytes - _offsetInLane;                 if (_bytesInLane > _sizeLeft)                     _bytesInLane = _sizeLeft;                 SnP_ExtractBytesInLane(state, _lanePosition, _curData, _offsetInLane, _bytesInLane);                 _sizeLeft -= _bytesInLane;                 _lanePosition++;                 _offsetInLane = 0;                 _curData += _bytesInLane;             }         }     }
void KeccakP1600_ExtractBytes(const void *state, unsigned char *data, unsigned int offset, unsigned int length)
{
    SnP_ExtractBytes(state, data, offset, length, KeccakP1600_ExtractLanes, KeccakP1600_ExtractBytesInLane, 8);
}
/* ---------------------------------------------------------------- */
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
#define HTOLE64(x) (x)
#else
#define HTOLE64(x) (  ((x & 0xff00000000000000ull) >> 56) |   ((x & 0x00ff000000000000ull) >> 40) |   ((x & 0x0000ff0000000000ull) >> 24) |   ((x & 0x000000ff00000000ull) >> 8)  |   ((x & 0x00000000ff000000ull) << 8)  |   ((x & 0x0000000000ff0000ull) << 24) |   ((x & 0x000000000000ff00ull) << 40) |   ((x & 0x00000000000000ffull) << 56))
#endif
#define addInput(X, input, laneCount)     if (laneCount == 21) {         X##ba ^= HTOLE64(input[ 0]);         X##be ^= HTOLE64(input[ 1]);         X##bi ^= HTOLE64(input[ 2]);         X##bo ^= HTOLE64(input[ 3]);         X##bu ^= HTOLE64(input[ 4]);         X##ga ^= HTOLE64(input[ 5]);         X##ge ^= HTOLE64(input[ 6]);         X##gi ^= HTOLE64(input[ 7]);         X##go ^= HTOLE64(input[ 8]);         X##gu ^= HTOLE64(input[ 9]);         X##ka ^= HTOLE64(input[10]);         X##ke ^= HTOLE64(input[11]);         X##ki ^= HTOLE64(input[12]);         X##ko ^= HTOLE64(input[13]);         X##ku ^= HTOLE64(input[14]);         X##ma ^= HTOLE64(input[15]);         X##me ^= HTOLE64(input[16]);         X##mi ^= HTOLE64(input[17]);         X##mo ^= HTOLE64(input[18]);         X##mu ^= HTOLE64(input[19]);         X##sa ^= HTOLE64(input[20]);     }     else if (laneCount < 16) {         if (laneCount < 8) {             if (laneCount < 4) {                 if (laneCount < 2) {                     if (laneCount < 1) {                     }                     else {                         X##ba ^= HTOLE64(input[ 0]);                     }                 }                 else {                     X##ba ^= HTOLE64(input[ 0]);                     X##be ^= HTOLE64(input[ 1]);                     if (laneCount < 3) {                     }                     else {                         X##bi ^= HTOLE64(input[ 2]);                     }                 }             }             else {                 X##ba ^= HTOLE64(input[ 0]);                 X##be ^= HTOLE64(input[ 1]);                 X##bi ^= HTOLE64(input[ 2]);                 X##bo ^= HTOLE64(input[ 3]);                 if (laneCount < 6) {                     if (laneCount < 5) {                     }                     else {                         X##bu ^= HTOLE64(input[ 4]);                     }                 }                 else {                     X##bu ^= HTOLE64(input[ 4]);                     X##ga ^= HTOLE64(input[ 5]);                     if (laneCount < 7) {                     }                     else {                         X##ge ^= HTOLE64(input[ 6]);                     }                 }             }         }         else {             X##ba ^= HTOLE64(input[ 0]);             X##be ^= HTOLE64(input[ 1]);             X##bi ^= HTOLE64(input[ 2]);             X##bo ^= HTOLE64(input[ 3]);             X##bu ^= HTOLE64(input[ 4]);             X##ga ^= HTOLE64(input[ 5]);             X##ge ^= HTOLE64(input[ 6]);             X##gi ^= HTOLE64(input[ 7]);             if (laneCount < 12) {                 if (laneCount < 10) {                     if (laneCount < 9) {                     }                     else {                         X##go ^= HTOLE64(input[ 8]);                     }                 }                 else {                     X##go ^= HTOLE64(input[ 8]);                     X##gu ^= HTOLE64(input[ 9]);                     if (laneCount < 11) {                     }                     else {                         X##ka ^= HTOLE64(input[10]);                     }                 }             }             else {                 X##go ^= HTOLE64(input[ 8]);                 X##gu ^= HTOLE64(input[ 9]);                 X##ka ^= HTOLE64(input[10]);                 X##ke ^= HTOLE64(input[11]);                 if (laneCount < 14) {                     if (laneCount < 13) {                     }                     else {                         X##ki ^= HTOLE64(input[12]);                     }                 }                 else {                     X##ki ^= HTOLE64(input[12]);                     X##ko ^= HTOLE64(input[13]);                     if (laneCount < 15) {                     }                     else {                         X##ku ^= HTOLE64(input[14]);                     }                 }             }         }     }     else {         X##ba ^= HTOLE64(input[ 0]);         X##be ^= HTOLE64(input[ 1]);         X##bi ^= HTOLE64(input[ 2]);         X##bo ^= HTOLE64(input[ 3]);         X##bu ^= HTOLE64(input[ 4]);         X##ga ^= HTOLE64(input[ 5]);         X##ge ^= HTOLE64(input[ 6]);         X##gi ^= HTOLE64(input[ 7]);         X##go ^= HTOLE64(input[ 8]);         X##gu ^= HTOLE64(input[ 9]);         X##ka ^= HTOLE64(input[10]);         X##ke ^= HTOLE64(input[11]);         X##ki ^= HTOLE64(input[12]);         X##ko ^= HTOLE64(input[13]);         X##ku ^= HTOLE64(input[14]);         X##ma ^= HTOLE64(input[15]);         if (laneCount < 24) {             if (laneCount < 20) {                 if (laneCount < 18) {                     if (laneCount < 17) {                     }                     else {                         X##me ^= HTOLE64(input[16]);                     }                 }                 else {                     X##me ^= HTOLE64(input[16]);                     X##mi ^= HTOLE64(input[17]);                     if (laneCount < 19) {                     }                     else {                         X##mo ^= HTOLE64(input[18]);                     }                 }             }             else {                 X##me ^= HTOLE64(input[16]);                 X##mi ^= HTOLE64(input[17]);                 X##mo ^= HTOLE64(input[18]);                 X##mu ^= HTOLE64(input[19]);                 if (laneCount < 22) {                     if (laneCount < 21) {                     }                     else {                         X##sa ^= HTOLE64(input[20]);                     }                 }                 else {                     X##sa ^= HTOLE64(input[20]);                     X##se ^= HTOLE64(input[21]);                     if (laneCount < 23) {                     }                     else {                         X##si ^= HTOLE64(input[22]);                     }                 }             }         }         else {             X##me ^= HTOLE64(input[16]);             X##mi ^= HTOLE64(input[17]);             X##mo ^= HTOLE64(input[18]);             X##mu ^= HTOLE64(input[19]);             X##sa ^= HTOLE64(input[20]);             X##se ^= HTOLE64(input[21]);             X##si ^= HTOLE64(input[22]);             X##so ^= HTOLE64(input[23]);             if (laneCount < 25) {             }             else {                 X##su ^= HTOLE64(input[24]);             }         }     }
size_t KeccakP1600_12rounds_FastLoop_Absorb(void *state, unsigned int laneCount, const unsigned char *data, size_t dataByteLen)
{
    size_t originalDataByteLen = dataByteLen;
    declareABCDE
    #ifndef KeccakP1600_fullUnrolling
    unsigned int i;
    #endif
    UINT64 *stateAsLanes = (UINT64*)state;
    UINT64 *inDataAsLanes = (UINT64*)data;
    copyFromState(A, stateAsLanes)
    while(dataByteLen >= laneCount*8) {
        addInput(A, inDataAsLanes, laneCount)
        rounds12
        inDataAsLanes += laneCount;
        dataByteLen -= laneCount*8;
    }
    copyToState(stateAsLanes, A)
    return originalDataByteLen - dataByteLen;
}
#else
/*
Implementation by Ronny Van Keer, hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
---
Please refer to the XKCP for more details.
*/
#ifndef _KeccakP_1600_SnP_h_
#define _KeccakP_1600_SnP_h_
#define KeccakP1600_implementation      "in-place 32-bit optimized implementation"
#define KeccakP1600_stateSizeInBytes    200
#define KeccakP1600_stateAlignment      8
#define KeccakP1600_StaticInitialize()
void KeccakP1600_Initialize(void *state);
void KeccakP1600_AddByte(void *state, unsigned char data, unsigned int offset);
void KeccakP1600_AddBytes(void *state, const unsigned char *data, unsigned int offset, unsigned int length);
void KeccakP1600_Permute_12rounds(void *state);
void KeccakP1600_ExtractBytes(const void *state, unsigned char *data, unsigned int offset, unsigned int length);
#endif
/*
Implementation by Ronny Van Keer, hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
---
Please refer to the XKCP for more details.
*/
/*
Implementation by Ronny Van Keer, hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
---
Please refer to the XKCP for more details.
*/
#ifndef _KeccakP_1600_SnP_h_
#define _KeccakP_1600_SnP_h_
#define KeccakP1600_implementation      "in-place 32-bit optimized implementation"
#define KeccakP1600_stateSizeInBytes    200
#define KeccakP1600_stateAlignment      8
#define KeccakP1600_StaticInitialize()
void KeccakP1600_Initialize(void *state);
void KeccakP1600_AddByte(void *state, unsigned char data, unsigned int offset);
void KeccakP1600_AddBytes(void *state, const unsigned char *data, unsigned int offset, unsigned int length);
void KeccakP1600_Permute_12rounds(void *state);
void KeccakP1600_ExtractBytes(const void *state, unsigned char *data, unsigned int offset, unsigned int length);
#endif
typedef unsigned char UINT8;
typedef unsigned int UINT32;
/* WARNING: on 8-bit and 16-bit platforms, this should be replaced by: */
/* typedef unsigned long       UINT32; */
#define ROL32(a, offset) ((((UINT32)a) << (offset)) ^ (((UINT32)a) >> (32-(offset))))
/* Credit to Henry S. Warren, Hacker's Delight, Addison-Wesley, 2002 */
#define prepareToBitInterleaving(low, high, temp, temp0, temp1)         temp0 = (low);         temp = (temp0 ^ (temp0 >>  1)) & 0x22222222UL;  temp0 = temp0 ^ temp ^ (temp <<  1);         temp = (temp0 ^ (temp0 >>  2)) & 0x0C0C0C0CUL;  temp0 = temp0 ^ temp ^ (temp <<  2);         temp = (temp0 ^ (temp0 >>  4)) & 0x00F000F0UL;  temp0 = temp0 ^ temp ^ (temp <<  4);         temp = (temp0 ^ (temp0 >>  8)) & 0x0000FF00UL;  temp0 = temp0 ^ temp ^ (temp <<  8);         temp1 = (high);         temp = (temp1 ^ (temp1 >>  1)) & 0x22222222UL;  temp1 = temp1 ^ temp ^ (temp <<  1);         temp = (temp1 ^ (temp1 >>  2)) & 0x0C0C0C0CUL;  temp1 = temp1 ^ temp ^ (temp <<  2);         temp = (temp1 ^ (temp1 >>  4)) & 0x00F000F0UL;  temp1 = temp1 ^ temp ^ (temp <<  4);         temp = (temp1 ^ (temp1 >>  8)) & 0x0000FF00UL;  temp1 = temp1 ^ temp ^ (temp <<  8);
#define toBitInterleavingAndXOR(low, high, even, odd, temp, temp0, temp1)         prepareToBitInterleaving(low, high, temp, temp0, temp1)         even ^= (temp0 & 0x0000FFFF) | (temp1 << 16);         odd ^= (temp0 >> 16) | (temp1 & 0xFFFF0000);
#define toBitInterleavingAndAND(low, high, even, odd, temp, temp0, temp1)         prepareToBitInterleaving(low, high, temp, temp0, temp1)         even &= (temp0 & 0x0000FFFF) | (temp1 << 16);         odd &= (temp0 >> 16) | (temp1 & 0xFFFF0000);
#define toBitInterleavingAndSet(low, high, even, odd, temp, temp0, temp1)         prepareToBitInterleaving(low, high, temp, temp0, temp1)         even = (temp0 & 0x0000FFFF) | (temp1 << 16);         odd = (temp0 >> 16) | (temp1 & 0xFFFF0000);
/* Credit to Henry S. Warren, Hacker's Delight, Addison-Wesley, 2002 */
#define prepareFromBitInterleaving(even, odd, temp, temp0, temp1)         temp0 = (even);         temp1 = (odd);         temp = (temp0 & 0x0000FFFF) | (temp1 << 16);         temp1 = (temp0 >> 16) | (temp1 & 0xFFFF0000);         temp0 = temp;         temp = (temp0 ^ (temp0 >>  8)) & 0x0000FF00UL;  temp0 = temp0 ^ temp ^ (temp <<  8);         temp = (temp0 ^ (temp0 >>  4)) & 0x00F000F0UL;  temp0 = temp0 ^ temp ^ (temp <<  4);         temp = (temp0 ^ (temp0 >>  2)) & 0x0C0C0C0CUL;  temp0 = temp0 ^ temp ^ (temp <<  2);         temp = (temp0 ^ (temp0 >>  1)) & 0x22222222UL;  temp0 = temp0 ^ temp ^ (temp <<  1);         temp = (temp1 ^ (temp1 >>  8)) & 0x0000FF00UL;  temp1 = temp1 ^ temp ^ (temp <<  8);         temp = (temp1 ^ (temp1 >>  4)) & 0x00F000F0UL;  temp1 = temp1 ^ temp ^ (temp <<  4);         temp = (temp1 ^ (temp1 >>  2)) & 0x0C0C0C0CUL;  temp1 = temp1 ^ temp ^ (temp <<  2);         temp = (temp1 ^ (temp1 >>  1)) & 0x22222222UL;  temp1 = temp1 ^ temp ^ (temp <<  1);
#define fromBitInterleaving(even, odd, low, high, temp, temp0, temp1)         prepareFromBitInterleaving(even, odd, temp, temp0, temp1)         low = temp0;         high = temp1;
#define fromBitInterleavingAndXOR(even, odd, lowIn, highIn, lowOut, highOut, temp, temp0, temp1)         prepareFromBitInterleaving(even, odd, temp, temp0, temp1)         lowOut = lowIn ^ temp0;         highOut = highIn ^ temp1;
void KeccakP1600_SetBytesInLaneToZero(void *state, unsigned int lanePosition, unsigned int offset, unsigned int length)
{
    UINT8 laneAsBytes[8];
    UINT32 low, high;
    UINT32 temp, temp0, temp1;
    UINT32 *stateAsHalfLanes = (UINT32*)state;
    memset(laneAsBytes, 0xFF, offset);
    memset(laneAsBytes+offset, 0x00, length);
    memset(laneAsBytes+offset+length, 0xFF, 8-offset-length);
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    low = *((UINT32*)(laneAsBytes+0));
    high = *((UINT32*)(laneAsBytes+4));
#else
    low = laneAsBytes[0]
        | ((UINT32)(laneAsBytes[1]) << 8)
        | ((UINT32)(laneAsBytes[2]) << 16)
        | ((UINT32)(laneAsBytes[3]) << 24);
    high = laneAsBytes[4]
        | ((UINT32)(laneAsBytes[5]) << 8)
        | ((UINT32)(laneAsBytes[6]) << 16)
        | ((UINT32)(laneAsBytes[7]) << 24);
#endif
    toBitInterleavingAndAND(low, high, stateAsHalfLanes[lanePosition*2+0], stateAsHalfLanes[lanePosition*2+1], temp, temp0, temp1);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_Initialize(void *state)
{
    memset(state, 0, 200);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_AddByte(void *state, unsigned char byte, unsigned int offset)
{
    unsigned int lanePosition = offset/8;
    unsigned int offsetInLane = offset%8;
    UINT32 low, high;
    UINT32 temp, temp0, temp1;
    UINT32 *stateAsHalfLanes = (UINT32*)state;
    if (offsetInLane < 4) {
        low = (UINT32)byte << (offsetInLane*8);
        high = 0;
    }
    else {
        low = 0;
        high = (UINT32)byte << ((offsetInLane-4)*8);
    }
    toBitInterleavingAndXOR(low, high, stateAsHalfLanes[lanePosition*2+0], stateAsHalfLanes[lanePosition*2+1], temp, temp0, temp1);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_AddBytesInLane(void *state, unsigned int lanePosition, const unsigned char *data, unsigned int offset, unsigned int length)
{
    UINT8 laneAsBytes[8];
    UINT32 low, high;
    UINT32 temp, temp0, temp1;
    UINT32 *stateAsHalfLanes = (UINT32*)state;
    memset(laneAsBytes, 0, 8);
    memcpy(laneAsBytes+offset, data, length);
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    low = *((UINT32*)(laneAsBytes+0));
    high = *((UINT32*)(laneAsBytes+4));
#else
    low = laneAsBytes[0]
        | ((UINT32)(laneAsBytes[1]) << 8)
        | ((UINT32)(laneAsBytes[2]) << 16)
        | ((UINT32)(laneAsBytes[3]) << 24);
    high = laneAsBytes[4]
        | ((UINT32)(laneAsBytes[5]) << 8)
        | ((UINT32)(laneAsBytes[6]) << 16)
        | ((UINT32)(laneAsBytes[7]) << 24);
#endif
    toBitInterleavingAndXOR(low, high, stateAsHalfLanes[lanePosition*2+0], stateAsHalfLanes[lanePosition*2+1], temp, temp0, temp1);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_AddLanes(void *state, const unsigned char *data, unsigned int laneCount)
{
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    const UINT32 * pI = (const UINT32 *)data;
    UINT32 * pS = (UINT32*)state;
    UINT32 t, x0, x1;
    int i;
    for (i = laneCount-1; i >= 0; --i) {
#ifdef NO_MISALIGNED_ACCESSES
        UINT32 low;
        UINT32 high;
        memcpy(&low, pI++, 4);
        memcpy(&high, pI++, 4);
        toBitInterleavingAndXOR(low, high, *(pS++), *(pS++), t, x0, x1);
#else
        toBitInterleavingAndXOR(*(pI++), *(pI++), *(pS++), *(pS++), t, x0, x1)
#endif
    }
#else
    unsigned int lanePosition;
    for(lanePosition=0; lanePosition<laneCount; lanePosition++) {
        UINT8 laneAsBytes[8];
        memcpy(laneAsBytes, data+lanePosition*8, 8);
        UINT32 low = laneAsBytes[0]
            | ((UINT32)(laneAsBytes[1]) << 8)
            | ((UINT32)(laneAsBytes[2]) << 16)
            | ((UINT32)(laneAsBytes[3]) << 24);
        UINT32 high = laneAsBytes[4]
            | ((UINT32)(laneAsBytes[5]) << 8)
            | ((UINT32)(laneAsBytes[6]) << 16)
            | ((UINT32)(laneAsBytes[7]) << 24);
        UINT32 even, odd, temp, temp0, temp1;
        UINT32 *stateAsHalfLanes = (UINT32*)state;
        toBitInterleavingAndXOR(low, high, stateAsHalfLanes[lanePosition*2+0], stateAsHalfLanes[lanePosition*2+1], temp, temp0, temp1);
    }
#endif
}
/* ---------------------------------------------------------------- */
#define SnP_AddBytes(state, data, offset, length, SnP_AddLanes, SnP_AddBytesInLane, SnP_laneLengthInBytes)     {         if ((offset) == 0) {             SnP_AddLanes(state, data, (length)/SnP_laneLengthInBytes);             SnP_AddBytesInLane(state,                 (length)/SnP_laneLengthInBytes,                 (data)+((length)/SnP_laneLengthInBytes)*SnP_laneLengthInBytes,                 0,                 (length)%SnP_laneLengthInBytes);         }         else {             unsigned int _sizeLeft = (length);             unsigned int _lanePosition = (offset)/SnP_laneLengthInBytes;             unsigned int _offsetInLane = (offset)%SnP_laneLengthInBytes;             const unsigned char *_curData = (data);             while(_sizeLeft > 0) {                 unsigned int _bytesInLane = SnP_laneLengthInBytes - _offsetInLane;                 if (_bytesInLane > _sizeLeft)                     _bytesInLane = _sizeLeft;                 SnP_AddBytesInLane(state, _lanePosition, _curData, _offsetInLane, _bytesInLane);                 _sizeLeft -= _bytesInLane;                 _lanePosition++;                 _offsetInLane = 0;                 _curData += _bytesInLane;             }         }     }
void KeccakP1600_AddBytes(void *state, const unsigned char *data, unsigned int offset, unsigned int length)
{
    SnP_AddBytes(state, data, offset, length, KeccakP1600_AddLanes, KeccakP1600_AddBytesInLane, 8);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_ExtractBytesInLane(const void *state, unsigned int lanePosition, unsigned char *data, unsigned int offset, unsigned int length)
{
    UINT32 *stateAsHalfLanes = (UINT32*)state;
    UINT32 low, high, temp, temp0, temp1;
    UINT8 laneAsBytes[8];
    fromBitInterleaving(stateAsHalfLanes[lanePosition*2], stateAsHalfLanes[lanePosition*2+1], low, high, temp, temp0, temp1);
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    *((UINT32*)(laneAsBytes+0)) = low;
    *((UINT32*)(laneAsBytes+4)) = high;
#else
    laneAsBytes[0] = low & 0xFF;
    laneAsBytes[1] = (low >> 8) & 0xFF;
    laneAsBytes[2] = (low >> 16) & 0xFF;
    laneAsBytes[3] = (low >> 24) & 0xFF;
    laneAsBytes[4] = high & 0xFF;
    laneAsBytes[5] = (high >> 8) & 0xFF;
    laneAsBytes[6] = (high >> 16) & 0xFF;
    laneAsBytes[7] = (high >> 24) & 0xFF;
#endif
    memcpy(data, laneAsBytes+offset, length);
}
/* ---------------------------------------------------------------- */
void KeccakP1600_ExtractLanes(const void *state, unsigned char *data, unsigned int laneCount)
{
#if (PLATFORM_BYTE_ORDER == IS_LITTLE_ENDIAN)
    UINT32 * pI = (UINT32 *)data;
    const UINT32 * pS = ( const UINT32 *)state;
    UINT32 t, x0, x1;
    int i;
    for (i = laneCount-1; i >= 0; --i) {
#ifdef NO_MISALIGNED_ACCESSES
        UINT32 low;
        UINT32 high;
        fromBitInterleaving(*(pS++), *(pS++), low, high, t, x0, x1);
        memcpy(pI++, &low, 4);
        memcpy(pI++, &high, 4);
#else
        fromBitInterleaving(*(pS++), *(pS++), *(pI++), *(pI++), t, x0, x1)
#endif
    }
#else
    unsigned int lanePosition;
    for(lanePosition=0; lanePosition<laneCount; lanePosition++) {
        UINT32 *stateAsHalfLanes = (UINT32*)state;
        UINT32 low, high, temp, temp0, temp1;
        fromBitInterleaving(stateAsHalfLanes[lanePosition*2], stateAsHalfLanes[lanePosition*2+1], low, high, temp, temp0, temp1);
        UINT8 laneAsBytes[8];
        laneAsBytes[0] = low & 0xFF;
        laneAsBytes[1] = (low >> 8) & 0xFF;
        laneAsBytes[2] = (low >> 16) & 0xFF;
        laneAsBytes[3] = (low >> 24) & 0xFF;
        laneAsBytes[4] = high & 0xFF;
        laneAsBytes[5] = (high >> 8) & 0xFF;
        laneAsBytes[6] = (high >> 16) & 0xFF;
        laneAsBytes[7] = (high >> 24) & 0xFF;
        memcpy(data+lanePosition*8, laneAsBytes, 8);
    }
#endif
}
/* ---------------------------------------------------------------- */
#define SnP_ExtractBytes(state, data, offset, length, SnP_ExtractLanes, SnP_ExtractBytesInLane, SnP_laneLengthInBytes)     {         if ((offset) == 0) {             SnP_ExtractLanes(state, data, (length)/SnP_laneLengthInBytes);             SnP_ExtractBytesInLane(state,                 (length)/SnP_laneLengthInBytes,                 (data)+((length)/SnP_laneLengthInBytes)*SnP_laneLengthInBytes,                 0,                 (length)%SnP_laneLengthInBytes);         }         else {             unsigned int _sizeLeft = (length);             unsigned int _lanePosition = (offset)/SnP_laneLengthInBytes;             unsigned int _offsetInLane = (offset)%SnP_laneLengthInBytes;             unsigned char *_curData = (data);             while(_sizeLeft > 0) {                 unsigned int _bytesInLane = SnP_laneLengthInBytes - _offsetInLane;                 if (_bytesInLane > _sizeLeft)                     _bytesInLane = _sizeLeft;                 SnP_ExtractBytesInLane(state, _lanePosition, _curData, _offsetInLane, _bytesInLane);                 _sizeLeft -= _bytesInLane;                 _lanePosition++;                 _offsetInLane = 0;                 _curData += _bytesInLane;             }         }     }
void KeccakP1600_ExtractBytes(const void *state, unsigned char *data, unsigned int offset, unsigned int length)
{
    SnP_ExtractBytes(state, data, offset, length, KeccakP1600_ExtractLanes, KeccakP1600_ExtractBytesInLane, 8);
}
/* ---------------------------------------------------------------- */
static const UINT32 KeccakF1600RoundConstants_int2[2*24+1] =
{
    0x00000001UL,    0x00000000UL,
    0x00000000UL,    0x00000089UL,
    0x00000000UL,    0x8000008bUL,
    0x00000000UL,    0x80008080UL,
    0x00000001UL,    0x0000008bUL,
    0x00000001UL,    0x00008000UL,
    0x00000001UL,    0x80008088UL,
    0x00000001UL,    0x80000082UL,
    0x00000000UL,    0x0000000bUL,
    0x00000000UL,    0x0000000aUL,
    0x00000001UL,    0x00008082UL,
    0x00000000UL,    0x00008003UL,
    0x00000001UL,    0x0000808bUL,
    0x00000001UL,    0x8000000bUL,
    0x00000001UL,    0x8000008aUL,
    0x00000001UL,    0x80000081UL,
    0x00000000UL,    0x80000081UL,
    0x00000000UL,    0x80000008UL,
    0x00000000UL,    0x00000083UL,
    0x00000000UL,    0x80008003UL,
    0x00000001UL,    0x80008088UL,
    0x00000000UL,    0x80000088UL,
    0x00000001UL,    0x00008000UL,
    0x00000000UL,    0x80008082UL,
    0x000000FFUL
};
#define KeccakRound0()         Cx = Abu0^Agu0^Aku0^Amu0^Asu0;         Du1 = Abe1^Age1^Ake1^Ame1^Ase1;         Da0 = Cx^ROL32(Du1, 1);         Cz = Abu1^Agu1^Aku1^Amu1^Asu1;         Du0 = Abe0^Age0^Ake0^Ame0^Ase0;         Da1 = Cz^Du0;         Cw = Abi0^Agi0^Aki0^Ami0^Asi0;         Do0 = Cw^ROL32(Cz, 1);         Cy = Abi1^Agi1^Aki1^Ami1^Asi1;         Do1 = Cy^Cx;         Cx = Aba0^Aga0^Aka0^Ama0^Asa0;         De0 = Cx^ROL32(Cy, 1);         Cz = Aba1^Aga1^Aka1^Ama1^Asa1;         De1 = Cz^Cw;         Cy = Abo1^Ago1^Ako1^Amo1^Aso1;         Di0 = Du0^ROL32(Cy, 1);         Cw = Abo0^Ago0^Ako0^Amo0^Aso0;         Di1 = Du1^Cw;         Du0 = Cw^ROL32(Cz, 1);         Du1 = Cy^Cx;         Ba = (Aba0^Da0);         Be = ROL32((Age0^De0), 22);         Bi = ROL32((Aki1^Di1), 22);         Bo = ROL32((Amo1^Do1), 11);         Bu = ROL32((Asu0^Du0),  7);         Aba0 =   Ba ^((~Be)&  Bi );         Aba0 ^= *(pRoundConstants++);         Age0 =   Be ^((~Bi)&  Bo );         Aki1 =   Bi ^((~Bo)&  Bu );         Amo1 =   Bo ^((~Bu)&  Ba );         Asu0 =   Bu ^((~Ba)&  Be );         Ba = (Aba1^Da1);         Be = ROL32((Age1^De1), 22);         Bi = ROL32((Aki0^Di0), 21);         Bo = ROL32((Amo0^Do0), 10);         Bu = ROL32((Asu1^Du1),  7);         Aba1 =   Ba ^((~Be)&  Bi );         Aba1 ^= *(pRoundConstants++);         Age1 =   Be ^((~Bi)&  Bo );         Aki0 =   Bi ^((~Bo)&  Bu );         Amo0 =   Bo ^((~Bu)&  Ba );         Asu1 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Aka1^Da1),  2);         Bo = ROL32((Ame1^De1), 23);         Bu = ROL32((Asi1^Di1), 31);         Ba = ROL32((Abo0^Do0), 14);         Be = ROL32((Agu0^Du0), 10);         Aka1 =   Ba ^((~Be)&  Bi );         Ame1 =   Be ^((~Bi)&  Bo );         Asi1 =   Bi ^((~Bo)&  Bu );         Abo0 =   Bo ^((~Bu)&  Ba );         Agu0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Aka0^Da0),  1);         Bo = ROL32((Ame0^De0), 22);         Bu = ROL32((Asi0^Di0), 30);         Ba = ROL32((Abo1^Do1), 14);         Be = ROL32((Agu1^Du1), 10);         Aka0 =   Ba ^((~Be)&  Bi );         Ame0 =   Be ^((~Bi)&  Bo );         Asi0 =   Bi ^((~Bo)&  Bu );         Abo1 =   Bo ^((~Bu)&  Ba );         Agu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Asa0^Da0),  9);         Ba = ROL32((Abe1^De1),  1);         Be = ROL32((Agi0^Di0),  3);         Bi = ROL32((Ako1^Do1), 13);         Bo = ROL32((Amu0^Du0),  4);         Asa0 =   Ba ^((~Be)&  Bi );         Abe1 =   Be ^((~Bi)&  Bo );         Agi0 =   Bi ^((~Bo)&  Bu );         Ako1 =   Bo ^((~Bu)&  Ba );         Amu0 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Asa1^Da1),  9);         Ba = (Abe0^De0);         Be = ROL32((Agi1^Di1),  3);         Bi = ROL32((Ako0^Do0), 12);         Bo = ROL32((Amu1^Du1),  4);         Asa1 =   Ba ^((~Be)&  Bi );         Abe0 =   Be ^((~Bi)&  Bo );         Agi1 =   Bi ^((~Bo)&  Bu );         Ako0 =   Bo ^((~Bu)&  Ba );         Amu1 =   Bu ^((~Ba)&  Be );         Be = ROL32((Aga0^Da0), 18);         Bi = ROL32((Ake0^De0),  5);         Bo = ROL32((Ami1^Di1),  8);         Bu = ROL32((Aso0^Do0), 28);         Ba = ROL32((Abu1^Du1), 14);         Aga0 =   Ba ^((~Be)&  Bi );         Ake0 =   Be ^((~Bi)&  Bo );         Ami1 =   Bi ^((~Bo)&  Bu );         Aso0 =   Bo ^((~Bu)&  Ba );         Abu1 =   Bu ^((~Ba)&  Be );         Be = ROL32((Aga1^Da1), 18);         Bi = ROL32((Ake1^De1),  5);         Bo = ROL32((Ami0^Di0),  7);         Bu = ROL32((Aso1^Do1), 28);         Ba = ROL32((Abu0^Du0), 13);         Aga1 =   Ba ^((~Be)&  Bi );         Ake1 =   Be ^((~Bi)&  Bo );         Ami0 =   Bi ^((~Bo)&  Bu );         Aso1 =   Bo ^((~Bu)&  Ba );         Abu0 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Ama1^Da1), 21);         Bu = ROL32((Ase0^De0),  1);         Ba = ROL32((Abi0^Di0), 31);         Be = ROL32((Ago1^Do1), 28);         Bi = ROL32((Aku1^Du1), 20);         Ama1 =   Ba ^((~Be)&  Bi );         Ase0 =   Be ^((~Bi)&  Bo );         Abi0 =   Bi ^((~Bo)&  Bu );         Ago1 =   Bo ^((~Bu)&  Ba );         Aku1 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Ama0^Da0), 20);         Bu = ROL32((Ase1^De1),  1);         Ba = ROL32((Abi1^Di1), 31);         Be = ROL32((Ago0^Do0), 27);         Bi = ROL32((Aku0^Du0), 19);         Ama0 =   Ba ^((~Be)&  Bi );         Ase1 =   Be ^((~Bi)&  Bo );         Abi1 =   Bi ^((~Bo)&  Bu );         Ago0 =   Bo ^((~Bu)&  Ba );         Aku0 =   Bu ^((~Ba)&  Be )
#define KeccakRound1()         Cx = Asu0^Agu0^Amu0^Abu1^Aku1;         Du1 = Age1^Ame0^Abe0^Ake1^Ase1;         Da0 = Cx^ROL32(Du1, 1);         Cz = Asu1^Agu1^Amu1^Abu0^Aku0;         Du0 = Age0^Ame1^Abe1^Ake0^Ase0;         Da1 = Cz^Du0;         Cw = Aki1^Asi1^Agi0^Ami1^Abi0;         Do0 = Cw^ROL32(Cz, 1);         Cy = Aki0^Asi0^Agi1^Ami0^Abi1;         Do1 = Cy^Cx;         Cx = Aba0^Aka1^Asa0^Aga0^Ama1;         De0 = Cx^ROL32(Cy, 1);         Cz = Aba1^Aka0^Asa1^Aga1^Ama0;         De1 = Cz^Cw;         Cy = Amo0^Abo1^Ako0^Aso1^Ago0;         Di0 = Du0^ROL32(Cy, 1);         Cw = Amo1^Abo0^Ako1^Aso0^Ago1;         Di1 = Du1^Cw;         Du0 = Cw^ROL32(Cz, 1);         Du1 = Cy^Cx;         Ba = (Aba0^Da0);         Be = ROL32((Ame1^De0), 22);         Bi = ROL32((Agi1^Di1), 22);         Bo = ROL32((Aso1^Do1), 11);         Bu = ROL32((Aku1^Du0),  7);         Aba0 =   Ba ^((~Be)&  Bi );         Aba0 ^= *(pRoundConstants++);         Ame1 =   Be ^((~Bi)&  Bo );         Agi1 =   Bi ^((~Bo)&  Bu );         Aso1 =   Bo ^((~Bu)&  Ba );         Aku1 =   Bu ^((~Ba)&  Be );         Ba = (Aba1^Da1);         Be = ROL32((Ame0^De1), 22);         Bi = ROL32((Agi0^Di0), 21);         Bo = ROL32((Aso0^Do0), 10);         Bu = ROL32((Aku0^Du1),  7);         Aba1 =   Ba ^((~Be)&  Bi );         Aba1 ^= *(pRoundConstants++);         Ame0 =   Be ^((~Bi)&  Bo );         Agi0 =   Bi ^((~Bo)&  Bu );         Aso0 =   Bo ^((~Bu)&  Ba );         Aku0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Asa1^Da1),  2);         Bo = ROL32((Ake1^De1), 23);         Bu = ROL32((Abi1^Di1), 31);         Ba = ROL32((Amo1^Do0), 14);         Be = ROL32((Agu0^Du0), 10);         Asa1 =   Ba ^((~Be)&  Bi );         Ake1 =   Be ^((~Bi)&  Bo );         Abi1 =   Bi ^((~Bo)&  Bu );         Amo1 =   Bo ^((~Bu)&  Ba );         Agu0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Asa0^Da0),  1);         Bo = ROL32((Ake0^De0), 22);         Bu = ROL32((Abi0^Di0), 30);         Ba = ROL32((Amo0^Do1), 14);         Be = ROL32((Agu1^Du1), 10);         Asa0 =   Ba ^((~Be)&  Bi );         Ake0 =   Be ^((~Bi)&  Bo );         Abi0 =   Bi ^((~Bo)&  Bu );         Amo0 =   Bo ^((~Bu)&  Ba );         Agu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Ama1^Da0),  9);         Ba = ROL32((Age1^De1),  1);         Be = ROL32((Asi1^Di0),  3);         Bi = ROL32((Ako0^Do1), 13);         Bo = ROL32((Abu1^Du0),  4);         Ama1 =   Ba ^((~Be)&  Bi );         Age1 =   Be ^((~Bi)&  Bo );         Asi1 =   Bi ^((~Bo)&  Bu );         Ako0 =   Bo ^((~Bu)&  Ba );         Abu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Ama0^Da1),  9);         Ba = (Age0^De0);         Be = ROL32((Asi0^Di1),  3);         Bi = ROL32((Ako1^Do0), 12);         Bo = ROL32((Abu0^Du1),  4);         Ama0 =   Ba ^((~Be)&  Bi );         Age0 =   Be ^((~Bi)&  Bo );         Asi0 =   Bi ^((~Bo)&  Bu );         Ako1 =   Bo ^((~Bu)&  Ba );         Abu0 =   Bu ^((~Ba)&  Be );         Be = ROL32((Aka1^Da0), 18);         Bi = ROL32((Abe1^De0),  5);         Bo = ROL32((Ami0^Di1),  8);         Bu = ROL32((Ago1^Do0), 28);         Ba = ROL32((Asu1^Du1), 14);         Aka1 =   Ba ^((~Be)&  Bi );         Abe1 =   Be ^((~Bi)&  Bo );         Ami0 =   Bi ^((~Bo)&  Bu );         Ago1 =   Bo ^((~Bu)&  Ba );         Asu1 =   Bu ^((~Ba)&  Be );         Be = ROL32((Aka0^Da1), 18);         Bi = ROL32((Abe0^De1),  5);         Bo = ROL32((Ami1^Di0),  7);         Bu = ROL32((Ago0^Do1), 28);         Ba = ROL32((Asu0^Du0), 13);         Aka0 =   Ba ^((~Be)&  Bi );         Abe0 =   Be ^((~Bi)&  Bo );         Ami1 =   Bi ^((~Bo)&  Bu );         Ago0 =   Bo ^((~Bu)&  Ba );         Asu0 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Aga1^Da1), 21);         Bu = ROL32((Ase0^De0),  1);         Ba = ROL32((Aki1^Di0), 31);         Be = ROL32((Abo1^Do1), 28);         Bi = ROL32((Amu1^Du1), 20);         Aga1 =   Ba ^((~Be)&  Bi );         Ase0 =   Be ^((~Bi)&  Bo );         Aki1 =   Bi ^((~Bo)&  Bu );         Abo1 =   Bo ^((~Bu)&  Ba );         Amu1 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Aga0^Da0), 20);         Bu = ROL32((Ase1^De1),  1);         Ba = ROL32((Aki0^Di1), 31);         Be = ROL32((Abo0^Do0), 27);         Bi = ROL32((Amu0^Du0), 19);         Aga0 =   Ba ^((~Be)&  Bi );         Ase1 =   Be ^((~Bi)&  Bo );         Aki0 =   Bi ^((~Bo)&  Bu );         Abo0 =   Bo ^((~Bu)&  Ba );         Amu0 =   Bu ^((~Ba)&  Be );
#define KeccakRound2()         Cx = Aku1^Agu0^Abu1^Asu1^Amu1;         Du1 = Ame0^Ake0^Age0^Abe0^Ase1;         Da0 = Cx^ROL32(Du1, 1);         Cz = Aku0^Agu1^Abu0^Asu0^Amu0;         Du0 = Ame1^Ake1^Age1^Abe1^Ase0;         Da1 = Cz^Du0;         Cw = Agi1^Abi1^Asi1^Ami0^Aki1;         Do0 = Cw^ROL32(Cz, 1);         Cy = Agi0^Abi0^Asi0^Ami1^Aki0;         Do1 = Cy^Cx;         Cx = Aba0^Asa1^Ama1^Aka1^Aga1;         De0 = Cx^ROL32(Cy, 1);         Cz = Aba1^Asa0^Ama0^Aka0^Aga0;         De1 = Cz^Cw;         Cy = Aso0^Amo0^Ako1^Ago0^Abo0;         Di0 = Du0^ROL32(Cy, 1);         Cw = Aso1^Amo1^Ako0^Ago1^Abo1;         Di1 = Du1^Cw;         Du0 = Cw^ROL32(Cz, 1);         Du1 = Cy^Cx;         Ba = (Aba0^Da0);         Be = ROL32((Ake1^De0), 22);         Bi = ROL32((Asi0^Di1), 22);         Bo = ROL32((Ago0^Do1), 11);         Bu = ROL32((Amu1^Du0),  7);         Aba0 =   Ba ^((~Be)&  Bi );         Aba0 ^= *(pRoundConstants++);         Ake1 =   Be ^((~Bi)&  Bo );         Asi0 =   Bi ^((~Bo)&  Bu );         Ago0 =   Bo ^((~Bu)&  Ba );         Amu1 =   Bu ^((~Ba)&  Be );         Ba = (Aba1^Da1);         Be = ROL32((Ake0^De1), 22);         Bi = ROL32((Asi1^Di0), 21);         Bo = ROL32((Ago1^Do0), 10);         Bu = ROL32((Amu0^Du1),  7);         Aba1 =   Ba ^((~Be)&  Bi );         Aba1 ^= *(pRoundConstants++);         Ake0 =   Be ^((~Bi)&  Bo );         Asi1 =   Bi ^((~Bo)&  Bu );         Ago1 =   Bo ^((~Bu)&  Ba );         Amu0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Ama0^Da1),  2);         Bo = ROL32((Abe0^De1), 23);         Bu = ROL32((Aki0^Di1), 31);         Ba = ROL32((Aso1^Do0), 14);         Be = ROL32((Agu0^Du0), 10);         Ama0 =   Ba ^((~Be)&  Bi );         Abe0 =   Be ^((~Bi)&  Bo );         Aki0 =   Bi ^((~Bo)&  Bu );         Aso1 =   Bo ^((~Bu)&  Ba );         Agu0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Ama1^Da0),  1);         Bo = ROL32((Abe1^De0), 22);         Bu = ROL32((Aki1^Di0), 30);         Ba = ROL32((Aso0^Do1), 14);         Be = ROL32((Agu1^Du1), 10);         Ama1 =   Ba ^((~Be)&  Bi );         Abe1 =   Be ^((~Bi)&  Bo );         Aki1 =   Bi ^((~Bo)&  Bu );         Aso0 =   Bo ^((~Bu)&  Ba );         Agu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Aga1^Da0),  9);         Ba = ROL32((Ame0^De1),  1);         Be = ROL32((Abi1^Di0),  3);         Bi = ROL32((Ako1^Do1), 13);         Bo = ROL32((Asu1^Du0),  4);         Aga1 =   Ba ^((~Be)&  Bi );         Ame0 =   Be ^((~Bi)&  Bo );         Abi1 =   Bi ^((~Bo)&  Bu );         Ako1 =   Bo ^((~Bu)&  Ba );         Asu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Aga0^Da1),  9);         Ba = (Ame1^De0);         Be = ROL32((Abi0^Di1),  3);         Bi = ROL32((Ako0^Do0), 12);         Bo = ROL32((Asu0^Du1),  4);         Aga0 =   Ba ^((~Be)&  Bi );         Ame1 =   Be ^((~Bi)&  Bo );         Abi0 =   Bi ^((~Bo)&  Bu );         Ako0 =   Bo ^((~Bu)&  Ba );         Asu0 =   Bu ^((~Ba)&  Be );         Be = ROL32((Asa1^Da0), 18);         Bi = ROL32((Age1^De0),  5);         Bo = ROL32((Ami1^Di1),  8);         Bu = ROL32((Abo1^Do0), 28);         Ba = ROL32((Aku0^Du1), 14);         Asa1 =   Ba ^((~Be)&  Bi );         Age1 =   Be ^((~Bi)&  Bo );         Ami1 =   Bi ^((~Bo)&  Bu );         Abo1 =   Bo ^((~Bu)&  Ba );         Aku0 =   Bu ^((~Ba)&  Be );         Be = ROL32((Asa0^Da1), 18);         Bi = ROL32((Age0^De1),  5);         Bo = ROL32((Ami0^Di0),  7);         Bu = ROL32((Abo0^Do1), 28);         Ba = ROL32((Aku1^Du0), 13);         Asa0 =   Ba ^((~Be)&  Bi );         Age0 =   Be ^((~Bi)&  Bo );         Ami0 =   Bi ^((~Bo)&  Bu );         Abo0 =   Bo ^((~Bu)&  Ba );         Aku1 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Aka0^Da1), 21);         Bu = ROL32((Ase0^De0),  1);         Ba = ROL32((Agi1^Di0), 31);         Be = ROL32((Amo0^Do1), 28);         Bi = ROL32((Abu0^Du1), 20);         Aka0 =   Ba ^((~Be)&  Bi );         Ase0 =   Be ^((~Bi)&  Bo );         Agi1 =   Bi ^((~Bo)&  Bu );         Amo0 =   Bo ^((~Bu)&  Ba );         Abu0 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Aka1^Da0), 20);         Bu = ROL32((Ase1^De1),  1);         Ba = ROL32((Agi0^Di1), 31);         Be = ROL32((Amo1^Do0), 27);         Bi = ROL32((Abu1^Du0), 19);         Aka1 =   Ba ^((~Be)&  Bi );         Ase1 =   Be ^((~Bi)&  Bo );         Agi0 =   Bi ^((~Bo)&  Bu );         Amo1 =   Bo ^((~Bu)&  Ba );         Abu1 =   Bu ^((~Ba)&  Be );
#define KeccakRound3()         Cx = Amu1^Agu0^Asu1^Aku0^Abu0;         Du1 = Ake0^Abe1^Ame1^Age0^Ase1;         Da0 = Cx^ROL32(Du1, 1);         Cz = Amu0^Agu1^Asu0^Aku1^Abu1;         Du0 = Ake1^Abe0^Ame0^Age1^Ase0;         Da1 = Cz^Du0;         Cw = Asi0^Aki0^Abi1^Ami1^Agi1;         Do0 = Cw^ROL32(Cz, 1);         Cy = Asi1^Aki1^Abi0^Ami0^Agi0;         Do1 = Cy^Cx;         Cx = Aba0^Ama0^Aga1^Asa1^Aka0;         De0 = Cx^ROL32(Cy, 1);         Cz = Aba1^Ama1^Aga0^Asa0^Aka1;         De1 = Cz^Cw;         Cy = Ago1^Aso0^Ako0^Abo0^Amo1;         Di0 = Du0^ROL32(Cy, 1);         Cw = Ago0^Aso1^Ako1^Abo1^Amo0;         Di1 = Du1^Cw;         Du0 = Cw^ROL32(Cz, 1);         Du1 = Cy^Cx;         Ba = (Aba0^Da0);         Be = ROL32((Abe0^De0), 22);         Bi = ROL32((Abi0^Di1), 22);         Bo = ROL32((Abo0^Do1), 11);         Bu = ROL32((Abu0^Du0),  7);         Aba0 =   Ba ^((~Be)&  Bi );         Aba0 ^= *(pRoundConstants++);         Abe0 =   Be ^((~Bi)&  Bo );         Abi0 =   Bi ^((~Bo)&  Bu );         Abo0 =   Bo ^((~Bu)&  Ba );         Abu0 =   Bu ^((~Ba)&  Be );         Ba = (Aba1^Da1);         Be = ROL32((Abe1^De1), 22);         Bi = ROL32((Abi1^Di0), 21);         Bo = ROL32((Abo1^Do0), 10);         Bu = ROL32((Abu1^Du1),  7);         Aba1 =   Ba ^((~Be)&  Bi );         Aba1 ^= *(pRoundConstants++);         Abe1 =   Be ^((~Bi)&  Bo );         Abi1 =   Bi ^((~Bo)&  Bu );         Abo1 =   Bo ^((~Bu)&  Ba );         Abu1 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Aga0^Da1),  2);         Bo = ROL32((Age0^De1), 23);         Bu = ROL32((Agi0^Di1), 31);         Ba = ROL32((Ago0^Do0), 14);         Be = ROL32((Agu0^Du0), 10);         Aga0 =   Ba ^((~Be)&  Bi );         Age0 =   Be ^((~Bi)&  Bo );         Agi0 =   Bi ^((~Bo)&  Bu );         Ago0 =   Bo ^((~Bu)&  Ba );         Agu0 =   Bu ^((~Ba)&  Be );         Bi = ROL32((Aga1^Da0),  1);         Bo = ROL32((Age1^De0), 22);         Bu = ROL32((Agi1^Di0), 30);         Ba = ROL32((Ago1^Do1), 14);         Be = ROL32((Agu1^Du1), 10);         Aga1 =   Ba ^((~Be)&  Bi );         Age1 =   Be ^((~Bi)&  Bo );         Agi1 =   Bi ^((~Bo)&  Bu );         Ago1 =   Bo ^((~Bu)&  Ba );         Agu1 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Aka0^Da0),  9);         Ba = ROL32((Ake0^De1),  1);         Be = ROL32((Aki0^Di0),  3);         Bi = ROL32((Ako0^Do1), 13);         Bo = ROL32((Aku0^Du0),  4);         Aka0 =   Ba ^((~Be)&  Bi );         Ake0 =   Be ^((~Bi)&  Bo );         Aki0 =   Bi ^((~Bo)&  Bu );         Ako0 =   Bo ^((~Bu)&  Ba );         Aku0 =   Bu ^((~Ba)&  Be );         Bu = ROL32((Aka1^Da1),  9);         Ba = (Ake1^De0);         Be = ROL32((Aki1^Di1),  3);         Bi = ROL32((Ako1^Do0), 12);         Bo = ROL32((Aku1^Du1),  4);         Aka1 =   Ba ^((~Be)&  Bi );         Ake1 =   Be ^((~Bi)&  Bo );         Aki1 =   Bi ^((~Bo)&  Bu );         Ako1 =   Bo ^((~Bu)&  Ba );         Aku1 =   Bu ^((~Ba)&  Be );         Be = ROL32((Ama0^Da0), 18);         Bi = ROL32((Ame0^De0),  5);         Bo = ROL32((Ami0^Di1),  8);         Bu = ROL32((Amo0^Do0), 28);         Ba = ROL32((Amu0^Du1), 14);         Ama0 =   Ba ^((~Be)&  Bi );         Ame0 =   Be ^((~Bi)&  Bo );         Ami0 =   Bi ^((~Bo)&  Bu );         Amo0 =   Bo ^((~Bu)&  Ba );         Amu0 =   Bu ^((~Ba)&  Be );         Be = ROL32((Ama1^Da1), 18);         Bi = ROL32((Ame1^De1),  5);         Bo = ROL32((Ami1^Di0),  7);         Bu = ROL32((Amo1^Do1), 28);         Ba = ROL32((Amu1^Du0), 13);         Ama1 =   Ba ^((~Be)&  Bi );         Ame1 =   Be ^((~Bi)&  Bo );         Ami1 =   Bi ^((~Bo)&  Bu );         Amo1 =   Bo ^((~Bu)&  Ba );         Amu1 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Asa0^Da1), 21);         Bu = ROL32((Ase0^De0),  1);         Ba = ROL32((Asi0^Di0), 31);         Be = ROL32((Aso0^Do1), 28);         Bi = ROL32((Asu0^Du1), 20);         Asa0 =   Ba ^((~Be)&  Bi );         Ase0 =   Be ^((~Bi)&  Bo );         Asi0 =   Bi ^((~Bo)&  Bu );         Aso0 =   Bo ^((~Bu)&  Ba );         Asu0 =   Bu ^((~Ba)&  Be );         Bo = ROL32((Asa1^Da0), 20);         Bu = ROL32((Ase1^De1),  1);         Ba = ROL32((Asi1^Di1), 31);         Be = ROL32((Aso1^Do0), 27);         Bi = ROL32((Asu1^Du0), 19);         Asa1 =   Ba ^((~Be)&  Bi );         Ase1 =   Be ^((~Bi)&  Bo );         Asi1 =   Bi ^((~Bo)&  Bu );         Aso1 =   Bo ^((~Bu)&  Ba );         Asu1 =   Bu ^((~Ba)&  Be );
void KeccakP1600_Permute_Nrounds(void *state, unsigned int nRounds)
{
    UINT32 Da0, De0, Di0, Do0, Du0;
    UINT32 Da1, De1, Di1, Do1, Du1;
    UINT32 Ba, Be, Bi, Bo, Bu;
    UINT32 Cx, Cy, Cz, Cw;
    const UINT32 *pRoundConstants = KeccakF1600RoundConstants_int2+(24-nRounds)*2;
    UINT32 *stateAsHalfLanes = (UINT32*)state;
    #define Aba0 stateAsHalfLanes[ 0]
    #define Aba1 stateAsHalfLanes[ 1]
    #define Abe0 stateAsHalfLanes[ 2]
    #define Abe1 stateAsHalfLanes[ 3]
    #define Abi0 stateAsHalfLanes[ 4]
    #define Abi1 stateAsHalfLanes[ 5]
    #define Abo0 stateAsHalfLanes[ 6]
    #define Abo1 stateAsHalfLanes[ 7]
    #define Abu0 stateAsHalfLanes[ 8]
    #define Abu1 stateAsHalfLanes[ 9]
    #define Aga0 stateAsHalfLanes[10]
    #define Aga1 stateAsHalfLanes[11]
    #define Age0 stateAsHalfLanes[12]
    #define Age1 stateAsHalfLanes[13]
    #define Agi0 stateAsHalfLanes[14]
    #define Agi1 stateAsHalfLanes[15]
    #define Ago0 stateAsHalfLanes[16]
    #define Ago1 stateAsHalfLanes[17]
    #define Agu0 stateAsHalfLanes[18]
    #define Agu1 stateAsHalfLanes[19]
    #define Aka0 stateAsHalfLanes[20]
    #define Aka1 stateAsHalfLanes[21]
    #define Ake0 stateAsHalfLanes[22]
    #define Ake1 stateAsHalfLanes[23]
    #define Aki0 stateAsHalfLanes[24]
    #define Aki1 stateAsHalfLanes[25]
    #define Ako0 stateAsHalfLanes[26]
    #define Ako1 stateAsHalfLanes[27]
    #define Aku0 stateAsHalfLanes[28]
    #define Aku1 stateAsHalfLanes[29]
    #define Ama0 stateAsHalfLanes[30]
    #define Ama1 stateAsHalfLanes[31]
    #define Ame0 stateAsHalfLanes[32]
    #define Ame1 stateAsHalfLanes[33]
    #define Ami0 stateAsHalfLanes[34]
    #define Ami1 stateAsHalfLanes[35]
    #define Amo0 stateAsHalfLanes[36]
    #define Amo1 stateAsHalfLanes[37]
    #define Amu0 stateAsHalfLanes[38]
    #define Amu1 stateAsHalfLanes[39]
    #define Asa0 stateAsHalfLanes[40]
    #define Asa1 stateAsHalfLanes[41]
    #define Ase0 stateAsHalfLanes[42]
    #define Ase1 stateAsHalfLanes[43]
    #define Asi0 stateAsHalfLanes[44]
    #define Asi1 stateAsHalfLanes[45]
    #define Aso0 stateAsHalfLanes[46]
    #define Aso1 stateAsHalfLanes[47]
    #define Asu0 stateAsHalfLanes[48]
    #define Asu1 stateAsHalfLanes[49]
    nRounds &= 3;
    switch ( nRounds )
    {
        #define I0 Ba
        #define I1 Be
        #define T0 Bi
        #define T1 Bo
        #define SwapPI13( in0,in1,in2,in3,eo0,eo1,eo2,eo3 )             I0 = (in0)[0]; I1 = (in0)[1];                   T0 = (in1)[0]; T1 = (in1)[1];                   (in0)[eo0] = T0; (in0)[eo0^1] = T1;             T0 = (in2)[0]; T1 = (in2)[1];                   (in1)[eo1] = T0; (in1)[eo1^1] = T1;             T0 = (in3)[0]; T1 = (in3)[1];                   (in2)[eo2] = T0; (in2)[eo2^1] = T1;             (in3)[eo3] = I0; (in3)[eo3^1] = I1
        #define SwapPI2( in0,in1,in2,in3 )             I0 = (in0)[0]; I1 = (in0)[1];             T0 = (in1)[0]; T1 = (in1)[1];             (in0)[1] = T0; (in0)[0] = T1;             (in1)[1] = I0; (in1)[0] = I1;             I0 = (in2)[0]; I1 = (in2)[1];             T0 = (in3)[0]; T1 = (in3)[1];             (in2)[1] = T0; (in2)[0] = T1;             (in3)[1] = I0; (in3)[0] = I1
        #define SwapEO( even,odd ) T0 = even; even = odd; odd = T0
        case 1:
            SwapPI13( &Aga0, &Aka0, &Asa0, &Ama0, 1, 0, 1, 0 );
            SwapPI13( &Abe0, &Age0, &Ame0, &Ake0, 0, 1, 0, 1 );
            SwapPI13( &Abi0, &Aki0, &Agi0, &Asi0, 1, 0, 1, 0 );
            SwapEO( Ami0, Ami1 );
            SwapPI13( &Abo0, &Amo0, &Aso0, &Ago0, 1, 0, 1, 0 );
            SwapEO( Ako0, Ako1 );
            SwapPI13( &Abu0, &Asu0, &Aku0, &Amu0, 0, 1, 0, 1 );
            break;
        case 2:
            SwapPI2( &Aga0, &Asa0, &Aka0, &Ama0 );
            SwapPI2( &Abe0, &Ame0, &Age0, &Ake0 );
            SwapPI2( &Abi0, &Agi0, &Aki0, &Asi0 );
            SwapPI2( &Abo0, &Aso0, &Ago0, &Amo0 );
            SwapPI2( &Abu0, &Aku0, &Amu0, &Asu0 );
            break;
        case 3:
            SwapPI13( &Aga0, &Ama0, &Asa0, &Aka0, 0, 1, 0, 1 );
            SwapPI13( &Abe0, &Ake0, &Ame0, &Age0, 1, 0, 1, 0 );
            SwapPI13( &Abi0, &Asi0, &Agi0, &Aki0, 0, 1, 0, 1 );
            SwapEO( Ami0, Ami1 );
            SwapPI13( &Abo0, &Ago0, &Aso0, &Amo0, 0, 1, 0, 1 );
            SwapEO( Ako0, Ako1 );
            SwapPI13( &Abu0, &Amu0, &Aku0, &Asu0, 1, 0, 1, 0 );
            break;
        #undef I0
        #undef I1
        #undef T0
        #undef T1
        #undef SwapPI13
        #undef SwapPI2
        #undef SwapEO
    }
    do
    {
        /* Code for 4 rounds, using factor 2 interleaving, 64-bit lanes mapped to 32-bit words */
        switch ( nRounds )
        {
            case 0: KeccakRound0();
            case 3: KeccakRound1();
            case 2: KeccakRound2();
            case 1: KeccakRound3();
        }
        nRounds = 0;
    }
    while ( *pRoundConstants != 0xFF );
    #undef Aba0
    #undef Aba1
    #undef Abe0
    #undef Abe1
    #undef Abi0
    #undef Abi1
    #undef Abo0
    #undef Abo1
    #undef Abu0
    #undef Abu1
    #undef Aga0
    #undef Aga1
    #undef Age0
    #undef Age1
    #undef Agi0
    #undef Agi1
    #undef Ago0
    #undef Ago1
    #undef Agu0
    #undef Agu1
    #undef Aka0
    #undef Aka1
    #undef Ake0
    #undef Ake1
    #undef Aki0
    #undef Aki1
    #undef Ako0
    #undef Ako1
    #undef Aku0
    #undef Aku1
    #undef Ama0
    #undef Ama1
    #undef Ame0
    #undef Ame1
    #undef Ami0
    #undef Ami1
    #undef Amo0
    #undef Amo1
    #undef Amu0
    #undef Amu1
    #undef Asa0
    #undef Asa1
    #undef Ase0
    #undef Ase1
    #undef Asi0
    #undef Asi1
    #undef Aso0
    #undef Aso1
    #undef Asu0
    #undef Asu1
}
/* ---------------------------------------------------------------- */
void KeccakP1600_Permute_12rounds(void *state)
{
     KeccakP1600_Permute_Nrounds(state, 12);
}
#endif
/*
Implementation by Ronny Van Keer, hereby denoted as "the implementer".
For more information, feedback or questions, please refer to our website:
https://keccak.team/
To the extent possible under law, the implementer has waived all copyright
and related or neighboring rights to the source code in this file.
http://creativecommons.org/publicdomain/zero/1.0/
*/
#ifndef _KangarooTwelve_h_
#define _KangarooTwelve_h_
//#include "KeccakP-1600-SnP.h"
#ifdef __64__
#else
#endif
#ifdef ALIGN
#undef ALIGN
#endif
#if defined(__GNUC__)
#define ALIGN(x) __attribute__ ((aligned(x)))
#elif defined(_MSC_VER)
#define ALIGN(x) __declspec(align(x))
#elif defined(__ARMCC_VERSION)
#define ALIGN(x) __align(x)
#else
#define ALIGN(x)
#endif
ALIGN(KeccakP1600_stateAlignment) typedef struct KeccakWidth1600_12rounds_SpongeInstanceStruct {
    unsigned char state[KeccakP1600_stateSizeInBytes];
    unsigned int rate;
    unsigned int byteIOIndex;
    int squeezing;
} KeccakWidth1600_12rounds_SpongeInstance;
typedef enum {
    NOT_INITIALIZED,
    ABSORBING,
    FINAL,
    SQUEEZING
} KCP_Phases;
typedef KCP_Phases KangarooTwelve_Phases;
typedef struct {
    KeccakWidth1600_12rounds_SpongeInstance queueNode;
    KeccakWidth1600_12rounds_SpongeInstance finalNode;
    size_t fixedOutputLength;
    size_t blockNumber;
    unsigned int queueAbsorbedLen;
    KangarooTwelve_Phases phase;
} KangarooTwelve_Instance;
/** Extendable ouput function KangarooTwelve.
  * @param  input           Pointer to the input message (M).
  * @param  inputByteLen    The length of the input message in bytes.
  * @param  output          Pointer to the output buffer.
  * @param  outputByteLen   The desired number of output bytes.
  * @param  customization   Pointer to the customization string (C).
  * @param  customByteLen   The length of the customization string in bytes.
  * @return 0 if successful, 1 otherwise.
  */
int KangarooTwelve(const unsigned char *input, size_t inputByteLen, unsigned char *output, size_t outputByteLen, const unsigned char *customization, size_t customByteLen );
/**
  * Function to initialize a KangarooTwelve instance.
  * @param  ktInstance      Pointer to the instance to be initialized.
  * @param  outputByteLen   The desired number of output bytes,
  *                         or 0 for an arbitrarily-long output.
  * @return 0 if successful, 1 otherwise.
  */
int KangarooTwelve_Initialize(KangarooTwelve_Instance *ktInstance, size_t outputByteLen);
/**
  * Function to give input data to be absorbed.
  * @param  ktInstance      Pointer to the instance initialized by KangarooTwelve_Initialize().
  * @param  input           Pointer to the input message data (M).
  * @param  inputByteLen    The number of bytes provided in the input message data.
  * @return 0 if successful, 1 otherwise.
  */
int KangarooTwelve_Update(KangarooTwelve_Instance *ktInstance, const unsigned char *input, size_t inputByteLen);
/**
  * Function to call after all the input message has been input, and to get
  * output bytes if the length was specified when calling KangarooTwelve_Initialize().
  * @param  ktInstance      Pointer to the hash instance initialized by KangarooTwelve_Initialize().
  * If @a outputByteLen was not 0 in the call to KangarooTwelve_Initialize(), the number of
  *     output bytes is equal to @a outputByteLen.
  * If @a outputByteLen was 0 in the call to KangarooTwelve_Initialize(), the output bytes
  *     must be extracted using the KangarooTwelve_Squeeze() function.
  * @param  output          Pointer to the buffer where to store the output data.
  * @param  customization   Pointer to the customization string (C).
  * @param  customByteLen   The length of the customization string in bytes.
  * @return 0 if successful, 1 otherwise.
  */
int KangarooTwelve_Final(KangarooTwelve_Instance *ktInstance, unsigned char *output, const unsigned char *customization, size_t customByteLen);
/**
  * Function to squeeze output data.
  * @param  ktInstance     Pointer to the hash instance initialized by KangarooTwelve_Initialize().
  * @param  data           Pointer to the buffer where to store the output data.
  * @param  outputByteLen  The number of output bytes desired.
  * @pre    KangarooTwelve_Final() must have been already called.
  * @return 0 if successful, 1 otherwise.
  */
int KangarooTwelve_Squeeze(KangarooTwelve_Instance *ktInstance, unsigned char *output, size_t outputByteLen);
#endif
int KeccakWidth1600_12rounds_SpongeInitialize(KeccakWidth1600_12rounds_SpongeInstance *spongeInstance, unsigned int rate, unsigned int capacity);
int KeccakWidth1600_12rounds_SpongeAbsorb(KeccakWidth1600_12rounds_SpongeInstance *spongeInstance, const unsigned char *data, size_t dataByteLen);
int KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(KeccakWidth1600_12rounds_SpongeInstance *spongeInstance, unsigned char delimitedData);
int KeccakWidth1600_12rounds_SpongeSqueeze(KeccakWidth1600_12rounds_SpongeInstance *spongeInstance, unsigned char *data, size_t dataByteLen);
int KeccakWidth1600_12rounds_SpongeInitialize(KeccakWidth1600_12rounds_SpongeInstance *instance, unsigned int rate, unsigned int capacity)
{
    if (rate+capacity != 1600)
        return 1;
    if ((rate <= 0) || (rate > 1600) || ((rate % 8) != 0))
        return 1;
    KeccakP1600_StaticInitialize();
    KeccakP1600_Initialize(instance->state);
    instance->rate = rate;
    instance->byteIOIndex = 0;
    instance->squeezing = 0;
    return 0;
}
/* ---------------------------------------------------------------- */
int KeccakWidth1600_12rounds_SpongeAbsorb(KeccakWidth1600_12rounds_SpongeInstance *instance, const unsigned char *data, size_t dataByteLen)
{
    size_t i, j;
    unsigned int partialBlock;
    const unsigned char *curData;
    unsigned int rateInBytes = instance->rate/8;
    if (instance->squeezing)
        return 1;
    i = 0;
    curData = data;
    while(i < dataByteLen) {
        if ((instance->byteIOIndex == 0) && (dataByteLen >= (i + rateInBytes))) {
#ifdef KeccakP1600_12rounds_FastLoop_supported
            /* processing full blocks first */
            if ((rateInBytes % (1600/200)) == 0) {
                /* fast lane: whole lane rate */
                j = KeccakP1600_12rounds_FastLoop_Absorb(instance->state, rateInBytes/(1600/200), curData, dataByteLen - i);
                i += j;
                curData += j;
            }
            else {
#endif
                for(j=dataByteLen-i; j>=rateInBytes; j-=rateInBytes) {
                    KeccakP1600_AddBytes(instance->state, curData, 0, rateInBytes);
                    KeccakP1600_Permute_12rounds(instance->state);
                    curData+=rateInBytes;
                }
                i = dataByteLen - j;
#ifdef KeccakP1600_12rounds_FastLoop_supported
            }
#endif
        }
        else {
            /* normal lane: using the message queue */
            partialBlock = (unsigned int)(dataByteLen - i);
            if (partialBlock+instance->byteIOIndex > rateInBytes)
                partialBlock = rateInBytes-instance->byteIOIndex;
            i += partialBlock;
            KeccakP1600_AddBytes(instance->state, curData, instance->byteIOIndex, partialBlock);
            curData += partialBlock;
            instance->byteIOIndex += partialBlock;
            if (instance->byteIOIndex == rateInBytes) {
                KeccakP1600_Permute_12rounds(instance->state);
                instance->byteIOIndex = 0;
            }
        }
    }
    return 0;
}
/* ---------------------------------------------------------------- */
int KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(KeccakWidth1600_12rounds_SpongeInstance *instance, unsigned char delimitedData)
{
    unsigned int rateInBytes = instance->rate/8;
    if (delimitedData == 0)
        return 1;
    if (instance->squeezing)
        return 1;
    /* Last few bits, whose delimiter coincides with first bit of padding */
    KeccakP1600_AddByte(instance->state, delimitedData, instance->byteIOIndex);
    /* If the first bit of padding is at position rate-1, we need a whole new block for the second bit of padding */
    if ((delimitedData >= 0x80) && (instance->byteIOIndex == (rateInBytes-1)))
        KeccakP1600_Permute_12rounds(instance->state);
    /* Second bit of padding */
    KeccakP1600_AddByte(instance->state, 0x80, rateInBytes-1);
    KeccakP1600_Permute_12rounds(instance->state);
    instance->byteIOIndex = 0;
    instance->squeezing = 1;
    return 0;
}
/* ---------------------------------------------------------------- */
int KeccakWidth1600_12rounds_SpongeSqueeze(KeccakWidth1600_12rounds_SpongeInstance *instance, unsigned char *data, size_t dataByteLen)
{
    size_t i, j;
    unsigned int partialBlock;
    unsigned int rateInBytes = instance->rate/8;
    unsigned char *curData;
    if (!instance->squeezing)
        KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(instance, 0x01);
    i = 0;
    curData = data;
    while(i < dataByteLen) {
        if ((instance->byteIOIndex == rateInBytes) && (dataByteLen >= (i + rateInBytes))) {
            for(j=dataByteLen-i; j>=rateInBytes; j-=rateInBytes) {
                KeccakP1600_Permute_12rounds(instance->state);
                KeccakP1600_ExtractBytes(instance->state, curData, 0, rateInBytes);
                curData+=rateInBytes;
            }
            i = dataByteLen - j;
        }
        else {
            /* normal lane: using the message queue */
            if (instance->byteIOIndex == rateInBytes) {
                KeccakP1600_Permute_12rounds(instance->state);
                instance->byteIOIndex = 0;
            }
            partialBlock = (unsigned int)(dataByteLen - i);
            if (partialBlock+instance->byteIOIndex > rateInBytes)
                partialBlock = rateInBytes-instance->byteIOIndex;
            i += partialBlock;
            KeccakP1600_ExtractBytes(instance->state, curData, instance->byteIOIndex, partialBlock);
            curData += partialBlock;
            instance->byteIOIndex += partialBlock;
        }
    }
    return 0;
}
/* ---------------------------------------------------------------- */
#define chunkSize       8192
#define laneSize        8
#define suffixLeaf      0x0B
#define security        128
#define capacity        (2*security)
#define capacityInBytes (capacity/8)
#define capacityInLanes (capacityInBytes/laneSize)
#define rate            (1600-capacity)
#define rateInBytes     (rate/8)
#define rateInLanes     (rateInBytes/laneSize)
#define ParallelSpongeFastLoop( Parallellism )     while ( inLen >= Parallellism * chunkSize ) {         ALIGN(KeccakP1600times##Parallellism##_statesAlignment) unsigned char states[KeccakP1600times##Parallellism##_statesSizeInBytes];         unsigned char intermediate[Parallellism*capacityInBytes];         unsigned int localBlockLen = chunkSize;         const unsigned char * localInput = input;         unsigned int i;         unsigned int fastLoopOffset;                 KeccakP1600times##Parallellism##_StaticInitialize();         KeccakP1600times##Parallellism##_InitializeAll(states);         fastLoopOffset = KeccakP1600times##Parallellism##_12rounds_FastLoop_Absorb(states, rateInLanes, chunkSize / laneSize, rateInLanes, localInput, Parallellism * chunkSize);         localBlockLen -= fastLoopOffset;         localInput += fastLoopOffset;         for ( i = 0; i < Parallellism; ++i, localInput += chunkSize ) {             KeccakP1600times##Parallellism##_AddBytes(states, i, localInput, 0, localBlockLen);             KeccakP1600times##Parallellism##_AddByte(states, i, suffixLeaf, localBlockLen);             KeccakP1600times##Parallellism##_AddByte(states, i, 0x80, rateInBytes-1);         }         KeccakP1600times##Parallellism##_PermuteAll_12rounds(states);         input += Parallellism * chunkSize;         inLen -= Parallellism * chunkSize;         ktInstance->blockNumber += Parallellism;         KeccakP1600times##Parallellism##_ExtractLanesAll(states, intermediate, capacityInLanes, capacityInLanes );         if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, intermediate, Parallellism * capacityInBytes) != 0) return 1;     }
#define ParallelSpongeLoop( Parallellism )     while ( inLen >= Parallellism * chunkSize ) {         ALIGN(KeccakP1600times##Parallellism##_statesAlignment) unsigned char states[KeccakP1600times##Parallellism##_statesSizeInBytes];         unsigned char intermediate[Parallellism*capacityInBytes];         unsigned int localBlockLen = chunkSize;         const unsigned char * localInput = input;         unsigned int i;                 KeccakP1600times##Parallellism##_StaticInitialize();         KeccakP1600times##Parallellism##_InitializeAll(states);         while(localBlockLen >= rateInBytes) {             KeccakP1600times##Parallellism##_AddLanesAll(states, localInput, rateInLanes, chunkSize / laneSize);             KeccakP1600times##Parallellism##_PermuteAll_12rounds(states);             localBlockLen -= rateInBytes;             localInput += rateInBytes;            }         for ( i = 0; i < Parallellism; ++i, localInput += chunkSize ) {             KeccakP1600times##Parallellism##_AddBytes(states, i, localInput, 0, localBlockLen);             KeccakP1600times##Parallellism##_AddByte(states, i, suffixLeaf, localBlockLen);             KeccakP1600times##Parallellism##_AddByte(states, i, 0x80, rateInBytes-1);         }         KeccakP1600times##Parallellism##_PermuteAll_12rounds(states);         input += Parallellism * chunkSize;         inLen -= Parallellism * chunkSize;         ktInstance->blockNumber += Parallellism;         KeccakP1600times##Parallellism##_ExtractLanesAll(states, intermediate, capacityInLanes, capacityInLanes );         if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, intermediate, Parallellism * capacityInBytes) != 0) return 1;     }
static unsigned int right_encode( unsigned char * encbuf, size_t value )
{
    unsigned int n, i;
    size_t v;
    for ( v = value, n = 0; v && (n < sizeof(size_t)); ++n, v >>= 8 )
        ;
    for ( i = 1; i <= n; ++i )
        encbuf[i-1] = (unsigned char)(value >> (8 * (n-i)));
    encbuf[n] = (unsigned char)n;
    return n + 1;
}
int KangarooTwelve_Initialize(KangarooTwelve_Instance *ktInstance, size_t outputLen)
{
    ktInstance->fixedOutputLength = outputLen;
    ktInstance->queueAbsorbedLen = 0;
    ktInstance->blockNumber = 0;
    ktInstance->phase = ABSORBING;
    return KeccakWidth1600_12rounds_SpongeInitialize(&ktInstance->finalNode, rate, capacity);
}
int KangarooTwelve_Update(KangarooTwelve_Instance *ktInstance, const unsigned char *input, size_t inLen)
{
    if (ktInstance->phase != ABSORBING)
        return 1;
    if ( ktInstance->blockNumber == 0 ) {
        /* First block, absorb in final node */
        unsigned int len = (unsigned int)((inLen < (chunkSize - ktInstance->queueAbsorbedLen)) ? inLen : (chunkSize - ktInstance->queueAbsorbedLen));
        if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, input, len) != 0)
            return 1;
        input += len;
        inLen -= len;
        ktInstance->queueAbsorbedLen += len;
        if ( (ktInstance->queueAbsorbedLen == chunkSize) && (inLen != 0) ) {
            /* First block complete and more input data available, finalize it */
            const unsigned char padding = 0x03;
            ktInstance->queueAbsorbedLen = 0;
            ktInstance->blockNumber = 1;
            if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, &padding, 1) != 0)
                return 1;
            ktInstance->finalNode.byteIOIndex = (ktInstance->finalNode.byteIOIndex + 7) & ~7;
        }
    }
    else if ( ktInstance->queueAbsorbedLen != 0 ) {
        /* There is data in the queue, absorb further in queue until block complete */
        unsigned int len = (unsigned int)((inLen < (chunkSize - ktInstance->queueAbsorbedLen)) ? inLen : (chunkSize - ktInstance->queueAbsorbedLen));
        if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->queueNode, input, len) != 0)
            return 1;
        input += len;
        inLen -= len;
        ktInstance->queueAbsorbedLen += len;
        if ( ktInstance->queueAbsorbedLen == chunkSize ) {
            unsigned char intermediate[capacityInBytes];
            ktInstance->queueAbsorbedLen = 0;
            ++ktInstance->blockNumber;
            if (KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(&ktInstance->queueNode, suffixLeaf) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeSqueeze(&ktInstance->queueNode, intermediate, capacityInBytes) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, intermediate, capacityInBytes) != 0)
                return 1;
        }
    }
    #if defined(KeccakP1600times8_implementation) && !defined(KeccakP1600times8_isFallback)
    #if defined(KeccakP1600times8_12rounds_FastLoop_supported)
    ParallelSpongeFastLoop( 8 )
    #else
    ParallelSpongeLoop( 8 )
    #endif
    #endif
    #if defined(KeccakP1600times4_implementation) && !defined(KeccakP1600times4_isFallback)
    #if defined(KeccakP1600times4_12rounds_FastLoop_supported)
    ParallelSpongeFastLoop( 4 )
    #else
    ParallelSpongeLoop( 4 )
    #endif
    #endif
    #if defined(KeccakP1600times2_implementation) && !defined(KeccakP1600times2_isFallback)
    #if defined(KeccakP1600times2_12rounds_FastLoop_supported)
    ParallelSpongeFastLoop( 2 )
    #else
    ParallelSpongeLoop( 2 )
    #endif
    #endif
    while ( inLen > 0 ) {
        unsigned int len = (unsigned int)((inLen < chunkSize) ? inLen : chunkSize);
        if (KeccakWidth1600_12rounds_SpongeInitialize(&ktInstance->queueNode, rate, capacity) != 0)
            return 1;
        if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->queueNode, input, len) != 0)
            return 1;
        input += len;
        inLen -= len;
        if ( len == chunkSize ) {
            unsigned char intermediate[capacityInBytes];
            ++ktInstance->blockNumber;
            if (KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(&ktInstance->queueNode, suffixLeaf) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeSqueeze(&ktInstance->queueNode, intermediate, capacityInBytes) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, intermediate, capacityInBytes) != 0)
                return 1;
        }
        else
            ktInstance->queueAbsorbedLen = len;
    }
    return 0;
}
int KangarooTwelve_Final(KangarooTwelve_Instance *ktInstance, unsigned char * output, const unsigned char * customization, size_t customLen)
{
    unsigned char encbuf[sizeof(size_t)+1+2];
    unsigned char padding;
    if (ktInstance->phase != ABSORBING)
        return 1;
    /* Absorb customization | right_encode(customLen) */
    if ((customLen != 0) && (KangarooTwelve_Update(ktInstance, customization, customLen) != 0))
        return 1;
    if (KangarooTwelve_Update(ktInstance, encbuf, right_encode(encbuf, customLen)) != 0)
        return 1;
    if ( ktInstance->blockNumber == 0 ) {
        /* Non complete first block in final node, pad it */
        padding = 0x07;
    }
    else {
        unsigned int n;
        if ( ktInstance->queueAbsorbedLen != 0 ) {
            /* There is data in the queue node */
            unsigned char intermediate[capacityInBytes];
            ++ktInstance->blockNumber;
            if (KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(&ktInstance->queueNode, suffixLeaf) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeSqueeze(&ktInstance->queueNode, intermediate, capacityInBytes) != 0)
                return 1;
            if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, intermediate, capacityInBytes) != 0)
                return 1;
        }
        --ktInstance->blockNumber;
        n = right_encode(encbuf, ktInstance->blockNumber);
        encbuf[n++] = 0xFF;
        encbuf[n++] = 0xFF;
        if (KeccakWidth1600_12rounds_SpongeAbsorb(&ktInstance->finalNode, encbuf, n) != 0)
            return 1;
        padding = 0x06;
    }
    if (KeccakWidth1600_12rounds_SpongeAbsorbLastFewBits(&ktInstance->finalNode, padding) != 0)
        return 1;
    if ( ktInstance->fixedOutputLength != 0 ) {
        ktInstance->phase = FINAL;
        return KeccakWidth1600_12rounds_SpongeSqueeze(&ktInstance->finalNode, output, ktInstance->fixedOutputLength);
    }
    ktInstance->phase = SQUEEZING;
    return 0;
}
int KangarooTwelve_Squeeze(KangarooTwelve_Instance *ktInstance, unsigned char * output, size_t outputLen)
{
    if (ktInstance->phase != SQUEEZING)
        return 1;
    return KeccakWidth1600_12rounds_SpongeSqueeze(&ktInstance->finalNode, output, outputLen);
}
int KangarooTwelve( const unsigned char * input, size_t inLen, unsigned char * output, size_t outLen, const unsigned char * customization, size_t customLen )
{
    KangarooTwelve_Instance ktInstance;
    if (outLen == 0)
        return 1;
    if (KangarooTwelve_Initialize(&ktInstance, outLen) != 0)
        return 1;
    if (KangarooTwelve_Update(&ktInstance, input, inLen) != 0)
        return 1;
    return KangarooTwelve_Final(&ktInstance, output, customization, customLen);
}
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
#ifndef SACK_SRG_INTERNAL_INCLUDED
#define SACK_SRG_INTERNAL_INCLUDED
/* SHA1 Standard library from somewhere... */
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef INCLUDED_SHA1_H_
#define INCLUDED_SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
#define SHA1_DIGEST_SIZE SHA1HashSize
typedef SHA1Context sha1_ctx;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifdef SACK_BAG_EXPORTS
#define SHA2_SOURCE
#endif
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.h  2017/19/12
// sha3.h
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
#ifndef SHA3_H
#define SHA3_H
#ifndef KECCAKF_ROUNDS
#define KECCAKF_ROUNDS 24
#endif
#ifndef ROTL64
#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))
#endif
// state context
typedef struct {
                                 // state:
    union {
                     // 8-bit bytes
        uint8_t b[200];
                     // 64-bit words
        uint64_t q[25];
    } st;
                    // these don't overflow
    int pt, rsiz, mdlen;
} sha3_ctx_t;
// Compression function.
void sha3_keccakf(uint64_t st[25]);
// OpenSSL - like interfece
    // mdlen = hash output in bytes
int sha3_init(sha3_ctx_t *c, int mdlen);
int sha3_update(sha3_ctx_t *c, const void *data, size_t len);
    // digest goes to md
int sha3_final(sha3_ctx_t *c, void *md );
// compute a sha3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen);
// SHAKE128 and SHAKE256 extensible-output functions
#define shake128_init(c) sha3_init(c, 16)
#define shake256_init(c) sha3_init(c, 32)
#define shake_update sha3_update
void shake_xof(sha3_ctx_t *c);
void shake_out(sha3_ctx_t *c, void *out, size_t len);
#endif
struct random_context {
	LOGICAL use_version2 : 1;
	LOGICAL use_version2_256 : 1;
	LOGICAL use_version3 : 1;
	LOGICAL use_versionK12 : 1;
	union {
		SHA1Context sha1_ctx;
		sha512_ctx  sha512;
		sha256_ctx  sha256;
		sha3_ctx_t  sha3;
		KangarooTwelve_Instance K12i;
	} f;
	size_t total_bits_used;
	POINTER salt;
	size_t salt_size;
	void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size);
	uintptr_t psv_user;
	uint8_t *entropy;
	union {
		uint8_t entropy0[SHA1HashSize];
		uint8_t entropy2[SHA512_DIGEST_SIZE];
		uint8_t entropy2_256[SHA256_DIGEST_SIZE];
 // 512 bits
#define SHA3_DIGEST_SIZE 64
		uint8_t entropy3[SHA3_DIGEST_SIZE];
  // 4096 bytes
#define K12_SQUEEZE_LENGTH 32768
  // used for re-seeding
#define K12_DIGEST_SIZE    64
		uint8_t entropy4[K12_SQUEEZE_LENGTH >> 3];
	} s;
	size_t bits_used;
	size_t bits_avail;
};
struct byte_shuffle_key {
// shuffle works on ints.
	uint8_t map[256];
	uint8_t dmap[256];
};
#define MY_MASK_MASK(n,length)	(MASK_TOP_MASK(length) << ((n)&(sizeof(MASKSET_READTYPE)-1)) )
#define MY_GET_MASK(v,n,mask_size)  ( ( ((MASKSET_READTYPE*)((((uint8_t*)v))+(n)/CHAR_BIT))[0]											 & MY_MASK_MASK(n,mask_size) )																										>> (((n))&(sizeof(MASKSET_READTYPE)-1)))
#define SRG_GetBit_(tmp,ctx)    (	    (ctx->total_bits_used += 1),	  (( (ctx->bits_used) >= ctx->bits_avail )?		  NeedBits( ctx ):(void)0),	  ( tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, 1 ) ),	  ( ctx->bits_used += 1 ),	  ( tmp ) )
#define SRG_GetByte_(tmp,ctx)    (	    (ctx->total_bits_used += 8),	  (( (ctx->bits_used) >= ctx->bits_avail )?		  NeedBits( ctx ):(void)0),	  ( tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, 8 ) ),	  ( ctx->bits_used += 8 ),	  ( tmp ) )
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
extern
#endif
 void NeedBits( struct random_context *ctx );
#define BlockShuffle_SubByte_(key, bytes_input, bytes_output )  ( (bytes_output)[0] = key->map[(bytes_input)[0]] )
#define BlockShuffle_Sub1Byte_(key, byte_input )  ( key->map[byte_input] )
#define BlockShuffle_SubBytes_(key, in, out, byteCount ) {	  size_t n;	   uint8_t *bytes_input = in, *bytes_output = out;	  uint8_t *map = key->map;	  for( n = 0; n < byteCount; n++, bytes_input++, bytes_output++ ) {		  bytes_output[0] = map[bytes_input[0]];	  }  }
#define BlockShuffle_BusByte_(key, bytes_input, bytes_output )  ( (bytes_output)[0] = key->dmap[(bytes_input)[0]] )
#define BlockShuffle_Bus1Byte_(key, byte_input )  ( key->dmap[byte_input] )
#define BlockShuffle_BusBytes_(key, in, out, byteCount )  {	  size_t n;	   uint8_t *bytes_input = in, *bytes_output = out;	  uint8_t *map = key->dmap;	  for( n = 0; n < byteCount; n++, bytes_input++, bytes_output++ ) {		  bytes_output[0] = map[bytes_input[0]];	   }  }
#endif
#define USE_K12_LONG_SQUEEZE 1
#define K12_SQUEEZE_LENGTH   32768
//#define K12_PRE_TEST
#ifdef K12_PRE_TEST
PRELOAD( zz ) {
	KangarooTwelve_Instance i;
	char output[64];
	KangarooTwelve_Initialize( &i, 0 );
	KangarooTwelve_Update( &i, (const unsigned char *)"abcd", 0 );
 // customization is a final pad string.
	KangarooTwelve_Final( &i, NULL, NULL, 0 );
 // customization is a final pad string.
	KangarooTwelve_Squeeze( &i, (unsigned char *)output, 64 );
	lprintf( "---" );
	LogBinary( output, 64 );
	KangarooTwelve_Initialize( &i, 0 );
	KangarooTwelve_Update( &i, (const unsigned char *)"asdf", 4 );
 // customization is a final pad string.
	KangarooTwelve_Final( &i, NULL, NULL, 0 );
 // customization is a final pad string.
	KangarooTwelve_Squeeze( &i, (unsigned char *)output, 64 );
	lprintf( "---" );
	LogBinary( output, 64 );
	KangarooTwelve_Initialize( &i, 0 );
	KangarooTwelve_Update( &i, (const unsigned char *)"asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf", 64 );
 // customization is a final pad string.
	KangarooTwelve_Final( &i, NULL, NULL, 0 );
 // customization is a final pad string.
	KangarooTwelve_Squeeze( &i, (unsigned char *)output, 64 );
	lprintf( "---" );
	LogBinary( output, 64 );
	{
		int n;
		int start, end;
		start = timeGetTime();
		for( n = 0; n < 10000000; n++ ) {
 // customization is a final pad string.
			KangarooTwelve_Squeeze( &i, (unsigned char *)output, 64 );
		}
		end = timeGetTime();
		lprintf( "did %d in %d  %d  %d", n, end - start, n / (end - start), (n * 32) / (end - start) );
	}
}
#endif
void NeedBits( struct random_context *ctx )
{
	if( ctx->use_versionK12 ) {
#if USE_K12_LONG_SQUEEZE
		if( ctx->f.K12i.phase == ABSORBING || ctx->total_bits_used >= K12_SQUEEZE_LENGTH ) {
			if( ctx->f.K12i.phase == SQUEEZING ) {
				KangarooTwelve_Initialize( &ctx->f.K12i, 0 );
 /* 1600/8 */
				KangarooTwelve_Update( &ctx->f.K12i, ctx->s.entropy4, 200 );
			}
			if( ctx->getsalt ) {
				ctx->getsalt( ctx->psv_user, &ctx->salt, &ctx->salt_size );
				KangarooTwelve_Update( &ctx->f.K12i, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
			}
 // customization is a final pad string.
			KangarooTwelve_Final( &ctx->f.K12i, NULL, NULL, 0 );
			ctx->total_bits_used = 0;
		}
		if( ctx->f.K12i.phase == SQUEEZING )
 // customization is a final pad string.
			KangarooTwelve_Squeeze( &ctx->f.K12i, ctx->s.entropy4, K12_SQUEEZE_LENGTH>>3 );
#else
		lprintf( "Use Long Squeeze instead!" );
		if( ctx->getsalt ) {
			ctx->getsalt( ctx->psv_user, &ctx->salt, &ctx->salt_size );
			KangarooTwelve_Update( &ctx->f.K12i, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
		}
 // customization is a final pad string.
		KangarooTwelve_Final( &ctx->f.K12i, ctx->s.entropy4, NULL, 0 );
		KangarooTwelve_Initialize( &ctx->f.K12i, K12_DIGEST_SIZE );
		KangarooTwelve_Update( &ctx->f.K12i, ctx->s.entropy4, K12_DIGEST_SIZE );
#endif
		ctx->bits_avail = sizeof( ctx->s.entropy4 ) * CHAR_BIT;
		ctx->entropy = ctx->s.entropy4;
	}
	else {
		if( ctx->getsalt )
			ctx->getsalt( ctx->psv_user, &ctx->salt, &ctx->salt_size );
		else
			ctx->salt_size = 0;
		if( ctx->use_version3 ) {
			if( ctx->salt_size )
				sha3_update( &ctx->f.sha3, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
			sha3_final( &ctx->f.sha3, ctx->s.entropy3 );
			sha3_init( &ctx->f.sha3, SHA3_DIGEST_SIZE );
			sha3_update( &ctx->f.sha3, ctx->s.entropy3, SHA3_DIGEST_SIZE );
			ctx->bits_avail = sizeof( ctx->s.entropy3 ) * CHAR_BIT;
			ctx->entropy = ctx->s.entropy3;
		}
		else if( ctx->use_version2_256 ) {
			if( ctx->salt_size )
				sha256_update( &ctx->f.sha256, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
			sha256_final( &ctx->f.sha256, ctx->s.entropy2_256 );
			sha256_init( &ctx->f.sha256 );
			sha256_update( &ctx->f.sha256, ctx->s.entropy2_256, SHA256_DIGEST_SIZE );
			ctx->bits_avail = sizeof( ctx->s.entropy2_256 ) * CHAR_BIT;
			ctx->entropy = ctx->s.entropy2_256;
		}
		else if( ctx->use_version2 ) {
			if( ctx->salt_size )
				sha512_update( &ctx->f.sha512, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
			sha512_final( &ctx->f.sha512, ctx->s.entropy2 );
			sha512_init( &ctx->f.sha512 );
			sha512_update( &ctx->f.sha512, ctx->s.entropy2, SHA512_DIGEST_SIZE );
			ctx->bits_avail = sizeof( ctx->s.entropy2 ) * CHAR_BIT;
			ctx->entropy = ctx->s.entropy2;
		}
		else {
			if( ctx->salt_size )
				SHA1Input( &ctx->f.sha1_ctx, (const uint8_t*)ctx->salt, ctx->salt_size );
			SHA1Result( &ctx->f.sha1_ctx, ctx->s.entropy0 );
			SHA1Reset( &ctx->f.sha1_ctx );
			SHA1Input( &ctx->f.sha1_ctx, ctx->s.entropy0, SHA1HashSize );
			ctx->bits_avail = sizeof( ctx->s.entropy0 ) * CHAR_BIT;
			ctx->entropy = ctx->s.entropy0;
		}
	}
	ctx->bits_used = 0;
}
void SRG_StepEntropy( struct random_context* ctx ) {
#if USE_K12_LONG_SQUEEZE
	if( ctx->use_versionK12 )
		ctx->total_bits_used = K12_SQUEEZE_LENGTH;
#endif
	NeedBits( ctx );
}
struct random_context *SRG_CreateEntropyInternal( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user
                                                , LOGICAL version2
                                                , LOGICAL version2_256
                                                , LOGICAL version3
                                                , LOGICAL versionk12
                                                )
{
	struct random_context *ctx = New( struct random_context );
	ctx->use_versionK12 = versionk12;
	ctx->use_version3 = version3;
	ctx->use_version2_256 = version2_256;
	ctx->use_version2 = version2;
	if( ctx->use_versionK12 )
		KangarooTwelve_Initialize( &ctx->f.K12i, 0 );
	if( ctx->use_version3 )
		sha3_init( &ctx->f.sha3, SHA3_DIGEST_SIZE );
	else if( ctx->use_version2_256 )
		sha256_init( &ctx->f.sha256 );
	else if( ctx->use_version2 )
		sha512_init( &ctx->f.sha512 );
	else
		SHA1Reset( &ctx->f.sha1_ctx );
	ctx->getsalt = getsalt;
	ctx->psv_user = psv_user;
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
	return ctx;
}
struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, FALSE, FALSE, FALSE );
}
struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, TRUE, FALSE, FALSE, FALSE );
}
struct random_context *SRG_CreateEntropy2_256( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, TRUE, FALSE, FALSE );
}
struct random_context *SRG_CreateEntropy3( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, FALSE, TRUE, FALSE );
}
struct random_context *SRG_CreateEntropy4( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, FALSE, FALSE, TRUE );
}
void SRG_DestroyEntropy( struct random_context **ppEntropy )
{
	Release( (*ppEntropy) );
	(*ppEntropy) = NULL;
}
uint32_t SRG_GetBit( struct random_context *ctx )
{
	uint32_t tmp;
	ctx->total_bits_used += 1;
	//if( ctx->bits_used > 512 ) DebugBreak();
	if( (ctx->bits_used) >= ctx->bits_avail ) {
		NeedBits( ctx );
	}
	tmp = MY_MASK_MASK( ctx->bits_used, 1 );
	tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, 1 );
	ctx->bits_used += 1;
	return tmp;
}
void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits )
{
	uint32_t tmp;
	uint32_t partial_tmp;
	uint32_t partial_bits = 0;
	uint32_t get_bits;
	uint32_t resultBits = 0;
	if( !ctx ) DebugBreak();
	ctx->total_bits_used += bits;
	//if( ctx->bits_used > 512 ) DebugBreak();
	do {
		if( bits > sizeof( tmp ) * 8 )
			get_bits = sizeof( tmp ) * 8;
		else
			get_bits = bits;
		// if there were 1-31 bits of data in partial, then can only get 32-partial max.
		if( 32 < (get_bits + partial_bits) )
			get_bits = 32 - partial_bits;
		// check1 :
		//    if get_bits == 32
		//    but bits_used is 1-7, then it would have to pull 5 bytes to get the 32 required
		//    so truncate get_bits to 25-31 bits
		if( 32 < (get_bits + (ctx->bits_used & 0x1f)) )
			get_bits = (32 - (ctx->bits_used & 0x1f));
		// if resultBits is 1-7 offset, then would have to store up to 5 bytes of value
		//    so have to truncate to just the up to 4 bytes that will fit.
		if( (get_bits+ resultBits) > 32 )
			get_bits = 32 - resultBits;
		// only greater... if equal just grab the bits.
		if( (get_bits + ctx->bits_used) > ctx->bits_avail ) {
			// if there are any bits left, grab the partial bits.
			if( ctx->bits_avail > ctx->bits_used ) {
				partial_bits = (uint32_t)(ctx->bits_avail - ctx->bits_used);
				if( partial_bits > get_bits ) partial_bits = get_bits;
				// partial can never be greater than 32; input is only max of 32
				//if( partial_bits > (sizeof( partial_tmp ) * 8) )
				//	partial_bits = (sizeof( partial_tmp ) * 8);
				partial_tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, partial_bits );
			}
			NeedBits( ctx );
			bits -= partial_bits;
		}
		else {
			tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, get_bits );
			ctx->bits_used += get_bits;
			//if( ctx->bits_used > 512 ) DebugBreak();
			if( partial_bits ) {
				tmp = partial_tmp | (tmp << partial_bits);
				partial_bits = 0;
			}
			if( (get_bits+resultBits) > 24 )
				(*buffer) = tmp << resultBits;
			else if( (get_bits+resultBits) > 16 ) {
				(*((uint16_t*)buffer)) |= tmp << resultBits;
				(*(((uint8_t*)buffer)+2)) |= ((tmp << resultBits) & 0xFF0000)>>16;
			} else if( (get_bits+resultBits) > 8 )
				(*((uint16_t*)buffer)) |= tmp << resultBits;
			else
				(*((uint8_t*)buffer)) |= tmp << resultBits;
			resultBits += get_bits;
			while( resultBits >= 8 ) {
#if defined( __cplusplus ) || defined( __GNUC__ )
				buffer = (uint32_t*)(((uintptr_t)buffer) + 1);
#else
				( *( (uintptr_t*)&buffer ) )++;
#endif
				resultBits -= 8;
			}
			//if( get_bits > bits ) DebugBreak();
			bits -= get_bits;
		}
	} while( bits );
}
int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed )
{
	int32_t result = 0;
	SRG_GetEntropyBuffer( ctx, (uint32_t*)&result, bits );
	if( get_signed )
		if( result & ( 1 << ( bits - 1 ) ) )
		{
			uint32_t negone = ~0;
			negone <<= bits;
			return (int32_t)( result | negone );
		}
	return result;
}
void SRG_ResetEntropy( struct random_context *ctx )
{
	ctx->total_bits_used = 0;
	if( ctx->use_versionK12 )
		KangarooTwelve_Initialize( &ctx->f.K12i, 0 );
	else if( ctx->use_version3 )
		sha3_init( &ctx->f.sha3, SHA3_DIGEST_SIZE );
	else if( ctx->use_version2_256 )
		sha256_init( &ctx->f.sha256 );
	else if( ctx->use_version2 )
		sha512_init( &ctx->f.sha512 );
	else
		SHA1Reset( &ctx->f.sha1_ctx );
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
}
void SRG_StreamEntropy( struct random_context *ctx )
{
	if( ctx->use_versionK12 )
 /* 1600/8 */
		KangarooTwelve_Update( &ctx->f.K12i, ctx->s.entropy4, 200 );
	else if( ctx->use_version3 )
		sha3_update( &ctx->f.sha3, ctx->s.entropy4, SHA3_DIGEST_SIZE );
	else if( ctx->use_version2_256 )
		sha256_update( &ctx->f.sha256, ctx->s.entropy2_256, SHA256_DIGEST_SIZE );
	else if( ctx->use_version2 )
		sha512_update( &ctx->f.sha512, ctx->s.entropy2, SHA512_DIGEST_SIZE );
	else
		SHA1Input( &ctx->f.sha1_ctx, ctx->s.entropy0, SHA1HashSize );
}
void SRG_FeedEntropy( struct random_context *ctx, const uint8_t *salt, size_t salt_size )
{
	if( ctx->use_versionK12 )
		KangarooTwelve_Update( &ctx->f.K12i, salt, (unsigned int)salt_size );
	else if( ctx->use_version3 )
		sha3_update( &ctx->f.sha3, salt, (unsigned int)salt_size );
	else if( ctx->use_version2_256 )
		sha256_update( &ctx->f.sha256, salt, (unsigned int)salt_size );
	else if( ctx->use_version2 )
		sha512_update( &ctx->f.sha512, salt, (unsigned int)salt_size );
	else
		SHA1Input( &ctx->f.sha1_ctx, salt, salt_size );
}
void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder, size_t *dataSize )
{
	if( !(*external_buffer_holder) )
		(*external_buffer_holder) = New( struct random_context );
	(*(struct random_context*)(*external_buffer_holder)) = (*ctx);
	if( dataSize )
		(*dataSize) = sizeof( struct random_context );
}
void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder )
{
	(*ctx) = *(struct random_context*)external_buffer_holder;
}
static void salt_generator(uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	static struct tickBuffer {
		uint32_t tick;
		uint64_t cputick;
	} tick;
	(void)psv;
	tick.cputick = GetCPUTick();
	tick.tick = timeGetTime();
	salt[0] = &tick;
	salt_size[0] = sizeof( tick );
}
#define SRG_MAX_GENERATOR_THREADS 32
static struct random_context *getGenerator(
			struct random_context *pool[SRG_MAX_GENERATOR_THREADS]
			, uint32_t used[SRG_MAX_GENERATOR_THREADS]
			, struct random_context * (*generator)(void( *)(uintptr_t , POINTER *, size_t *), uintptr_t)
			, int *pUsingCtx
		)
{
	struct random_context *ctx;
	int usingCtx;
	usingCtx = 0;
	do {
		while( used[++usingCtx] ) { if( ++usingCtx >= SRG_MAX_GENERATOR_THREADS ) usingCtx = 0; }
	} while( LockedExchange( used + usingCtx, 1 ) );
	ctx = pool[usingCtx];
	if( !ctx ) ctx = pool[usingCtx] = generator( salt_generator, 0 );
	(*pUsingCtx) = usingCtx;
	return ctx;
}
char *SRG_ID_Generator( void ) {
	struct random_context *ctx;
	uint32_t buf[(16 + 16) / 4];
	size_t outlen;
	static struct random_context *_ctx[SRG_MAX_GENERATOR_THREADS];
	static uint32_t used[SRG_MAX_GENERATOR_THREADS];
	int usingCtx;
	ctx = getGenerator( _ctx, used, SRG_CreateEntropy2, &usingCtx );
	do {
		SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	} while( ( buf[0] & 0x3f ) < 10 );
	used[usingCtx] = 0;
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
char *SRG_ID_Generator_256( void ) {
	struct random_context *ctx;
	uint32_t buf[(16 + 16) / 4];
	size_t outlen;
	static struct random_context *_ctx[SRG_MAX_GENERATOR_THREADS];
	static uint32_t used[SRG_MAX_GENERATOR_THREADS];
	int usingCtx;
	ctx = getGenerator( _ctx, used, SRG_CreateEntropy2_256, &usingCtx );
	do {
		SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	} while( (buf[0] & 0x3f) < 10 );
	used[usingCtx] = 0;
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
char *SRG_ID_Generator3( void ) {
	struct random_context *ctx;
	uint32_t buf[(16 + 16) / 4];
	size_t outlen;
	static struct random_context *_ctx[SRG_MAX_GENERATOR_THREADS];
	static uint32_t used[SRG_MAX_GENERATOR_THREADS];
	int usingCtx;
	usingCtx = 0;
	ctx = getGenerator( _ctx, used, SRG_CreateEntropy3, &usingCtx );
	do {
		SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	} while( (buf[0] & 0x3f) < 10 );
	used[usingCtx] = 0;
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
char *SRG_ID_Generator4( void ) {
	struct random_context *ctx;
	uint32_t buf[(16 + 16)/4];
	size_t outlen;
	static struct random_context *_ctx[SRG_MAX_GENERATOR_THREADS];
	static uint32_t used[SRG_MAX_GENERATOR_THREADS];
	int usingCtx;
	usingCtx = 0;
	ctx = getGenerator( _ctx, used, SRG_CreateEntropy4, &usingCtx );
	//do {
	SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	//} while( (buf[0] & 0x3f) < 10 );
	used[usingCtx] = 0;
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
char *SRG_ID_ShortGenerator4( void ) {
	    struct random_context *ctx;
	uint32_t buf[(12)/4];
	size_t outlen;
	static struct random_context *_ctx[SRG_MAX_GENERATOR_THREADS];
	static uint32_t used[SRG_MAX_GENERATOR_THREADS];
	int usingCtx;
	usingCtx = 0;
	ctx = getGenerator( _ctx, used, SRG_CreateEntropy4, &usingCtx );
        SRG_GetEntropyBuffer( ctx, buf, 8 * (12) );
	used[usingCtx] = 0;
	return EncodeBase64Ex( (uint8*)buf, (12), &outlen, (const char *)1 );
}
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
// partial lower bit expressions
#  pragma warning( disable: 26451 )
#endif
static struct crypt_local
{
	char * use_salt;
	struct random_context *entropy;
	PLINKQUEUE plqCrypters;
} crypt_local;
static void FeedSalt( uintptr_t psv, POINTER *salt, size_t *salt_size )
{
	if( crypt_local.use_salt)
	{
		(*salt) = crypt_local.use_salt;
		(*salt_size) = 4;
	}
	else
	{
		static uint32_t tick;
		tick = timeGetTime();
		(*salt) = &tick;
		(*salt_size) = 4;
	}
}
void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, (uintptr_t)0 );
	{
		uint32_t mask;
		uint8_t* pass_byte_in;
		uint8_t* pass_byte_out;
		int index;
		//if( length < chars )
		{
			SRG_ResetEntropy( crypt_local.entropy );
			crypt_local.use_salt = (char *)binary;
			pass_byte_in = ((uint8_t*)binary) + 4;
			length -= 4;
			(*buffer) = NewArray( uint8_t, length );
			pass_byte_out = (*buffer);
			for( index = 0; length; length--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
			(*chars) = pass_byte_out - (*buffer);
		}
	}
}
void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars )
{
	{
		POINTER binary;
		size_t length;
		if( local_password && DecodeBinaryConfig( local_password, &binary, &length ) )
		{
			SRG_DecryptRawData( (uint8_t*)binary, length, buffer, chars );
		}
		else
		{
			(*buffer) = 0;
			(*chars) = 0;
			//lprintf( "failed to decode data" );
		}
	}
}
TEXTSTR SRG_DecryptString( CTEXTSTR local_password )
{
	uint8_t* buffer;
	size_t chars;
	SRG_DecryptData( local_password, &buffer, &chars );
	return (TEXTSTR)buffer;
}
void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		{
			uint32_t mask;
			uint32_t seed;
			uint8_t* pass_byte_in;
			uint8_t* pass_byte_out;
			int index;
			uint8_t* tmpbuf;
			crypt_local.use_salt = NULL;
			(*result_buf) = tmpbuf = NewArray( uint8_t, buflen + 4 );
			(*result_size) = buflen + 4;
			SRG_ResetEntropy( crypt_local.entropy );
			seed = (uint32_t)GetCPUTick();
			tmpbuf[0] = ((seed >> 17) & 0xFF) ^ ((seed >> 8) & 0xFF);
			tmpbuf[1] = ((seed >> 11) & 0xFF) ^ ((seed >> 4) & 0xFF);
			tmpbuf[2] = ((seed >> 5) & 0xFF) ^ ((seed >> 12) & 0xFF);
			tmpbuf[3] = ((seed >> 0) & 0xFF) ^ ((seed >> 13) & 0xFF);
			crypt_local.use_salt = (char*)tmpbuf;
			SRG_ResetEntropy( crypt_local.entropy );
			pass_byte_in = ((uint8_t*)buffer);
			pass_byte_out = (uint8_t*)tmpbuf + 4;
			for( index = 0; buflen; buflen--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
		}
	}
}
TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		uint8_t* result_buf;
		size_t result_size;
		TEXTSTR tmpbuf;
		SRG_EncryptRawData( buffer, buflen, &result_buf, &result_size );
		EncodeBinaryConfig( &tmpbuf, result_buf, buflen + 4 );
		return tmpbuf;
	}
	return NULL;
}
TEXTSTR SRG_EncryptString( CTEXTSTR buffer )
{
	return SRG_EncryptData( (uint8_t*)buffer, StrLen( buffer ) + 1 );
}
#ifndef NO_SSL
#  include <openssl/evp.h>
#  include <openssl/err.h>
static void handleErrors( void )
{
	ERR_print_errors_fp( stderr );
	abort();
}
size_t SRG_AES_encrypt( uint8_t *plaintext, size_t plaintext_len, uint8_t *key, uint8_t **ciphertext )
{
	EVP_CIPHER_CTX *ctx;
	int len;
	int ciphertext_len;
	/* Create and initialise the context */
	if( !(ctx = EVP_CIPHER_CTX_new()) ) handleErrors();
	/* Initialise the encryption operation. IMPORTANT - ensure you use a key
	 * and IV size appropriate for your cipher
	 * In this example we are using 256 bit AES (i.e. a 256 bit key). The
	 * IV size for *most* modes is the same as the block size. For AES this
	 * is 128 bits */
	if( 1 != EVP_EncryptInit_ex( ctx, EVP_aes_256_cbc(), NULL, key, key ) )
		handleErrors();
	EVP_CIPHER_CTX_set_padding( ctx, 0 );
	int blockSize = EVP_CIPHER_CTX_block_size( ctx );
	if( blockSize < 16 ) DebugBreak();
	int outSize = (int)(plaintext_len + sizeof( uint32_t ) + (blockSize - 1));
	uint8_t *block = NewArray( uint8_t, blockSize );
	outSize -= outSize % blockSize;
	ciphertext[0] = NewArray( uint8_t, outSize );
	((uint32_t*)block)[0] = (uint32_t)plaintext_len;
	size_t remaining = blockSize - sizeof( uint32_t );
	if( remaining > plaintext_len ) {
		memcpy( block + sizeof( uint32_t ), plaintext, plaintext_len );
		remaining = plaintext_len + sizeof( uint32_t );
		plaintext_len = 0;
	}
	else {
		memcpy( block + sizeof( uint32_t ), plaintext, blockSize - sizeof( uint32_t ) );
		remaining = blockSize;
		plaintext_len -= (blockSize - sizeof( uint32_t ));
	}
	/* Provide the message to be encrypted, and obtain the encrypted output.
	 * EVP_EncryptUpdate can be called multiple times if necessary
	 */
	if( 1 != EVP_EncryptUpdate( ctx, ciphertext[0], &len, (const unsigned char*)block, (int)remaining ) )
		handleErrors();
	ciphertext_len = len;
	Release( block );
	if( plaintext_len > 0 ) {
		if( plaintext_len % blockSize ) {
			int tailLen = plaintext_len % blockSize;
			if( 1 != EVP_EncryptUpdate( ctx, ciphertext[0] + ciphertext_len, &len
				, plaintext + (blockSize - sizeof( uint32_t ))
				, (int)(plaintext_len - tailLen) ) )
				handleErrors();
			ciphertext_len += len;
			memcpy( block
				, plaintext + (blockSize - sizeof( uint32_t )) + plaintext_len - tailLen
				, tailLen);
			memset( block + tailLen, 0, blockSize - tailLen );
			if( 1 != EVP_EncryptUpdate( ctx, ciphertext[0] + ciphertext_len, &len
				, block
				, blockSize ) )
				handleErrors();
		}
		else {
			if( 1 != EVP_EncryptUpdate( ctx, ciphertext[0] + ciphertext_len, &len
				, plaintext + (blockSize - sizeof( uint32_t ))
				, (int)plaintext_len ) )
				handleErrors();
		}
		ciphertext_len += len;
	}
	/* Finalise the encryption. Further ciphertext bytes may be written at
	 * this stage.
	 */
	len = 0;
	if( 1 != EVP_EncryptFinal_ex( ctx, ciphertext[0] + ciphertext_len, &len ) ) handleErrors();
	ciphertext_len += len;
	/* Clean up */
	EVP_CIPHER_CTX_free( ctx );
	return ciphertext_len;
}
int SRG_AES_decrypt( uint8_t *ciphertext, int ciphertext_len, uint8_t *key, uint8_t **plaintext )
{
	EVP_CIPHER_CTX *ctx;
	int len;
	int used = 0;
	int plaintext_len;
	/* Create and initialise the context */
	if( !(ctx = EVP_CIPHER_CTX_new()) ) handleErrors();
	/* Initialise the decryption operation. IMPORTANT - ensure you use a key
	 * and IV size appropriate for your cipher
	 * In this example we are using 256 bit AES (i.e. a 256 bit key). The
	 * IV size for *most* modes is the same as the block size. For AES this
	 * is 128 bits */
	if( 1 != EVP_DecryptInit_ex( ctx, EVP_aes_256_cbc(), NULL, key, key ) )
		handleErrors();
	EVP_CIPHER_CTX_set_padding( ctx, 0 );
	int blockSize = EVP_CIPHER_CTX_block_size( ctx );
	uint8_t *block = NewArray( uint8_t, blockSize * 2 );
	// read the first block of 1 block size.  This has the length so we know
	// how much more to read.
	if( 1 != EVP_DecryptUpdate( ctx, block, &len, ciphertext, blockSize ) )
		handleErrors();
	used += blockSize;
	if( !len ) {
		if( 1 != EVP_DecryptUpdate( ctx, block, &len, ciphertext + used, blockSize ) )
			handleErrors();
		used += blockSize;
		if( !len ) {
			lprintf( "Really? Give me the first block!" );
			DebugBreak();
		}
	}
	plaintext_len = ((uint32_t*)block)[0];
 // have to accept over-writes from crypt
	int outSize = (plaintext_len + (blockSize - 1));
	outSize -= outSize % blockSize;
	plaintext[0] = NewArray( uint8_t, outSize );
	memcpy( plaintext[0], block + sizeof( uint32_t ), blockSize - sizeof( uint32_t ) );
	if( ciphertext_len > blockSize ) {
		/* Provide the message to be decrypted, and obtain the plaintext output.
		 * EVP_DecryptUpdate can be called multiple times if necessary
		 */
		if( 1 != EVP_DecryptUpdate( ctx
			, plaintext[0] + (blockSize - sizeof( uint32_t )), &len
			, ciphertext + used
			, ciphertext_len - used ) )
			handleErrors();
		//plaintext_len = len;
	}
	/* Finalise the decryption. Further plaintext bytes may be written at
	 * this stage.
	 */
	if( 1 != EVP_DecryptFinal_ex( ctx, plaintext[0] + plaintext_len, &len ) ) handleErrors();
	plaintext_len += len;
	/* Clean up */
	EVP_CIPHER_CTX_free( ctx );
	Release( block );
	return plaintext_len;
}
#endif
// bit size of masking hash.
#define RNGHASH 256
static __inline void encryptBlock( uint8_t const * const map
	, uint8_t * const output, size_t const outlen
	, uint8_t const bufKey[RNGHASH/8]
)
{
	uint8_t *curBuf_out;
	size_t n;
	uint8_t p = 0x55;
	curBuf_out = output;
#if __64__
	for( n = 0; n < outlen; n += 8, curBuf_out += 8 ) {
		((uint64_t*)curBuf_out)[0] ^= ((uint64_t*)(bufKey + (n % (RNGHASH / 8))))[0];;
	}
#else
	for( n = 0; n < outlen; n += 4, curBuf_out += 4 ) {
		((uint32_t*)curBuf_out)[0] ^= ((uint32_t*)(bufKey + (n % (RNGHASH / 8))))[0];
	}
#endif
	curBuf_out = output;
	for( n = 0; n < outlen; n++, curBuf_out++ ) {
		p = curBuf_out[0] = map[curBuf_out[0] ^ p];
	}
	curBuf_out--;
	p = 0xAA;
	for( n = 0; n < outlen; n++, curBuf_out-- ) {
		p = curBuf_out[0] = map[curBuf_out[0] ^ p];
	}
}
void SRG_XSWS_encryptData( uint8_t *objBuf, size_t objBufLen
	, uint64_t tick, const uint8_t *keyBuf, size_t keyBufLen
	, uint8_t **outBuf, size_t *outBufLen
) {
	struct random_context *signEntropy = (struct random_context *)DequeLink( &crypt_local.plqCrypters );
	size_t b;
	//size_t outLen_;
	if( !signEntropy )
		signEntropy = SRG_CreateEntropy4( NULL, (uintptr_t)0 );
	SRG_ResetEntropy( signEntropy );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)&tick, sizeof( tick ) );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)keyBuf, keyBufLen );
	static uint8_t bufKey[RNGHASH /8];
	SRG_GetEntropyBuffer( signEntropy, (uint32_t*)bufKey, RNGHASH );
	struct byte_shuffle_key *bytKey = BlockShuffle_ByteShuffler( signEntropy );
	if( outBuf ) {
		(*outBufLen) = (sizeof( uint8_t ))
			+ objBufLen
			+ (((objBufLen + sizeof( uint8_t )) & 0x7)
				? (8 - ((objBufLen + sizeof( uint8_t )) & 0x7))
				: 0);
		//outBuf[0] = (uint8_t*)HeapAllocateAligned( NULL, (*outBufLen), 4096 );
		outBuf[0] = (uint8_t*)HeapAllocate( NULL, (*outBufLen) );
 // clear any padding bits.
		((uint64_t*)(outBuf[0] + (*outBufLen) - 8))[0] = 0;
		//SRG_GetEntropyBuffer( signEntropy, (uint32_t*)outBuf[0] + (*outBufLen) - 8, 64 );
  // copy contents for in-place encrypt.
		memcpy( outBuf[0], objBuf, objBufLen );
		((uint8_t*)(outBuf[0] + (*outBufLen) - 1))[0] = (uint8_t)(*outBufLen - objBufLen);
	}
	else {
		outBufLen = &objBufLen;
		outBuf = &objBuf;
	}
	for( b = 0; b < (*outBufLen); b += 4096 ) {
		size_t bs = (*outBufLen) - b;
		if( bs > 4096 )
			encryptBlock( bytKey->map, outBuf[0] + b, 4096, bufKey );
		else
			encryptBlock( bytKey->map, outBuf[0] + b, bs, bufKey );
	}
	BlockShuffle_DropByteShuffler( bytKey );
	EnqueLink( &crypt_local.plqCrypters, signEntropy );
}
static __inline void decryptBlock( uint8_t const * const dmap
	, uint8_t *input, size_t const len
	, uint8_t *output
	, uint8_t const bufKey[RNGHASH / 8]
) {
	size_t n;
	uint8_t *curBuf = output;
	for( n = 0; n < (len - 1); n++, curBuf++, input++ ) {
		curBuf[0] = dmap[input[0]] ^ input[1];
	}
	curBuf[0] = dmap[input[0]] ^ 0xAA;
	curBuf = output + len - 1;
	for( n = (int)(len - 1); n > 0; n--, curBuf-- ) {
		curBuf[0] = dmap[curBuf[0]] ^ curBuf[-1];
	}
	curBuf[0] = dmap[curBuf[0]] ^ 0x55;
#if __64__
	for( n = 0; n < len; n += 8, output += 8 ) {
		((uint64_t*)output)[0] ^= ((uint64_t*)(bufKey + (n % (RNGHASH / 8))))[0];
	}
#else
	for( n = 0; n < len; n += 4, output += 4 ) {
		((uint32_t*)output)[0] ^= ((uint32_t*)(bufKey + (n % (RNGHASH / 8))))[0];
	}
#endif
}
void SRG_XSWS_decryptData( uint8_t *objBuf, size_t objBufLen
	, uint64_t tick, const uint8_t *keyBuf, size_t keyBufLen
	, uint8_t **outBuf, size_t *outBufLen
) {
	struct random_context *signEntropy = (struct random_context *)DequeLink( &crypt_local.plqCrypters );
	size_t b;
	if( !signEntropy )
		signEntropy = SRG_CreateEntropy4( NULL, (uintptr_t)0 );
	SRG_ResetEntropy( signEntropy );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)&tick, sizeof( tick ) );
	SRG_FeedEntropy( signEntropy, (const uint8_t*)keyBuf, keyBufLen );
	static uint8_t bufKey[RNGHASH /8];
	SRG_GetEntropyBuffer( signEntropy, (uint32_t*)bufKey, RNGHASH );
	struct byte_shuffle_key *bytKey = BlockShuffle_ByteShuffler( signEntropy );
	if( !outBuf ) {
		for( b = 0; b < objBufLen; b += 4096 ) {
			size_t bs = objBufLen - b;
			if( bs > 4096 )
				decryptBlock( bytKey->dmap, objBuf + b, 4096, objBuf + b, bufKey );
			else
				decryptBlock( bytKey->dmap, objBuf + b, bs, objBuf + b, bufKey );
		}
	}
	else {
		outBuf[0] = NewArray( uint8_t, (*outBufLen) = objBufLen );
		for( b = 0; b < objBufLen; b += 4096 ) {
			size_t bs = objBufLen - b;
			if( bs > 4096 )
				decryptBlock( bytKey->dmap, objBuf + b, 4096, outBuf[0] + b, bufKey );
			else
				decryptBlock( bytKey->dmap, objBuf + b, bs, outBuf[0] + b, bufKey );
		}
		// enforce pad bytes to be 0.
		(*outBufLen) -= ((uint8_t*)(outBuf[0] + objBufLen - 1))[0];
	}
	// in-place encrypt does not pad.
	if( outBuf )
		if( (((uint64_t*)(outBuf[0] + objBufLen - 8))[0] & 0x00FFFFFFFFFFFFFFULL ) >> ((8 - ((uint8_t*)(outBuf[0] + objBufLen - 1))[0]) * 8) )
 // segfault.
			((uint32_t*)0)[0] = 0;
	BlockShuffle_DropByteShuffler( bytKey );
	EnqueLink( &crypt_local.plqCrypters, signEntropy );
}
#if 0
// internal test code...
// some performance benchmarking for instance.
void logBinary( uint8_t *inbuf, int len ) {
#define BINBUFSIZE 280
#define LINELEN 64
	char buf[280];
	int ofs;
	for( int i = 0; i < 32; i++ ) {
		int j;
		ofs = 0;
		for( j = 0; j < 64; j++ ) {
			if( (i * 64 + j) >= len ) break;
			ofs += snprintf( buf + ofs, BINBUFSIZE - ofs, "%02x ", inbuf[i * LINELEN + j] );
		}
		for( ; j < 64; j++ ) {
			ofs += snprintf( buf + ofs, BINBUFSIZE - ofs, "   " );
		}
		ofs += snprintf( buf + ofs, BINBUFSIZE - ofs, "   " );
		for( int j = 0; j < LINELEN; j++ ) {
			if( (i * 64 + j) >= len ) break;
			ofs += snprintf( buf + ofs, BINBUFSIZE - ofs, "%c", (inbuf[i * LINELEN + j] >= 32 && inbuf[i * LINELEN + j] <= 127) ? inbuf[i * LINELEN + j] : '.' );
		}
		puts( buf );
		if( (i * LINELEN + j) >= len ) break;
	}
}
PRELOAD( CryptTestBuiltIn ) {
	// this sample happened to be 44 bytes + 4 for the length = 48 = 3*16
	// happened to be a perfect pad.
	// with padding (libressl) padds a while extra block.
	static char message[] = "Hello, This is a test, this is Only a test.";
	static char messageBig[2048] = "Hello, This is a test, this is Only a test.";
	static char messageMega[2048 * 2048] = "Hello, This is a test, this is Only a test.";
	// this is a 1 bit change in message from message
	static char message2[] = "Hello, This is a test, this is only a test.";
	// this is a slightly shorter message, which needs padding
	// (manual pad test to avoid a full 16 byte 0 pad block)
	static char message3[] = "Hello, This is a test, this is the test.";
	static uint8_t key[] = { 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
						   , 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
						   , 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
						   , 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0
	};
	uint8_t *output;
	size_t outlen;
	uint8_t *orig;
	size_t origlen;
#define DO_PERF_TESTS
#define LENGTH_RECOVERY_TESTING
#ifdef LENGTH_RECOVERY_TESTING
	for( int p = 0; p < 10; p++ ) {
		printf( "TESTDATA  %d\n", p );
		logBinary( (uint8_t*)message, sizeof( message ) );
		SRG_XSWS_encryptData( (uint8_t*)message, sizeof( message ) - p, 1234, key, sizeof( key ), &output, &outlen );
		puts( "BINARY" );
		logBinary( output, outlen );
		SRG_XSWS_decryptData( (uint8_t*)output, outlen, 1234, key, sizeof( key ), &orig, &origlen );
		puts( "ORIG" );
		logBinary( orig, origlen );
		Release( output );
		Release( orig );
	}
	SRG_XSWS_encryptData( (uint8_t*)message2, sizeof( message2 ), 1234, key, sizeof( key ), &output, &outlen );
	puts( "BINARY - 1 bit change input" );
	logBinary( output, outlen );
	Release( output );
#endif
#ifdef DO_PERF_TESTS
	uint32_t start, end;
	int i;
	start = timeGetTime();
	for( i = 0; i < 900000; i++ ) {
		SRG_XSWS_encryptData( (uint8_t*)message, sizeof( message ), 1234, key, sizeof( key ), &output, &outlen );
		Release( output );
	}
	end = timeGetTime();
	printf( "Tiny DID %d in %d   %d %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start)) * sizeof( message )
	);
	Sleep( 1000 );
	start = timeGetTime();
	for( i = 0; i < 300000; i++ ) {
		SRG_XSWS_encryptData( (uint8_t*)messageBig, sizeof( messageBig ), 1234, key, sizeof( key ), &output, &outlen );
		Release( output );
	}
	end = timeGetTime();
	printf( "Big DID %d in %d   %d %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start))*sizeof( messageBig )
	);
	Sleep( 1000 );
	start = timeGetTime();
	for( i = 0; i < 300; i++ ) {
		SRG_XSWS_encryptData( (uint8_t*)messageMega, sizeof( messageMega ), 1234, key, sizeof( key ), &output, &outlen );
		Release( output );
	}
	end = timeGetTime();
	printf( "Mega DID %d in %d   %d %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start)) * sizeof( messageMega )
	);
	Sleep( 1000 );
#endif
#ifndef NO_SSL
#  ifdef DO_PERF_TESTS
	// SRG_AES_encrypt and SRG_AES_decrypt are symmetric.
	start = timeGetTime();
	for( i = 0; i < 300000; i++ ) {
		SRG_XSWS_decryptData( (uint8_t*)message, sizeof( message ), 1234, key, sizeof( key ), &output, &outlen );
		Release( output );
	}
	end = timeGetTime();
	printf( "DID %d in %d   %d\n", i, end - start, i * 1000 / (end - start) );
	Sleep( 1000 );
#  endif
	puts( "TESTDATA" );
	logBinary( (uint8_t*)message, sizeof( message ) );
	outlen = SRG_AES_encrypt( (uint8_t*)message, sizeof( message ), key, &output );
	puts( "BINARY" );
	logBinary( output, outlen );
	origlen = SRG_AES_decrypt( output, outlen, key, &orig );
	puts( "ORIG" );
	logBinary( orig, origlen );
	Release( output );
	Release( orig );
	puts( "TESTDATA" );
	logBinary( (uint8_t*)message2, sizeof( message2 ) );
	outlen = SRG_AES_encrypt( (uint8_t*)message2, sizeof( message2 ), key, &output );
	puts( "BINARY" );
	logBinary( output, outlen );
	origlen = SRG_AES_decrypt( output, outlen, key, &orig );
	puts( "ORIG" );
	logBinary( orig, origlen );
	Release( output );
	Release( orig );
	puts( "TESTDATA" );
	logBinary( (uint8_t*)message3, sizeof( message3 ) );
	outlen = SRG_AES_encrypt( (uint8_t*)message3, sizeof( message3 ), key, &output );
	puts( "BINARY" );
	logBinary( output, outlen );
	origlen = SRG_AES_decrypt( output, outlen, key, &orig );
	puts( "ORIG" );
	logBinary( orig, origlen );
	Release( output );
	Release( orig );
#endif
#if 0
	// memory leak tests.... if in 2M tests memory is +0, probably no leaks.
	// is about 5 seconds for these tests each....
	start = timeGetTime();
	for( i = 0; i < 4000000; i++ ) {
		outlen = SRG_AES_encrypt( (uint8_t*)message, sizeof( message ), key, &output );
		Release( output );
	}
	end = timeGetTime();
	printf( "tiny DID %d in %d   %d   %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start)) * sizeof( message )
	);
	start = timeGetTime();
	for( i = 0; i < 200000; i++ ) {
		outlen = SRG_AES_encrypt( (uint8_t*)messageBig, sizeof( messageBig ), key, &output );
		Release( output );
	}
	end = timeGetTime();
	printf( "Big DID %d in %d   %d   %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start)) * sizeof( messageBig )
	);
	start = timeGetTime();
	for( i = 0; i < 100; i++ ) {
		outlen = SRG_AES_encrypt( (uint8_t*)messageMega, sizeof( messageMega ), key, &output );
		Release( output );
	}
	end = timeGetTime();
	printf( "Mega DID %d in %d   %d   %d\n", i, end - start, i * 1000 / (end - start)
		, (i * 1000 / (end - start)) * sizeof( messageMega )
	);
#endif
#if 0
	outlen = SRG_AES_encrypt( (uint8_t*)messageBig, sizeof( messageBig ), key, &output );
	start = timeGetTime();
	for( i = 0; i < 100000; i++ ) {
		origlen = SRG_AES_decrypt( output, outlen, key, &orig );
		Release( orig );
	}
	end = timeGetTime();
	printf( "DID %d in %d   %d\n", i, end - start, i * 1000 / (end - start) );
	Release( output );
	Sleep( 1000 );
	start = timeGetTime();
	for( i = 0; i < 100000; i++ ) {
		outlen = SRG_AES_encrypt( (uint8_t*)message, sizeof( message ), key, &output );
		Release( output );
	}
	end = timeGetTime();
	printf( "DID %d in %d   %d\n", i, end - start, i * 1000 / (end - start) );
	outlen = SRG_AES_encrypt( (uint8_t*)message, sizeof( message ), key, &output );
	start = timeGetTime();
	for( i = 0; i < 100000; i++ ) {
		origlen = SRG_AES_decrypt( output, outlen, key, &orig );
		Release( orig );
	}
	end = timeGetTime();
	printf( "DID %d in %d   %d\n", i, end - start, i * 1000 / (end - start) );
	Release( output );
	Sleep( 1000 );
#endif
}
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
// partial lower bit expressions
#  pragma warning( default: 26451 )
#endif
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
// partial lower bit expressions
// disable warnings about integer partial expressions being used
// to sum to larger integers.
#  pragma warning( disable: 26451 )
#endif
struct block_shuffle_key
{
	size_t width;
	size_t height;
  // in case the map isn't entirely rectangular
	size_t extra;
	int *map;
	struct random_context *ctx;
};
typedef struct holder_tag
{
	int number;
	int r;
	int pLess, pMore;
} HOLDER, *PHOLDER;
static int sort( int *nHolders, PHOLDER holders, int nTree, int number, int r )
{
	PHOLDER tree = holders + nTree;
	if( nTree < 0 )
	{
		tree = holders + (*nHolders)++;
		tree->number = number;
		tree->r = r;
		tree->pLess = tree->pMore = -1;
		return (int)(tree - holders);
	}
	else
	{
		if( r > tree->r )
			tree->pMore = sort( nHolders, holders, tree->pMore, number, r );
		else
			tree->pLess = sort( nHolders, holders, tree->pLess, number, r );
	}
	return nTree;
}
static void FoldTree( int *nNumber, int *numbers, PHOLDER holders, int nTree )
{
	PHOLDER tree = holders + nTree;
	if( tree->pLess >= 0 )
		FoldTree( nNumber, numbers, holders, tree->pLess );
	numbers[(*nNumber)++] = tree->number;
	if( tree->pMore >= 0 )
		FoldTree( nNumber, numbers, holders, tree->pMore );
}
static void Shuffle( struct block_shuffle_key *key, int *numbers , int count )
{
	int tree;
	int n;
	int nHolders = 0;
	int nNumber = 0;
	int need_bits;
	PHOLDER holders = NewArray( HOLDER, count );
	tree = -1;
	nNumber = 0;
	for( n = 31; n > 0; n-- )
		if( count & ( 1 << n ) )
			break;
	need_bits = n + 1;
	for( n = 0; n < count; n++ )
		tree = sort( &nHolders, holders, tree, numbers[n], SRG_GetEntropy( key->ctx, need_bits, 0 ) );
	FoldTree( &nNumber, numbers, holders, tree );
	Release( holders );
}
struct block_shuffle_key *BlockShuffle_CreateKey( struct random_context *ctx, size_t width, size_t height )
{
	struct block_shuffle_key *key = New( struct block_shuffle_key );
	size_t n;
	key->width = width;
	key->height = height;
	key->extra = 0;
	key->map = NewArray( int, width * height );
	key->ctx = ctx;
	{
		size_t m;
		for( n = 0; n < width; n++ )
			for( m = 0; m < height; m++ )
			{
				key->map[m*width+n] = (int)(m*width+n);
			}
		Shuffle( key, key->map, (int)(width * height) );
	}
	return key;
}
void BlockShuffle_GetDataBlock( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, int y, size_t w, size_t h, size_t encrypted_stride
	, uint8_t* output, int ofs_x, int ofs_y, size_t stride )
{
	size_t ix, iy;
	for( ix = 0; ix < (w); ix++ ) {
		for( iy = 0; iy < (h); iy++ ) {
			int km = key->map[ix%key->width + (iy%key->height) * key->width];
			int kmx = km % key->width;
			int kmy = (int)(km / key->width);
			((uint8_t*)( ( (uintptr_t)output ) + (ix + ofs_x ) + stride * ( iy + ofs_y ) ))[0] =
				((uint8_t*)( ( (uintptr_t)encrypted ) + (x+kmx)+(y*kmy)*encrypted_stride ))[0];
		}
	}
}
void BlockShuffle_GetData( struct block_shuffle_key *key
	, uint8_t* encrypted, size_t x, size_t w
	, uint8_t* output, size_t ofs_x )
{
	BlockShuffle_GetDataBlock( key, encrypted, (int)x, 0, w, 1, 0, output, (int)ofs_x, 0, 0 );
}
void BlockShuffle_SetDataBlock( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, int y, size_t w, size_t h, size_t output_stride
	, uint8_t* input, int ofs_x, int ofs_y, size_t input_stride
)
{
	size_t ix, iy;
	for( ix = 0; ix < ( w ); ix++ )
	{
		for( iy = 0; iy < ( h ); iy++ )
		{
			int km = key->map[ix%key->width + (iy%key->height) * key->width];
			int kmx = km % key->width;
			int kmy = (int)(km / key->width);
			((uint8_t*)( ( (uintptr_t)encrypted ) + (x + kmx) + (y+kmy)*output_stride  ))[0]
				= ((uint8_t*)( ( (uintptr_t)input ) + (ix + ofs_x ) + input_stride * ( iy + ofs_y ) ))[0];
		}
	}
}
void BlockShuffle_SetData( struct block_shuffle_key *key
	, uint8_t* encrypted, int x, size_t w
	, uint8_t* input, int ofs_x )
{
	BlockShuffle_SetDataBlock( key, encrypted, x, 0, w, 1, 0
		, input, ofs_x, 0, 0 );
}
//------------------------------------------------------------------
// Byte Swap (works better than a position swap?)
//------------------------------------------------------------------
void BlockShuffle_DropByteShuffler( struct byte_shuffle_key *key ) {
	Release( key );
}
//0, 43, 86
//128, 171, 214
static uint8_t leftStacks[3][2] = { { 0, 43 }, {43, 43}, {86,42} };
static uint8_t rightStacks[4][2] = { { 128, 43 }, {171, 43}, {214,42} };
static uint8_t leftOrders[4][3] = { { 1, 0, 2 }, { 1, 2, 0 }, {2, 1, 0 }, {2, 0, 1 } };
static uint8_t rightOrders[4][3] = { { 0, 2, 1 }, { 2, 0, 1 }, { 1, 2, 0 }, {2, 1, 0 } };
struct halfDeck {
	int from;
	int until;
	int cut;
	uint8_t starts[3];
	uint8_t lens[3];
};
struct byte_shuffle_key *BlockShuffle_ByteShuffler( struct random_context *ctx ) {
	//struct byte_shuffle_key *key = New( struct byte_shuffle_key );
	struct byte_shuffle_key *key = ( struct byte_shuffle_key *)HeapAllocateAligned( NULL, sizeof( struct byte_shuffle_key ), 256 );
	int n;
	for( n = 0; n < 256; n++ )
		key->map[n] = n;
//#define USE_ALT_SHUFFLER
#ifdef USE_ALT_SHUFFLER
	uint8_t root = 0;
	uint8_t last = 0;
	for( n = 0; n < 256; n++ ) {
		SRG_GetByte_( key->dmap[n], ctx );
	}
	while( root < 255 ) {
		if( key->dmap[root] > key->dmap[root + 1] ) {
			last = root;
			while( key->dmap[root] > key->dmap[root + 1] ) {
				uint8_t tmp;
				tmp = key->map[root];
				key->map[root] = key->map[root + 1];
				key->map[root + 1] = tmp;
				tmp = key->dmap[root];
				key->dmap[root] = key->dmap[root + 1];
				key->dmap[root + 1] = tmp;
				if( root ) root--;
				else {
					root = last+1; last = root;
				}
			}
			root = last+1;
		}
		else
			root++;
	}
	//lprintf( "Shuffled:%d", root );
	//LogBinary( key->map, 256 );
	//lprintf( "sorted------" );
	//LogBinary( key->dmap, 256 );
#else
	// simple-in-place shuffler.
#  if 1
	for( n = 0; n < 256; n++ ) {
		int m;
		int t;
		SRG_GetByte_( m, ctx );
		t = key->map[m];
		key->map[m] = key->map[n];
		key->map[n] = t;
	}
#  endif
#endif
#if 0
		// validate that each number is in the mapping only once.
		{
			srcMap = 0;
			uint8_t *check = maps[1 - srcMap];
			int n;
			for( n = 0; n < 256; n++ ) {
				int m;
				for( m = 0; m < 256; m++ ) {
					if( m == n ) continue;
					if( check[n] == check[m] ) {
						lprintf( "Index %d matches %d  %d", n, m, check[n] );
						DebugBreak();
					}
				}
			}
		}
#endif
	for( n = 0; n < 256; n++ )
		key->dmap[key->map[n]] = n;
	return key;
}
// Small Entropy version.  (SE)
struct byte_shuffle_key *BlockShuffle_ByteShufflerSE( struct random_context *ctx ) {
	struct byte_shuffle_key *key = New( struct byte_shuffle_key );
	int n;
	int srcMap;
	uint8_t *maps[2] = { key->dmap, key->map };
	for( n = 0; n < 256; n++ )
		key->map[n] = n;
	srcMap = 1;
#define BLOCKSHUF_BYTE_ROUNDS 5
	uint8_t stacks[86];
	uint8_t halves[8][2];
	uint8_t lrStarts[8];
	uint8_t lrStart;
	uint8_t *readLMap;
	uint8_t *readRMap;
	uint8_t *writeMap;
	/* 40 bits for 8 shuffles. */
	for( n = 0; n < BLOCKSHUF_BYTE_ROUNDS; n++ ) {
		halves[n][0] = SRG_GetEntropy( ctx, 2, 0 );
		halves[n][1] = SRG_GetEntropy( ctx, 2, 0 );
		lrStarts[n] = SRG_GetEntropy( ctx, 1, 0 );
	}
	int t[2] = { 0, 0 };
	SRG_GetBit_( lrStart, ctx );
	for( n = 0; (t[0] < 43 || t[1] < 43) && n < 86; n++ ) {
		int bit;
		int c;
		c = 1;
		while( c < (5 - lrStart) && (SRG_GetBit_( bit, ctx ), !bit) ) {
			c++;
		}
		lrStart = !lrStart;
		stacks[n] = c;
		t[n & 1] += c;
	}
	for( n = 0; n < BLOCKSHUF_BYTE_ROUNDS; n++ ) {
		struct halfDeck left, right;
		int s;
		int useCards;
		int outCard;
		left.starts[0] = leftStacks[leftOrders[halves[n][0]][0]][0];
		left.lens[0] = leftStacks[leftOrders[halves[n][0]][0]][1];
		left.starts[1] = leftStacks[leftOrders[halves[n][0]][1]][0];
		left.lens[1] = leftStacks[leftOrders[halves[n][0]][1]][1];
		left.starts[2] = leftStacks[leftOrders[halves[n][0]][2]][0];
		left.lens[2] = leftStacks[leftOrders[halves[n][0]][2]][1];
		left.cut = 0;
		left.from = left.starts[left.cut];
		left.until = left.starts[left.cut] + left.lens[left.cut];
		right.starts[0] = rightStacks[rightOrders[halves[n][1]][0]][0];
		right.lens[0] = rightStacks[rightOrders[halves[n][1]][0]][1];
		right.starts[1] = rightStacks[rightOrders[halves[n][1]][1]][0];
		right.lens[1] = rightStacks[rightOrders[halves[n][1]][1]][1];
		right.starts[2] = rightStacks[rightOrders[halves[n][1]][2]][0];
		right.lens[2] = rightStacks[rightOrders[halves[n][1]][2]][1];
		right.cut = 0;
		right.from = right.starts[right.cut];
		right.until = right.starts[right.cut] + right.lens[right.cut];
		lrStart = lrStarts[n];
		useCards = stacks[s = 0];
		readLMap = maps[srcMap] + left.from;
		readRMap = maps[srcMap] + right.from;
		writeMap = maps[1 - srcMap];
		s = 0;
		for( outCard = 0; outCard < 256; ) {
			int c;
			useCards = stacks[s];
			for( c = 0; c < useCards; c++ ) {
				if( lrStart ) {
					(writeMap++)[0] = (readLMap++)[0];
					outCard++;
					left.from++;
					//maps[1 - srcMap][outCard++] = maps[srcMap][left.from++];
					if( left.from >= left.until ) {
						if( ++left.cut < 3 ) {
							s = 0;
							useCards = stacks[s];
							c = -1;
							left.from = left.starts[left.cut];
							left.until = left.starts[left.cut] + left.lens[left.cut];
							readLMap = maps[srcMap] + left.from;
						}
						while( left.cut != right.cut ) {
							(writeMap++)[0] = (readRMap++)[0];
							outCard++;
							right.from++;
							//maps[1 - srcMap][outCard++] = maps[srcMap][right.from++];
							if( right.from >= right.until ) {
								if( ++right.cut < 3 ) {
									right.from = right.starts[right.cut];
									right.until = right.starts[right.cut] + right.lens[right.cut];
									readRMap = maps[srcMap] + right.from;
								}
							}
						}
						if( s ) break;
						// L/R 2 new stacks... lrStart = same for whole stack each 3 subpart so...;
					}
				}
				else {
					(writeMap++)[0] = (readRMap++)[0];
					outCard++;
					right.from++;
					//maps[1 - srcMap][outCard++] = maps[srcMap][right.from++];
					if( right.from >= right.until ) {
						if( ++right.cut < 3 ) {
							s = 0;
							useCards = stacks[s];
							c = -1;
							right.from = right.starts[right.cut];
							right.until = right.starts[right.cut] + right.lens[right.cut];
							readRMap = maps[srcMap] + right.from;
						}
						while( left.cut != right.cut ) {
							(writeMap++)[0] = (readLMap++)[0];
							outCard++;
							left.from++;
							//maps[1 - srcMap][outCard++] = maps[srcMap][left.from++];
							if( left.from >= left.until ) {
								if( ++left.cut < 3 ) {
									left.from = left.starts[left.cut];
									left.until = left.starts[left.cut] + left.lens[left.cut];
									readLMap = maps[srcMap] + left.from;
								}
							}
						}
						if( s ) break;
						// L/R 2 new stacks... lrStart = same for whole stack each 3 subpart so...;
					}
				}
			}
			if( outCard >= 256 )
				break;
			lrStart = 1 - lrStart;
			s++;
			if( s >= 86 ) {
				useCards = stacks[s = 0];
			}
		}
	}
#if 0
	// validate that each number is in the mapping only once.
	{
		uint8_t *check = maps[1 - srcMap];
		int n;
		int m;
		for( n = 0; n < 256; n++ ) {
			for( m = 0; m < 256; m++ ) {
				if( m == n ) continue;
				if( check[n] == check[m] ) {
					lprintf( "Index %d matches %d  %d", n, m, check[n] );
					DebugBreak();
				}
			}
		}
	}
#endif
	for( n = 0; n < 256; n++ )
		key->dmap[key->map[n]] = n;
	return key;
}
void BlockShuffle_SubByte( struct byte_shuffle_key *key
	, uint8_t *bytes_input, uint8_t *bytes_output ) {
	bytes_output[0] = key->map[bytes_input[0]];
}
void BlockShuffle_SubBytes( struct byte_shuffle_key *key
	, uint8_t *bytes_input, uint8_t *bytes_output
	, size_t byteCount )
{
	size_t n;
	uint8_t *map = key->map;
	for( n = 0; n < byteCount; n++, bytes_input++, bytes_output++ ) {
		bytes_output[0] = map[bytes_input[0]];
	}
}
void BlockShuffle_BusByte( struct byte_shuffle_key *key
	, uint8_t *bytes_input, uint8_t *bytes_output ) {
	bytes_output[0] = key->dmap[bytes_input[0]];
}
void BlockShuffle_BusBytes( struct byte_shuffle_key *key
	, uint8_t *bytes_input, uint8_t *bytes_output
	, size_t byteCount )
{
	size_t n;
	uint8_t *map = key->dmap;
	for( n = 0; n < byteCount; n++, bytes_input++, bytes_output++ ) {
		bytes_output[0] = map[bytes_input[0]];
	}
}
#ifdef _MSC_VER
// integer partial expresions summed into 64 bit.
// partial lower bit expressions
// disable warnings about integer partial expressions being used
// to sum to larger integers.
#  pragma warning( default: 26451 )
#endif
#ifdef _WIN64
#ifndef __64__
#define __64__
#endif
#endif
#ifdef WIN32
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x501
#endif
#endif
// debugging only gets you the ordering(priority) logging and something else...
// useful logging is now controlled with l.flags.bLog
#define DISABLE_DEBUG_REGISTER_AND_DISPATCH
//#define DEBUG_SHUTDOWN
//#define DEBUG_ATEXIT
#define LOG_ALL 0
//
// core library load
//    all procs scheduled, initial = 0
// Application starts, invokes preloads
//    additional libraries load, scheduling because of suspend
//    library load completes by invoking the newly registered list
// final core application schedulging happens, after initial preload completes
//    additional preload scheduligin happens( not suspended, is initial)
//#define DEBUG_CYGWIN_START
//#ifndef __LINUX__
#define IS_DEADSTART
#ifdef __LINUX__
#include <signal.h>
#endif
#ifdef WIN32
 // GetConsoleWindow()
#include <wincon.h>
#endif
#ifdef __NO_BAG__
#undef lprintf
#define lprintf printf
#define BAG_Exit exit
#else
#endif
#ifdef __LINUX__
#endif
typedef struct startup_proc_tag {
	DeclareLink( struct startup_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} STARTUP_PROC, *PSTARTUP_PROC;
typedef struct shutdown_proc_tag {
	DeclareLink( struct shutdown_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} SHUTDOWN_PROC, *PSHUTDOWN_PROC;
struct deadstart_local_data_
{
	// this is a lot of procs...
	int nShutdownProcs;
#ifdef __LINUX__
	LOGICAL registerdSigint ;
	struct sigaction prior_sigint;
#endif
#define nShutdownProcs l.nShutdownProcs
	SHUTDOWN_PROC shutdown_procs[512];
#define shutdown_procs l.shutdown_procs
	int bInitialDone;
#define bInitialDone l.bInitialDone
	LOGICAL bInitialStarted;
#define bInitialStarted l.bInitialStarted
	int bSuspend;
#define bSuspend l.bSuspend
	int bDispatched;
//#define bDispatched l.bDispatched
	PSHUTDOWN_PROC shutdown_proc_schedule;
#define shutdown_proc_schedule l.shutdown_proc_schedule
 // count of used procs...
	int nProcs;
#define nProcs l.nProcs
	STARTUP_PROC procs[1024];
#define procs l.procs
	PSTARTUP_PROC proc_schedule;
#define proc_schedule l.proc_schedule
	struct
	{
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bLog : 1;
	} flags;
};
//#define lprintf(f,...) printf(f "\n",##__VA_ARGS__)
//#define _lprintf(n) lprintf
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
#ifndef __STATIC_GLOBALS__
#  ifdef __cplusplus
extern "C" {
#  endif
	IMPORT_METHOD struct deadstart_local_data_* GetDeadstartSharedGlobal( void );
#  ifdef __cplusplus
}
#  endif
#endif
SACK_DEADSTART_NAMESPACE
//#undef PRELOAD
EXPORT_METHOD void RunDeadstart( void );
#ifdef __STATIC_GLOBALS__
struct deadstart_local_data_ deadstart_local_data;
#  define l (deadstart_local_data)
#else
static struct deadstart_local_data_ *deadstart_local_data;
#  define l (*deadstart_local_data)
#endif
EXPORT_METHOD void RunExits( void )
{
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "Run Exits InvokeExits()\n" );
#endif
	InvokeExits();
}
static void InitLocal( void )
{
#ifndef __STATIC_GLOBALS__
	if( !deadstart_local_data ) deadstart_local_data = GetDeadstartSharedGlobal();
#endif
	if( !l.flags.bInitialized )
	{
		l.flags.bInitialized = 1;
	}
}
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
#define ENQUE_STARTUP_DBG_SRC DBG_SRC
static void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc DBG_PASS )
#else
#define ENQUE_STARTUP_DBG_SRC
static void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc )
#endif
{
	PSTARTUP_PROC check;
	PSTARTUP_PROC last;
		if( proc->next || proc->me )
		{
			if( ( (*proc->me) = proc->next ) )
				proc->next->me = proc->me;
		}
		for( last = check = (*root); check; check = check->next )
		{
			// if the current one being added is less then the one in the list
			// then the one in the list becomes the new one's next...
			if( proc->priority < check->priority )
			{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
				_lprintf(DBG_RELAY)( "%s(%d) is to run before %s and after %s first is %s"
						 , proc->func
						 , proc - procs
						 , check->func
						 , (check->me==root)?"Is First":((PSTARTUP_PROC)check->me)->func
						 , (*root)?(*root)->func:"First"
						 );
#endif
				proc->next = check;
				proc->me = check->me;
				(*check->me) = proc;
				check->me = &proc->next;
				break;
			}
			last = check;
		}
		if( !check )
		{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
			lprintf( "%s(%d) is to run after all"
					 , proc->func
					 , proc - procs
					 );
#endif
			proc->next = NULL;
			if( last )
			{
				last->next = proc;
				proc->me = &last->next;
			}
			else
			{
				(*root) = proc;
				proc->me = root;
			}
		}
}
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityStartupProc( void (CPROC*proc)(void), CTEXTSTR func,int priority, void *use_label DBG_PASS )
{
	int use_proc;
	InitLocal();
	if( LOG_ALL || (
#ifndef __STATIC_GLOBALS__
		 deadstart_local_data &&
#endif
		  l.flags.bLog ))
		lprintf( "Register %s@" DBG_FILELINEFMT_MIN " %d", func DBG_RELAY, priority);
	if( nProcs == 1024 )
	{
		for( use_proc = 0; use_proc < 1024; use_proc++ )
			if( !procs[use_proc].bUsed )
				break;
		if( use_proc == 1024 )
		{
			lprintf( "Used all 1024, and, have 1024 startups total scheduled." );
			DebugBreak();
		}
	}
	else
		use_proc = nProcs;
	procs[use_proc].proc = proc;
	procs[use_proc].func = func;
#ifdef _DEBUG
	procs[use_proc].file = pFile;
	procs[use_proc].line = nLine;
#endif
	procs[use_proc].priority = priority;
	procs[use_proc].bUsed = 1;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].next = NULL;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].me = NULL;
	EnqueStartupProc( &proc_schedule, procs + use_proc ENQUE_STARTUP_DBG_SRC );
	if( nProcs < 1024 )
		nProcs++;
	/*
	if( nProcs == 1024 )
	{
		lprintf( "Excessive number of startup procs!" );
		DebugBreak();
	}
	*/
	if( bInitialDone && !bSuspend )
	{
#ifdef _DEBUG
		_xlprintf(LOG_NOISE,pFile,nLine)( "Initial done, not suspended, dispatch immediate." );
#endif
		InvokeDeadstart();
	}
	//lprintf( "Total procs %d", nProcs );
}
#ifdef __LINUX__
// this handles the peculiarities of fork() and exit()
void ClearDeadstarts( void )
{
	// this is reserved for the sole use of
	// fork() success and then exec() failing...
	// when oh wait - __attribute__((destructor))
	// if( registered_pid != getppid() )
	shutdown_proc_schedule = NULL;
	// be rude - yes we lose resources. but everything goes away cause
	// this is just a clone..
}
#endif
static int ignoreBreak;
void IgnoreBreakHandler( int ignore) {
	ignoreBreak = ignore;
}
#ifndef UNDER_CE
#  if defined( WIN32 )
#    ifndef __cplusplus_cli
static BOOL WINAPI CtrlC( DWORD dwCtrlType )
{
	if( ignoreBreak & ( 1 << dwCtrlType ) ) return TRUE;
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "Received ctrlC Event %08x %d\n", ignoreBreak, dwCtrlType );
#endif
	switch( dwCtrlType )
	{
	case CTRL_BREAK_EVENT:
	case CTRL_C_EVENT:
	case CTRL_CLOSE_EVENT:
	case CTRL_LOGOFF_EVENT:
	case CTRL_SHUTDOWN_EVENT:
		InvokeExits();
		// allow C api to exit, whatever C api we're using
		// (allows triggering atexit functions)
		//exit(3);
		break;
	}
	// default... return not processed.
 // allow others to process this too
	return FALSE;
}
#    endif
#  endif
#  ifndef WIN32
static void CtrlC( int signal, siginfo_t* siginfo, void*p )
{
	static int tries;
	static int in_self;
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "linux system SIGINT... %d\n", in_self);
#endif
	if( in_self ) return;
	in_self = 1;
	if( ignoreBreak ) return;
	if( l.prior_sigint.sa_handler ) {
		if( l.prior_sigint.sa_handler == SIG_DFL ){
			fprintf( stderr, "default handler...\n");
		}
		else if( l.prior_sigint.sa_handler == SIG_IGN ){
			fprintf( stderr, "ignore handler...\n");
		}
		else if( l.prior_sigint.sa_handler ){
			if( 1 || (l.prior_sigint.sa_flags & SA_SIGINFO) )
			{
				l.prior_sigint.sa_sigaction( signal, siginfo, p );
			} else {
				l.prior_sigint.sa_handler( signal );
			}
		}
	}
	in_self = 0;
	InvokeExits();
	if( tries++ == 10 )
		exit(3);
}
#  endif
#endif
// wow no such thing as static-izing this... it's
// always retrieved with dynamic function loading, therefore
// MUST be exported if at all possible.
// this one is used when a library is loaded.
void InvokeDeadstart( void )
{
	PSTARTUP_PROC proc;
	PSTARTUP_PROC resumed_proc;
#ifndef __STATIC_GLOBALS__
 // nothing was registerd to run.
	if( !deadstart_local_data ) return;
#endif
	if( bInitialStarted )
		return;
	bInitialStarted = 1;
	// allowing initial start to be set lets final resume do this invoke.
	if( bSuspend )
	{
		if( l.flags.bLog )
 //-V595
			lprintf( "Suspended, first proc is %s", proc_schedule?proc_schedule->func:"No First" );
		return;
	}
#ifdef WIN32
	if( !bInitialDone && !l.bDispatched )
	{
#  ifndef UNDER_CE
		if( GetConsoleWindow() )
		{
			if( !SetConsoleCtrlHandler( CtrlC, TRUE ) ) fprintf( stderr, "failed to SetConsoleCtrlHandler? %lu\n", GetLastError() );
		}
		else
		{
			//MessageBox( NULL, "!!--!! NO CtrlC", "blah", MB_OK );
			// do nothing if not actually a console window. this should fix ctrl-c not working in CMD prompts launched by MILK/InterShell
		}
#  endif
	}
#else
	if( !bInitialDone && !l.bDispatched )
	{
		struct sigaction sact;
		/*
           struct sigaction {
			union{
               void     (*sa_handler)(int);
               void     (*sa_sigaction)(int, siginfo_t *, void *);
			}
               sigset_t   sa_mask;
               int        sa_flags;
               void     (*sa_restorer)(void);
           };
		*/
		if( !l.registerdSigint )
		{
			l.registerdSigint = TRUE;
			MemSet( &sact, 0, sizeof( sact ));
			sact.sa_sigaction = CtrlC;
			sigemptyset(&sact.sa_mask);
			//sigaddset( &sact.sa_mask, SIGINT );
			sact.sa_flags = SA_SIGINFO | SA_NODEFER;
			sact.sa_restorer = NULL;
			// this means I have to generate a terminate myself....
			//sigaction(SIGINT, &sact, &l.prior_sigint);
			//fprintf( stderr, "Registered sigint handler...\n");
		}
	}
#endif
	while( ( proc = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
	{
		// need to set this to point to new head of list... it's not in proc_schedule anymore
		//proc->me = &proc;
		if( LOG_ALL || (
#ifndef __STATIC_GLOBALS__
		   deadstart_local_data  &&
#endif
		   l.flags.bLog ))
		{
#ifdef _DEBUG
			lprintf( "Dispatch %s@%s(%d)p:%d ", proc->func,proc->file,proc->line, proc->priority );
#else
			lprintf( "Dispatch %s@p:%d ", proc->func, proc->priority );
#endif
		}
		{
			l.bDispatched = 1;
#ifdef _DEBUG
			if( proc->proc
#  ifndef __LINUX__
#    if  __WATCOMC__ >= 1280
				&& !IsBadCodePtr( (int(STDCALL*)(void))proc->proc )
#    elif defined( __64__ )
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#    else
//				&& !IsBadCodePtr( (int STDCALL(*)(void))proc->proc )
#    endif
#  endif
			  )
#endif
			{
				proc->proc();
			}
			proc->bUsed = 0;
			l.bDispatched = 0;
		}
		// look to see if anything new was scheduled.  Grab the list, add it to the one's we're processing.
		{
			{
				PSTARTUP_PROC newly_scheduled_things;
				proc->me = &proc;
				resumed_proc = proc;
				if( ( newly_scheduled_things = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
				{
					newly_scheduled_things->me = &newly_scheduled_things;
					//lprintf( "------------------  newly scheduled startups; requeue old startups into new list ------------------ " );
					while( newly_scheduled_things )
					{
						EnqueStartupProc( &proc, newly_scheduled_things ENQUE_STARTUP_DBG_SRC );
					}
				}
				else
					resumed_proc = NULL;
			}
			proc_schedule = proc;
			proc_schedule->me = &proc_schedule;
		}
		if( resumed_proc )
			UnlinkThing( resumed_proc );
		else
			UnlinkThing( proc );
	}
	bInitialStarted = 0;
}
void MarkRootDeadstartComplete( void )
{
	bInitialDone = 1;
}
#ifndef __NO_OPTIONS__
// options initializes at SQL+1
PRIORITY_PRELOAD( InitDeadstartOptions, NAMESPACE_PRELOAD_PRIORITY+1 )
{
#ifdef DISABLE_DEBUG_REGISTER_AND_DISPATCH
#  ifndef __NO_OPTIONS
	l.flags.bLog = SACK_GetProfileIntEx( "SACK/Deadstart", "Logging Enabled?", 0, TRUE );
#  else
	l.flags.bLog = 0;
#  endif
#else
	l.flags.bLog = 1;
#endif
}
#endif
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityShutdownProc( void (CPROC*proc)(void), CTEXTSTR func, int priority,void *use_label DBG_PASS )
{
	InitLocal();
	if( LOG_ALL || (
#ifndef __STATIC_GLOBALS__
		deadstart_local_data &&
#endif
		   l.flags.bLog ))
		lprintf( "Exit Proc %s(%p) from " DBG_FILELINEFMT_MIN " registered..."
				 , func
				 , proc DBG_RELAY );
	shutdown_procs[nShutdownProcs].proc = proc;
	shutdown_procs[nShutdownProcs].func = func;
#ifdef _DEBUG
	shutdown_procs[nShutdownProcs].file = pFile;
	shutdown_procs[nShutdownProcs].line = nLine;
#endif
	shutdown_procs[nShutdownProcs].bUsed = 1;
	shutdown_procs[nShutdownProcs].priority = priority;
	{
		PSHUTDOWN_PROC check;
		for( check = shutdown_proc_schedule; check; check = check->next )
		{
			if( shutdown_procs[nShutdownProcs].priority >= check->priority )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "%s(%d) is to run before %s(%d) %s"
						 , shutdown_procs[nShutdownProcs].func
						 , nShutdownProcs
						 , check->file
						 , check->line
						 , check->func );
#endif
				shutdown_procs[nShutdownProcs].next = check;
				shutdown_procs[nShutdownProcs].me = check->me;
				(*check->me) = shutdown_procs + nShutdownProcs;
				check->me = &shutdown_procs[nShutdownProcs].next;
				break;
			}
		}
		if( !check )
			LinkLast( shutdown_proc_schedule, PSHUTDOWN_PROC, shutdown_procs + nShutdownProcs );
		//lprintf( "first routine is %s(%d)"
		//		 , shutdown_proc_schedule->func
		//		 , shutdown_proc_schedule->line );
	}
	nShutdownProcs++;
	//lprintf( "Total procs %d", nProcs );
}
void InvokeExits( void )
{
	// okay well since noone previously scheduled exits...
	// this runs a prioritized list of exits - all within
	// a single moment of exited-ness.
	PSHUTDOWN_PROC proc;
	// shutdown is much easier than startup cause more
	// procedures shouldn't be added as a property of shutdown.
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "InvokeExits()\n" );
#endif
	// don't allow shutdown procs to schedule more shutdown procs...
	// although in theory we could; if the first list contained
	// ReleaseAllMemory(); then there is no memory.
	if(
#ifndef __STATIC_GLOBALS__
		deadstart_local_data &&
#endif
			( proc = (PSHUTDOWN_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&shutdown_proc_schedule, 0 ) ) != NULL
		  )
	{
		// just before all memory goes away
		// global memory goes away (including mine) so deadstart_local_data is invalidated.
#ifndef __STATIC_GLOBALS__
		//struct deadstart_local_data_ *local_pointer = (struct deadstart_local_data_*)(((uintptr_t)deadstart_local_data)-sizeof(PLIST));
#endif
		PSHUTDOWN_PROC proclist = proc;
		// link list to myself..
#ifndef __STATIC_GLOBALS__
		//Hold( local_pointer );
#endif
		proc->me = &proclist;
		while( ( proc = proclist ) )
		{
#if defined( DEBUG_SHUTDOWN )
			lprintf( "Exit Proc %s(%p)(%d) priority %d from %s(%d)..."
			       , proc->func
			       , proc->proc
			       , proc - shutdown_procs
			       , proc->priority
			       , proc->file
			       , proc->line );
#endif
			if( proc->priority == 0 )
			{
				//atexit( proc->proc );
				//continue;
			}
			// don't release this stuff... memory might be one of the autoexiters.
			UnlinkThing( proc );
			if( proc->proc
#ifndef __LINUX__
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#endif
			  )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "Dispatching..." );
#endif
				proc->proc();
			}
			// okay I have the whol elist... so...
#ifdef DEBUG_SHUTDOWN
			lprintf( "Okay and that's done... next is %p %p", proclist, shutdown_proc_schedule );
#endif
		}
		// nope by this time memory doesn't exist anywhere.
		//Release( local_pointer );
		//shutdown_proc_schedule = proc;
	}
#ifndef __STATIC_GLOBALS__
	deadstart_local_data = (struct deadstart_local_data_*)NULL;
#endif
	//shutdown_proc_schedule = NULL;
}
void DispelDeadstart( void )
{
	shutdown_proc_schedule = NULL;
}
#ifdef __cplusplus
ROOT_ATEXIT(AutoRunExits)
{
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "ROOT_ATEXIT()" );
#endif
	InvokeExits();
}
#endif
void SuspendDeadstart( void )
{
	bSuspend++;
}
void ResumeDeadstart( void )
{
	bSuspend--;
	if( !bSuspend )
	{
		if( bInitialDone )
			InvokeDeadstart();
	}
}
SACK_DEADSTART_NAMESPACE_END
SACK_NAMESPACE
// linked into BAG to provide a common definition for function Exit()
// this then invokes an exit in the mainline program (if available)
void BAG_Exit( int code )
{
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "BAG_Exit();" );
#endif
	InvokeExits();
#undef exit
	exit( code );
}
// legacy linking code - might still be usin this for linux...
LOGICAL is_deadstart_complete( void )
{
	//extern uint32_t deadstart_complete;
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
//deadstart_complete;
		return bInitialDone;
#endif
	return FALSE;
}
SACK_NAMESPACE_END
SACK_DEADSTART_NAMESPACE
LOGICAL IsRootDeadstartStarted( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialStarted;
	return 0;
#else
	return bInitialStarted;
#endif
}
LOGICAL IsRootDeadstartComplete( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialDone;
	return 0;
#else
	return bInitialDone;
#endif
}
#ifndef __STATIC__
#  ifndef __WATCOMC__
#    if !defined( NO_DEADSTART_DLLMAIN ) && !defined( BUILD_PORTABLE_EXECUTABLE )
#      if !defined( __LINUX__ ) && !defined( __GNUC__ )
#        ifdef __cplusplus
extern "C"
#        endif
__declspec(dllexport)
	BOOL WINAPI DllMain(  HINSTANCE hinstDLL,
   DWORD fdwReason,
   LPVOID lpvReserved
		   )
{
	if( fdwReason == DLL_PROCESS_DETACH ) {
#ifdef DEBUG_ATEXIT
		fprintf( stderr, "DLL_DETACH\n" );
#endif
		InvokeExits();
	}
	return TRUE;
}
#      else
void RootDestructor(void) __attribute__((destructor));
void RootDestructor( void )
{
#ifdef DEBUG_ATEXIT
	fprintf( stderr, "RootDestructor\n" );
#endif
	InvokeExits();
}
#      endif
#    endif
#  endif
#endif
#undef l
SACK_DEADSTART_NAMESPACE_END
